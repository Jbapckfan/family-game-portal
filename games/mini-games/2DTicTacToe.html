<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Tic Tac Toe - Classic strategy game with AI opponent and neon cyberpunk styling.">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta property="og:title" content="Tic Tac Toe">
    <meta property="og:description" content="Classic strategy game with AI opponent.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Tic-Tac-Toe: Code Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* === THEME CSS CUSTOM PROPERTIES === */
        :root {
            /* Neon Pink theme (default) */
            --theme-bg: #0d0c1d;
            --theme-bg-gradient: radial-gradient(circle at center, rgba(14, 1, 36, 0.8) 0%, rgba(0, 0, 0, 1) 100%);
            --theme-card-bg: rgba(0, 0, 0, 0.4);
            --theme-card-border: rgba(29, 78, 216, 0.5);
            --theme-cell-bg: rgba(255, 255, 255, 0.05);
            --theme-cell-border: rgba(34, 211, 238, 0.3);
            --theme-cell-hover: rgba(34, 211, 238, 0.1);
            --theme-x-color: #FF007F;
            --theme-x-glow: 0 0 10px #FF007F, 0 0 20px #FF007F;
            --theme-o-color: #00FFFF;
            --theme-o-glow: 0 0 10px #00FFFF, 0 0 20px #00FFFF;
            --theme-text-primary: #E0F7FA;
            --theme-text-status: rgba(34, 211, 238, 0.8);
            --theme-win-line: #FFFF00;
            --theme-grid-bg: rgba(55, 65, 81, 0.3);
            --theme-grid-border: rgba(75, 85, 99, 0.3);
        }

        [data-theme="classic"] {
            --theme-bg: #1a1a1a;
            --theme-bg-gradient: radial-gradient(circle at center, #2a2a2a 0%, #0a0a0a 100%);
            --theme-card-bg: rgba(40, 40, 40, 0.6);
            --theme-card-border: rgba(120, 120, 120, 0.5);
            --theme-cell-bg: rgba(255, 255, 255, 0.08);
            --theme-cell-border: rgba(180, 180, 180, 0.4);
            --theme-cell-hover: rgba(255, 255, 255, 0.15);
            --theme-x-color: #FFFFFF;
            --theme-x-glow: 0 0 8px rgba(255,255,255,0.6);
            --theme-o-color: #AAAAAA;
            --theme-o-glow: 0 0 8px rgba(170,170,170,0.4);
            --theme-text-primary: #E0E0E0;
            --theme-text-status: rgba(200, 200, 200, 0.9);
            --theme-win-line: #FFD700;
            --theme-grid-bg: rgba(60, 60, 60, 0.4);
            --theme-grid-border: rgba(100, 100, 100, 0.4);
        }

        [data-theme="retro-green"] {
            --theme-bg: #0a0f0a;
            --theme-bg-gradient: radial-gradient(circle at center, #0d1a0d 0%, #000000 100%);
            --theme-card-bg: rgba(0, 20, 0, 0.5);
            --theme-card-border: rgba(0, 200, 0, 0.3);
            --theme-cell-bg: rgba(0, 255, 0, 0.03);
            --theme-cell-border: rgba(0, 200, 0, 0.3);
            --theme-cell-hover: rgba(0, 255, 0, 0.1);
            --theme-x-color: #00FF00;
            --theme-x-glow: 0 0 10px #00FF00, 0 0 20px #00AA00;
            --theme-o-color: #00CC66;
            --theme-o-glow: 0 0 10px #00CC66, 0 0 20px #009944;
            --theme-text-primary: #00FF00;
            --theme-text-status: rgba(0, 255, 0, 0.7);
            --theme-win-line: #FFFF00;
            --theme-grid-bg: rgba(0, 40, 0, 0.4);
            --theme-grid-border: rgba(0, 150, 0, 0.3);
        }

        body {
            font-family: 'Orbitron', sans-serif; /* Retro-futuristic font */
            background-color: var(--theme-bg);
            background-image: var(--theme-bg-gradient);
            overflow-x: hidden; /* Prevent horizontal scroll but allow vertical scrolling on mobile */
        }
        .text-shadow-neon {
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(34, 211, 238, 0.5), 0 0 20px rgba(34, 211, 238, 0.5);
        }
        .scanline-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.1) 1px,
                rgba(0, 0, 0, 0) 2px
            );
            pointer-events: none; /* Allow clicks through */
            z-index: 0;
        }
        /* Winning Animation */
        .win-animation {
            animation: winPulse 1.5s infinite alternate;
        }
        @keyframes winPulse {
            0% { transform: scale(1); text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(255, 255, 0, 0.5); }
            100% { transform: scale(1.05); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 0, 0.8), 0 0 30px rgba(255, 255, 0, 0.6); }
        }
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #1a202c;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.7);
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
            border: 2px solid #00FFFF;
            color: #E0F7FA; /* Light cyan text for readability */
        }
        .modal-close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #00FFFF;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
        }
        .modal-close-button:hover {
            background-color: rgba(0, 255, 255, 0.15);
        }
        .cell {
            width: 100%;
            padding-bottom: 100%; /* Makes cells square */
            position: relative;
            background-color: var(--theme-cell-bg);
            border: 2px solid var(--theme-cell-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.8rem, 8vmin, 3rem); /* Responsive size of X/O */
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            min-height: 44px; /* Touch target minimum */
        }
        .cell:hover {
            background-color: var(--theme-cell-hover);
            transform: scale(1.02);
        }
        .cell.occupied {
            cursor: default;
        }
        .cell-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1; /* Default to visible */
            transform: scale(1); /* Default to full size */
            filter: blur(0px); /* Default to no blur */
            animation: popIn 0.4s forwards ease-out; /* Animation for initial pop */
        }
        /* Ghost preview styling */
        .cell-ghost {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.3;
            pointer-events: none;
        }
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.2); filter: blur(5px); }
            60% { opacity: 1; transform: scale(1.1); filter: blur(0px); } /* Overshoot for bounce */
            100% { transform: scale(1); }
        }
        .x-color {
            color: var(--theme-x-color);
            text-shadow: var(--theme-x-glow);
        }
        .o-color {
            color: var(--theme-o-color);
            text-shadow: var(--theme-o-glow);
        }

        /* Win line SVG animation - pathLength normalises speed regardless of line length */
        .win-line-svg line {
            stroke-dasharray: 1;
            stroke-dashoffset: 1;
            animation: drawSvgLine 0.5s ease-out forwards;
        }
        @keyframes drawSvgLine {
            to { stroke-dashoffset: 0; }
        }

        /* AI Thinking Indicator */
        .ai-thinking-indicator {
            animation: blink 1s infinite alternate;
        }
        @keyframes blink {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker background */
            backdrop-filter: blur(20px); /* Significantly stronger blur */
            z-index: 50; /* Above game content, below modals */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            border-radius: 0.75rem;
        }
        /* Touch target minimum for action buttons */
        .action-btn {
            min-height: 44px;
            min-width: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        button:focus-visible, [role="button"]:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
        }
        /* Title overflow on narrow viewports */
        h1 {
            overflow-wrap: break-word;
            word-break: break-word;
        }
        /* Difficulty selector styling */
        .difficulty-selector {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 0.75rem;
        }
        .difficulty-btn {
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: bold;
            border: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
            min-height: 36px;
        }
        .difficulty-btn.active {
            transform: scale(1.05);
        }
        .difficulty-btn.easy { background: #065f46; border-color: #10b981; }
        .difficulty-btn.easy.active { background: #10b981; color: #000; box-shadow: 0 0 10px #10b981; }
        .difficulty-btn.medium { background: #92400e; border-color: #f59e0b; }
        .difficulty-btn.medium.active { background: #f59e0b; color: #000; box-shadow: 0 0 10px #f59e0b; }
        .difficulty-btn.hard { background: #7f1d1d; border-color: #ef4444; }
        .difficulty-btn.hard.active { background: #ef4444; color: #fff; box-shadow: 0 0 10px #ef4444; }
        /* Stats bar */
        .stats-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }
        .stats-bar .stat-win { color: #4ade80; }
        .stats-bar .stat-loss { color: #f87171; }
        .stats-bar .stat-draw { color: #facc15; }
        .stats-bar .stat-streak { color: #c084fc; }
        .stats-reset-btn {
            font-size: 0.65rem;
            padding: 0.15rem 0.5rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #94a3b8;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .stats-reset-btn:hover { background: rgba(255,255,255,0.2); }
        /* Mute toggle */
        .mute-btn {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 9999;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .mute-btn:hover { background: rgba(0,0,0,0.9); }

        /* === BOARD ENTRANCE ANIMATION (Feature 2) === */
        @keyframes cellEntrance {
            0% { opacity: 0; transform: scale(0.3); }
            60% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }
        .cell-entrance {
            opacity: 0;
            animation: cellEntrance 0.35s ease-out forwards;
        }

        /* === CONFETTI CANVAS (Feature 8) === */
        .confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }

        /* === THEME SELECTOR (Feature 7) === */
        .theme-selector {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 0.75rem;
        }
        .theme-btn {
            padding: 0.2rem 0.6rem;
            border-radius: 0.4rem;
            font-size: 0.65rem;
            font-weight: bold;
            border: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
            min-height: 30px;
            color: #fff;
        }
        .theme-btn.active {
            transform: scale(1.05);
        }
        .theme-btn.neon-pink { background: #4a1942; border-color: #FF007F; }
        .theme-btn.neon-pink.active { background: #FF007F; color: #000; box-shadow: 0 0 10px #FF007F; }
        .theme-btn.classic { background: #333; border-color: #999; }
        .theme-btn.classic.active { background: #999; color: #000; box-shadow: 0 0 10px #999; }
        .theme-btn.retro-green { background: #0a2e0a; border-color: #00FF00; }
        .theme-btn.retro-green.active { background: #00FF00; color: #000; box-shadow: 0 0 10px #00FF00; }

        /* === NAME INPUT STYLING (Feature 6) === */
        .name-input {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(34, 211, 238, 0.4);
            border-radius: 0.5rem;
            padding: 0.4rem 0.6rem;
            color: #E0F7FA;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            width: 120px;
            text-align: center;
            outline: none;
            transition: border-color 0.2s;
        }
        .name-input:focus {
            border-color: #00FFFF;
            box-shadow: 0 0 8px rgba(0,255,255,0.3);
        }
        .name-input::placeholder {
            color: rgba(255,255,255,0.3);
        }

        /* === FIRST-MOVE CHOOSER (Feature 3) === */
        .first-move-chooser {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .first-move-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px;
            font-size: 1rem;
        }

        @media (max-width: 360px) {
            h1 { font-size: clamp(1.5rem, 8vw, 2.25rem) !important; }
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
  <a href="../../"
     aria-label="Back to menu"
     style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;"
     onmouseover="this.style.background='rgba(0,0,0,0.9)'"
     onmouseout="this.style.background='rgba(0,0,0,0.7)'"
  >&#x1F3E0; Menu</a>
    <div id="root"></div>

    <script type="text/babel">
        // --- CONFIGURATION ---
        const PLAYERS = { X: 'X', O: 'O' };
        const GAME_MODES = { PVP: 'PvP', PVAI: 'PvAI' };
        const DIFFICULTIES = { EASY: 'easy', MEDIUM: 'medium', HARD: 'hard' };
        const AI_THINK_DELAY = 800; // Milliseconds for AI to "think"
        const STATS_KEY_PVP = 'ttt-stats-pvp';
        const STATS_KEY_PVAI = 'ttt-stats-pvai';
        const STREAK_KEY_PVP = 'ttt-streak-pvp';
        const STREAK_KEY_PVAI = 'ttt-streak-pvai';
        const THEME_KEY = 'ttt-theme';
        const REPLAY_STEP_DELAY = 600; // ms between replay steps

        // Theme definitions
        const THEMES = [
            { id: 'neon-pink', label: 'Neon Pink' },
            { id: 'classic', label: 'Classic' },
            { id: 'retro-green', label: 'Retro Green' },
        ];

        // --- SOUND ENGINE (Web Audio API) ---
        const SoundEngine = (() => {
            let audioCtx = null;
            let muted = false;

            const getCtx = () => {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                return audioCtx;
            };

            const playTone = (freq, duration, type = 'square', gain = 0.15, delay = 0) => {
                if (muted) return;
                try {
                    const ctx = getCtx();
                    const osc = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);
                    gainNode.gain.setValueAtTime(gain, ctx.currentTime + delay);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + duration);
                    osc.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    osc.start(ctx.currentTime + delay);
                    osc.stop(ctx.currentTime + delay + duration);
                } catch (e) {
                    // Silently fail if audio not supported
                }
            };

            return {
                isMuted: () => muted,
                setMuted: (val) => { muted = val; },
                toggleMute: () => { muted = !muted; return muted; },

                playX: () => {
                    playTone(520, 0.12, 'square', 0.12);
                    playTone(780, 0.08, 'square', 0.08, 0.06);
                },
                playO: () => {
                    playTone(440, 0.15, 'sine', 0.15);
                    playTone(330, 0.1, 'sine', 0.1, 0.07);
                },
                playAIMove: () => {
                    playTone(350, 0.1, 'triangle', 0.08);
                    playTone(500, 0.1, 'triangle', 0.06, 0.08);
                },
                playVictory: () => {
                    playTone(523, 0.15, 'square', 0.12, 0);
                    playTone(659, 0.15, 'square', 0.12, 0.15);
                    playTone(784, 0.15, 'square', 0.12, 0.30);
                    playTone(1047, 0.35, 'square', 0.18, 0.45);
                },
                playDraw: () => {
                    playTone(220, 0.3, 'sawtooth', 0.08);
                    playTone(196, 0.4, 'sawtooth', 0.06, 0.25);
                },
            };
        })();

        // --- STATS HELPERS ---
        const loadStats = (key) => {
            try {
                const raw = localStorage.getItem(key);
                if (raw) return JSON.parse(raw);
            } catch (e) {}
            return { wins: 0, losses: 0, draws: 0 };
        };

        const saveStats = (key, stats) => {
            try {
                localStorage.setItem(key, JSON.stringify(stats));
            } catch (e) {}
        };

        // --- STREAK HELPERS (Feature 1) ---
        const loadStreak = (key) => {
            try {
                const raw = localStorage.getItem(key);
                if (raw) return parseInt(raw, 10) || 0;
            } catch (e) {}
            return 0;
        };

        const saveStreak = (key, val) => {
            try {
                localStorage.setItem(key, String(val));
            } catch (e) {}
        };

        // --- THEME HELPERS (Feature 7) ---
        const loadTheme = () => {
            try {
                return localStorage.getItem(THEME_KEY) || 'neon-pink';
            } catch (e) {}
            return 'neon-pink';
        };

        const saveTheme = (theme) => {
            try {
                localStorage.setItem(THEME_KEY, theme);
            } catch (e) {}
        };

        // --- HELPER FUNCTIONS ---

        const WIN_LINES = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        /**
         * Checks if there's a winner on the given board.
         */
        const checkWinner = (board, player) => {
            const flatBoard = board.flat();
            for (let i = 0; i < WIN_LINES.length; i++) {
                const [a, b, c] = WIN_LINES[i];
                if (flatBoard[a] === player && flatBoard[b] === player && flatBoard[c] === player) {
                    return { winner: player, line: [a, b, c] };
                }
            }
            return null;
        };

        /**
         * Checks if the game is a draw (all cells filled).
         */
        const checkDraw = (board) => {
            return board.flat().every(cell => cell !== '');
        };

        /**
         * Early draw detection (Feature 9): checks if any winning line
         * can still be completed by either player. A line is dead if it
         * contains both an X and an O.
         */
        const checkEarlyDraw = (board) => {
            const flatBoard = board.flat();
            // If the board is already full, use normal draw check
            if (flatBoard.every(cell => cell !== '')) return false;

            for (let i = 0; i < WIN_LINES.length; i++) {
                const [a, b, c] = WIN_LINES[i];
                const cells = [flatBoard[a], flatBoard[b], flatBoard[c]];
                const hasX = cells.includes(PLAYERS.X);
                const hasO = cells.includes(PLAYERS.O);
                // If a line has only one player's marks (or empty), it's still winnable
                if (!(hasX && hasO)) {
                    return false; // At least one line is still viable
                }
            }
            // All lines are blocked - early draw
            return true;
        };

        /**
         * Converts a flat array back into a 3x3 board.
         */
        const unflatten = (flat) => {
            return [flat.slice(0, 3), flat.slice(3, 6), flat.slice(6, 9)];
        };

        // --- AI LOGIC ---

        const minimax = (flatBoard, isMaximizing, aiPlayer, alpha, beta) => {
            const opponent = aiPlayer === PLAYERS.X ? PLAYERS.O : PLAYERS.X;
            const board2d = unflatten(flatBoard);

            if (checkWinner(board2d, aiPlayer)) return 10;
            if (checkWinner(board2d, opponent)) return -10;
            if (flatBoard.every(cell => cell !== '')) return 0;

            const emptyCells = [];
            for (let i = 0; i < 9; i++) {
                if (flatBoard[i] === '') emptyCells.push(i);
            }

            if (isMaximizing) {
                let best = -Infinity;
                for (const idx of emptyCells) {
                    flatBoard[idx] = aiPlayer;
                    const score = minimax(flatBoard, false, aiPlayer, alpha, beta);
                    flatBoard[idx] = '';
                    best = Math.max(best, score);
                    alpha = Math.max(alpha, best);
                    if (beta <= alpha) break;
                }
                return best;
            } else {
                let best = Infinity;
                for (const idx of emptyCells) {
                    flatBoard[idx] = opponent;
                    const score = minimax(flatBoard, true, aiPlayer, alpha, beta);
                    flatBoard[idx] = '';
                    best = Math.min(best, score);
                    beta = Math.min(beta, best);
                    if (beta <= alpha) break;
                }
                return best;
            }
        };

        const getAIMoveHard = (board, aiPlayer) => {
            const flatBoard = [...board.flat()];
            let bestScore = -Infinity;
            let bestMove = -1;

            for (let i = 0; i < 9; i++) {
                if (flatBoard[i] === '') {
                    flatBoard[i] = aiPlayer;
                    const score = minimax(flatBoard, false, aiPlayer, -Infinity, Infinity);
                    flatBoard[i] = '';
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = i;
                    }
                }
            }
            return bestMove;
        };

        const getAIMoveEasy = (board) => {
            const flatBoard = board.flat();
            const emptyCells = flatBoard.map((cell, i) => cell === '' ? i : -1).filter(i => i !== -1);
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        };

        const getAIMoveMedium = (board, aiPlayer) => {
            const opponent = aiPlayer === PLAYERS.X ? PLAYERS.O : PLAYERS.X;
            const flatBoard = board.flat();
            const emptyCells = flatBoard.map((cell, index) => cell === '' ? index : -1).filter(index => index !== -1);

            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                const tempBoard = [...flatBoard];
                tempBoard[move] = aiPlayer;
                if (checkWinner(unflatten(tempBoard), aiPlayer)) return move;
            }

            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                const tempBoard = [...flatBoard];
                tempBoard[move] = opponent;
                if (checkWinner(unflatten(tempBoard), opponent)) return move;
            }

            if (emptyCells.includes(4)) return 4;

            const corners = [0, 2, 6, 8];
            const availableCorners = corners.filter(corner => emptyCells.includes(corner));
            if (availableCorners.length > 0) {
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }

            const sides = [1, 3, 5, 7];
            const availableSides = sides.filter(side => emptyCells.includes(side));
            if (availableSides.length > 0) {
                return availableSides[Math.floor(Math.random() * availableSides.length)];
            }

            return emptyCells[0];
        };

        const getAIMove = (board, aiPlayer, difficulty) => {
            switch (difficulty) {
                case DIFFICULTIES.EASY:
                    return getAIMoveEasy(board);
                case DIFFICULTIES.HARD:
                    return getAIMoveHard(board, aiPlayer);
                case DIFFICULTIES.MEDIUM:
                default:
                    return getAIMoveMedium(board, aiPlayer);
            }
        };

        // --- CONFETTI ENGINE (Feature 8) ---
        const ConfettiEngine = (() => {
            let animFrame = null;
            let particles = [];
            let canvas = null;
            let ctx = null;

            const PARTICLE_COUNT = 80;
            const COLORS = ['#FF007F', '#00FFFF', '#FFFF00', '#FF6600', '#00FF00', '#FF00FF', '#4488FF'];
            const GRAVITY = 0.12;
            const FRICTION = 0.99;

            const createParticle = (canvasW, canvasH) => {
                const angle = Math.random() * Math.PI * 2;
                const speed = 4 + Math.random() * 8;
                return {
                    x: canvasW / 2 + (Math.random() - 0.5) * 100,
                    y: canvasH / 2 - 50,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 4,
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    size: 3 + Math.random() * 5,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    life: 1,
                    decay: 0.005 + Math.random() * 0.008,
                    shape: Math.random() > 0.5 ? 'rect' : 'circle',
                };
            };

            const update = () => {
                if (!canvas || !ctx) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                let alive = false;
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    if (p.life <= 0) continue;
                    alive = true;

                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += GRAVITY;
                    p.vx *= FRICTION;
                    p.rotation += p.rotationSpeed;
                    p.life -= p.decay;

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate((p.rotation * Math.PI) / 180);
                    ctx.globalAlpha = Math.max(0, p.life);
                    ctx.fillStyle = p.color;

                    if (p.shape === 'rect') {
                        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                if (alive) {
                    animFrame = requestAnimationFrame(update);
                } else {
                    stop();
                }
            };

            const start = (canvasEl) => {
                stop();
                canvas = canvasEl;
                if (!canvas) return;
                ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                particles = [];
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push(createParticle(canvas.width, canvas.height));
                }
                animFrame = requestAnimationFrame(update);
            };

            const stop = () => {
                if (animFrame) {
                    cancelAnimationFrame(animFrame);
                    animFrame = null;
                }
                if (ctx && canvas) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                particles = [];
            };

            return { start, stop };
        })();


        // --- COMPONENTS ---

        /**
         * Rules modal with focus trapping and escape key support.
         */
        const RulesModal = ({ onClose }) => {
            const closeRef = React.useRef(null);
            const modalRef = React.useRef(null);

            React.useEffect(() => {
                const prevFocus = document.activeElement;
                if (closeRef.current) closeRef.current.focus();

                return () => {
                    if (prevFocus && typeof prevFocus.focus === 'function') {
                        prevFocus.focus();
                    }
                };
            }, []);

            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        onClose();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [onClose]);

            const handleModalKeyDown = (e) => {
                if (e.key !== 'Tab') return;
                const focusable = modalRef.current.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                if (focusable.length === 0) return;
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            };

            return (
                <div
                    className="modal-overlay"
                    role="dialog"
                    aria-modal="true"
                    aria-label="Game rules"
                    onKeyDown={handleModalKeyDown}
                    ref={modalRef}
                    onClick={(e) => { if (e.target === e.currentTarget) onClose(); }}
                >
                    <div className="modal-content">
                        <button
                            ref={closeRef}
                            onClick={onClose}
                            className="modal-close-button"
                            aria-label="Close rules"
                        >
                            &times;
                        </button>
                        <h2 className="text-3xl font-bold text-cyan-400 mb-4 text-shadow-neon">Game Rules: Tic-Tac-Toe</h2>
                        <p className="text-gray-200 mb-2">
                            The classic game of Tic-Tac-Toe! Get three of your marks ('X' or 'O') in a row, column, or diagonal to win.
                        </p>
                        <h3 className="text-xl font-bold text-blue-300 mt-4 mb-2">How to Play:</h3>
                        <ul className="list-disc list-inside text-gray-200 space-y-2">
                            <li>
                                <strong>Choose a Mode:</strong> Select "1 vs 1 (Local)" to play against another person on the same device, or "1 vs AI" to challenge the computer.
                            </li>
                            <li>
                                <strong>Take Turns:</strong> Players take turns placing their mark ('X' or 'O') into an empty square on the 3x3 grid.
                            </li>
                            <li>
                                <strong>Win Condition:</strong> The first player to get three of their marks in a horizontal, vertical, or diagonal row wins the game.
                            </li>
                            <li>
                                <strong>Draw:</strong> If all 9 squares are filled and no player has achieved three in a row, the game is a draw. The game also detects early draws when no winning lines remain possible.
                            </li>
                            <li>
                                <strong>Difficulty:</strong> In AI mode, choose <strong>Easy</strong> (random), <strong>Medium</strong> (heuristic), or <strong>Hard</strong> (unbeatable minimax).
                            </li>
                            <li>
                                <strong>First Move:</strong> In AI mode, you can choose to play as X (go first) or O (go second).
                            </li>
                            <li>
                                <strong>Undo:</strong> Click the <strong>"Undo"</strong> button to take back your last move. In AI mode, this undoes both your move and the AI's response.
                            </li>
                            <li>
                                <strong>Replay:</strong> After a game ends, click <strong>"Replay"</strong> to step through the move history one move at a time.
                            </li>
                            <li>
                                <strong>Pause/Resume:</strong> Click the <strong>"Pause"</strong> button to temporarily stop the game and blur the screen. Click <strong>"Resume"</strong> to continue.
                            </li>
                            <li>
                                <strong>Custom Names:</strong> Enter nicknames on the start screen to personalise the game.
                            </li>
                            <li>
                                <strong>Themes:</strong> Switch between Neon Pink, Classic, and Retro Green board themes.
                            </li>
                            <li>
                                <strong>New Game:</strong> Click the "New Game" button to start over.
                            </li>
                        </ul>
                    </div>
                </div>
            );
        };

        /**
         * Represents a single cell on the Tic-Tac-Toe board.
         */
        const Cell = ({ value, onClick, row, col, ghostMark, canInteract, entranceDelay }) => {
            const [hovered, setHovered] = React.useState(false);
            const isOccupied = !!value;
            const showGhost = hovered && !isOccupied && canInteract && ghostMark;

            const entranceStyle = entranceDelay !== undefined ? {
                animationDelay: `${entranceDelay}ms`,
            } : {};

            const entranceClass = entranceDelay !== undefined ? 'cell-entrance' : '';

            return (
                <div
                    className={`cell rounded-lg transition-all duration-200 ${isOccupied ? 'occupied' : 'cursor-pointer'} ${entranceClass}`}
                    style={entranceStyle}
                    onClick={isOccupied ? undefined : onClick}
                    onKeyDown={isOccupied ? undefined : (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onClick(); } }}
                    onMouseEnter={() => setHovered(true)}
                    onMouseLeave={() => setHovered(false)}
                    role="gridcell"
                    tabIndex={isOccupied ? "-1" : "0"}
                    aria-disabled={isOccupied ? "true" : undefined}
                    aria-label={`Row ${row + 1}, column ${col + 1}${value ? `, marked ${value}` : ', empty'}`}
                >
                    {value && (
                        <div className={`cell-content ${value === PLAYERS.X ? 'x-color' : 'o-color'}`} aria-hidden="true">
                            {value}
                        </div>
                    )}
                    {showGhost && (
                        <div className={`cell-ghost ${ghostMark === PLAYERS.X ? 'x-color' : 'o-color'}`} aria-hidden="true">
                            {ghostMark}
                        </div>
                    )}
                </div>
            );
        };

        /**
         * SVG win line overlay using grid-relative coordinates.
         */
        const WinLineOverlay = ({ winningLine }) => {
            if (!winningLine) return null;

            const [c1, , c3] = winningLine;
            const row1 = Math.floor(c1 / 3);
            const col1 = c1 % 3;
            const row3 = Math.floor(c3 / 3);
            const col3 = c3 % 3;

            const x1 = col1 + 0.5;
            const y1 = row1 + 0.5;
            const x2 = col3 + 0.5;
            const y2 = row3 + 0.5;

            return (
                <svg
                    className="win-line-svg"
                    viewBox="0 0 3 3"
                    preserveAspectRatio="none"
                    aria-hidden="true"
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none',
                        zIndex: 10,
                    }}
                >
                    <line
                        x1={x1} y1={y1}
                        x2={x2} y2={y2}
                        stroke={getComputedStyle(document.documentElement).getPropertyValue('--theme-win-line').trim() || '#FFFF00'}
                        strokeWidth="0.12"
                        strokeLinecap="round"
                        pathLength="1"
                        style={{ filter: 'drop-shadow(0 0 3px #FFFF00)' }}
                    />
                </svg>
            );
        };

        /**
         * Main Tic-Tac-Toe game component.
         */
        const TicTacToeGame = () => {
            const emptyBoard = () => Array(3).fill(null).map(() => Array(3).fill(''));

            const [board, setBoard] = React.useState(emptyBoard());
            const [currentPlayer, setCurrentPlayer] = React.useState(PLAYERS.X);
            const [gameMode, setGameMode] = React.useState(null); // null, 'PvP', 'PvAI'
            const [difficulty, setDifficulty] = React.useState(DIFFICULTIES.MEDIUM);
            const [winner, setWinner] = React.useState(null); // null, 'X', 'O', 'Draw'
            const [winningLine, setWinningLine] = React.useState(null);
            const [message, setMessage] = React.useState('');
            const [showRules, setShowRules] = React.useState(false);
            const [isPaused, setIsPaused] = React.useState(false);
            const [aiThinking, setAiThinking] = React.useState(false);
            const [isMuted, setIsMuted] = React.useState(SoundEngine.isMuted());

            // Move history for undo: array of { board, currentPlayer } snapshots
            const [moveHistory, setMoveHistory] = React.useState([]);

            // Feature 1: Win streak
            const [streakPvp, setStreakPvp] = React.useState(() => loadStreak(STREAK_KEY_PVP));
            const [streakPvai, setStreakPvai] = React.useState(() => loadStreak(STREAK_KEY_PVAI));

            // Feature 2: Board entrance animation key
            const [boardKey, setBoardKey] = React.useState(0);

            // Feature 3: First-move chooser for PvAI
            const [humanPlayer, setHumanPlayer] = React.useState(PLAYERS.X);
            const [aiPlayer, setAiPlayer] = React.useState(PLAYERS.O);
            const [choosingFirstMove, setChoosingFirstMove] = React.useState(false);

            // Feature 4: Game Replay
            const [gameMoves, setGameMoves] = React.useState([]); // Array of { index, player } for replay
            const [isReplaying, setIsReplaying] = React.useState(false);
            const [replayStep, setReplayStep] = React.useState(0);
            const replayTimeoutRef = React.useRef(null);

            // Feature 6: Custom player names
            const [nameX, setNameX] = React.useState('');
            const [nameO, setNameO] = React.useState('');

            // Feature 7: Board theme
            const [theme, setTheme] = React.useState(() => loadTheme());

            // Feature 8: Confetti canvas ref
            const confettiCanvasRef = React.useRef(null);

            // Feature 9: Early draw message
            const [earlyDrawMessage, setEarlyDrawMessage] = React.useState('');

            // Stats
            const [statsPvp, setStatsPvp] = React.useState(() => loadStats(STATS_KEY_PVP));
            const [statsPvai, setStatsPvai] = React.useState(() => loadStats(STATS_KEY_PVAI));

            // Ref to hold AI timeout for proper cleanup
            const aiTimeoutRef = React.useRef(null);
            const boardRef = React.useRef(board);
            React.useEffect(() => { boardRef.current = board; }, [board]);
            const difficultyRef = React.useRef(difficulty);
            React.useEffect(() => { difficultyRef.current = difficulty; }, [difficulty]);
            const gridRef = React.useRef(null);
            const winButtonRef = React.useRef(null);

            // Apply theme to document
            React.useEffect(() => {
                if (theme === 'neon-pink') {
                    document.documentElement.removeAttribute('data-theme');
                } else {
                    document.documentElement.setAttribute('data-theme', theme);
                }
            }, [theme]);

            const handleThemeChange = (newTheme) => {
                setTheme(newTheme);
                saveTheme(newTheme);
            };

            // Clean up AI timeout on unmount
            React.useEffect(() => {
                return () => {
                    if (aiTimeoutRef.current !== null) {
                        clearTimeout(aiTimeoutRef.current);
                        aiTimeoutRef.current = null;
                    }
                    if (replayTimeoutRef.current !== null) {
                        clearTimeout(replayTimeoutRef.current);
                        replayTimeoutRef.current = null;
                    }
                    ConfettiEngine.stop();
                };
            }, []);

            // Helper to get display name for a player mark
            const getPlayerName = (mark) => {
                if (mark === PLAYERS.X) {
                    return nameX || 'Player X';
                }
                return nameO || 'Player O';
            };

            // Record outcome to stats and update streak (Feature 1)
            const recordOutcome = React.useCallback((outcome) => {
                if (!gameMode) return;
                const key = gameMode === GAME_MODES.PVP ? STATS_KEY_PVP : STATS_KEY_PVAI;
                const streakKey = gameMode === GAME_MODES.PVP ? STREAK_KEY_PVP : STREAK_KEY_PVAI;
                const setter = gameMode === GAME_MODES.PVP ? setStatsPvp : setStatsPvai;
                const streakSetter = gameMode === GAME_MODES.PVP ? setStreakPvp : setStreakPvai;

                setter(prev => {
                    const next = { ...prev };
                    if (outcome === 'draw') {
                        next.draws += 1;
                    } else if (gameMode === GAME_MODES.PVP) {
                        if (outcome === 'X_wins') next.wins += 1;
                        else next.losses += 1;
                    } else {
                        // PvAI: determine win/loss from human player perspective
                        const humanWon = (outcome === 'X_wins' && humanPlayer === PLAYERS.X) ||
                                         (outcome === 'O_wins' && humanPlayer === PLAYERS.O);
                        if (humanWon) next.wins += 1;
                        else next.losses += 1;
                    }
                    saveStats(key, next);
                    return next;
                });

                // Update streak (Feature 1)
                streakSetter(prev => {
                    let isWin = false;
                    if (outcome === 'draw') {
                        // Draw doesn't change streak
                        return prev;
                    } else if (gameMode === GAME_MODES.PVP) {
                        isWin = outcome === 'X_wins';
                    } else {
                        isWin = (outcome === 'X_wins' && humanPlayer === PLAYERS.X) ||
                                (outcome === 'O_wins' && humanPlayer === PLAYERS.O);
                    }
                    const newStreak = isWin ? prev + 1 : 0;
                    saveStreak(streakKey, newStreak);
                    return newStreak;
                });
            }, [gameMode, humanPlayer]);

            // Handle a player's move
            const handleMove = React.useCallback((newBoard, playerMoved, isAIMove) => {
                setBoard(newBoard);

                if (isAIMove) {
                    SoundEngine.playAIMove();
                } else if (playerMoved === PLAYERS.X) {
                    SoundEngine.playX();
                } else {
                    SoundEngine.playO();
                }

                const winResult = checkWinner(newBoard, playerMoved);

                if (winResult) {
                    setWinner(winResult.winner);
                    setWinningLine(winResult.line);
                    setMessage(`${getPlayerName(winResult.winner)} WINS!`);
                    setEarlyDrawMessage('');
                    SoundEngine.playVictory();
                    recordOutcome(winResult.winner === PLAYERS.X ? 'X_wins' : 'O_wins');
                    // Feature 8: Trigger confetti
                    if (confettiCanvasRef.current) {
                        ConfettiEngine.start(confettiCanvasRef.current);
                    }
                } else if (checkDraw(newBoard)) {
                    setWinner('Draw');
                    setMessage("It's a DRAW!");
                    setEarlyDrawMessage('');
                    SoundEngine.playDraw();
                    recordOutcome('draw');
                } else if (checkEarlyDraw(newBoard)) {
                    // Feature 9: Early draw detection
                    setWinner('Draw');
                    setMessage("Draw - No possible wins remaining.");
                    setEarlyDrawMessage("Draw - No possible wins remaining.");
                    SoundEngine.playDraw();
                    recordOutcome('draw');
                } else {
                    const nextPlayer = playerMoved === PLAYERS.X ? PLAYERS.O : PLAYERS.X;
                    setCurrentPlayer(nextPlayer);
                    setMessage(`${getPlayerName(nextPlayer)}'s turn`);
                }
            }, [recordOutcome, nameX, nameO]);

            // AI move logic - now uses dynamic aiPlayer instead of hardcoded O
            const handleAIMove = React.useCallback(() => {
                if (gameMode === GAME_MODES.PVAI && currentPlayer === aiPlayer && !winner && !checkDraw(board) && !checkEarlyDraw(board) && !isPaused) {
                    setAiThinking(true);
                    setMessage("AI is thinking...");
                    aiTimeoutRef.current = setTimeout(() => {
                        aiTimeoutRef.current = null;
                        const latestBoard = boardRef.current;
                        const moveIndex = getAIMove(latestBoard, aiPlayer, difficultyRef.current);
                        if (moveIndex === -1 || moveIndex === undefined) return;
                        const newBoardFlat = [...latestBoard.flat()];
                        newBoardFlat[moveIndex] = aiPlayer;
                        const updatedBoard = unflatten(newBoardFlat);

                        // Save state before AI move for undo
                        setMoveHistory(prev => [...prev, { board: latestBoard, currentPlayer: aiPlayer }]);

                        // Record move for replay (Feature 4)
                        setGameMoves(prev => [...prev, { index: moveIndex, player: aiPlayer }]);

                        handleMove(updatedBoard, aiPlayer, true);
                        setAiThinking(false);
                    }, AI_THINK_DELAY);
                }
            }, [board, currentPlayer, gameMode, winner, isPaused, handleMove, aiPlayer]);

            // Effect to trigger AI's turn
            React.useEffect(() => {
                if (gameMode === GAME_MODES.PVAI && currentPlayer === aiPlayer && !winner && !checkDraw(board) && !checkEarlyDraw(board) && !isPaused && !aiThinking && !isReplaying) {
                    handleAIMove();
                }
                return () => {
                    if (aiTimeoutRef.current !== null) {
                        clearTimeout(aiTimeoutRef.current);
                        aiTimeoutRef.current = null;
                        setAiThinking(false);
                    }
                };
            }, [board, currentPlayer, gameMode, winner, isPaused, aiThinking, handleAIMove, aiPlayer, isReplaying]);

            // Handle cell click from UI
            const handleCellClick = React.useCallback((rowIndex, colIndex) => {
                if (winner || isPaused || aiThinking || isReplaying || board[rowIndex][colIndex] !== '') {
                    return;
                }

                // In PvAI, only allow human player to click
                if (gameMode === GAME_MODES.PVAI && currentPlayer !== humanPlayer) {
                    return;
                }

                setMoveHistory(prev => [...prev, { board: board, currentPlayer: currentPlayer }]);

                // Record move for replay (Feature 4)
                const flatIndex = rowIndex * 3 + colIndex;
                setGameMoves(prev => [...prev, { index: flatIndex, player: currentPlayer }]);

                const newBoard = board.map(row => [...row]);
                newBoard[rowIndex][colIndex] = currentPlayer;

                handleMove(newBoard, currentPlayer, false);
            }, [winner, isPaused, aiThinking, isReplaying, board, currentPlayer, handleMove, gameMode, humanPlayer]);

            // Undo handler
            const handleUndo = React.useCallback(() => {
                if (moveHistory.length === 0 || winner || aiThinking || isPaused || isReplaying) return;

                if (gameMode === GAME_MODES.PVAI) {
                    if (moveHistory.length >= 2) {
                        const playerState = moveHistory[moveHistory.length - 2];
                        setBoard(playerState.board);
                        setCurrentPlayer(playerState.currentPlayer);
                        setMoveHistory(prev => prev.slice(0, -2));
                        setGameMoves(prev => prev.slice(0, -2));
                        setMessage(`${getPlayerName(playerState.currentPlayer)}'s turn`);
                    } else if (moveHistory.length === 1) {
                        const prevState = moveHistory[moveHistory.length - 1];
                        setBoard(prevState.board);
                        setCurrentPlayer(prevState.currentPlayer);
                        setMoveHistory([]);
                        setGameMoves(prev => prev.slice(0, -1));
                        setMessage(`${getPlayerName(prevState.currentPlayer)}'s turn`);
                    }
                } else {
                    const prevState = moveHistory[moveHistory.length - 1];
                    setBoard(prevState.board);
                    setCurrentPlayer(prevState.currentPlayer);
                    setMoveHistory(prev => prev.slice(0, -1));
                    setGameMoves(prev => prev.slice(0, -1));
                    setMessage(`${getPlayerName(prevState.currentPlayer)}'s turn`);
                }
            }, [moveHistory, winner, aiThinking, isPaused, gameMode, isReplaying, nameX, nameO]);

            const canUndo = moveHistory.length > 0 && !winner && !aiThinking && !isPaused && !isReplaying;

            // --- Feature 4: Game Replay ---
            const startReplay = React.useCallback(() => {
                if (gameMoves.length === 0) return;
                setIsReplaying(true);
                setReplayStep(0);
                setBoard(emptyBoard());
                setWinner(null);
                setWinningLine(null);
                setEarlyDrawMessage('');
                setMessage('Replaying...');
            }, [gameMoves]);

            // Replay stepper effect
            React.useEffect(() => {
                if (!isReplaying) return;

                if (replayStep >= gameMoves.length) {
                    // Replay finished - restore final state
                    replayTimeoutRef.current = setTimeout(() => {
                        // Rebuild final board from all moves
                        const finalFlat = Array(9).fill('');
                        gameMoves.forEach(m => { finalFlat[m.index] = m.player; });
                        const finalBoard = unflatten(finalFlat);
                        setBoard(finalBoard);

                        // Check for winner on final board
                        const winX = checkWinner(finalBoard, PLAYERS.X);
                        const winO = checkWinner(finalBoard, PLAYERS.O);
                        if (winX) {
                            setWinner(winX.winner);
                            setWinningLine(winX.line);
                            setMessage(`${getPlayerName(winX.winner)} WINS!`);
                            if (confettiCanvasRef.current) ConfettiEngine.start(confettiCanvasRef.current);
                        } else if (winO) {
                            setWinner(winO.winner);
                            setWinningLine(winO.line);
                            setMessage(`${getPlayerName(winO.winner)} WINS!`);
                            if (confettiCanvasRef.current) ConfettiEngine.start(confettiCanvasRef.current);
                        } else {
                            setWinner('Draw');
                            setMessage(earlyDrawMessage || "It's a DRAW!");
                        }
                        setIsReplaying(false);
                    }, REPLAY_STEP_DELAY);
                    return;
                }

                replayTimeoutRef.current = setTimeout(() => {
                    const move = gameMoves[replayStep];
                    setBoard(prevBoard => {
                        const flat = [...prevBoard.flat()];
                        flat[move.index] = move.player;
                        return unflatten(flat);
                    });
                    setMessage(`Replaying... move ${replayStep + 1}/${gameMoves.length}`);
                    setReplayStep(prev => prev + 1);
                }, REPLAY_STEP_DELAY);

                return () => {
                    if (replayTimeoutRef.current) {
                        clearTimeout(replayTimeoutRef.current);
                        replayTimeoutRef.current = null;
                    }
                };
            }, [isReplaying, replayStep, gameMoves, nameX, nameO]);

            const stopReplay = React.useCallback(() => {
                if (replayTimeoutRef.current) {
                    clearTimeout(replayTimeoutRef.current);
                    replayTimeoutRef.current = null;
                }
                // Restore final board state
                const finalFlat = Array(9).fill('');
                gameMoves.forEach(m => { finalFlat[m.index] = m.player; });
                const finalBoard = unflatten(finalFlat);
                setBoard(finalBoard);

                const winX = checkWinner(finalBoard, PLAYERS.X);
                const winO = checkWinner(finalBoard, PLAYERS.O);
                if (winX) {
                    setWinner(winX.winner);
                    setWinningLine(winX.line);
                    setMessage(`${getPlayerName(winX.winner)} WINS!`);
                } else if (winO) {
                    setWinner(winO.winner);
                    setWinningLine(winO.line);
                    setMessage(`${getPlayerName(winO.winner)} WINS!`);
                } else {
                    setWinner('Draw');
                    setMessage(earlyDrawMessage || "It's a DRAW!");
                }
                setIsReplaying(false);
            }, [gameMoves, nameX, nameO, earlyDrawMessage]);

            const resetGame = () => {
                if (aiTimeoutRef.current !== null) {
                    clearTimeout(aiTimeoutRef.current);
                    aiTimeoutRef.current = null;
                }
                if (replayTimeoutRef.current !== null) {
                    clearTimeout(replayTimeoutRef.current);
                    replayTimeoutRef.current = null;
                }
                ConfettiEngine.stop();
                setBoard(emptyBoard());
                setCurrentPlayer(PLAYERS.X);
                setWinner(null);
                setWinningLine(null);
                setMessage('');
                setIsPaused(false);
                setAiThinking(false);
                setMoveHistory([]);
                setGameMoves([]);
                setIsReplaying(false);
                setReplayStep(0);
                setEarlyDrawMessage('');
                setGameMode(null);
                setChoosingFirstMove(false);
                setHumanPlayer(PLAYERS.X);
                setAiPlayer(PLAYERS.O);
                // Increment boardKey so next game gets entrance animation
                setBoardKey(prev => prev + 1);
            };

            const startNewGameSameMode = () => {
                if (aiTimeoutRef.current !== null) {
                    clearTimeout(aiTimeoutRef.current);
                    aiTimeoutRef.current = null;
                }
                if (replayTimeoutRef.current !== null) {
                    clearTimeout(replayTimeoutRef.current);
                    replayTimeoutRef.current = null;
                }
                ConfettiEngine.stop();
                setBoard(emptyBoard());
                setCurrentPlayer(PLAYERS.X);
                setWinner(null);
                setWinningLine(null);
                setIsPaused(false);
                setAiThinking(false);
                setMoveHistory([]);
                setGameMoves([]);
                setIsReplaying(false);
                setReplayStep(0);
                setEarlyDrawMessage('');
                setBoardKey(prev => prev + 1);

                if (gameMode === GAME_MODES.PVAI && humanPlayer === PLAYERS.O) {
                    // AI goes first as X
                    setMessage("AI is thinking...");
                } else {
                    setMessage(`${getPlayerName(PLAYERS.X)}'s turn`);
                }
            };

            const resetStats = (key) => {
                const empty = { wins: 0, losses: 0, draws: 0 };
                saveStats(key, empty);
                if (key === STATS_KEY_PVP) {
                    setStatsPvp(empty);
                    setStreakPvp(0);
                    saveStreak(STREAK_KEY_PVP, 0);
                } else {
                    setStatsPvai(empty);
                    setStreakPvai(0);
                    saveStreak(STREAK_KEY_PVAI, 0);
                }
            };

            const handleMuteToggle = () => {
                const nowMuted = SoundEngine.toggleMute();
                setIsMuted(nowMuted);
            };

            // Focus management: move focus to Play Again button when win/draw overlay appears
            React.useEffect(() => {
                if (winner && !isReplaying && winButtonRef.current) {
                    winButtonRef.current.focus();
                }
            }, [winner, isReplaying]);

            // Feature 3: Start game flow
            const startGame = (mode) => {
                if (mode === GAME_MODES.PVAI) {
                    setChoosingFirstMove(true);
                    setGameMode(mode);
                } else {
                    setGameMode(mode);
                    setMessage(`${getPlayerName(PLAYERS.X)}'s turn`);
                    setMoveHistory([]);
                    setGameMoves([]);
                    setBoardKey(prev => prev + 1);
                }
            };

            const chooseFirstMove = (playAs) => {
                setHumanPlayer(playAs);
                const ai = playAs === PLAYERS.X ? PLAYERS.O : PLAYERS.X;
                setAiPlayer(ai);
                setChoosingFirstMove(false);
                setMoveHistory([]);
                setGameMoves([]);
                setBoardKey(prev => prev + 1);

                if (playAs === PLAYERS.O) {
                    // AI goes first as X
                    setCurrentPlayer(PLAYERS.X);
                    setMessage("AI is thinking...");
                } else {
                    setCurrentPlayer(PLAYERS.X);
                    setMessage(`${nameX || 'Player X'}'s turn`);
                }
            };

            // Current stats based on game mode
            const currentStats = gameMode === GAME_MODES.PVP ? statsPvp : statsPvai;
            const currentStatsKey = gameMode === GAME_MODES.PVP ? STATS_KEY_PVP : STATS_KEY_PVAI;
            const currentStreak = gameMode === GAME_MODES.PVP ? streakPvp : streakPvai;

            // Whether cells can be interacted with
            const cellsInteractive = !winner && !isPaused && !aiThinking && !isReplaying;

            // Ghost mark: in PvAI show humanPlayer mark, in PvP show currentPlayer
            const ghostMark = cellsInteractive
                ? (gameMode === GAME_MODES.PVAI ? humanPlayer : currentPlayer)
                : null;

            // --- MODE SELECTION SCREEN ---
            if (!gameMode) {
                return (
                    <div className="min-h-screen relative bg-gray-900 text-white flex flex-col items-center justify-center p-4">
                        <div className="scanline-overlay" aria-hidden="true"></div>
                        <button className="mute-btn" onClick={handleMuteToggle} aria-label={isMuted ? 'Unmute sounds' : 'Mute sounds'}>
                            {isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A'}
                        </button>
                        <div className="relative z-10 bg-black/40 rounded-xl shadow-2xl p-6 w-full max-w-md border border-blue-700/50 shadow-blue-900/40 text-center">
                            <h1 className="text-4xl md:text-5xl font-bold mb-6 bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent tracking-wider text-shadow-neon">
                                TIC-TAC-TOE
                            </h1>

                            {/* Feature 6: Custom Player Names */}
                            <div className="mb-5">
                                <p className="text-cyan-300/60 text-xs mb-2">Enter nicknames (optional):</p>
                                <div className="flex justify-center gap-3 flex-wrap">
                                    <div className="flex flex-col items-center gap-1">
                                        <label className="text-xs text-gray-400" htmlFor="name-x">Player X</label>
                                        <input
                                            id="name-x"
                                            className="name-input"
                                            type="text"
                                            maxLength={12}
                                            placeholder="Player X"
                                            value={nameX}
                                            onChange={(e) => setNameX(e.target.value)}
                                        />
                                    </div>
                                    <div className="flex flex-col items-center gap-1">
                                        <label className="text-xs text-gray-400" htmlFor="name-o">Player O</label>
                                        <input
                                            id="name-o"
                                            className="name-input"
                                            type="text"
                                            maxLength={12}
                                            placeholder="Player O"
                                            value={nameO}
                                            onChange={(e) => setNameO(e.target.value)}
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* Feature 7: Theme selector */}
                            <div className="theme-selector mb-5" role="group" aria-label="Board theme">
                                {THEMES.map(t => (
                                    <button
                                        key={t.id}
                                        className={`theme-btn ${t.id} ${theme === t.id ? 'active' : ''}`}
                                        onClick={() => handleThemeChange(t.id)}
                                        aria-pressed={theme === t.id}
                                    >
                                        {t.label}
                                    </button>
                                ))}
                            </div>

                            <p className="text-cyan-300/80 mb-6 text-shadow-neon">Choose your challenge:</p>
                            <div className="flex flex-col space-y-4" role="group" aria-label="Game mode selection">
                                <button
                                    onClick={() => startGame(GAME_MODES.PVP)}
                                    className="action-btn py-3 px-8 bg-blue-700 hover:bg-blue-800 text-white font-bold rounded-lg shadow-lg shadow-blue-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xl"
                                >
                                    1 vs 1 (Local)
                                </button>
                                <button
                                    onClick={() => startGame(GAME_MODES.PVAI)}
                                    className="action-btn py-3 px-8 bg-green-700 hover:bg-green-800 text-white font-bold rounded-lg shadow-lg shadow-green-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xl"
                                >
                                    1 vs AI
                                </button>
                            </div>
                            <button
                                onClick={() => setShowRules(true)}
                                className="action-btn mt-8 py-2 px-6 bg-yellow-700 hover:bg-yellow-800 text-white font-bold rounded-lg shadow-lg shadow-yellow-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                            >
                                Rules
                            </button>
                        </div>
                        {showRules && <RulesModal onClose={() => setShowRules(false)} />}
                    </div>
                );
            }

            // --- Feature 3: FIRST-MOVE CHOOSER SCREEN ---
            if (choosingFirstMove) {
                return (
                    <div className="min-h-screen relative bg-gray-900 text-white flex flex-col items-center justify-center p-4">
                        <div className="scanline-overlay" aria-hidden="true"></div>
                        <button className="mute-btn" onClick={handleMuteToggle} aria-label={isMuted ? 'Unmute sounds' : 'Mute sounds'}>
                            {isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A'}
                        </button>
                        <div className="relative z-10 bg-black/40 rounded-xl shadow-2xl p-6 w-full max-w-md border border-blue-700/50 shadow-blue-900/40 text-center">
                            <h1 className="text-3xl md:text-4xl font-bold mb-6 bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent tracking-wider text-shadow-neon">
                                CHOOSE YOUR SIDE
                            </h1>
                            <p className="text-cyan-300/80 mb-6 text-shadow-neon">Do you want to go first or second?</p>
                            <div className="first-move-chooser">
                                <button
                                    onClick={() => chooseFirstMove(PLAYERS.X)}
                                    className="first-move-btn action-btn py-3 px-8 bg-pink-700 hover:bg-pink-800 text-white font-bold rounded-lg shadow-lg shadow-pink-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-lg"
                                >
                                    Play as X (Go First)
                                </button>
                                <button
                                    onClick={() => chooseFirstMove(PLAYERS.O)}
                                    className="first-move-btn action-btn py-3 px-8 bg-cyan-700 hover:bg-cyan-800 text-white font-bold rounded-lg shadow-lg shadow-cyan-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-lg"
                                >
                                    Play as O (Go Second)
                                </button>
                                <button
                                    onClick={resetGame}
                                    className="action-btn mt-4 py-2 px-6 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105 active:scale-95 text-sm"
                                >
                                    Back
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen relative bg-gray-900 text-white flex flex-col items-center justify-center p-4">
                    {/* Scanline overlay for retro CRT effect */}
                    <div className="scanline-overlay" aria-hidden="true"></div>
                    {/* Mute toggle */}
                    <button className="mute-btn" onClick={handleMuteToggle} aria-label={isMuted ? 'Unmute sounds' : 'Mute sounds'}>
                        {isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A'}
                    </button>

                    {/* Feature 8: Confetti canvas */}
                    <canvas ref={confettiCanvasRef} className="confetti-canvas" aria-hidden="true"></canvas>

                    <div className="relative z-10 bg-black/40 rounded-xl shadow-2xl p-6 w-full max-w-md border border-blue-700/50 shadow-blue-900/40">
                        <h1 className="text-4xl md:text-5xl font-bold text-center mb-4 bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent tracking-wider text-shadow-neon">
                            TIC-TAC-TOE
                        </h1>

                        {/* Difficulty Selector (PvAI only) */}
                        {gameMode === GAME_MODES.PVAI && (
                            <div className="difficulty-selector" role="group" aria-label="AI difficulty">
                                <button
                                    className={`difficulty-btn easy ${difficulty === DIFFICULTIES.EASY ? 'active' : ''}`}
                                    onClick={() => setDifficulty(DIFFICULTIES.EASY)}
                                    aria-pressed={difficulty === DIFFICULTIES.EASY}
                                    disabled={isPaused}
                                >
                                    Easy
                                </button>
                                <button
                                    className={`difficulty-btn medium ${difficulty === DIFFICULTIES.MEDIUM ? 'active' : ''}`}
                                    onClick={() => setDifficulty(DIFFICULTIES.MEDIUM)}
                                    aria-pressed={difficulty === DIFFICULTIES.MEDIUM}
                                    disabled={isPaused}
                                >
                                    Medium
                                </button>
                                <button
                                    className={`difficulty-btn hard ${difficulty === DIFFICULTIES.HARD ? 'active' : ''}`}
                                    onClick={() => setDifficulty(DIFFICULTIES.HARD)}
                                    aria-pressed={difficulty === DIFFICULTIES.HARD}
                                    disabled={isPaused}
                                >
                                    Hard
                                </button>
                            </div>
                        )}

                        {/* Feature 7: Theme selector */}
                        <div className="theme-selector" role="group" aria-label="Board theme">
                            {THEMES.map(t => (
                                <button
                                    key={t.id}
                                    className={`theme-btn ${t.id} ${theme === t.id ? 'active' : ''}`}
                                    onClick={() => handleThemeChange(t.id)}
                                    aria-pressed={theme === t.id}
                                >
                                    {t.label}
                                </button>
                            ))}
                        </div>

                        <p
                            className="text-center text-cyan-300/80 mb-4 text-shadow-neon"
                            style={{ color: 'var(--theme-text-status)' }}
                            role="status"
                            aria-live="polite"
                            aria-atomic="true"
                        >
                            {message || `${getPlayerName(currentPlayer)}'s turn`}
                            {aiThinking && <span className="ai-thinking-indicator ml-2" aria-hidden="true">. . .</span>}
                        </p>

                        {/* Game Board - key prop triggers re-mount for entrance animation */}
                        <div
                            key={boardKey}
                            className="p-4 rounded-lg shadow-inner mb-4 relative"
                            style={{
                                backgroundColor: 'var(--theme-grid-bg)',
                                borderColor: 'var(--theme-grid-border)',
                                borderWidth: '1px',
                                borderStyle: 'solid',
                            }}
                            role="grid"
                            aria-label="Tic-Tac-Toe board"
                            ref={gridRef}
                        >
                            {board.map((rowCells, rowIndex) => (
                                <div key={`row-${rowIndex}`} role="row" className="grid grid-cols-3 gap-2" style={rowIndex < 2 ? { marginBottom: '0.5rem' } : undefined}>
                                    {rowCells.map((cellValue, colIndex) => {
                                        const flatIdx = rowIndex * 3 + colIndex;
                                        return (
                                            <Cell
                                                key={`${rowIndex}-${colIndex}`}
                                                value={cellValue}
                                                row={rowIndex}
                                                col={colIndex}
                                                onClick={() => handleCellClick(rowIndex, colIndex)}
                                                ghostMark={ghostMark}
                                                canInteract={cellsInteractive}
                                                entranceDelay={flatIdx * 50}
                                            />
                                        );
                                    })}
                                </div>
                            ))}

                            {/* Win Line Overlay */}
                            {winner && winner !== 'Draw' && !isReplaying && (
                                <WinLineOverlay winningLine={winningLine} />
                            )}
                        </div>

                        {/* Stats Bar (Feature 1: includes streak) */}
                        <div className="stats-bar" aria-label="Game statistics">
                            <span className="stat-win" title="Wins">W: {currentStats.wins}</span>
                            <span className="stat-loss" title="Losses">L: {currentStats.losses}</span>
                            <span className="stat-draw" title="Draws">D: {currentStats.draws}</span>
                            <span className="stat-streak" title="Win Streak">Streak: {currentStreak}</span>
                            <button
                                className="stats-reset-btn"
                                onClick={() => resetStats(currentStatsKey)}
                                aria-label="Reset statistics"
                                title="Reset stats"
                            >
                                Reset
                            </button>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex justify-center space-x-3 flex-wrap gap-y-2">
                            <button
                                onClick={() => setShowRules(true)}
                                className="action-btn py-2 px-4 bg-yellow-700 hover:bg-yellow-800 text-white font-bold rounded-lg shadow-lg shadow-yellow-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                                disabled={isPaused}
                                aria-label="Show game rules"
                            >
                                Rules
                            </button>
                            <button
                                onClick={handleUndo}
                                className="action-btn py-2 px-4 bg-orange-700 hover:bg-orange-800 text-white font-bold rounded-lg shadow-lg shadow-orange-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 disabled:opacity-40 disabled:cursor-not-allowed disabled:transform-none"
                                disabled={!canUndo}
                                aria-label="Undo last move"
                            >
                                Undo
                            </button>
                            <button
                                onClick={() => setIsPaused(!isPaused)}
                                className="action-btn py-2 px-4 bg-gray-700 hover:bg-gray-800 text-white font-bold rounded-lg shadow-lg shadow-gray-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                                disabled={winner !== null || isReplaying}
                                aria-label={isPaused ? 'Resume game' : 'Pause game'}
                            >
                                {isPaused ? 'Resume' : 'Pause'}
                            </button>
                            <button
                                onClick={resetGame}
                                className="action-btn py-2 px-4 bg-purple-700 hover:bg-purple-800 text-white font-bold rounded-lg shadow-lg shadow-purple-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                                disabled={isPaused}
                                aria-label="Start a new game"
                            >
                                New Game
                            </button>
                        </div>

                        {/* Win/Draw Overlay */}
                        {winner && !isReplaying && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-70 fade-in pointer-events-none rounded-xl" role="alert" aria-live="assertive">
                                <h2 className={`text-5xl font-bold text-yellow-300 text-shadow-neon ${winner !== 'Draw' ? 'win-animation' : ''}`}>
                                    {winner === 'Draw'
                                        ? (earlyDrawMessage || "IT'S A DRAW!")
                                        : `${getPlayerName(winner)} WINS!`}
                                </h2>
                                <div className="flex gap-3 mt-6 flex-wrap justify-center">
                                    <button
                                        ref={winButtonRef}
                                        onClick={startNewGameSameMode}
                                        className="action-btn py-2 px-6 bg-purple-700 hover:bg-purple-800 text-white font-bold rounded-lg shadow-lg shadow-purple-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 pointer-events-auto"
                                    >
                                        Play Again
                                    </button>
                                    {/* Feature 4: Replay button */}
                                    {gameMoves.length > 0 && (
                                        <button
                                            onClick={startReplay}
                                            className="action-btn py-2 px-6 bg-teal-700 hover:bg-teal-800 text-white font-bold rounded-lg shadow-lg shadow-teal-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 pointer-events-auto"
                                        >
                                            Replay
                                        </button>
                                    )}
                                    <button
                                        onClick={resetGame}
                                        className="action-btn py-2 px-6 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-lg shadow-lg shadow-gray-600/50 transition-all duration-200 transform hover:scale-105 active:scale-95 pointer-events-auto"
                                    >
                                        Menu
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Replay overlay indicator */}
                        {isReplaying && (
                            <div className="absolute inset-0 flex flex-col items-center justify-end pb-8 pointer-events-none rounded-xl">
                                <button
                                    onClick={stopReplay}
                                    className="action-btn py-2 px-6 bg-red-700 hover:bg-red-800 text-white font-bold rounded-lg shadow-lg shadow-red-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 pointer-events-auto"
                                >
                                    Stop Replay
                                </button>
                            </div>
                        )}

                        {/* Pause Overlay */}
                        {isPaused && (
                            <div className="pause-overlay" role="alert" aria-live="assertive">
                                PAUSED
                            </div>
                        )}

                        {/* Rules Modal */}
                        {showRules && <RulesModal onClose={() => setShowRules(false)} />}
                    </div>
                </div>
            );
        };

        // Render the main component to the root div
        ReactDOM.render(<TicTacToeGame />, document.getElementById('root'));
    </script>
</body>
</html>
