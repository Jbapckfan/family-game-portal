<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Tic Tac Toe - Classic strategy game with AI opponent and neon cyberpunk styling.">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta property="og:title" content="Tic Tac Toe">
    <meta property="og:description" content="Classic strategy game with AI opponent.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Tic-Tac-Toe: Code Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif; /* Retro-futuristic font */
            background-color: #0d0c1d; /* Very dark blue/purple background */
            background-image: radial-gradient(circle at center, rgba(14, 1, 36, 0.8) 0%, rgba(0, 0, 0, 1) 100%);
            overflow-x: hidden; /* Prevent horizontal scroll but allow vertical scrolling on mobile */
        }
        .text-shadow-neon {
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(34, 211, 238, 0.5), 0 0 20px rgba(34, 211, 238, 0.5);
        }
        .scanline-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.1) 1px,
                rgba(0, 0, 0, 0) 2px
            );
            pointer-events: none; /* Allow clicks through */
            z-index: 0;
        }
        /* Winning Animation */
        .win-animation {
            animation: winPulse 1.5s infinite alternate;
        }
        @keyframes winPulse {
            0% { transform: scale(1); text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(255, 255, 0, 0.5); }
            100% { transform: scale(1.05); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 0, 0.8), 0 0 30px rgba(255, 255, 0, 0.6); }
        }
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #1a202c;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.7);
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
            border: 2px solid #00FFFF;
            color: #E0F7FA; /* Light cyan text for readability */
        }
        .modal-close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #00FFFF;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
        }
        .modal-close-button:hover {
            background-color: rgba(0, 255, 255, 0.15);
        }
        .cell {
            width: 100%;
            padding-bottom: 100%; /* Makes cells square */
            position: relative;
            background-color: rgba(255, 255, 255, 0.05); /* Subtle cell background */
            border: 2px solid rgba(34, 211, 238, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.8rem, 8vmin, 3rem); /* Responsive size of X/O */
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            min-height: 44px; /* Touch target minimum */
        }
        .cell:hover {
            background-color: rgba(34, 211, 238, 0.1); /* Hover glow */
            transform: scale(1.02);
        }
        .cell.occupied {
            cursor: default;
        }
        .cell-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1; /* Default to visible */
            transform: scale(1); /* Default to full size */
            filter: blur(0px); /* Default to no blur */
            animation: popIn 0.4s forwards ease-out; /* Animation for initial pop */
        }
        /* Ghost preview styling */
        .cell-ghost {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.3;
            pointer-events: none;
        }
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.2); filter: blur(5px); }
            60% { opacity: 1; transform: scale(1.1); filter: blur(0px); } /* Overshoot for bounce */
            100% { transform: scale(1); }
        }
        .x-color {
            color: #FF007F; /* Neon Pink for X */
            text-shadow: 0 0 10px #FF007F, 0 0 20px #FF007F; /* Enhanced glow */
        }
        .o-color {
            color: #00FFFF; /* Cyan for O */
            text-shadow: 0 0 10px #00FFFF, 0 0 20px #00FFFF; /* Enhanced glow */
        }

        /* Win line SVG animation - pathLength normalises speed regardless of line length */
        .win-line-svg line {
            stroke-dasharray: 1;
            stroke-dashoffset: 1;
            animation: drawSvgLine 0.5s ease-out forwards;
        }
        @keyframes drawSvgLine {
            to { stroke-dashoffset: 0; }
        }

        /* AI Thinking Indicator */
        .ai-thinking-indicator {
            animation: blink 1s infinite alternate;
        }
        @keyframes blink {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker background */
            backdrop-filter: blur(20px); /* Significantly stronger blur */
            z-index: 50; /* Above game content, below modals */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            border-radius: 0.75rem;
        }
        /* Touch target minimum for action buttons */
        .action-btn {
            min-height: 44px;
            min-width: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        button:focus-visible, [role="button"]:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
        }
        /* Title overflow on narrow viewports */
        h1 {
            overflow-wrap: break-word;
            word-break: break-word;
        }
        /* Difficulty selector styling */
        .difficulty-selector {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 0.75rem;
        }
        .difficulty-btn {
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: bold;
            border: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
            min-height: 36px;
        }
        .difficulty-btn.active {
            transform: scale(1.05);
        }
        .difficulty-btn.easy { background: #065f46; border-color: #10b981; }
        .difficulty-btn.easy.active { background: #10b981; color: #000; box-shadow: 0 0 10px #10b981; }
        .difficulty-btn.medium { background: #92400e; border-color: #f59e0b; }
        .difficulty-btn.medium.active { background: #f59e0b; color: #000; box-shadow: 0 0 10px #f59e0b; }
        .difficulty-btn.hard { background: #7f1d1d; border-color: #ef4444; }
        .difficulty-btn.hard.active { background: #ef4444; color: #fff; box-shadow: 0 0 10px #ef4444; }
        /* Stats bar */
        .stats-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 0.5rem;
        }
        .stats-bar .stat-win { color: #4ade80; }
        .stats-bar .stat-loss { color: #f87171; }
        .stats-bar .stat-draw { color: #facc15; }
        .stats-reset-btn {
            font-size: 0.65rem;
            padding: 0.15rem 0.5rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #94a3b8;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .stats-reset-btn:hover { background: rgba(255,255,255,0.2); }
        /* Mute toggle */
        .mute-btn {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 9999;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .mute-btn:hover { background: rgba(0,0,0,0.9); }
        @media (max-width: 360px) {
            h1 { font-size: clamp(1.5rem, 8vw, 2.25rem) !important; }
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
  <a href="../../"
     aria-label="Back to menu"
     style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;"
     onmouseover="this.style.background='rgba(0,0,0,0.9)'"
     onmouseout="this.style.background='rgba(0,0,0,0.7)'"
  >&#x1F3E0; Menu</a>
    <div id="root"></div>

    <script type="text/babel">
        // --- CONFIGURATION ---
        const PLAYERS = { X: 'X', O: 'O' };
        const GAME_MODES = { PVP: 'PvP', PVAI: 'PvAI' };
        const DIFFICULTIES = { EASY: 'easy', MEDIUM: 'medium', HARD: 'hard' };
        const AI_THINK_DELAY = 800; // Milliseconds for AI to "think"
        const STATS_KEY_PVP = 'ttt-stats-pvp';
        const STATS_KEY_PVAI = 'ttt-stats-pvai';

        // --- SOUND ENGINE (Web Audio API) ---
        const SoundEngine = (() => {
            let audioCtx = null;
            let muted = false;

            const getCtx = () => {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                return audioCtx;
            };

            const playTone = (freq, duration, type = 'square', gain = 0.15, delay = 0) => {
                if (muted) return;
                try {
                    const ctx = getCtx();
                    const osc = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);
                    gainNode.gain.setValueAtTime(gain, ctx.currentTime + delay);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + duration);
                    osc.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    osc.start(ctx.currentTime + delay);
                    osc.stop(ctx.currentTime + delay + duration);
                } catch (e) {
                    // Silently fail if audio not supported
                }
            };

            return {
                isMuted: () => muted,
                setMuted: (val) => { muted = val; },
                toggleMute: () => { muted = !muted; return muted; },

                playX: () => {
                    playTone(520, 0.12, 'square', 0.12);
                    playTone(780, 0.08, 'square', 0.08, 0.06);
                },
                playO: () => {
                    playTone(440, 0.15, 'sine', 0.15);
                    playTone(330, 0.1, 'sine', 0.1, 0.07);
                },
                playAIMove: () => {
                    playTone(350, 0.1, 'triangle', 0.08);
                    playTone(500, 0.1, 'triangle', 0.06, 0.08);
                },
                playVictory: () => {
                    playTone(523, 0.15, 'square', 0.12, 0);
                    playTone(659, 0.15, 'square', 0.12, 0.15);
                    playTone(784, 0.15, 'square', 0.12, 0.30);
                    playTone(1047, 0.35, 'square', 0.18, 0.45);
                },
                playDraw: () => {
                    playTone(220, 0.3, 'sawtooth', 0.08);
                    playTone(196, 0.4, 'sawtooth', 0.06, 0.25);
                },
            };
        })();

        // --- STATS HELPERS ---
        const loadStats = (key) => {
            try {
                const raw = localStorage.getItem(key);
                if (raw) return JSON.parse(raw);
            } catch (e) {}
            return { wins: 0, losses: 0, draws: 0 };
        };

        const saveStats = (key, stats) => {
            try {
                localStorage.setItem(key, JSON.stringify(stats));
            } catch (e) {}
        };

        // --- HELPER FUNCTIONS ---

        /**
         * Checks if there's a winner on the given board.
         * @param {string[][]} board - The 3x3 game board.
         * @param {string} player - The player ('X' or 'O') to check for.
         * @returns {object|null} An object with winner and line coordinates if won, otherwise null.
         */
        const checkWinner = (board, player) => {
            const flatBoard = board.flat();
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (flatBoard[a] === player && flatBoard[b] === player && flatBoard[c] === player) {
                    return { winner: player, line: [a, b, c] };
                }
            }
            return null;
        };

        /**
         * Checks if the game is a draw.
         * @param {string[][]} board - The 3x3 game board.
         * @returns {boolean} True if draw, false otherwise.
         */
        const checkDraw = (board) => {
            return board.flat().every(cell => cell !== '');
        };

        /**
         * Converts a flat array back into a 3x3 board.
         * @param {string[]} flat - A 9-element flat array.
         * @returns {string[][]} A 3x3 board.
         */
        const unflatten = (flat) => {
            return [flat.slice(0, 3), flat.slice(3, 6), flat.slice(6, 9)];
        };

        // --- AI LOGIC ---

        /**
         * True minimax with alpha-beta pruning for unbeatable AI.
         */
        const minimax = (flatBoard, isMaximizing, aiPlayer, alpha, beta) => {
            const opponent = aiPlayer === PLAYERS.X ? PLAYERS.O : PLAYERS.X;
            const board2d = unflatten(flatBoard);

            // Terminal checks
            if (checkWinner(board2d, aiPlayer)) return 10;
            if (checkWinner(board2d, opponent)) return -10;
            if (flatBoard.every(cell => cell !== '')) return 0;

            const emptyCells = [];
            for (let i = 0; i < 9; i++) {
                if (flatBoard[i] === '') emptyCells.push(i);
            }

            if (isMaximizing) {
                let best = -Infinity;
                for (const idx of emptyCells) {
                    flatBoard[idx] = aiPlayer;
                    const score = minimax(flatBoard, false, aiPlayer, alpha, beta);
                    flatBoard[idx] = '';
                    best = Math.max(best, score);
                    alpha = Math.max(alpha, best);
                    if (beta <= alpha) break;
                }
                return best;
            } else {
                let best = Infinity;
                for (const idx of emptyCells) {
                    flatBoard[idx] = opponent;
                    const score = minimax(flatBoard, true, aiPlayer, alpha, beta);
                    flatBoard[idx] = '';
                    best = Math.min(best, score);
                    beta = Math.min(beta, best);
                    if (beta <= alpha) break;
                }
                return best;
            }
        };

        /**
         * Get best move using minimax (Hard difficulty - unbeatable).
         */
        const getAIMoveHard = (board, aiPlayer) => {
            const flatBoard = [...board.flat()];
            let bestScore = -Infinity;
            let bestMove = -1;

            for (let i = 0; i < 9; i++) {
                if (flatBoard[i] === '') {
                    flatBoard[i] = aiPlayer;
                    const score = minimax(flatBoard, false, aiPlayer, -Infinity, Infinity);
                    flatBoard[i] = '';
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = i;
                    }
                }
            }
            return bestMove;
        };

        /**
         * Random move (Easy difficulty).
         */
        const getAIMoveEasy = (board) => {
            const flatBoard = board.flat();
            const emptyCells = flatBoard.map((cell, i) => cell === '' ? i : -1).filter(i => i !== -1);
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        };

        /**
         * Medium AI - original heuristic (win/block/center/corner/side).
         */
        const getAIMoveMedium = (board, aiPlayer) => {
            const opponent = aiPlayer === PLAYERS.X ? PLAYERS.O : PLAYERS.X;
            const flatBoard = board.flat();
            const emptyCells = flatBoard.map((cell, index) => cell === '' ? index : -1).filter(index => index !== -1);

            // 1. Check for winning move
            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                const tempBoard = [...flatBoard];
                tempBoard[move] = aiPlayer;
                if (checkWinner(unflatten(tempBoard), aiPlayer)) {
                    return move;
                }
            }

            // 2. Check for blocking move
            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                const tempBoard = [...flatBoard];
                tempBoard[move] = opponent;
                if (checkWinner(unflatten(tempBoard), opponent)) {
                    return move;
                }
            }

            // 3. Take center if available
            if (emptyCells.includes(4)) return 4;

            // 4. Take a corner if available
            const corners = [0, 2, 6, 8];
            const availableCorners = corners.filter(corner => emptyCells.includes(corner));
            if (availableCorners.length > 0) {
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }

            // 5. Take any available side
            const sides = [1, 3, 5, 7];
            const availableSides = sides.filter(side => emptyCells.includes(side));
            if (availableSides.length > 0) {
                return availableSides[Math.floor(Math.random() * availableSides.length)];
            }

            return emptyCells[0];
        };

        /**
         * Dispatch AI move based on difficulty level.
         */
        const getAIMove = (board, aiPlayer, difficulty) => {
            switch (difficulty) {
                case DIFFICULTIES.EASY:
                    return getAIMoveEasy(board);
                case DIFFICULTIES.HARD:
                    return getAIMoveHard(board, aiPlayer);
                case DIFFICULTIES.MEDIUM:
                default:
                    return getAIMoveMedium(board, aiPlayer);
            }
        };


        // --- COMPONENTS ---

        /**
         * Rules modal with focus trapping and escape key support.
         */
        const RulesModal = ({ onClose }) => {
            const closeRef = React.useRef(null);
            const modalRef = React.useRef(null);

            // Focus the close button when modal opens
            React.useEffect(() => {
                const prevFocus = document.activeElement;
                if (closeRef.current) closeRef.current.focus();

                return () => {
                    // Restore focus when modal closes
                    if (prevFocus && typeof prevFocus.focus === 'function') {
                        prevFocus.focus();
                    }
                };
            }, []);

            // Escape key closes modal
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        onClose();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [onClose]);

            // Focus trap: cycle focus within modal
            const handleModalKeyDown = (e) => {
                if (e.key !== 'Tab') return;
                const focusable = modalRef.current.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                if (focusable.length === 0) return;
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            };

            return (
                <div
                    className="modal-overlay"
                    role="dialog"
                    aria-modal="true"
                    aria-label="Game rules"
                    onKeyDown={handleModalKeyDown}
                    ref={modalRef}
                    onClick={(e) => { if (e.target === e.currentTarget) onClose(); }}
                >
                    <div className="modal-content">
                        <button
                            ref={closeRef}
                            onClick={onClose}
                            className="modal-close-button"
                            aria-label="Close rules"
                        >
                            &times;
                        </button>
                        <h2 className="text-3xl font-bold text-cyan-400 mb-4 text-shadow-neon">Game Rules: Tic-Tac-Toe</h2>
                        <p className="text-gray-200 mb-2">
                            The classic game of Tic-Tac-Toe! Get three of your marks ('X' or 'O') in a row, column, or diagonal to win.
                        </p>
                        <h3 className="text-xl font-bold text-blue-300 mt-4 mb-2">How to Play:</h3>
                        <ul className="list-disc list-inside text-gray-200 space-y-2">
                            <li>
                                <strong>Choose a Mode:</strong> Select "1 vs 1 (Local)" to play against another person on the same device, or "1 vs AI" to challenge the computer.
                            </li>
                            <li>
                                <strong>Take Turns:</strong> Players take turns placing their mark ('X' or 'O') into an empty square on the 3x3 grid.
                            </li>
                            <li>
                                <strong>Win Condition:</strong> The first player to get three of their marks in a horizontal, vertical, or diagonal row wins the game.
                            </li>
                            <li>
                                <strong>Draw:</strong> If all 9 squares are filled and no player has achieved three in a row, the game is a draw.
                            </li>
                            <li>
                                <strong>Difficulty:</strong> In AI mode, choose <strong>Easy</strong> (random), <strong>Medium</strong> (heuristic), or <strong>Hard</strong> (unbeatable minimax).
                            </li>
                            <li>
                                <strong>Undo:</strong> Click the <strong>"Undo"</strong> button to take back your last move. In AI mode, this undoes both your move and the AI's response.
                            </li>
                            <li>
                                <strong>Pause/Resume:</strong> Click the <strong>"Pause"</strong> button to temporarily stop the game and blur the screen. Click <strong>"Resume"</strong> to continue.
                            </li>
                            <li>
                                <strong>New Game:</strong> Click the "New Game" button to start over.
                            </li>
                        </ul>
                    </div>
                </div>
            );
        };

        /**
         * Represents a single cell on the Tic-Tac-Toe board.
         * @param {object} props
         * @param {string} props.value - 'X', 'O', or ''.
         * @param {function} props.onClick - Click handler for the cell.
         * @param {string} props.ghostMark - Mark to show as ghost preview.
         * @param {boolean} props.canInteract - Whether cell can receive interactions.
         */
        const Cell = ({ value, onClick, row, col, ghostMark, canInteract }) => {
            const [hovered, setHovered] = React.useState(false);
            const isOccupied = !!value;
            const showGhost = hovered && !isOccupied && canInteract && ghostMark;

            return (
                <div
                    className={`cell rounded-lg transition-all duration-200 ${isOccupied ? 'occupied' : 'cursor-pointer'}`}
                    onClick={isOccupied ? undefined : onClick}
                    onKeyDown={isOccupied ? undefined : (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onClick(); } }}
                    onMouseEnter={() => setHovered(true)}
                    onMouseLeave={() => setHovered(false)}
                    role="gridcell"
                    tabIndex={isOccupied ? "-1" : "0"}
                    aria-disabled={isOccupied ? "true" : undefined}
                    aria-label={`Row ${row + 1}, column ${col + 1}${value ? `, marked ${value}` : ', empty'}`}
                >
                    {value && (
                        <div className={`cell-content ${value === PLAYERS.X ? 'x-color' : 'o-color'}`} aria-hidden="true">
                            {value}
                        </div>
                    )}
                    {showGhost && (
                        <div className={`cell-ghost ${ghostMark === PLAYERS.X ? 'x-color' : 'o-color'}`} aria-hidden="true">
                            {ghostMark}
                        </div>
                    )}
                </div>
            );
        };

        /**
         * SVG win line overlay using grid-relative coordinates.
         * No DOM measurement needed - positions are calculated from cell indices.
         */
        const WinLineOverlay = ({ winningLine }) => {
            if (!winningLine) return null;

            const [c1, , c3] = winningLine;
            const row1 = Math.floor(c1 / 3);
            const col1 = c1 % 3;
            const row3 = Math.floor(c3 / 3);
            const col3 = c3 % 3;

            // Map grid indices to SVG coordinates (0-3 viewBox, centers at 0.5, 1.5, 2.5)
            const x1 = col1 + 0.5;
            const y1 = row1 + 0.5;
            const x2 = col3 + 0.5;
            const y2 = row3 + 0.5;

            return (
                <svg
                    className="win-line-svg"
                    viewBox="0 0 3 3"
                    preserveAspectRatio="none"
                    aria-hidden="true"
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none',
                        zIndex: 10,
                    }}
                >
                    <line
                        x1={x1} y1={y1}
                        x2={x2} y2={y2}
                        stroke="#FFFF00"
                        strokeWidth="0.12"
                        strokeLinecap="round"
                        pathLength="1"
                        style={{ filter: 'drop-shadow(0 0 3px #FFFF00)' }}
                    />
                </svg>
            );
        };

        /**
         * Main Tic-Tac-Toe game component.
         */
        const TicTacToeGame = () => {
            const emptyBoard = () => Array(3).fill(null).map(() => Array(3).fill(''));

            const [board, setBoard] = React.useState(emptyBoard());
            const [currentPlayer, setCurrentPlayer] = React.useState(PLAYERS.X);
            const [gameMode, setGameMode] = React.useState(null); // null, 'PvP', 'PvAI'
            const [difficulty, setDifficulty] = React.useState(DIFFICULTIES.MEDIUM);
            const [winner, setWinner] = React.useState(null); // null, 'X', 'O', 'Draw'
            const [winningLine, setWinningLine] = React.useState(null); // Array of indices for winning line
            const [message, setMessage] = React.useState('');
            const [showRules, setShowRules] = React.useState(false);
            const [isPaused, setIsPaused] = React.useState(false);
            const [aiThinking, setAiThinking] = React.useState(false);
            const [isMuted, setIsMuted] = React.useState(SoundEngine.isMuted());

            // Move history for undo: array of { board, currentPlayer } snapshots
            const [moveHistory, setMoveHistory] = React.useState([]);

            // Stats
            const [statsPvp, setStatsPvp] = React.useState(() => loadStats(STATS_KEY_PVP));
            const [statsPvai, setStatsPvai] = React.useState(() => loadStats(STATS_KEY_PVAI));

            // Ref to hold AI timeout for proper cleanup
            const aiTimeoutRef = React.useRef(null);
            // Ref to hold the latest board state so AI timeout closure is never stale
            const boardRef = React.useRef(board);
            React.useEffect(() => { boardRef.current = board; }, [board]);
            // Ref for latest difficulty
            const difficultyRef = React.useRef(difficulty);
            React.useEffect(() => { difficultyRef.current = difficulty; }, [difficulty]);
            // Refs for focus management
            const gridRef = React.useRef(null);
            const winButtonRef = React.useRef(null);

            // Clean up AI timeout on unmount
            React.useEffect(() => {
                return () => {
                    if (aiTimeoutRef.current !== null) {
                        clearTimeout(aiTimeoutRef.current);
                        aiTimeoutRef.current = null;
                    }
                };
            }, []);

            // Record outcome to stats
            const recordOutcome = React.useCallback((outcome) => {
                // outcome: 'X_wins', 'O_wins', 'draw'
                if (!gameMode) return;
                const key = gameMode === GAME_MODES.PVP ? STATS_KEY_PVP : STATS_KEY_PVAI;
                const setter = gameMode === GAME_MODES.PVP ? setStatsPvp : setStatsPvai;

                setter(prev => {
                    const next = { ...prev };
                    if (outcome === 'draw') {
                        next.draws += 1;
                    } else if (gameMode === GAME_MODES.PVP) {
                        // In PvP, X winning = win, O winning = loss (from X's perspective)
                        if (outcome === 'X_wins') next.wins += 1;
                        else next.losses += 1;
                    } else {
                        // PvAI: player is X, AI is O
                        if (outcome === 'X_wins') next.wins += 1;
                        else next.losses += 1;
                    }
                    saveStats(key, next);
                    return next;
                });
            }, [gameMode]);

            // Handle a player's move (stable callback - only uses setState functions which are stable)
            const handleMove = React.useCallback((newBoard, playerMoved, isAIMove) => {
                setBoard(newBoard);

                // Always play the placement sound first
                if (isAIMove) {
                    SoundEngine.playAIMove();
                } else if (playerMoved === PLAYERS.X) {
                    SoundEngine.playX();
                } else {
                    SoundEngine.playO();
                }

                const winResult = checkWinner(newBoard, playerMoved);

                if (winResult) {
                    setWinner(winResult.winner);
                    setWinningLine(winResult.line);
                    setMessage(`${winResult.winner} WINS!`);
                    SoundEngine.playVictory();
                    recordOutcome(winResult.winner === PLAYERS.X ? 'X_wins' : 'O_wins');
                } else if (checkDraw(newBoard)) {
                    setWinner('Draw');
                    setMessage("It's a DRAW!");
                    SoundEngine.playDraw();
                    recordOutcome('draw');
                } else {
                    setCurrentPlayer(playerMoved === PLAYERS.X ? PLAYERS.O : PLAYERS.X);
                    setMessage(`Player ${playerMoved === PLAYERS.X ? PLAYERS.O : PLAYERS.X}'s turn`);
                }
            }, [recordOutcome]);

            // Function to handle AI's move sequence
            // Uses boardRef inside the timeout so the closure always reads the latest board
            const handleAIMove = React.useCallback(() => {
                if (gameMode === GAME_MODES.PVAI && currentPlayer === PLAYERS.O && !winner && !checkDraw(board) && !isPaused) {
                    setAiThinking(true);
                    setMessage("AI is thinking...");
                    aiTimeoutRef.current = setTimeout(() => {
                        aiTimeoutRef.current = null;
                        const latestBoard = boardRef.current;
                        const moveIndex = getAIMove(latestBoard, PLAYERS.O, difficultyRef.current);
                        const newBoardFlat = [...latestBoard.flat()];
                        newBoardFlat[moveIndex] = PLAYERS.O;
                        const updatedBoard = unflatten(newBoardFlat);

                        // Save state before AI move for undo
                        setMoveHistory(prev => [...prev, { board: latestBoard, currentPlayer: PLAYERS.O }]);

                        handleMove(updatedBoard, PLAYERS.O, true);
                        setAiThinking(false);
                    }, AI_THINK_DELAY);
                }
            }, [board, currentPlayer, gameMode, winner, isPaused, handleMove]);

            // Effect to trigger AI's turn when it's O's turn in PvAI mode
            React.useEffect(() => {
                if (gameMode === GAME_MODES.PVAI && currentPlayer === PLAYERS.O && !winner && !checkDraw(board) && !isPaused && !aiThinking) {
                    handleAIMove();
                }
                // Cleanup: cancel pending AI move if dependencies change before it fires
                return () => {
                    if (aiTimeoutRef.current !== null) {
                        clearTimeout(aiTimeoutRef.current);
                        aiTimeoutRef.current = null;
                        // Only reset aiThinking if we actually cancelled a pending move
                        setAiThinking(false);
                    }
                };
            }, [board, currentPlayer, gameMode, winner, isPaused, aiThinking, handleAIMove]);

            // Handle cell click from UI (memoized)
            const handleCellClick = React.useCallback((rowIndex, colIndex) => {
                if (winner || isPaused || aiThinking || board[rowIndex][colIndex] !== '') {
                    return; // Do nothing if game is over, paused, AI is thinking, or cell is occupied
                }

                // Save current state for undo before making the move
                setMoveHistory(prev => [...prev, { board: board, currentPlayer: currentPlayer }]);

                const newBoard = board.map(row => [...row]);
                newBoard[rowIndex][colIndex] = currentPlayer;

                handleMove(newBoard, currentPlayer, false);
            }, [winner, isPaused, aiThinking, board, currentPlayer, handleMove]);

            // Undo handler
            const handleUndo = React.useCallback(() => {
                if (moveHistory.length === 0 || winner || aiThinking || isPaused) return;

                if (gameMode === GAME_MODES.PVAI) {
                    // In PvAI mode, undo both AI move and player move
                    // The last entry is the AI's pre-move state, the one before is the player's pre-move state
                    if (moveHistory.length >= 2) {
                        const playerState = moveHistory[moveHistory.length - 2];
                        setBoard(playerState.board);
                        setCurrentPlayer(playerState.currentPlayer);
                        setMoveHistory(prev => prev.slice(0, -2));
                        setMessage(`Player ${playerState.currentPlayer}'s turn`);
                    } else if (moveHistory.length === 1) {
                        // Only one entry (player moved but AI hasn't yet, or first move)
                        const prevState = moveHistory[moveHistory.length - 1];
                        setBoard(prevState.board);
                        setCurrentPlayer(prevState.currentPlayer);
                        setMoveHistory([]);
                        setMessage(`Player ${prevState.currentPlayer}'s turn`);
                    }
                } else {
                    // PvP: undo single move
                    const prevState = moveHistory[moveHistory.length - 1];
                    setBoard(prevState.board);
                    setCurrentPlayer(prevState.currentPlayer);
                    setMoveHistory(prev => prev.slice(0, -1));
                    setMessage(`Player ${prevState.currentPlayer}'s turn`);
                }
            }, [moveHistory, winner, aiThinking, isPaused, gameMode]);

            const canUndo = moveHistory.length > 0 && !winner && !aiThinking && !isPaused;

            const resetGame = () => {
                // Clear any pending AI timeout to prevent stale state updates
                if (aiTimeoutRef.current !== null) {
                    clearTimeout(aiTimeoutRef.current);
                    aiTimeoutRef.current = null;
                }
                setBoard(emptyBoard());
                setCurrentPlayer(PLAYERS.X);
                setWinner(null);
                setWinningLine(null);
                setMessage('');
                setIsPaused(false);
                setAiThinking(false);
                setMoveHistory([]);
                setGameMode(null); // Go back to mode selection
            };

            const resetStats = (key) => {
                const empty = { wins: 0, losses: 0, draws: 0 };
                saveStats(key, empty);
                if (key === STATS_KEY_PVP) setStatsPvp(empty);
                else setStatsPvai(empty);
            };

            // Mute toggle handler
            const handleMuteToggle = () => {
                const nowMuted = SoundEngine.toggleMute();
                setIsMuted(nowMuted);
            };

            // Focus management: move focus to Play Again button when win/draw overlay appears
            React.useEffect(() => {
                if (winner && winButtonRef.current) {
                    winButtonRef.current.focus();
                }
            }, [winner]);

            const startGame = (mode) => {
                setGameMode(mode);
                setMessage(`Player ${PLAYERS.X}'s turn`);
                setMoveHistory([]);
            };

            // Current stats based on game mode
            const currentStats = gameMode === GAME_MODES.PVP ? statsPvp : statsPvai;
            const currentStatsKey = gameMode === GAME_MODES.PVP ? STATS_KEY_PVP : STATS_KEY_PVAI;

            // Whether cells can be interacted with (for ghost preview)
            const cellsInteractive = !winner && !isPaused && !aiThinking;

            if (!gameMode) {
                return (
                    <div className="min-h-screen relative bg-gray-900 text-white flex flex-col items-center justify-center p-4">
                        <div className="scanline-overlay" aria-hidden="true"></div>
                        {/* Mute toggle */}
                        <button className="mute-btn" onClick={handleMuteToggle} aria-label={isMuted ? 'Unmute sounds' : 'Mute sounds'}>
                            {isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A'}
                        </button>
                        <div className="relative z-10 bg-black/40 rounded-xl shadow-2xl p-6 w-full max-w-md border border-blue-700/50 shadow-blue-900/40 text-center">
                            <h1 className="text-4xl md:text-5xl font-bold mb-8 bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent tracking-wider text-shadow-neon">
                                TIC-TAC-TOE
                            </h1>
                            <p className="text-cyan-300/80 mb-6 text-shadow-neon">Choose your challenge:</p>
                            <div className="flex flex-col space-y-4" role="group" aria-label="Game mode selection">
                                <button
                                    onClick={() => startGame(GAME_MODES.PVP)}
                                    className="action-btn py-3 px-8 bg-blue-700 hover:bg-blue-800 text-white font-bold rounded-lg shadow-lg shadow-blue-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xl"
                                >
                                    1 vs 1 (Local)
                                </button>
                                <button
                                    onClick={() => startGame(GAME_MODES.PVAI)}
                                    className="action-btn py-3 px-8 bg-green-700 hover:bg-green-800 text-white font-bold rounded-lg shadow-lg shadow-green-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xl"
                                >
                                    1 vs AI
                                </button>
                            </div>
                            <button
                                onClick={() => setShowRules(true)}
                                className="action-btn mt-8 py-2 px-6 bg-yellow-700 hover:bg-yellow-800 text-white font-bold rounded-lg shadow-lg shadow-yellow-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                            >
                                Rules
                            </button>
                        </div>
                        {showRules && <RulesModal onClose={() => setShowRules(false)} />}
                    </div>
                );
            }

            return (
                <div className="min-h-screen relative bg-gray-900 text-white flex flex-col items-center justify-center p-4">
                    {/* Scanline overlay for retro CRT effect */}
                    <div className="scanline-overlay" aria-hidden="true"></div>
                    {/* Mute toggle */}
                    <button className="mute-btn" onClick={handleMuteToggle} aria-label={isMuted ? 'Unmute sounds' : 'Mute sounds'}>
                        {isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A'}
                    </button>

                    <div className="relative z-10 bg-black/40 rounded-xl shadow-2xl p-6 w-full max-w-md border border-blue-700/50 shadow-blue-900/40">
                        <h1 className="text-4xl md:text-5xl font-bold text-center mb-4 bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent tracking-wider text-shadow-neon">
                            TIC-TAC-TOE
                        </h1>

                        {/* Difficulty Selector (PvAI only) */}
                        {gameMode === GAME_MODES.PVAI && (
                            <div className="difficulty-selector" role="group" aria-label="AI difficulty">
                                <button
                                    className={`difficulty-btn easy ${difficulty === DIFFICULTIES.EASY ? 'active' : ''}`}
                                    onClick={() => setDifficulty(DIFFICULTIES.EASY)}
                                    aria-pressed={difficulty === DIFFICULTIES.EASY}
                                    disabled={isPaused}
                                >
                                    Easy
                                </button>
                                <button
                                    className={`difficulty-btn medium ${difficulty === DIFFICULTIES.MEDIUM ? 'active' : ''}`}
                                    onClick={() => setDifficulty(DIFFICULTIES.MEDIUM)}
                                    aria-pressed={difficulty === DIFFICULTIES.MEDIUM}
                                    disabled={isPaused}
                                >
                                    Medium
                                </button>
                                <button
                                    className={`difficulty-btn hard ${difficulty === DIFFICULTIES.HARD ? 'active' : ''}`}
                                    onClick={() => setDifficulty(DIFFICULTIES.HARD)}
                                    aria-pressed={difficulty === DIFFICULTIES.HARD}
                                    disabled={isPaused}
                                >
                                    Hard
                                </button>
                            </div>
                        )}

                        <p
                            className="text-center text-cyan-300/80 mb-4 text-shadow-neon"
                            role="status"
                            aria-live="polite"
                            aria-atomic="true"
                        >
                            {message || `Player ${currentPlayer}'s turn`}
                            {aiThinking && <span className="ai-thinking-indicator ml-2" aria-hidden="true">. . .</span>}
                        </p>

                        {/* Game Board */}
                        <div
                            className="p-4 bg-gray-700/30 rounded-lg shadow-inner border border-gray-600/30 mb-4 relative"
                            role="grid"
                            aria-label="Tic-Tac-Toe board"
                            ref={gridRef}
                        >
                            {board.map((rowCells, rowIndex) => (
                                <div key={`row-${rowIndex}`} role="row" className="grid grid-cols-3 gap-2" style={rowIndex < 2 ? { marginBottom: '0.5rem' } : undefined}>
                                    {rowCells.map((cellValue, colIndex) => (
                                        <Cell
                                            key={`${rowIndex}-${colIndex}`}
                                            value={cellValue}
                                            row={rowIndex}
                                            col={colIndex}
                                            onClick={() => handleCellClick(rowIndex, colIndex)}
                                            ghostMark={cellsInteractive ? currentPlayer : null}
                                            canInteract={cellsInteractive}
                                        />
                                    ))}
                                </div>
                            ))}

                            {/* Win Line Overlay - positioned relative to grid */}
                            {winner && winner !== 'Draw' && (
                                <WinLineOverlay winningLine={winningLine} />
                            )}
                        </div>

                        {/* Stats Bar */}
                        <div className="stats-bar" aria-label="Game statistics">
                            <span className="stat-win" title="Wins">W: {currentStats.wins}</span>
                            <span className="stat-loss" title="Losses">L: {currentStats.losses}</span>
                            <span className="stat-draw" title="Draws">D: {currentStats.draws}</span>
                            <button
                                className="stats-reset-btn"
                                onClick={() => resetStats(currentStatsKey)}
                                aria-label="Reset statistics"
                                title="Reset stats"
                            >
                                Reset
                            </button>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex justify-center space-x-3 flex-wrap gap-y-2">
                            <button
                                onClick={() => setShowRules(true)}
                                className="action-btn py-2 px-4 bg-yellow-700 hover:bg-yellow-800 text-white font-bold rounded-lg shadow-lg shadow-yellow-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                                disabled={isPaused}
                                aria-label="Show game rules"
                            >
                                Rules
                            </button>
                            <button
                                onClick={handleUndo}
                                className="action-btn py-2 px-4 bg-orange-700 hover:bg-orange-800 text-white font-bold rounded-lg shadow-lg shadow-orange-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 disabled:opacity-40 disabled:cursor-not-allowed disabled:transform-none"
                                disabled={!canUndo}
                                aria-label="Undo last move"
                            >
                                Undo
                            </button>
                            <button
                                onClick={() => setIsPaused(!isPaused)}
                                className="action-btn py-2 px-4 bg-gray-700 hover:bg-gray-800 text-white font-bold rounded-lg shadow-lg shadow-gray-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                                disabled={winner !== null} /* Cannot pause if game is won/drawn */
                                aria-label={isPaused ? 'Resume game' : 'Pause game'}
                            >
                                {isPaused ? 'Resume' : 'Pause'}
                            </button>
                            <button
                                onClick={resetGame}
                                className="action-btn py-2 px-4 bg-purple-700 hover:bg-purple-800 text-white font-bold rounded-lg shadow-lg shadow-purple-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95"
                                disabled={isPaused}
                                aria-label="Start a new game"
                            >
                                New Game
                            </button>
                        </div>

                        {/* Win/Draw Overlay */}
                        {winner && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-70 fade-in pointer-events-none rounded-xl" role="alert" aria-live="assertive">
                                <h2 className={`text-5xl font-bold text-yellow-300 text-shadow-neon ${winner !== 'Draw' ? 'win-animation' : ''}`}>
                                    {winner === 'Draw' ? "IT'S A DRAW!" : `${winner} WINS!`}
                                </h2>
                                <button
                                    ref={winButtonRef}
                                    onClick={resetGame}
                                    className="action-btn mt-6 py-2 px-6 bg-purple-700 hover:bg-purple-800 text-white font-bold rounded-lg shadow-lg shadow-purple-700/50 transition-all duration-200 transform hover:scale-105 active:scale-95 pointer-events-auto"
                                >
                                    Play Again
                                </button>
                            </div>
                        )}

                        {/* Pause Overlay */}
                        {isPaused && (
                            <div className="pause-overlay" role="alert" aria-live="assertive">
                                PAUSED
                            </div>
                        )}

                        {/* Rules Modal */}
                        {showRules && <RulesModal onClose={() => setShowRules(false)} />}
                    </div>
                </div>
            );
        };

        // Render the main component to the root div
        ReactDOM.render(<TicTacToeGame />, document.getElementById('root'));
    </script>
</body>
</html>
