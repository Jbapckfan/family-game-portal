<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Lights Out - Toggle lights to turn them all off in this classic logic puzzle.">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta property="og:title" content="Lights Out">
    <meta property="og:description" content="Toggle lights to turn them all off in this classic logic puzzle.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Neon Lights Out</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>

    <!-- Babel to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">

    <style>
        html, body {
            background-color: #000;
        }
        body {
            font-family: 'Orbitron', sans-serif;
        }
        .text-shadow-neon {
          text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(34, 211, 238, 0.5), 0 0 20px rgba(34, 211, 238, 0.5);
        }
        .scanline-animation {
          background-image: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0) 50%,
            rgba(0, 0, 0, 0.25) 50%
          );
          background-size: 100% 4px;
          animation: scanlines 5s linear infinite;
        }
        @keyframes scanlines {
          from { background-position: 0 0; }
          to { background-position: 0 -4px; }
        }
        @keyframes fade-in {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
          animation: fade-in 0.5s ease-out forwards;
        }
        @keyframes star-pop {
          0% { opacity: 0; transform: scale(0) rotate(-30deg); }
          60% { transform: scale(1.3) rotate(5deg); }
          100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        .animate-star-pop {
          animation: star-pop 0.4s ease-out forwards;
        }
        @keyframes hint-pulse {
          0%, 100% { box-shadow: 0 0 8px rgba(250, 204, 21, 0.6), 0 0 16px rgba(250, 204, 21, 0.3); }
          50% { box-shadow: 0 0 16px rgba(250, 204, 21, 0.9), 0 0 32px rgba(250, 204, 21, 0.5); }
        }
        .hint-highlight {
          animation: hint-pulse 1s ease-in-out infinite;
          border-color: rgb(250, 204, 21) !important;
          border-width: 3px !important;
        }
        button:focus-visible, [role="button"]:focus-visible, a:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
  <noscript>
    <div style="display:flex;align-items:center;justify-content:center;min-height:100vh;color:#22d3ee;font-family:sans-serif;text-align:center;padding:2rem;">
      <p>JavaScript is required to play Lights Out. Please enable JavaScript in your browser settings.</p>
    </div>
  </noscript>
  <a href="../../" aria-label="Back to menu" style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">&#127968; Menu</a>
    <div id="root"></div>

    <script type="text/babel">
        // --- CONFIGURATION ---
        const LIGHT_COLOR_ON = 'rgb(34, 211, 238)';
        const LIGHT_GLOW_ON = 'rgb(34, 211, 238)';
        const LIGHT_COLOR_OFF = 'transparent';

        const DIFFICULTY_OPTIONS = [
            { size: 3, label: 'Beginner', sublabel: '3x3' },
            { size: 5, label: 'Standard', sublabel: '5x5' },
            { size: 7, label: 'Expert', sublabel: '7x7' },
        ];

        const HINTS_PER_GAME = 3;

        // --- HELPER FUNCTIONS ---
        const MAX_BOARD_GEN_ITERATIONS = 1000;

        const generateBoard = (gridSize) => {
            let board;
            let iterations = 0;
            do {
                board = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
                const clicks = Math.floor(Math.random() * 8) + 5;
                const usedPositions = new Set();
                for (let i = 0; i < clicks; i++) {
                    let r, c, key;
                    do {
                        r = Math.floor(Math.random() * gridSize);
                        c = Math.floor(Math.random() * gridSize);
                        key = r + ',' + c;
                    } while (usedPositions.has(key));
                    usedPositions.add(key);
                    board = toggleLights(board, r, c, gridSize);
                }
                iterations++;
            } while (checkWinCondition(board) && iterations < MAX_BOARD_GEN_ITERATIONS);
            return board;
        };

        const toggleLights = (board, r, c, gridSize) => {
            const size = gridSize || board.length;
            const newBoard = board.map(row => [...row]);
            const positions = [[r, c], [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
            positions.forEach(([row, col]) => {
                if (row >= 0 && row < size && col >= 0 && col < size) {
                    newBoard[row][col] = !newBoard[row][col];
                }
            });
            return newBoard;
        };

        const checkWinCondition = (board) => {
            return board.every(row => row.every(light => !light));
        };

        // --- GF(2) GAUSSIAN ELIMINATION SOLVER ---
        // Solves the Lights Out puzzle mathematically using linear algebra over GF(2).
        // Returns an array of {row, col} cells to click for the optimal solution,
        // or null if no solution exists.
        const solveLightsOut = (board) => {
            const n = board.length;
            const N = n * n;

            // Build the toggle matrix A (N x N) over GF(2)
            // A[i][j] = 1 if clicking cell j affects cell i
            const A = [];
            for (let i = 0; i < N; i++) {
                A.push(new Uint8Array(N + 1)); // augmented column for board state
            }

            for (let j = 0; j < N; j++) {
                const jr = Math.floor(j / n);
                const jc = j % n;
                const affected = [[jr, jc], [jr - 1, jc], [jr + 1, jc], [jr, jc - 1], [jr, jc + 1]];
                for (const [ar, ac] of affected) {
                    if (ar >= 0 && ar < n && ac >= 0 && ac < n) {
                        const i = ar * n + ac;
                        A[i][j] = 1;
                    }
                }
            }

            // Flatten board into the augmented column
            for (let r = 0; r < n; r++) {
                for (let c = 0; c < n; c++) {
                    A[r * n + c][N] = board[r][c] ? 1 : 0;
                }
            }

            // Gaussian elimination over GF(2)
            const pivotRow = new Array(N).fill(-1);
            let col = 0;
            for (let row = 0; row < N && col < N; col++) {
                // Find pivot
                let pivotR = -1;
                for (let r = row; r < N; r++) {
                    if (A[r][col] === 1) {
                        pivotR = r;
                        break;
                    }
                }
                if (pivotR === -1) continue;

                // Swap rows
                if (pivotR !== row) {
                    const temp = A[row];
                    A[row] = A[pivotR];
                    A[pivotR] = temp;
                }
                pivotRow[col] = row;

                // Eliminate all other rows
                for (let r = 0; r < N; r++) {
                    if (r !== row && A[r][col] === 1) {
                        for (let k = col; k <= N; k++) {
                            A[r][k] ^= A[row][k];
                        }
                    }
                }
                row++;
            }

            // Extract solution - free variables default to 0 for minimal solution
            const solution = new Uint8Array(N);
            for (let c = 0; c < N; c++) {
                if (pivotRow[c] !== -1) {
                    solution[c] = A[pivotRow[c]][N];
                }
            }

            // Verify solution
            for (let i = 0; i < N; i++) {
                let sum = 0;
                for (let j = 0; j < N; j++) {
                    // Recompute original A values for verification
                    const ir = Math.floor(i / n);
                    const ic = i % n;
                    const jr = Math.floor(j / n);
                    const jc = j % n;
                    const dist = Math.abs(ir - jr) + Math.abs(ic - jc);
                    if (dist <= 1) {
                        sum ^= solution[j];
                    }
                }
                const target = board[Math.floor(i / n)][i % n] ? 1 : 0;
                if (sum !== target) {
                    return null; // No solution exists
                }
            }

            // Convert to cell coordinates
            const moves = [];
            for (let i = 0; i < N; i++) {
                if (solution[i] === 1) {
                    moves.push({ row: Math.floor(i / n), col: i % n });
                }
            }
            return moves;
        };

        // --- LOCALSTORAGE HELPERS ---
        const STORAGE_KEY_BEST_MOVES = 'lightsout_best_moves';
        const STORAGE_KEY_BEST_STARS = 'lightsout_best_stars';

        const loadBestScores = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_BEST_MOVES);
                return raw ? JSON.parse(raw) : {};
            } catch {
                return {};
            }
        };

        const saveBestScore = (gridSize, moves) => {
            const scores = loadBestScores();
            const key = String(gridSize);
            if (!scores[key] || moves < scores[key]) {
                scores[key] = moves;
                try { localStorage.setItem(STORAGE_KEY_BEST_MOVES, JSON.stringify(scores)); } catch {}
            }
            return scores;
        };

        const loadBestStars = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_BEST_STARS);
                return raw ? JSON.parse(raw) : {};
            } catch {
                return {};
            }
        };

        const saveBestStars = (gridSize, stars) => {
            const allStars = loadBestStars();
            const key = String(gridSize);
            if (!allStars[key] || stars > allStars[key]) {
                allStars[key] = stars;
                try { localStorage.setItem(STORAGE_KEY_BEST_STARS, JSON.stringify(allStars)); } catch {}
            }
            return allStars;
        };

        // --- STAR RATING CALCULATION ---
        const calculateStars = (playerMoves, minMoves) => {
            if (minMoves <= 0) return 3;
            if (playerMoves <= minMoves + 1) return 3;
            if (playerMoves <= minMoves + 3) return 2;
            return 1;
        };

        // --- COMPONENTS ---
        const HowToPlayModal = ({ isOpen, onClose, triggerRef }) => {
            const closeButtonRef = React.useRef(null);
            const modalRef = React.useRef(null);

            // Focus management: move focus into modal on open, restore on close
            React.useEffect(() => {
                if (isOpen && closeButtonRef.current) {
                    closeButtonRef.current.focus();
                }
            }, [isOpen]);

            // Escape key and focus trap
            React.useEffect(() => {
                if (!isOpen) return;

                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        onClose();
                        return;
                    }

                    if (e.key === 'Tab' && modalRef.current) {
                        const focusableEls = modalRef.current.querySelectorAll(
                            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                        );
                        if (focusableEls.length === 0) return;

                        const firstEl = focusableEls[0];
                        const lastEl = focusableEls[focusableEls.length - 1];

                        if (e.shiftKey) {
                            if (document.activeElement === firstEl) {
                                e.preventDefault();
                                lastEl.focus();
                            }
                        } else {
                            if (document.activeElement === lastEl) {
                                e.preventDefault();
                                firstEl.focus();
                            }
                        }
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [isOpen, onClose]);

            // Restore focus to trigger on close
            const handleClose = React.useCallback(() => {
                onClose();
                // Defer focus restoration to after the modal unmounts
                requestAnimationFrame(() => {
                    if (triggerRef && triggerRef.current) {
                        triggerRef.current.focus();
                    }
                });
            }, [onClose, triggerRef]);

            if (!isOpen) return null;
            return (
                <div
                    className="fixed inset-0 z-50 flex items-center justify-center p-4"
                    onClick={handleClose}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="how-to-play-title"
                    ref={modalRef}
                >
                    <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" aria-hidden="true" />
                    <div
                        className="relative bg-gray-900 border border-cyan-500/50 rounded-2xl p-6 max-w-sm w-full shadow-2xl shadow-cyan-500/20 animate-fade-in"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <button
                            ref={closeButtonRef}
                            onClick={handleClose}
                            className="absolute top-2 right-2 min-w-[44px] min-h-[44px] flex items-center justify-center text-cyan-300 hover:text-white transition-colors text-2xl leading-none rounded-lg"
                            aria-label="Close instructions"
                        >
                            &times;
                        </button>
                        <h2 id="how-to-play-title" className="text-2xl font-bold bg-gradient-to-r from-cyan-400 to-blue-400 bg-clip-text text-transparent mb-4">
                            How to Play
                        </h2>
                        <ul className="text-cyan-100/90 text-sm space-y-3 list-none">
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Click any <strong className="text-cyan-300">light</strong> to toggle it and its <strong className="text-cyan-300">4 adjacent neighbors</strong> (up, down, left, right).</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Your goal is to turn <strong className="text-yellow-300">ALL lights off</strong> to win the game.</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>The <strong className="text-cyan-300">fewer moves</strong> you use, the better your score!</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Use <strong className="text-cyan-300">Undo</strong> to take back your last move, or <strong className="text-yellow-300">Hint</strong> (3 per game) for help.</span>
                            </li>
                        </ul>
                        <button
                            onClick={handleClose}
                            className="mt-5 w-full py-2 min-h-[44px] rounded-lg font-bold text-black bg-gradient-to-r from-cyan-400 to-blue-500 hover:from-cyan-300 hover:to-blue-400 transition-all"
                        >
                            Got it!
                        </button>
                    </div>
                </div>
            );
        };

        // --- DIFFICULTY SELECTOR ---
        const DifficultySelector = ({ gridSize, onChange }) => {
            return (
                <div className="flex gap-2 justify-center mb-4" role="radiogroup" aria-label="Difficulty">
                    {DIFFICULTY_OPTIONS.map(opt => {
                        const isActive = opt.size === gridSize;
                        return (
                            <button
                                key={opt.size}
                                role="radio"
                                aria-checked={isActive}
                                onClick={() => onChange(opt.size)}
                                className={`px-3 py-1.5 min-h-[40px] rounded-lg text-xs font-bold transition-all border ${
                                    isActive
                                        ? 'bg-cyan-500/30 border-cyan-400 text-cyan-200 shadow-lg shadow-cyan-500/20'
                                        : 'bg-black/40 border-cyan-500/20 text-cyan-400/60 hover:border-cyan-500/50 hover:text-cyan-300'
                                }`}
                            >
                                <div>{opt.label}</div>
                                <div className="text-[10px] opacity-70">{opt.sublabel}</div>
                            </button>
                        );
                    })}
                </div>
            );
        };

        // --- STAR DISPLAY ---
        const StarRating = ({ stars, animated, className }) => {
            return (
                <div className={`flex gap-1 justify-center ${className || ''}`} aria-label={`${stars} out of 3 stars`}>
                    {[1, 2, 3].map(i => (
                        <span
                            key={i}
                            className={`text-3xl ${animated && i <= stars ? 'animate-star-pop' : ''}`}
                            style={animated && i <= stars ? { animationDelay: `${(i - 1) * 0.15}s`, opacity: 0 } : {}}
                            aria-hidden="true"
                        >
                            {i <= stars ? '\u2605' : '\u2606'}
                        </span>
                    ))}
                </div>
            );
        };

        const LightCell = React.memo(({ isOn, onToggle, row, col, isHinted, cellSizeClass }) => {
            const style = React.useMemo(() => ({
                backgroundColor: isOn ? LIGHT_COLOR_ON : LIGHT_COLOR_OFF,
                boxShadow: isOn ? `0 0 15px ${LIGHT_GLOW_ON}, 0 0 25px ${LIGHT_GLOW_ON}60, inset 0 0 5px ${LIGHT_GLOW_ON}80` : 'inset 0 0 10px rgba(0,0,0,0.5)',
            }), [isOn]);

            const handleClick = React.useCallback(() => {
                onToggle(row, col);
            }, [onToggle, row, col]);

            return (
                <button
                    onClick={handleClick}
                    role="gridcell"
                    className={`${cellSizeClass} rounded-lg border-2 border-cyan-500/30 transition-all duration-200 ease-in-out transform hover:scale-105 hover:border-cyan-400 ${isHinted ? 'hint-highlight' : ''}`}
                    style={style}
                    aria-label={`Row ${row + 1}, Column ${col + 1}, light ${isOn ? 'on' : 'off'}${isHinted ? ', suggested move' : ''}`}
                    aria-pressed={isOn}
                />
            );
        });

        const LightsOutGame = () => {
            const [gridSize, setGridSize] = React.useState(5);
            const [board, setBoard] = React.useState(() => generateBoard(5));
            const [moves, setMoves] = React.useState(0);
            const [moveHistory, setMoveHistory] = React.useState([]);
            const [hintsRemaining, setHintsRemaining] = React.useState(HINTS_PER_GAME);
            const [hintCell, setHintCell] = React.useState(null);
            const [minSolution, setMinSolution] = React.useState(null);
            const [bestScores, setBestScores] = React.useState(() => loadBestScores());
            const [bestStarsMap, setBestStarsMap] = React.useState(() => loadBestStars());
            const [showHowToPlay, setShowHowToPlay] = React.useState(false);
            const [wonStars, setWonStars] = React.useState(0);
            const howToPlayTriggerRef = React.useRef(null);
            const resetButtonRef = React.useRef(null);
            const isWon = checkWinCondition(board);
            const prevIsWonRef = React.useRef(false);

            // Compute minimum solution length when board changes (for new game)
            const computeMinSolution = React.useCallback((b) => {
                const sol = solveLightsOut(b);
                return sol ? sol.length : null;
            }, []);

            // Initialize min solution on first render
            React.useEffect(() => {
                setMinSolution(computeMinSolution(board));
            }, []);

            // Cell size classes based on grid size
            const cellSizeClass = React.useMemo(() => {
                if (gridSize <= 3) return 'w-20 h-20 md:w-24 md:h-24';
                if (gridSize <= 5) return 'w-14 h-14 md:w-16 md:h-16';
                return 'w-10 h-10 md:w-12 md:h-12';
            }, [gridSize]);

            // When the game is won, compute stars, save best scores
            React.useEffect(() => {
                if (isWon && !prevIsWonRef.current) {
                    // Save best move score
                    const updatedScores = saveBestScore(gridSize, moves);
                    setBestScores(updatedScores);

                    // Calculate and save star rating
                    const stars = calculateStars(moves, minSolution);
                    setWonStars(stars);
                    const updatedStars = saveBestStars(gridSize, stars);
                    setBestStarsMap(updatedStars);

                    if (resetButtonRef.current) {
                        resetButtonRef.current.focus();
                    }
                }
                prevIsWonRef.current = isWon;
            }, [isWon, moves, gridSize, minSolution]);

            const handleLightClick = React.useCallback((r, c) => {
                if (checkWinCondition(board)) return;
                setMoveHistory(prev => [...prev, { row: r, col: c }]);
                setBoard(prevBoard => toggleLights(prevBoard, r, c, gridSize));
                setMoves(prevMoves => prevMoves + 1);
                setHintCell(null); // Clear hint highlight on any click
            }, [board, gridSize]);

            const handleUndo = React.useCallback(() => {
                if (moveHistory.length === 0) return;
                const lastMove = moveHistory[moveHistory.length - 1];
                setMoveHistory(prev => prev.slice(0, -1));
                setBoard(prevBoard => toggleLights(prevBoard, lastMove.row, lastMove.col, gridSize));
                setMoves(prevMoves => Math.max(0, prevMoves - 1));
                setHintCell(null);
            }, [moveHistory, gridSize]);

            const handleHint = React.useCallback(() => {
                if (hintsRemaining <= 0 || isWon) return;
                const solution = solveLightsOut(board);
                if (!solution || solution.length === 0) {
                    setHintCell(null);
                    return;
                }
                // Pick the first cell from the optimal solution
                const target = solution[0];
                setHintCell(target);
                setHintsRemaining(prev => prev - 1);
            }, [hintsRemaining, isWon, board]);

            const startNewGame = React.useCallback((size) => {
                const newBoard = generateBoard(size);
                setBoard(newBoard);
                setMoves(0);
                setMoveHistory([]);
                setHintsRemaining(HINTS_PER_GAME);
                setHintCell(null);
                setWonStars(0);
                const sol = solveLightsOut(newBoard);
                setMinSolution(sol ? sol.length : null);
            }, []);

            const handleSizeChange = React.useCallback((newSize) => {
                setGridSize(newSize);
                startNewGame(newSize);
            }, [startNewGame]);

            const resetGame = React.useCallback(() => {
                startNewGame(gridSize);
            }, [gridSize, startNewGame]);

            const openHowToPlay = React.useCallback(() => {
                setShowHowToPlay(true);
            }, []);

            const closeHowToPlay = React.useCallback(() => {
                setShowHowToPlay(false);
            }, []);

            const lightsOnCount = React.useMemo(() => {
                return board.reduce((total, row) => total + row.filter(Boolean).length, 0);
            }, [board]);

            const currentBestMoves = bestScores[String(gridSize)];
            const currentBestStars = bestStarsMap[String(gridSize)];

            return (
                <div className="min-h-screen bg-black text-white font-sans relative overflow-hidden p-4 flex items-center justify-center">
                    <div className="absolute inset-0 bg-gradient-to-br from-black via-blue-900/40 to-black" aria-hidden="true" />
                    <div className="absolute top-0 left-0 w-full h-full bg-repeat scanline-animation pointer-events-none" aria-hidden="true" />
                    <div className="relative z-10 max-w-lg mx-auto text-center">
                        <header className="py-4">
                            <div className="flex items-center justify-center gap-3">
                                <h1 className="text-4xl md:text-5xl font-bold bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent tracking-wider text-shadow-neon">
                                    LIGHTS OUT
                                </h1>
                                <button
                                    ref={howToPlayTriggerRef}
                                    onClick={openHowToPlay}
                                    className="min-w-[44px] min-h-[44px] rounded-full border border-cyan-500/50 bg-cyan-500/10 text-cyan-300 hover:bg-cyan-500/30 hover:text-white transition-all flex items-center justify-center text-lg flex-shrink-0"
                                    aria-label="How to Play"
                                    title="How to Play"
                                >
                                    &#10067;
                                </button>
                            </div>
                            <p className="text-cyan-300/80 mt-1 text-sm">Turn off all the lights!</p>
                        </header>

                        {/* Difficulty Selector */}
                        <DifficultySelector gridSize={gridSize} onChange={handleSizeChange} />

                        <HowToPlayModal isOpen={showHowToPlay} onClose={closeHowToPlay} triggerRef={howToPlayTriggerRef} />

                        <main className="bg-black/30 backdrop-blur-sm rounded-2xl p-4 border border-cyan-500/30 shadow-2xl shadow-cyan-500/20">
                            <div
                                role="grid"
                                aria-label={`Lights Out ${gridSize}x${gridSize} puzzle grid, ${lightsOnCount} lights remaining`}
                                className="flex flex-col gap-1.5"
                            >
                                {board.map((row, r) => (
                                    <div key={r} role="row" className="flex gap-1.5 justify-center">
                                        {row.map((isOn, c) => (
                                            <LightCell
                                                key={`${r}-${c}`}
                                                isOn={isOn}
                                                row={r}
                                                col={c}
                                                onToggle={handleLightClick}
                                                isHinted={hintCell !== null && hintCell.row === r && hintCell.col === c}
                                                cellSizeClass={cellSizeClass}
                                            />
                                        ))}
                                    </div>
                                ))}
                            </div>

                            {/* Undo and Hint buttons */}
                            {!isWon && (
                                <div className="flex gap-3 justify-center mt-4">
                                    <button
                                        onClick={handleUndo}
                                        disabled={moveHistory.length === 0}
                                        className={`px-4 py-2 min-h-[40px] rounded-lg text-sm font-bold transition-all border ${
                                            moveHistory.length === 0
                                                ? 'border-gray-600/30 bg-gray-800/30 text-gray-600 cursor-not-allowed'
                                                : 'border-cyan-500/40 bg-cyan-500/10 text-cyan-300 hover:bg-cyan-500/20 hover:border-cyan-400'
                                        }`}
                                        aria-label={`Undo last move${moveHistory.length === 0 ? ', no moves to undo' : ''}`}
                                    >
                                        &#8630; Undo
                                    </button>
                                    <button
                                        onClick={handleHint}
                                        disabled={hintsRemaining <= 0}
                                        className={`px-4 py-2 min-h-[40px] rounded-lg text-sm font-bold transition-all border ${
                                            hintsRemaining <= 0
                                                ? 'border-gray-600/30 bg-gray-800/30 text-gray-600 cursor-not-allowed'
                                                : 'border-yellow-500/40 bg-yellow-500/10 text-yellow-300 hover:bg-yellow-500/20 hover:border-yellow-400'
                                        }`}
                                        aria-label={`Get hint, ${hintsRemaining} hints remaining`}
                                    >
                                        &#9733; Hint ({hintsRemaining})
                                    </button>
                                </div>
                            )}
                        </main>

                        <footer className="py-4">
                            {isWon ? (
                                <div className="animate-fade-in" role="alert">
                                    <h2 className="text-3xl font-bold text-yellow-300 text-shadow-neon mb-2">
                                        YOU WON!
                                    </h2>
                                    <StarRating stars={wonStars} animated={true} className="mb-2" />
                                    <p className="text-sm text-cyan-200/70 mb-1">
                                        {wonStars === 3 ? 'Perfect!' : wonStars === 2 ? 'Great job!' : 'Solved!'}
                                        {minSolution !== null && (
                                            <span className="ml-1">(Optimal: {minSolution} moves)</span>
                                        )}
                                    </p>
                                    <p className="text-lg text-white mb-3">
                                        Solved in <span className="font-bold text-cyan-300">{moves}</span> moves.
                                    </p>
                                </div>
                            ) : (
                                <div className="space-y-1">
                                    <div className="text-2xl text-white" aria-live="polite" aria-atomic="true">
                                        Moves: <span className="font-bold text-cyan-300">{moves}</span>
                                    </div>
                                    {currentBestMoves !== undefined && (
                                        <div className="text-sm text-cyan-400/60">
                                            Best: <span className="font-bold">{currentBestMoves}</span> moves
                                            {currentBestStars > 0 && (
                                                <span className="ml-2 text-yellow-400/70">
                                                    {'\u2605'.repeat(currentBestStars)}{'\u2606'.repeat(3 - currentBestStars)}
                                                </span>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                            <button
                                ref={resetButtonRef}
                                onClick={resetGame}
                                className="mt-3 py-3 px-10 min-h-[44px] rounded-xl font-bold text-lg text-black transition-all duration-200 bg-gradient-to-r from-yellow-400 to-orange-500 hover:scale-105 shadow-lg shadow-yellow-500/50"
                            >
                                {isWon ? 'Play Again' : 'Reset'}
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        // Render the main component to the root div
        ReactDOM.render(<LightsOutGame />, document.getElementById('root'));
    </script>
</body>
</html>
