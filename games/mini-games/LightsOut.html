<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Lights Out - Toggle lights to turn them all off in this classic logic puzzle.">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta property="og:title" content="Lights Out">
    <meta property="og:description" content="Toggle lights to turn them all off in this classic logic puzzle.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Neon Lights Out</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>

    <!-- Babel to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">

    <style>
        :root {
            --lo-primary: 34, 211, 238;
            --lo-primary-hex: #22d3ee;
            --lo-secondary: 96, 165, 250;
            --lo-secondary-hex: #60a5fa;
            --lo-accent: 168, 85, 247;
            --lo-accent-hex: #a855f7;
            --lo-glow: 34, 211, 238;
            --lo-bg-via: 30, 58, 138;
            --lo-text-primary: 207, 250, 254;
            --lo-gradient-from: var(--lo-primary-hex);
            --lo-gradient-to: var(--lo-secondary-hex);
        }
        [data-theme="green"] {
            --lo-primary: 74, 222, 128;
            --lo-primary-hex: #4ade80;
            --lo-secondary: 34, 197, 94;
            --lo-secondary-hex: #22c55e;
            --lo-accent: 163, 230, 53;
            --lo-accent-hex: #a3e635;
            --lo-glow: 74, 222, 128;
            --lo-bg-via: 20, 83, 45;
            --lo-text-primary: 220, 252, 231;
            --lo-gradient-from: #4ade80;
            --lo-gradient-to: #22c55e;
        }
        [data-theme="amber"] {
            --lo-primary: 251, 191, 36;
            --lo-primary-hex: #fbbf24;
            --lo-secondary: 245, 158, 11;
            --lo-secondary-hex: #f59e0b;
            --lo-accent: 252, 211, 77;
            --lo-accent-hex: #fcd34d;
            --lo-glow: 251, 191, 36;
            --lo-bg-via: 120, 53, 15;
            --lo-text-primary: 254, 243, 199;
            --lo-gradient-from: #fbbf24;
            --lo-gradient-to: #f59e0b;
        }
        [data-theme="purple"] {
            --lo-primary: 192, 132, 252;
            --lo-primary-hex: #c084fc;
            --lo-secondary: 168, 85, 247;
            --lo-secondary-hex: #a855f7;
            --lo-accent: 232, 121, 249;
            --lo-accent-hex: #e879f9;
            --lo-glow: 192, 132, 252;
            --lo-bg-via: 88, 28, 135;
            --lo-text-primary: 243, 232, 255;
            --lo-gradient-from: #c084fc;
            --lo-gradient-to: #a855f7;
        }
        html, body {
            background-color: #000;
        }
        body {
            font-family: 'Orbitron', sans-serif;
        }
        .text-shadow-neon {
          text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px rgba(var(--lo-primary), 0.5), 0 0 20px rgba(var(--lo-primary), 0.5);
        }
        .scanline-animation {
          background-image: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0) 50%,
            rgba(0, 0, 0, 0.25) 50%
          );
          background-size: 100% 4px;
          animation: scanlines 5s linear infinite;
        }
        @keyframes scanlines {
          from { background-position: 0 0; }
          to { background-position: 0 -4px; }
        }
        @keyframes fade-in {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
          animation: fade-in 0.5s ease-out forwards;
        }
        @keyframes star-pop {
          0% { opacity: 0; transform: scale(0) rotate(-30deg); }
          60% { transform: scale(1.3) rotate(5deg); }
          100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        .animate-star-pop {
          animation: star-pop 0.4s ease-out forwards;
        }
        @keyframes hint-pulse {
          0%, 100% { box-shadow: 0 0 8px rgba(250, 204, 21, 0.6), 0 0 16px rgba(250, 204, 21, 0.3); }
          50% { box-shadow: 0 0 16px rgba(250, 204, 21, 0.9), 0 0 32px rgba(250, 204, 21, 0.5); }
        }
        .hint-highlight {
          animation: hint-pulse 1s ease-in-out infinite;
          border-color: rgb(250, 204, 21) !important;
          border-width: 3px !important;
        }
        /* Toggle Pattern Indicator - adjacent cell highlight on hover */
        .adjacent-highlight {
            outline: 2px solid rgba(var(--lo-primary), 0.5);
            outline-offset: -2px;
            box-shadow: 0 0 10px rgba(var(--lo-primary), 0.3), inset 0 0 6px rgba(var(--lo-primary), 0.15) !important;
            transition: outline 0.15s ease, box-shadow 0.15s ease;
        }
        /* Click Ripple Animation */
        @keyframes cell-ripple {
            0% {
                box-shadow: 0 0 0 0 rgba(var(--lo-primary), 0.7);
            }
            70% {
                box-shadow: 0 0 0 12px rgba(var(--lo-primary), 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(var(--lo-primary), 0);
            }
        }
        .ripple-center {
            animation: cell-ripple 0.5s ease-out;
        }
        @keyframes cell-ripple-adjacent {
            0% {
                box-shadow: 0 0 0 0 rgba(var(--lo-primary), 0.4);
            }
            70% {
                box-shadow: 0 0 0 8px rgba(var(--lo-primary), 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(var(--lo-primary), 0);
            }
        }
        .ripple-adjacent {
            animation: cell-ripple-adjacent 0.5s ease-out 0.1s;
        }
        /* Theme switcher dot active state */
        .theme-dot {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .theme-dot:hover {
            transform: scale(1.2);
        }
        .theme-dot.active {
            box-shadow: 0 0 0 2px #000, 0 0 0 4px rgba(var(--lo-primary), 0.8);
            transform: scale(1.15);
        }
        /* Countdown bar animation */
        @keyframes countdown-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .countdown-urgent {
            animation: countdown-pulse 0.5s ease-in-out infinite;
        }
        button:focus-visible, [role="button"]:focus-visible, a:focus-visible {
            outline: 2px solid rgba(var(--lo-primary), 1);
            outline-offset: 2px;
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
  <noscript>
    <div style="display:flex;align-items:center;justify-content:center;min-height:100vh;color:#22d3ee;font-family:sans-serif;text-align:center;padding:2rem;">
      <p>JavaScript is required to play Lights Out. Please enable JavaScript in your browser settings.</p>
    </div>
  </noscript>
  <a href="../../" aria-label="Back to menu" style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">&#127968; Menu</a>
    <div id="root"></div>

    <script type="text/babel">
        // --- CONFIGURATION ---
        const getLightColorOn = () => {
            const style = getComputedStyle(document.documentElement);
            const rgb = style.getPropertyValue('--lo-primary').trim();
            return `rgb(${rgb})`;
        };
        const getLightGlowOn = () => getLightColorOn();
        const LIGHT_COLOR_OFF = 'transparent';

        const DIFFICULTY_OPTIONS = [
            { size: 3, label: 'Beginner', sublabel: '3x3' },
            { size: 5, label: 'Standard', sublabel: '5x5' },
            { size: 7, label: 'Expert', sublabel: '7x7' },
        ];

        const HINTS_PER_GAME = 3;

        // --- THEME CONFIGURATION ---
        const THEMES = [
            { id: 'cyan', label: 'Neon Cyan', color: '#22d3ee' },
            { id: 'green', label: 'Matrix Green', color: '#4ade80' },
            { id: 'amber', label: 'Warm Amber', color: '#fbbf24' },
            { id: 'purple', label: 'Purple Haze', color: '#c084fc' },
        ];
        const STORAGE_KEY_THEME = 'lightsout_theme';

        const loadTheme = () => {
            try {
                return localStorage.getItem(STORAGE_KEY_THEME) || 'cyan';
            } catch { return 'cyan'; }
        };

        const saveTheme = (themeId) => {
            try { localStorage.setItem(STORAGE_KEY_THEME, themeId); } catch {}
        };

        const applyTheme = (themeId) => {
            if (themeId === 'cyan') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', themeId);
            }
        };

        // Apply saved theme immediately on load
        applyTheme(loadTheme());

        // --- TIMED CHALLENGE CONFIGURATION ---
        const TIME_LIMITS = {
            3: 30,
            5: 60,
            7: 120,
            9: 180,
            11: 240,
        };
        const getTimeLimit = (size) => TIME_LIMITS[size] || Math.max(60, size * size * 2);
        const BONUS_POINTS_PER_SECOND = 10;

        // --- HELPER FUNCTIONS ---
        const MAX_BOARD_GEN_ITERATIONS = 1000;

        const generateBoard = (gridSize) => {
            let board;
            let iterations = 0;
            do {
                board = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
                const clicks = Math.floor(Math.random() * 8) + 5;
                const usedPositions = new Set();
                for (let i = 0; i < clicks; i++) {
                    let r, c, key;
                    do {
                        r = Math.floor(Math.random() * gridSize);
                        c = Math.floor(Math.random() * gridSize);
                        key = r + ',' + c;
                    } while (usedPositions.has(key));
                    usedPositions.add(key);
                    board = toggleLights(board, r, c, gridSize);
                }
                iterations++;
            } while (checkWinCondition(board) && iterations < MAX_BOARD_GEN_ITERATIONS);
            return board;
        };

        const toggleLights = (board, r, c, gridSize) => {
            const size = gridSize || board.length;
            const newBoard = board.map(row => [...row]);
            const positions = [[r, c], [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
            positions.forEach(([row, col]) => {
                if (row >= 0 && row < size && col >= 0 && col < size) {
                    newBoard[row][col] = !newBoard[row][col];
                }
            });
            return newBoard;
        };

        const checkWinCondition = (board) => {
            return board.every(row => row.every(light => !light));
        };

        // --- GF(2) GAUSSIAN ELIMINATION SOLVER ---
        // Solves the Lights Out puzzle mathematically using linear algebra over GF(2).
        // Returns an array of {row, col} cells to click for the optimal solution,
        // or null if no solution exists.
        const solveLightsOut = (board) => {
            const n = board.length;
            const N = n * n;

            // Build the toggle matrix A (N x N) over GF(2)
            // A[i][j] = 1 if clicking cell j affects cell i
            const A = [];
            for (let i = 0; i < N; i++) {
                A.push(new Uint8Array(N + 1)); // augmented column for board state
            }

            for (let j = 0; j < N; j++) {
                const jr = Math.floor(j / n);
                const jc = j % n;
                const affected = [[jr, jc], [jr - 1, jc], [jr + 1, jc], [jr, jc - 1], [jr, jc + 1]];
                for (const [ar, ac] of affected) {
                    if (ar >= 0 && ar < n && ac >= 0 && ac < n) {
                        const i = ar * n + ac;
                        A[i][j] = 1;
                    }
                }
            }

            // Flatten board into the augmented column
            for (let r = 0; r < n; r++) {
                for (let c = 0; c < n; c++) {
                    A[r * n + c][N] = board[r][c] ? 1 : 0;
                }
            }

            // Gaussian elimination over GF(2)
            const pivotRow = new Array(N).fill(-1);
            let col = 0;
            for (let row = 0; row < N && col < N; col++) {
                // Find pivot
                let pivotR = -1;
                for (let r = row; r < N; r++) {
                    if (A[r][col] === 1) {
                        pivotR = r;
                        break;
                    }
                }
                if (pivotR === -1) continue;

                // Swap rows
                if (pivotR !== row) {
                    const temp = A[row];
                    A[row] = A[pivotR];
                    A[pivotR] = temp;
                }
                pivotRow[col] = row;

                // Eliminate all other rows
                for (let r = 0; r < N; r++) {
                    if (r !== row && A[r][col] === 1) {
                        for (let k = col; k <= N; k++) {
                            A[r][k] ^= A[row][k];
                        }
                    }
                }
                row++;
            }

            // Extract solution - free variables default to 0 for minimal solution
            const solution = new Uint8Array(N);
            for (let c = 0; c < N; c++) {
                if (pivotRow[c] !== -1) {
                    solution[c] = A[pivotRow[c]][N];
                }
            }

            // Verify solution
            for (let i = 0; i < N; i++) {
                let sum = 0;
                for (let j = 0; j < N; j++) {
                    // Recompute original A values for verification
                    const ir = Math.floor(i / n);
                    const ic = i % n;
                    const jr = Math.floor(j / n);
                    const jc = j % n;
                    const dist = Math.abs(ir - jr) + Math.abs(ic - jc);
                    if (dist <= 1) {
                        sum ^= solution[j];
                    }
                }
                const target = board[Math.floor(i / n)][i % n] ? 1 : 0;
                if (sum !== target) {
                    return null; // No solution exists
                }
            }

            // Convert to cell coordinates
            const moves = [];
            for (let i = 0; i < N; i++) {
                if (solution[i] === 1) {
                    moves.push({ row: Math.floor(i / n), col: i % n });
                }
            }
            return moves;
        };

        // --- LOCALSTORAGE HELPERS ---
        const STORAGE_KEY_BEST_MOVES = 'lightsout_best_moves';
        const STORAGE_KEY_BEST_STARS = 'lightsout_best_stars';
        const STORAGE_KEY_BEST_TIMED = 'lightsout_best_timed';

        const loadBestScores = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_BEST_MOVES);
                return raw ? JSON.parse(raw) : {};
            } catch {
                return {};
            }
        };

        const saveBestScore = (gridSize, moves) => {
            const scores = loadBestScores();
            const key = String(gridSize);
            if (!scores[key] || moves < scores[key]) {
                scores[key] = moves;
                try { localStorage.setItem(STORAGE_KEY_BEST_MOVES, JSON.stringify(scores)); } catch {}
            }
            return scores;
        };

        const loadBestStars = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_BEST_STARS);
                return raw ? JSON.parse(raw) : {};
            } catch {
                return {};
            }
        };

        const saveBestStars = (gridSize, stars) => {
            const allStars = loadBestStars();
            const key = String(gridSize);
            if (!allStars[key] || stars > allStars[key]) {
                allStars[key] = stars;
                try { localStorage.setItem(STORAGE_KEY_BEST_STARS, JSON.stringify(allStars)); } catch {}
            }
            return allStars;
        };

        const loadBestTimed = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_BEST_TIMED);
                return raw ? JSON.parse(raw) : {};
            } catch { return {}; }
        };

        const saveBestTimed = (gridSize, score) => {
            const scores = loadBestTimed();
            const key = String(gridSize);
            if (!scores[key] || score > scores[key]) {
                scores[key] = score;
                try { localStorage.setItem(STORAGE_KEY_BEST_TIMED, JSON.stringify(scores)); } catch {}
            }
            return scores;
        };

        // --- STAR RATING CALCULATION ---
        const calculateStars = (playerMoves, minMoves) => {
            if (minMoves <= 0) return 3;
            if (playerMoves <= minMoves + 1) return 3;
            if (playerMoves <= minMoves + 3) return 2;
            return 1;
        };

        // --- COMPONENTS ---
        const HowToPlayModal = ({ isOpen, onClose, triggerRef }) => {
            const closeButtonRef = React.useRef(null);
            const modalRef = React.useRef(null);

            // Focus management: move focus into modal on open, restore on close
            React.useEffect(() => {
                if (isOpen && closeButtonRef.current) {
                    closeButtonRef.current.focus();
                }
            }, [isOpen]);

            // Escape key and focus trap
            React.useEffect(() => {
                if (!isOpen) return;

                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        onClose();
                        return;
                    }

                    if (e.key === 'Tab' && modalRef.current) {
                        const focusableEls = modalRef.current.querySelectorAll(
                            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                        );
                        if (focusableEls.length === 0) return;

                        const firstEl = focusableEls[0];
                        const lastEl = focusableEls[focusableEls.length - 1];

                        if (e.shiftKey) {
                            if (document.activeElement === firstEl) {
                                e.preventDefault();
                                lastEl.focus();
                            }
                        } else {
                            if (document.activeElement === lastEl) {
                                e.preventDefault();
                                firstEl.focus();
                            }
                        }
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [isOpen, onClose]);

            // Restore focus to trigger on close
            const handleClose = React.useCallback(() => {
                onClose();
                // Defer focus restoration to after the modal unmounts
                requestAnimationFrame(() => {
                    if (triggerRef && triggerRef.current) {
                        triggerRef.current.focus();
                    }
                });
            }, [onClose, triggerRef]);

            if (!isOpen) return null;
            return (
                <div
                    className="fixed inset-0 z-50 flex items-center justify-center p-4"
                    onClick={handleClose}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="how-to-play-title"
                    ref={modalRef}
                >
                    <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" aria-hidden="true" />
                    <div
                        className="relative bg-gray-900 rounded-2xl p-6 max-w-sm w-full animate-fade-in"
                        style={{
                            border: `1px solid rgba(var(--lo-primary), 0.4)`,
                            boxShadow: `0 25px 50px rgba(var(--lo-primary), 0.15)`,
                        }}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <button
                            ref={closeButtonRef}
                            onClick={handleClose}
                            className="absolute top-2 right-2 min-w-[44px] min-h-[44px] flex items-center justify-center hover:text-white transition-colors text-2xl leading-none rounded-lg"
                            style={{ color: `rgba(var(--lo-primary), 0.8)` }}
                            aria-label="Close instructions"
                        >
                            &times;
                        </button>
                        <h2 id="how-to-play-title" className="text-2xl font-bold bg-clip-text text-transparent mb-4"
                            style={{ backgroundImage: `linear-gradient(to right, var(--lo-gradient-from), var(--lo-gradient-to))` }}>
                            How to Play
                        </h2>
                        <ul className="text-sm space-y-3 list-none" style={{ color: `rgba(var(--lo-text-primary), 0.85)` }}>
                            <li className="flex gap-2">
                                <span className="mt-0.5" style={{ color: `rgba(var(--lo-primary), 0.9)` }} aria-hidden="true">&#9654;</span>
                                <span>Click any <strong style={{ color: `rgba(var(--lo-primary), 0.9)` }}>light</strong> to toggle it and its <strong style={{ color: `rgba(var(--lo-primary), 0.9)` }}>4 adjacent neighbors</strong> (up, down, left, right).</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="mt-0.5" style={{ color: `rgba(var(--lo-primary), 0.9)` }} aria-hidden="true">&#9654;</span>
                                <span>Your goal is to turn <strong className="text-yellow-300">ALL lights off</strong> to win the game.</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="mt-0.5" style={{ color: `rgba(var(--lo-primary), 0.9)` }} aria-hidden="true">&#9654;</span>
                                <span>The <strong style={{ color: `rgba(var(--lo-primary), 0.9)` }}>fewer moves</strong> you use, the better your score!</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="mt-0.5" style={{ color: `rgba(var(--lo-primary), 0.9)` }} aria-hidden="true">&#9654;</span>
                                <span>Use <strong style={{ color: `rgba(var(--lo-primary), 0.9)` }}>Undo</strong> to take back your last move, or <strong className="text-yellow-300">Hint</strong> (3 per game) for help.</span>
                            </li>
                        </ul>
                        <button
                            onClick={handleClose}
                            className="mt-5 w-full py-2 min-h-[44px] rounded-lg font-bold text-black transition-all"
                            style={{ backgroundImage: `linear-gradient(to right, var(--lo-gradient-from), var(--lo-gradient-to))` }}
                        >
                            Got it!
                        </button>
                    </div>
                </div>
            );
        };

        // --- THEME SWITCHER ---
        const ThemeSwitcher = ({ currentTheme, onThemeChange }) => {
            return (
                <div className="flex items-center justify-center gap-2 mb-3">
                    <span className="text-xs" style={{ color: `rgba(var(--lo-text-primary), 0.6)` }}>Theme:</span>
                    {THEMES.map(t => (
                        <button
                            key={t.id}
                            onClick={() => onThemeChange(t.id)}
                            className={`theme-dot w-6 h-6 rounded-full border-2 ${currentTheme === t.id ? 'active border-white/80' : 'border-white/20 hover:border-white/50'}`}
                            style={{ backgroundColor: t.color }}
                            aria-label={`${t.label} theme${currentTheme === t.id ? ' (active)' : ''}`}
                            title={t.label}
                        />
                    ))}
                </div>
            );
        };

        // --- DIFFICULTY SELECTOR ---
        const DifficultySelector = ({ gridSize, onChange, customSize, onCustomSizeChange }) => {
            const isCustomActive = !DIFFICULTY_OPTIONS.some(opt => opt.size === gridSize);
            const [customInput, setCustomInput] = React.useState(customSize || '');
            const [customError, setCustomError] = React.useState('');

            const handleCustomSubmit = () => {
                const val = parseInt(customInput, 10);
                if (isNaN(val) || val < 3 || val > 15) {
                    setCustomError('3-15 only');
                    return;
                }
                if (val % 2 === 0) {
                    setCustomError('Must be odd');
                    return;
                }
                setCustomError('');
                onCustomSizeChange(val);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') handleCustomSubmit();
            };

            return (
                <div className="flex flex-col items-center gap-2 mb-4">
                    <div className="flex gap-2 justify-center flex-wrap" role="radiogroup" aria-label="Difficulty">
                        {DIFFICULTY_OPTIONS.map(opt => {
                            const isActive = opt.size === gridSize;
                            return (
                                <button
                                    key={opt.size}
                                    role="radio"
                                    aria-checked={isActive}
                                    onClick={() => { setCustomError(''); onChange(opt.size); }}
                                    className={`px-3 py-1.5 min-h-[40px] rounded-lg text-xs font-bold transition-all border`}
                                    style={{
                                        backgroundColor: isActive ? `rgba(var(--lo-primary), 0.2)` : 'rgba(0,0,0,0.4)',
                                        borderColor: isActive ? `rgba(var(--lo-primary), 0.8)` : `rgba(var(--lo-primary), 0.15)`,
                                        color: isActive ? `rgba(var(--lo-text-primary), 0.9)` : `rgba(var(--lo-primary), 0.5)`,
                                        boxShadow: isActive ? `0 4px 15px rgba(var(--lo-primary), 0.15)` : 'none',
                                    }}
                                >
                                    <div>{opt.label}</div>
                                    <div className="text-[10px] opacity-70">{opt.sublabel}</div>
                                </button>
                            );
                        })}
                        <div className="flex flex-col items-center">
                            <div className="flex items-center gap-1">
                                <input
                                    type="number"
                                    min="3"
                                    max="15"
                                    step="2"
                                    value={customInput}
                                    onChange={(e) => { setCustomInput(e.target.value); setCustomError(''); }}
                                    onKeyDown={handleKeyDown}
                                    placeholder="NxN"
                                    className="w-14 h-[40px] rounded-lg text-xs font-bold text-center border bg-black/40 focus:outline-none"
                                    style={{
                                        borderColor: isCustomActive ? `rgba(var(--lo-primary), 0.8)` : `rgba(var(--lo-primary), 0.15)`,
                                        color: `rgba(var(--lo-text-primary), 0.9)`,
                                        backgroundColor: isCustomActive ? `rgba(var(--lo-primary), 0.15)` : 'rgba(0,0,0,0.4)',
                                    }}
                                    aria-label="Custom grid size (odd number, 3-15)"
                                />
                                <button
                                    onClick={handleCustomSubmit}
                                    className="h-[40px] px-2 rounded-lg text-xs font-bold border transition-all"
                                    style={{
                                        borderColor: `rgba(var(--lo-primary), 0.4)`,
                                        color: `rgba(var(--lo-primary), 0.9)`,
                                        backgroundColor: 'rgba(0,0,0,0.3)',
                                    }}
                                    aria-label="Apply custom board size"
                                >
                                    Go
                                </button>
                            </div>
                            {customError && (
                                <div className="text-[10px] text-red-400 mt-0.5">{customError}</div>
                            )}
                            {isCustomActive && !customError && (
                                <div className="text-[10px] mt-0.5" style={{ color: `rgba(var(--lo-primary), 0.6)` }}>Custom {gridSize}x{gridSize}</div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- STAR DISPLAY ---
        const StarRating = ({ stars, animated, className }) => {
            return (
                <div className={`flex gap-1 justify-center ${className || ''}`} aria-label={`${stars} out of 3 stars`}>
                    {[1, 2, 3].map(i => (
                        <span
                            key={i}
                            className={`text-3xl ${animated && i <= stars ? 'animate-star-pop' : ''}`}
                            style={animated && i <= stars ? { animationDelay: `${(i - 1) * 0.15}s`, opacity: 0 } : {}}
                            aria-hidden="true"
                        >
                            {i <= stars ? '\u2605' : '\u2606'}
                        </span>
                    ))}
                </div>
            );
        };

        const LightCell = React.memo(({ isOn, onToggle, row, col, isHinted, cellSizeClass, isAdjacentHighlight, rippleClass }) => {
            const style = React.useMemo(() => ({
                backgroundColor: isOn ? `rgb(var(--lo-primary))` : LIGHT_COLOR_OFF,
                boxShadow: isOn ? `0 0 15px rgba(var(--lo-primary), 1), 0 0 25px rgba(var(--lo-primary), 0.38), inset 0 0 5px rgba(var(--lo-primary), 0.5)` : 'inset 0 0 10px rgba(0,0,0,0.5)',
                borderColor: `rgba(var(--lo-primary), 0.3)`,
            }), [isOn]);

            const handleClick = React.useCallback(() => {
                onToggle(row, col);
            }, [onToggle, row, col]);

            return (
                <button
                    onClick={handleClick}
                    role="gridcell"
                    className={`${cellSizeClass} rounded-lg border-2 transition-all duration-200 ease-in-out transform hover:scale-105 ${isHinted ? 'hint-highlight' : ''} ${isAdjacentHighlight ? 'adjacent-highlight' : ''} ${rippleClass || ''}`}
                    style={style}
                    aria-label={`Row ${row + 1}, Column ${col + 1}, light ${isOn ? 'on' : 'off'}${isHinted ? ', suggested move' : ''}`}
                    aria-pressed={isOn}
                />
            );
        });

        const LightsOutGame = () => {
            const [gridSize, setGridSize] = React.useState(5);
            const [board, setBoard] = React.useState(() => generateBoard(5));
            const [moves, setMoves] = React.useState(0);
            const [moveHistory, setMoveHistory] = React.useState([]);
            const [hintsRemaining, setHintsRemaining] = React.useState(HINTS_PER_GAME);
            const [hintCell, setHintCell] = React.useState(null);
            const [minSolution, setMinSolution] = React.useState(null);
            const [bestScores, setBestScores] = React.useState(() => loadBestScores());
            const [bestStarsMap, setBestStarsMap] = React.useState(() => loadBestStars());
            const [showHowToPlay, setShowHowToPlay] = React.useState(false);
            const [wonStars, setWonStars] = React.useState(0);
            const howToPlayTriggerRef = React.useRef(null);
            const resetButtonRef = React.useRef(null);
            const isWon = checkWinCondition(board);
            const prevIsWonRef = React.useRef(false);

            // --- Feature: Color Theme Toggle ---
            const [currentTheme, setCurrentTheme] = React.useState(() => loadTheme());

            const handleThemeChange = React.useCallback((themeId) => {
                setCurrentTheme(themeId);
                applyTheme(themeId);
                saveTheme(themeId);
            }, []);

            // --- Feature: Toggle Pattern Indicator (hover) ---
            const [hoveredCell, setHoveredCell] = React.useState(null);

            const getAdjacentCells = React.useCallback((r, c, size) => {
                const adj = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
                return adj.filter(([row, col]) => row >= 0 && row < size && col >= 0 && col < size);
            }, []);

            const handleCellHover = React.useCallback((r, c) => {
                setHoveredCell({ row: r, col: c });
            }, []);

            const handleCellLeave = React.useCallback(() => {
                setHoveredCell(null);
            }, []);

            const isAdjacentToHovered = React.useCallback((r, c) => {
                if (!hoveredCell) return false;
                const adj = getAdjacentCells(hoveredCell.row, hoveredCell.col, gridSize);
                return adj.some(([ar, ac]) => ar === r && ac === c);
            }, [hoveredCell, gridSize, getAdjacentCells]);

            // --- Feature: Click Ripple Animation ---
            const [rippleCells, setRippleCells] = React.useState({});

            const triggerRipple = React.useCallback((r, c, size) => {
                const centerKey = `${r}-${c}`;
                const adjacents = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]]
                    .filter(([row, col]) => row >= 0 && row < size && col >= 0 && col < size)
                    .map(([row, col]) => `${row}-${col}`);

                const newRipples = { [centerKey]: 'ripple-center' };
                adjacents.forEach(key => { newRipples[key] = 'ripple-adjacent'; });
                setRippleCells(newRipples);

                // Clear ripple classes after animation completes
                setTimeout(() => setRippleCells({}), 600);
            }, []);

            // --- Feature: Custom Board Size ---
            const [customSize, setCustomSize] = React.useState(null);

            const handleCustomSizeChange = React.useCallback((size) => {
                setCustomSize(size);
                setGridSize(size);
                startNewGame(size);
            }, []);

            // --- Feature: Timed Challenge Mode ---
            const [timedMode, setTimedMode] = React.useState(false);
            const [timeRemaining, setTimeRemaining] = React.useState(0);
            const [timerActive, setTimerActive] = React.useState(false);
            const [timedScore, setTimedScore] = React.useState(null);
            const [bestTimedScores, setBestTimedScores] = React.useState(() => loadBestTimed());
            const timerRef = React.useRef(null);

            // Timer countdown effect
            React.useEffect(() => {
                if (timerActive && timeRemaining > 0 && !isWon) {
                    timerRef.current = setInterval(() => {
                        setTimeRemaining(prev => {
                            if (prev <= 1) {
                                setTimerActive(false);
                                clearInterval(timerRef.current);
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                    return () => clearInterval(timerRef.current);
                }
                if (isWon && timerRef.current) {
                    clearInterval(timerRef.current);
                    setTimerActive(false);
                }
            }, [timerActive, isWon]);

            const isTimedGameOver = timedMode && timeRemaining === 0 && timerActive === false && !isWon && moves > 0;

            const toggleTimedMode = React.useCallback(() => {
                setTimedMode(prev => {
                    const newMode = !prev;
                    return newMode;
                });
            }, []);

            // Compute minimum solution length when board changes (for new game)
            const computeMinSolution = React.useCallback((b) => {
                const sol = solveLightsOut(b);
                return sol ? sol.length : null;
            }, []);

            // Initialize min solution on first render
            React.useEffect(() => {
                setMinSolution(computeMinSolution(board));
            }, []);

            // Cell size classes based on grid size
            const cellSizeClass = React.useMemo(() => {
                if (gridSize <= 3) return 'w-20 h-20 md:w-24 md:h-24';
                if (gridSize <= 5) return 'w-14 h-14 md:w-16 md:h-16';
                if (gridSize <= 7) return 'w-10 h-10 md:w-12 md:h-12';
                if (gridSize <= 9) return 'w-8 h-8 md:w-10 md:h-10';
                return 'w-6 h-6 md:w-8 md:h-8';
            }, [gridSize]);

            // When the game is won, compute stars, save best scores
            React.useEffect(() => {
                if (isWon && !prevIsWonRef.current) {
                    // Save best move score
                    const updatedScores = saveBestScore(gridSize, moves);
                    setBestScores(updatedScores);

                    // Calculate and save star rating
                    const stars = calculateStars(moves, minSolution);
                    setWonStars(stars);
                    const updatedStars = saveBestStars(gridSize, stars);
                    setBestStarsMap(updatedStars);

                    // Timed mode scoring
                    if (timedMode && timeRemaining > 0) {
                        const bonus = timeRemaining * BONUS_POINTS_PER_SECOND;
                        const moveScore = Math.max(0, 1000 - (moves * 20));
                        const totalScore = moveScore + bonus;
                        setTimedScore(totalScore);
                        const updatedTimed = saveBestTimed(gridSize, totalScore);
                        setBestTimedScores(updatedTimed);
                    }

                    if (resetButtonRef.current) {
                        resetButtonRef.current.focus();
                    }
                }
                prevIsWonRef.current = isWon;
            }, [isWon, moves, gridSize, minSolution, timedMode, timeRemaining]);

            const handleLightClick = React.useCallback((r, c) => {
                if (checkWinCondition(board)) return;
                if (timedMode && timeRemaining === 0 && moves > 0) return; // Time's up

                // Start timer on first move in timed mode
                if (timedMode && moves === 0) {
                    setTimeRemaining(getTimeLimit(gridSize));
                    setTimerActive(true);
                }

                setMoveHistory(prev => [...prev, { row: r, col: c }]);
                setBoard(prevBoard => toggleLights(prevBoard, r, c, gridSize));
                setMoves(prevMoves => prevMoves + 1);
                setHintCell(null);
                triggerRipple(r, c, gridSize);
            }, [board, gridSize, timedMode, timeRemaining, moves, triggerRipple]);

            const handleUndo = React.useCallback(() => {
                if (moveHistory.length === 0) return;
                if (timedMode && timeRemaining === 0 && moves > 0) return;
                const lastMove = moveHistory[moveHistory.length - 1];
                setMoveHistory(prev => prev.slice(0, -1));
                setBoard(prevBoard => toggleLights(prevBoard, lastMove.row, lastMove.col, gridSize));
                setMoves(prevMoves => Math.max(0, prevMoves - 1));
                setHintCell(null);
            }, [moveHistory, gridSize, timedMode, timeRemaining, moves]);

            const handleHint = React.useCallback(() => {
                if (hintsRemaining <= 0 || isWon) return;
                if (timedMode && timeRemaining === 0 && moves > 0) return;
                const solution = solveLightsOut(board);
                if (!solution || solution.length === 0) {
                    setHintCell(null);
                    return;
                }
                // Pick the first cell from the optimal solution
                const target = solution[0];
                setHintCell(target);
                setHintsRemaining(prev => prev - 1);
            }, [hintsRemaining, isWon, board, timedMode, timeRemaining, moves]);

            const startNewGame = React.useCallback((size) => {
                const newBoard = generateBoard(size);
                setBoard(newBoard);
                setMoves(0);
                setMoveHistory([]);
                setHintsRemaining(HINTS_PER_GAME);
                setHintCell(null);
                setWonStars(0);
                setTimedScore(null);
                setTimeRemaining(0);
                setTimerActive(false);
                setRippleCells({});
                setHoveredCell(null);
                if (timerRef.current) clearInterval(timerRef.current);
                const sol = solveLightsOut(newBoard);
                setMinSolution(sol ? sol.length : null);
            }, []);

            // Fix: handleCustomSizeChange needs startNewGame, defined after it.
            // We use a ref to avoid stale closure.
            const startNewGameRef = React.useRef(startNewGame);
            startNewGameRef.current = startNewGame;

            const handleCustomSizeChangeStable = React.useCallback((size) => {
                setCustomSize(size);
                setGridSize(size);
                startNewGameRef.current(size);
            }, []);

            const handleSizeChange = React.useCallback((newSize) => {
                setCustomSize(null);
                setGridSize(newSize);
                startNewGame(newSize);
            }, [startNewGame]);

            const resetGame = React.useCallback(() => {
                startNewGame(gridSize);
            }, [gridSize, startNewGame]);

            const openHowToPlay = React.useCallback(() => {
                setShowHowToPlay(true);
            }, []);

            const closeHowToPlay = React.useCallback(() => {
                setShowHowToPlay(false);
            }, []);

            const lightsOnCount = React.useMemo(() => {
                return board.reduce((total, row) => total + row.filter(Boolean).length, 0);
            }, [board]);

            const currentBestMoves = bestScores[String(gridSize)];
            const currentBestStars = bestStarsMap[String(gridSize)];
            const currentBestTimed = bestTimedScores[String(gridSize)];

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m}:${s.toString().padStart(2, '0')}`;
            };

            const timeLimit = getTimeLimit(gridSize);
            const timerPercent = timedMode && timeLimit > 0 ? (timeRemaining / timeLimit) * 100 : 100;
            const timerUrgent = timedMode && timerActive && timeRemaining <= 10 && timeRemaining > 0;
            const gameDisabled = isWon || isTimedGameOver;

            return (
                <div className="min-h-screen bg-black text-white font-sans relative overflow-hidden p-4 flex items-center justify-center">
                    <div className="absolute inset-0 bg-gradient-to-br from-black to-black" style={{ background: `linear-gradient(135deg, #000 0%, rgba(var(--lo-bg-via), 0.4) 50%, #000 100%)` }} aria-hidden="true" />
                    <div className="absolute top-0 left-0 w-full h-full bg-repeat scanline-animation pointer-events-none" aria-hidden="true" />
                    <div className="relative z-10 max-w-lg mx-auto text-center">
                        <header className="py-4">
                            <div className="flex items-center justify-center gap-3">
                                <h1 className="text-4xl md:text-5xl font-bold bg-clip-text text-transparent tracking-wider text-shadow-neon"
                                    style={{ backgroundImage: `linear-gradient(to right, var(--lo-gradient-from), var(--lo-gradient-to), var(--lo-accent-hex))` }}>
                                    LIGHTS OUT
                                </h1>
                                <button
                                    ref={howToPlayTriggerRef}
                                    onClick={openHowToPlay}
                                    className="min-w-[44px] min-h-[44px] rounded-full transition-all flex items-center justify-center text-lg flex-shrink-0"
                                    style={{
                                        borderColor: `rgba(var(--lo-primary), 0.4)`,
                                        backgroundColor: `rgba(var(--lo-primary), 0.08)`,
                                        color: `rgba(var(--lo-primary), 0.8)`,
                                        border: `1px solid rgba(var(--lo-primary), 0.4)`,
                                    }}
                                    aria-label="How to Play"
                                    title="How to Play"
                                >
                                    &#10067;
                                </button>
                            </div>
                            <p className="mt-1 text-sm" style={{ color: `rgba(var(--lo-primary), 0.6)` }}>Turn off all the lights!</p>
                        </header>

                        {/* Theme Switcher */}
                        <ThemeSwitcher currentTheme={currentTheme} onThemeChange={handleThemeChange} />

                        {/* Difficulty Selector with Custom Size */}
                        <DifficultySelector gridSize={gridSize} onChange={handleSizeChange} customSize={customSize} onCustomSizeChange={handleCustomSizeChangeStable} />

                        {/* Timed Challenge Mode Toggle */}
                        <div className="flex items-center justify-center gap-3 mb-3">
                            <button
                                onClick={() => { toggleTimedMode(); resetGame(); }}
                                className="flex items-center gap-2 px-3 py-1.5 min-h-[36px] rounded-lg text-xs font-bold transition-all border"
                                style={{
                                    borderColor: timedMode ? 'rgba(239, 68, 68, 0.6)' : `rgba(var(--lo-primary), 0.2)`,
                                    backgroundColor: timedMode ? 'rgba(239, 68, 68, 0.15)' : 'rgba(0,0,0,0.3)',
                                    color: timedMode ? 'rgb(252, 165, 165)' : `rgba(var(--lo-primary), 0.5)`,
                                }}
                                aria-pressed={timedMode}
                                aria-label={`Timed challenge mode: ${timedMode ? 'on' : 'off'}`}
                            >
                                <span aria-hidden="true">{timedMode ? '\u23F1' : '\u23F1'}</span>
                                Timed {timedMode ? 'ON' : 'OFF'}
                                {timedMode && <span className="text-[10px] opacity-70">({formatTime(getTimeLimit(gridSize))})</span>}
                            </button>
                        </div>

                        {/* Timed Mode Timer Bar */}
                        {timedMode && (timerActive || timeRemaining > 0 || isTimedGameOver) && (
                            <div className="mb-3 px-2">
                                <div className="flex items-center justify-between text-xs mb-1">
                                    <span className={`font-bold ${timerUrgent ? 'text-red-400 countdown-urgent' : ''}`}
                                        style={!timerUrgent ? { color: `rgba(var(--lo-primary), 0.8)` } : {}}>
                                        {formatTime(timeRemaining)}
                                    </span>
                                    {timedMode && moves === 0 && !timerActive && (
                                        <span className="text-gray-400 text-[10px]">Timer starts on first move</span>
                                    )}
                                </div>
                                <div className="w-full h-2 rounded-full bg-gray-800 overflow-hidden">
                                    <div
                                        className={`h-full rounded-full transition-all duration-1000 ease-linear ${timerUrgent ? 'countdown-urgent' : ''}`}
                                        style={{
                                            width: `${timerPercent}%`,
                                            backgroundColor: timerPercent > 50 ? `rgba(var(--lo-primary), 0.8)` :
                                                timerPercent > 20 ? 'rgb(251, 191, 36)' : 'rgb(239, 68, 68)',
                                        }}
                                    />
                                </div>
                            </div>
                        )}

                        <HowToPlayModal isOpen={showHowToPlay} onClose={closeHowToPlay} triggerRef={howToPlayTriggerRef} />

                        <main className="bg-black/30 backdrop-blur-sm rounded-2xl p-4 border shadow-2xl"
                            style={{
                                borderColor: `rgba(var(--lo-primary), 0.2)`,
                                boxShadow: `0 25px 50px rgba(var(--lo-primary), 0.1)`,
                            }}>
                            <div
                                role="grid"
                                aria-label={`Lights Out ${gridSize}x${gridSize} puzzle grid, ${lightsOnCount} lights remaining`}
                                className="flex flex-col gap-1.5"
                                onMouseLeave={handleCellLeave}
                            >
                                {board.map((row, r) => (
                                    <div key={r} role="row" className="flex gap-1.5 justify-center">
                                        {row.map((isOn, c) => (
                                            <div
                                                key={`${r}-${c}`}
                                                onMouseEnter={() => !gameDisabled && handleCellHover(r, c)}
                                            >
                                                <LightCell
                                                    isOn={isOn}
                                                    row={r}
                                                    col={c}
                                                    onToggle={gameDisabled ? () => {} : handleLightClick}
                                                    isHinted={hintCell !== null && hintCell.row === r && hintCell.col === c}
                                                    cellSizeClass={cellSizeClass}
                                                    isAdjacentHighlight={!gameDisabled && isAdjacentToHovered(r, c)}
                                                    rippleClass={rippleCells[`${r}-${c}`] || ''}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                ))}
                            </div>

                            {/* Undo and Hint buttons */}
                            {!isWon && !isTimedGameOver && (
                                <div className="flex gap-3 justify-center mt-4">
                                    <button
                                        onClick={handleUndo}
                                        disabled={moveHistory.length === 0}
                                        className={`px-4 py-2 min-h-[40px] rounded-lg text-sm font-bold transition-all border ${
                                            moveHistory.length === 0
                                                ? 'border-gray-600/30 bg-gray-800/30 text-gray-600 cursor-not-allowed'
                                                : ''
                                        }`}
                                        style={moveHistory.length > 0 ? {
                                            borderColor: `rgba(var(--lo-primary), 0.35)`,
                                            backgroundColor: `rgba(var(--lo-primary), 0.08)`,
                                            color: `rgba(var(--lo-primary), 0.8)`,
                                        } : {}}
                                        aria-label={`Undo last move${moveHistory.length === 0 ? ', no moves to undo' : ''}`}
                                    >
                                        &#8630; Undo
                                    </button>
                                    <button
                                        onClick={handleHint}
                                        disabled={hintsRemaining <= 0}
                                        className={`px-4 py-2 min-h-[40px] rounded-lg text-sm font-bold transition-all border ${
                                            hintsRemaining <= 0
                                                ? 'border-gray-600/30 bg-gray-800/30 text-gray-600 cursor-not-allowed'
                                                : 'border-yellow-500/40 bg-yellow-500/10 text-yellow-300 hover:bg-yellow-500/20 hover:border-yellow-400'
                                        }`}
                                        aria-label={`Get hint, ${hintsRemaining} hints remaining`}
                                    >
                                        &#9733; Hint ({hintsRemaining})
                                    </button>
                                </div>
                            )}
                        </main>

                        <footer className="py-4">
                            {/* Timed Game Over */}
                            {isTimedGameOver && (
                                <div className="animate-fade-in" role="alert">
                                    <h2 className="text-3xl font-bold text-red-400 text-shadow-neon mb-2">
                                        TIME'S UP!
                                    </h2>
                                    <p className="text-sm text-gray-300 mb-1">
                                        You ran out of time after <span className="font-bold" style={{ color: `rgba(var(--lo-primary), 0.9)` }}>{moves}</span> moves.
                                    </p>
                                    <p className="text-xs text-gray-500 mb-3">
                                        {lightsOnCount} light{lightsOnCount !== 1 ? 's' : ''} still on.
                                    </p>
                                </div>
                            )}
                            {isWon ? (
                                <div className="animate-fade-in" role="alert">
                                    <h2 className="text-3xl font-bold text-yellow-300 text-shadow-neon mb-2">
                                        YOU WON!
                                    </h2>
                                    <StarRating stars={wonStars} animated={true} className="mb-2" />
                                    <p className="text-sm mb-1" style={{ color: `rgba(var(--lo-text-primary), 0.6)` }}>
                                        {wonStars === 3 ? 'Perfect!' : wonStars === 2 ? 'Great job!' : 'Solved!'}
                                        {minSolution !== null && (
                                            <span className="ml-1">(Optimal: {minSolution} moves)</span>
                                        )}
                                    </p>
                                    <p className="text-lg text-white mb-1">
                                        Solved in <span className="font-bold" style={{ color: `rgba(var(--lo-primary), 0.9)` }}>{moves}</span> moves.
                                    </p>
                                    {timedMode && timedScore !== null && (
                                        <div className="mb-2">
                                            <p className="text-sm text-yellow-300">
                                                Time bonus: +{timeRemaining * BONUS_POINTS_PER_SECOND} pts ({formatTime(timeRemaining)} remaining)
                                            </p>
                                            <p className="text-lg font-bold text-yellow-200">
                                                Score: {timedScore}
                                            </p>
                                            {currentBestTimed && (
                                                <p className="text-xs text-yellow-400/60">
                                                    Best timed score: {currentBestTimed}
                                                </p>
                                            )}
                                        </div>
                                    )}
                                </div>
                            ) : !isTimedGameOver && (
                                <div className="space-y-1">
                                    <div className="text-2xl text-white" aria-live="polite" aria-atomic="true">
                                        Moves: <span className="font-bold" style={{ color: `rgba(var(--lo-primary), 0.9)` }}>{moves}</span>
                                    </div>
                                    {currentBestMoves !== undefined && (
                                        <div className="text-sm" style={{ color: `rgba(var(--lo-primary), 0.45)` }}>
                                            Best: <span className="font-bold">{currentBestMoves}</span> moves
                                            {currentBestStars > 0 && (
                                                <span className="ml-2 text-yellow-400/70">
                                                    {'\u2605'.repeat(currentBestStars)}{'\u2606'.repeat(3 - currentBestStars)}
                                                </span>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                            <button
                                ref={resetButtonRef}
                                onClick={resetGame}
                                className="mt-3 py-3 px-10 min-h-[44px] rounded-xl font-bold text-lg text-black transition-all duration-200 bg-gradient-to-r from-yellow-400 to-orange-500 hover:scale-105 shadow-lg shadow-yellow-500/50"
                            >
                                {isWon ? 'Play Again' : isTimedGameOver ? 'Try Again' : 'Reset'}
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        // Render the main component to the root div
        ReactDOM.render(<LightsOutGame />, document.getElementById('root'));
    </script>
</body>
</html>
