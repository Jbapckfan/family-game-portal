<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Peg Jumper - Jump pegs to leave just one in this classic board puzzle.">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Peg Jumper">
    <meta property="og:title" content="Peg Jumper">
    <meta property="og:description" content="Jump pegs to leave just one in this classic board puzzle.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Peg Jumper - Pro Edition</title>
    <!-- React and Babel for JSX transpilation -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes validTargetPulse {
            0%, 100% { box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.5), 0 0 8px rgba(74, 222, 128, 0.3); border-color: rgba(74, 222, 128, 0.7); }
            50% { box-shadow: 0 0 0 4px rgba(74, 222, 128, 0.8), 0 0 16px rgba(74, 222, 128, 0.5); border-color: rgba(74, 222, 128, 1); }
        }
        .valid-target-hole {
            animation: validTargetPulse 1s ease-in-out infinite;
            border-color: rgba(74, 222, 128, 0.7) !important;
            background: rgba(74, 222, 128, 0.15) !important;
        }
        @keyframes pegShrinkFade {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        .peg-shrink-fade {
            animation: pegShrinkFade 0.35s ease-in forwards;
        }
        .peg-flying {
            position: absolute;
            z-index: 100;
            transition: left 0.35s ease-in-out, top 0.35s ease-in-out;
            pointer-events: none;
        }
        .solved-level-btn {
            border: 2px solid #fbbf24 !important;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }
        button:focus-visible,
        [role="button"]:focus-visible,
        a:focus-visible {
            outline: 3px solid #00ffff;
            outline-offset: 2px;
        }
        @keyframes hintPulseSource {
            0%, 100% { box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.4), 0 0 12px rgba(251, 191, 36, 0.3); border-color: rgba(251, 191, 36, 0.7); }
            50% { box-shadow: 0 0 0 6px rgba(251, 191, 36, 0.9), 0 0 24px rgba(251, 191, 36, 0.6); border-color: rgba(251, 191, 36, 1); }
        }
        @keyframes hintPulseTarget {
            0%, 100% { box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.4), 0 0 12px rgba(74, 222, 128, 0.3); border-color: rgba(74, 222, 128, 0.7); background: rgba(74, 222, 128, 0.15); }
            50% { box-shadow: 0 0 0 6px rgba(74, 222, 128, 0.9), 0 0 24px rgba(74, 222, 128, 0.6); border-color: rgba(74, 222, 128, 1); background: rgba(74, 222, 128, 0.35); }
        }
        .hint-source-pulse > div {
            animation: hintPulseSource 0.6s ease-in-out 3;
            border-color: rgba(251, 191, 36, 0.7) !important;
        }
        .hint-target-pulse > div {
            animation: hintPulseTarget 0.6s ease-in-out 3;
            border-color: rgba(74, 222, 128, 0.7) !important;
            background: rgba(74, 222, 128, 0.25) !important;
        }
        @keyframes confettiFall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        @keyframes badgeAppear {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            60% { transform: scale(1.2) rotate(10deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes niceTryFade {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            top: -10px;
            animation: confettiFall linear forwards;
        }
        .golden-badge {
            animation: badgeAppear 0.8s ease-out forwards;
        }
        .nice-try-anim {
            animation: niceTryFade 0.6s ease-out forwards;
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body class="bg-gray-900">
  <a href="../../"
     aria-label="Back to main menu"
     style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;min-width:44px;display:flex;align-items:center;gap:6px;"
     onmouseover="this.style.background='rgba(0,0,0,0.9)'"
     onmouseout="this.style.background='rgba(0,0,0,0.7)'"
  >&#x1F3E0; Menu</a>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- GAME CONSTANTS & DATA ---

        // Represents the shape of various peg boards.
        // 1: Valid peg position, null: Not a playable position.
        const LEVELS = [
            {
                name: "Triangle",
                layout: [
                    [null, null, null, null, 1, null, null, null, null],
                    [null, null, null, 1, null, 1, null, null, null],
                    [null, null, 1, null, 1, null, 1, null, null],
                    [null, 1, null, 1, null, 1, null, 1, null],
                    [1, null, 1, null, 1, null, 1, null, 1],
                ],
                initialEmpty: { row: 0, col: 4 },
                directions: [[0,4],[0,-4],[4,0],[-4,0],[2,2],[2,-2],[-2,2],[-2,-2]]
            },
            {
                name: "Cross",
                layout: [
                    [null, null, 1, 1, 1, null, null],
                    [null, null, 1, 1, 1, null, null],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [null, null, 1, 1, 1, null, null],
                    [null, null, 1, 1, 1, null, null],
                ],
                initialEmpty: { row: 3, col: 3 },
                directions: [[0,2],[0,-2],[2,0],[-2,0]]
            },
            {
                name: "Triple Triangle",
                layout: [
                    [null, null, 1, null, 1, null, 1, null, null],
                    [null, 1, null, 1, null, 1, null, 1, null],
                    [1, null, 1, null, 1, null, 1, null, 1],
                    [null, null, null, 1, null, 1, null, null, null],
                    [null, null, 1, null, 1, null, 1, null, null],
                ],
                initialEmpty: { row: 2, col: 4 },
                directions: [[0,4],[0,-4],[4,0],[-4,0],[2,2],[2,-2],[-2,2],[-2,-2]]
            },
            {
                name: "Rectangle",
                layout: [
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                ],
                initialEmpty: { row: 1, col: 2 },
                directions: [[0,2],[0,-2],[2,0],[-2,0]]
            }
        ];

        const GameState = {
            PLAYING: 'playing',
            WON: 'won',
            LOST: 'lost'
        };

        const RAPID_MOVE_BONUS = 50;
        const RAPID_MOVE_THRESHOLD_MS = 2500;

        // --- SAFE LOCALSTORAGE HELPERS ---
        function safeGetItem(key) {
            try {
                return localStorage.getItem(key);
            } catch (e) {
                console.warn('localStorage read failed:', e);
                return null;
            }
        }

        function safeSetItem(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                console.warn('localStorage write failed:', e);
            }
        }

        // --- HELPER & UI COMPONENTS ---

        // Feature 7: Enhanced Celebration with confetti for perfect solve, nice-try for 2-3 pegs
        const Celebration = ({ show, pegsRemaining }) => {
            if (!show) return null;
            const isPerfect = pegsRemaining === 1;
            const isNiceTry = pegsRemaining >= 2 && pegsRemaining <= 3;

            // Generate confetti pieces for perfect solve
            const confettiColors = ['#fbbf24', '#f472b6', '#34d399', '#60a5fa', '#a78bfa', '#fb923c', '#f87171'];
            const confettiPieces = isPerfect ? Array.from({ length: 50 }, (_, i) => ({
                id: i,
                left: Math.random() * 100,
                color: confettiColors[i % confettiColors.length],
                delay: Math.random() * 1.5,
                duration: 2.5 + Math.random() * 2,
                size: 6 + Math.random() * 8,
                shape: Math.random() > 0.5 ? 'circle' : 'rect',
            })) : [];

            return (
                <div className="fixed inset-0 pointer-events-none z-50 flex items-center justify-center"
                     role="status"
                     aria-live="assertive"
                     aria-label={isPerfect ? 'Perfect solve! Congratulations!' : isNiceTry ? 'Nice try! Almost perfect!' : 'Congratulations, you won!'}
                >
                    {isPerfect && (
                        <>
                            {/* Confetti particles */}
                            {confettiPieces.map(p => (
                                <div
                                    key={p.id}
                                    className="confetti-piece"
                                    aria-hidden="true"
                                    style={{
                                        left: `${p.left}%`,
                                        width: p.size,
                                        height: p.size,
                                        backgroundColor: p.color,
                                        borderRadius: p.shape === 'circle' ? '50%' : '2px',
                                        animationDelay: `${p.delay}s`,
                                        animationDuration: `${p.duration}s`,
                                    }}
                                />
                            ))}
                            {/* Golden badge */}
                            <div className="golden-badge flex flex-col items-center gap-2" aria-hidden="true">
                                <div className="text-8xl">&#x1F3C6;</div>
                                <div className="px-6 py-2 bg-gradient-to-r from-yellow-400 via-amber-300 to-yellow-500 rounded-full shadow-lg shadow-yellow-500/50">
                                    <span className="text-xl font-black text-gray-900 tracking-wide">PERFECT SOLVE!</span>
                                </div>
                            </div>
                            <div className="absolute inset-0 bg-gradient-to-r from-yellow-400/20 via-pink-400/20 to-purple-400/20 animate-pulse" aria-hidden="true"></div>
                        </>
                    )}
                    {isNiceTry && (
                        <div className="nice-try-anim flex flex-col items-center gap-2" aria-hidden="true">
                            <div className="text-6xl">&#128079;</div>
                            <div className="px-5 py-2 bg-gradient-to-r from-blue-500 to-purple-500 rounded-full shadow-lg">
                                <span className="text-lg font-bold text-white">Nice Try! {pegsRemaining} pegs left</span>
                            </div>
                        </div>
                    )}
                    {!isPerfect && !isNiceTry && (
                        <>
                            <div className="text-8xl animate-bounce" aria-hidden="true">&#x1F3C6;</div>
                            <div className="absolute inset-0 bg-gradient-to-r from-yellow-400/20 via-pink-400/20 to-purple-400/20 animate-pulse" aria-hidden="true"></div>
                        </>
                    )}
                </div>
            );
        };

        const Peg = ({ onClick, onKeyDown, isSelected, rowIndex, colIndex, animClass, hidden }) => (
            <div
                className="min-w-[44px] min-h-[44px] flex items-center justify-center cursor-pointer"
                onClick={onClick}
                onKeyDown={onKeyDown}
                role="button"
                tabIndex={0}
                aria-label={`Peg at row ${rowIndex + 1}, column ${colIndex + 1}${isSelected ? ', selected' : ''}`}
                aria-pressed={isSelected}
            >
                <div
                    className={`w-8 h-8 sm:w-9 sm:h-9 rounded-full bg-gradient-to-br from-cyan-400 to-blue-600 shadow-lg shadow-cyan-400/70 transition-all duration-200 pointer-events-none ${isSelected ? 'border-4 border-yellow-400 animate-pulse ring-2 ring-yellow-400/50' : 'border-2 border-cyan-400/30'} ${animClass || ''}`}
                    style={hidden ? { opacity: 0 } : undefined}
                    aria-hidden="true"
                />
            </div>
        );

        const Hole = ({ onClick, onKeyDown, rowIndex, colIndex, isValidTarget, onMouseEnter, onMouseLeave }) => (
            <div
                className="min-w-[44px] min-h-[44px] flex items-center justify-center cursor-pointer"
                onClick={onClick}
                onKeyDown={onKeyDown}
                onMouseEnter={onMouseEnter}
                onMouseLeave={onMouseLeave}
                role="button"
                tabIndex={0}
                aria-label={`Empty hole at row ${rowIndex + 1}, column ${colIndex + 1}${isValidTarget ? ', valid move target' : ''}`}
            >
                <div className={`w-6 h-6 sm:w-7 sm:h-7 rounded-full shadow-inner border-2 transition-colors pointer-events-none ${isValidTarget ? 'valid-target-hole bg-gray-800' : 'bg-gray-800 border-purple-500/30 hover:border-purple-500'}`} aria-hidden="true" />
            </div>
        );

        const HowToPlayModal = ({ isOpen, onClose, triggerRef }) => {
            const closeButtonRef = useRef(null);
            const gotItButtonRef = useRef(null);
            const modalRef = useRef(null);

            // Focus trap and focus management
            useEffect(() => {
                if (!isOpen) return;

                // Focus the close button on open
                const timer = setTimeout(() => {
                    if (gotItButtonRef.current) gotItButtonRef.current.focus();
                }, 50);

                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        onClose();
                        return;
                    }
                    // Trap focus within modal
                    if (e.key === 'Tab' && modalRef.current) {
                        const focusable = modalRef.current.querySelectorAll(
                            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                        );
                        const first = focusable[0];
                        const last = focusable[focusable.length - 1];
                        if (e.shiftKey && document.activeElement === first) {
                            e.preventDefault();
                            last.focus();
                        } else if (!e.shiftKey && document.activeElement === last) {
                            e.preventDefault();
                            first.focus();
                        }
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => {
                    clearTimeout(timer);
                    document.removeEventListener('keydown', handleKeyDown);
                    // Return focus to trigger element
                    if (triggerRef && triggerRef.current) {
                        triggerRef.current.focus();
                    }
                };
            }, [isOpen, onClose, triggerRef]);

            if (!isOpen) return null;
            return (
                <div
                    className="fixed inset-0 z-50 flex items-center justify-center p-4"
                    onClick={onClose}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="how-to-play-title"
                >
                    <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" aria-hidden="true" />
                    <div
                        ref={modalRef}
                        className="relative bg-gray-900 border border-purple-500/50 rounded-2xl p-6 max-w-sm w-full shadow-2xl shadow-purple-500/20"
                        style={{ animation: 'fadeIn 0.3s ease-out' }}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <button
                            ref={closeButtonRef}
                            onClick={onClose}
                            className="absolute top-3 right-3 text-purple-300 hover:text-white transition-colors text-2xl leading-none min-w-[44px] min-h-[44px] flex items-center justify-center rounded-lg"
                            aria-label="Close instructions"
                        >
                            &times;
                        </button>
                        <h2 id="how-to-play-title" className="text-2xl font-black bg-gradient-to-r from-pink-400 via-purple-400 to-cyan-400 bg-clip-text text-transparent mb-4">
                            How to Play
                        </h2>
                        <ul className="text-purple-100/90 text-sm space-y-3 list-none">
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span><strong className="text-cyan-300">Click a peg</strong> to select it, then click an <strong className="text-cyan-300">empty hole</strong> two spaces away to jump.</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>The peg you <strong className="text-pink-300">jump over</strong> is removed from the board.</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Goal: remove as many pegs as possible. Ideally, leave <strong className="text-yellow-300">just 1 peg</strong>!</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Jump over adjacent pegs into empty holes along <strong className="text-cyan-300">valid paths</strong>.</span>
                            </li>
                        </ul>
                        <button
                            ref={gotItButtonRef}
                            onClick={onClose}
                            className="mt-5 w-full py-3 rounded-lg font-bold text-white bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 transition-all min-h-[44px]"
                        >
                            Got it!
                        </button>
                    </div>
                </div>
            );
        };

        // Feature 5: Flying peg animation component
        const FlyingPeg = ({ from, to, getCellPosition }) => {
            const [style, setStyle] = useState({});
            const pegRef = useRef(null);

            useEffect(() => {
                const fromPos = getCellPosition(from.row, from.col);
                const toPos = getCellPosition(to.row, to.col);

                // Start at the origin position
                setStyle({
                    left: fromPos.x - 18,
                    top: fromPos.y - 18,
                    width: 36,
                    height: 36
                });

                // Trigger the transition to the destination after a frame
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setStyle({
                            left: toPos.x - 18,
                            top: toPos.y - 18,
                            width: 36,
                            height: 36
                        });
                    });
                });
            }, [from, to, getCellPosition]);

            return (
                <div
                    ref={pegRef}
                    className="peg-flying rounded-full bg-gradient-to-br from-cyan-400 to-blue-600 shadow-lg shadow-cyan-400/70 border-2 border-yellow-400"
                    style={style}
                    aria-hidden="true"
                />
            );
        };

        // Feature 9: Difficulty computation per level
        const getLevelDifficulty = (level) => {
            // Count total pegs
            let pegCount = 0;
            level.layout.forEach(row => row.forEach(cell => { if (cell === 1) pegCount++; }));
            const dirCount = level.directions.length;
            // Heuristic: more pegs + fewer directions = harder
            const complexity = pegCount - dirCount * 1.5;
            if (complexity >= 20) return { label: 'Hard', color: 'text-red-400', dotColor: 'bg-red-400', bgColor: 'bg-red-400/10' };
            if (complexity >= 10) return { label: 'Medium', color: 'text-yellow-400', dotColor: 'bg-yellow-400', bgColor: 'bg-yellow-400/10' };
            return { label: 'Easy', color: 'text-green-400', dotColor: 'bg-green-400', bgColor: 'bg-green-400/10' };
        };

        // Feature 4: Ghost Trail SVG overlay component
        const GhostTrail = ({ from, to, jumped, getCellPosition }) => {
            const [positions, setPositions] = useState(null);

            useEffect(() => {
                const fromPos = getCellPosition(from.row, from.col);
                const toPos = getCellPosition(to.row, to.col);
                const jumpedPos = getCellPosition(jumped.row, jumped.col);
                if (fromPos.x === 0 && fromPos.y === 0) return;
                setPositions({ from: fromPos, to: toPos, jumped: jumpedPos });
            }, [from, to, jumped, getCellPosition]);

            if (!positions) return null;

            const { from: fp, to: tp, jumped: jp } = positions;
            // Compute a gentle arc: control point offset perpendicular to line
            const midX = (fp.x + tp.x) / 2;
            const midY = (fp.y + tp.y) / 2;
            const dx = tp.x - fp.x;
            const dy = tp.y - fp.y;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const arcHeight = len * 0.25;
            const cpX = midX - (dy / len) * arcHeight;
            const cpY = midY + (dx / len) * arcHeight;

            return (
                <svg className="absolute inset-0 pointer-events-none" style={{ width: '100%', height: '100%', zIndex: 50 }} aria-hidden="true">
                    <defs>
                        <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                            <polygon points="0 0, 8 3, 0 6" fill="rgba(74, 222, 128, 0.7)" />
                        </marker>
                    </defs>
                    {/* Dashed arc from source to target */}
                    <path
                        d={`M ${fp.x} ${fp.y} Q ${cpX} ${cpY} ${tp.x} ${tp.y}`}
                        fill="none"
                        stroke="rgba(74, 222, 128, 0.5)"
                        strokeWidth="2.5"
                        strokeDasharray="6 4"
                        markerEnd="url(#arrowhead)"
                    />
                    {/* X mark on jumped peg */}
                    <line x1={jp.x - 6} y1={jp.y - 6} x2={jp.x + 6} y2={jp.y + 6} stroke="rgba(239, 68, 68, 0.7)" strokeWidth="2.5" strokeLinecap="round" />
                    <line x1={jp.x + 6} y1={jp.y - 6} x2={jp.x - 6} y2={jp.y + 6} stroke="rgba(239, 68, 68, 0.7)" strokeWidth="2.5" strokeLinecap="round" />
                    {/* Ghost peg at destination */}
                    <circle cx={tp.x} cy={tp.y} r="14" fill="rgba(34, 211, 238, 0.2)" stroke="rgba(34, 211, 238, 0.4)" strokeWidth="1.5" strokeDasharray="4 3" />
                </svg>
            );
        };

        // --- MAIN PEG JUMPER GAME COMPONENT ---
        const PegJumperGame = () => {
            const [currentLevelIndex, setCurrentLevelIndex] = useState(0);
            const [board, setBoard] = useState([]);
            const [selectedPeg, setSelectedPeg] = useState(null);
            const [gameState, setGameState] = useState(GameState.PLAYING);
            const [pegsRemaining, setPegsRemaining] = useState(0);
            const [initialPegCount, setInitialPegCount] = useState(0);
            const [showWin, setShowWin] = useState(false);
            const [showHowToPlay, setShowHowToPlay] = useState(false);

            // Scoring and Timer State
            const [score, setScore] = useState(0);
            const [highScores, setHighScores] = useState({});
            const [time, setTime] = useState(0);
            const [isTimerRunning, setIsTimerRunning] = useState(false);
            const lastMoveTimestamp = useRef(0);
            const timerRef = useRef(null);
            const timeRef = useRef(0);
            const winTimeoutRef = useRef(null);
            const howToPlayTriggerRef = useRef(null);

            // Feature 2: Multi-step undo history stack
            const [historyStack, setHistoryStack] = useState([]);

            // Feature 3: Move counter
            const [moveCount, setMoveCount] = useState(0);

            // Feature 4: Solved levels persistence
            const [solvedLevels, setSolvedLevels] = useState({});

            // Feature 5: Animation state
            const [animatingMove, setAnimatingMove] = useState(null); // {from, to, jumped}
            const boardRef = useRef(null);

            // Feature 3 (Hint System): hints remaining and active hint highlight
            const HINTS_PER_GAME = 3;
            const [hintsRemaining, setHintsRemaining] = useState(HINTS_PER_GAME);
            const [hintHighlight, setHintHighlight] = useState(null); // { source: {row,col}, target: {row,col} }
            const hintTimeoutRef = useRef(null);

            // Feature 4 (Ghost Trail Preview): hovered valid target
            const [hoveredTarget, setHoveredTarget] = useState(null); // {row, col}

            // Feature 6 (Best Move Count per Level): fewest moves to 1-peg solve
            const [bestMoves, setBestMoves] = useState({});

            // Feature 8 (Pause/Resume): paused state
            const [isPaused, setIsPaused] = useState(false);

            // Load high scores and solved levels from localStorage on mount
            useEffect(() => {
                const saved = safeGetItem('pegJumperHighScores');
                if (saved) {
                    try {
                        setHighScores(JSON.parse(saved));
                    } catch (e) {
                        console.warn('Could not parse high scores:', e);
                    }
                }
                const savedSolved = safeGetItem('pegJumperSolvedLevels');
                if (savedSolved) {
                    try {
                        setSolvedLevels(JSON.parse(savedSolved));
                    } catch (e) {
                        console.warn('Could not parse solved levels:', e);
                    }
                }
                // Feature 6: Load best move counts
                const savedBestMoves = safeGetItem('pegJumperBestMoves');
                if (savedBestMoves) {
                    try {
                        setBestMoves(JSON.parse(savedBestMoves));
                    } catch (e) {
                        console.warn('Could not parse best moves:', e);
                    }
                }
            }, []);

            // Feature 1: Compute valid move targets for selected peg
            const getValidTargets = useCallback((currentBoard, selected, levelIndex) => {
                const targets = new Set();
                if (!selected || !currentBoard.length) return targets;
                const levelDirections = LEVELS[levelIndex].directions;
                const { row, col } = selected;
                for (const [dr, dc] of levelDirections) {
                    const endR = row + dr, endC = col + dc;
                    const midR = row + dr / 2, midC = col + dc / 2;
                    if (currentBoard[endR] && currentBoard[endR][endC] === false &&
                        currentBoard[midR] && currentBoard[midR][midC] === true) {
                        targets.add(`${endR},${endC}`);
                    }
                }
                return targets;
            }, []);

            const validTargets = selectedPeg ? getValidTargets(board, selectedPeg, currentLevelIndex) : new Set();

            // Timer effect
            useEffect(() => {
                if (isTimerRunning) {
                    timerRef.current = setInterval(() => {
                        setTime(prevTime => {
                            const newTime = prevTime + 1;
                            timeRef.current = newTime;
                            return newTime;
                        });
                    }, 1000);
                } else {
                    clearInterval(timerRef.current);
                }
                return () => clearInterval(timerRef.current);
            }, [isTimerRunning]);

            // Cleanup win celebration timeout on unmount or level change
            useEffect(() => {
                return () => {
                    if (winTimeoutRef.current) {
                        clearTimeout(winTimeoutRef.current);
                        winTimeoutRef.current = null;
                    }
                };
            }, []);

            const initializeBoard = useCallback((levelIndex) => {
                // Clear any pending win timeout from previous game
                if (winTimeoutRef.current) {
                    clearTimeout(winTimeoutRef.current);
                    winTimeoutRef.current = null;
                }

                const level = LEVELS[levelIndex];
                let pegCount = 0;
                const newBoard = level.layout.map(row =>
                    row.map(cell => {
                        if (cell === 1) {
                            pegCount++;
                            return true; // true represents a peg
                        }
                        return null; // null for invalid spots
                    })
                );

                const { row, col } = level.initialEmpty;
                if (newBoard[row] && newBoard[row][col] === true) {
                    newBoard[row][col] = false;
                    pegCount--;
                }

                setBoard(newBoard);
                setInitialPegCount(pegCount);
                setPegsRemaining(pegCount);
                setGameState(GameState.PLAYING);
                setSelectedPeg(null);
                setShowWin(false);
                setCurrentLevelIndex(levelIndex);

                // Reset score and timer
                setScore(0);
                setTime(0);
                timeRef.current = 0;
                setIsTimerRunning(false);
                lastMoveTimestamp.current = 0;

                // Reset history, moves, animation
                setHistoryStack([]);
                setMoveCount(0);
                setAnimatingMove(null);

                // Reset hints and pause
                setHintsRemaining(HINTS_PER_GAME);
                setHintHighlight(null);
                setIsPaused(false);
                if (hintTimeoutRef.current) {
                    clearTimeout(hintTimeoutRef.current);
                    hintTimeoutRef.current = null;
                }

            }, []);

            useEffect(() => {
                initializeBoard(0);
            }, [initializeBoard]);

            // --- Game Logic ---

            const checkForNoMoves = useCallback((currentBoard, levelIndex) => {
                const levelDirections = LEVELS[levelIndex].directions;
                for (let r = 0; r < currentBoard.length; r++) {
                    for (let c = 0; c < currentBoard[r].length; c++) {
                        if (currentBoard[r][c] === true) { // It's a peg
                             for (const [dr, dc] of levelDirections) {
                                const endR = r + dr, endC = c + dc;
                                const midR = r + dr / 2, midC = c + dc / 2;
                                if (currentBoard[endR] && currentBoard[endR][endC] === false && currentBoard[midR] && currentBoard[midR][midC] === true) {
                                    return false; // Found a possible move
                                }
                            }
                        }
                    }
                }
                return true; // No moves found
            }, []);

            // Feature 5: Apply board changes after animation completes
            const applyMove = useCallback((newBoard, start, end, jumpedRow, jumpedCol, isRapidMove) => {
                const newPegsRemaining = pegsRemaining - 1;
                setPegsRemaining(newPegsRemaining);
                setBoard(newBoard);
                setSelectedPeg(null);
                setMoveCount(mc => mc + 1);
                setAnimatingMove(null);

                // Check for win/loss condition
                if (newPegsRemaining === 1) {
                    setGameState(GameState.WON);
                    setIsTimerRunning(false);
                    setShowWin(true);
                    winTimeoutRef.current = setTimeout(() => {
                        setShowWin(false);
                        winTimeoutRef.current = null;
                    }, 4000);
                    const rapidBonus = isRapidMove ? RAPID_MOVE_BONUS : 0;
                    const currentScore = score + rapidBonus;
                    const finalScore = Math.max(0, currentScore + (initialPegCount * 100) - (timeRef.current * 10));
                    setScore(finalScore);
                    if (finalScore > (highScores[currentLevelIndex] || 0)) {
                        const newHighScores = {...highScores, [currentLevelIndex]: finalScore};
                        setHighScores(newHighScores);
                        safeSetItem('pegJumperHighScores', JSON.stringify(newHighScores));
                    }
                    // Feature 4: Mark level as solved
                    const newSolved = {...solvedLevels, [currentLevelIndex]: true};
                    setSolvedLevels(newSolved);
                    safeSetItem('pegJumperSolvedLevels', JSON.stringify(newSolved));
                    // Feature 6: Track best move count for this level (moveCount is pre-increment, so final = moveCount + 1)
                    const finalMoveCount = moveCount + 1;
                    const currentBest = bestMoves[currentLevelIndex];
                    if (!currentBest || finalMoveCount < currentBest) {
                        const newBestMoves = {...bestMoves, [currentLevelIndex]: finalMoveCount};
                        setBestMoves(newBestMoves);
                        safeSetItem('pegJumperBestMoves', JSON.stringify(newBestMoves));
                    }
                } else {
                    if (isRapidMove) {
                        setScore(s => s + RAPID_MOVE_BONUS);
                    }
                    if (checkForNoMoves(newBoard, currentLevelIndex)) {
                        setGameState(GameState.LOST);
                        setIsTimerRunning(false);
                        // Feature 7: Show "nice try" animation for 2-3 pegs remaining
                        if (newPegsRemaining >= 2 && newPegsRemaining <= 3) {
                            setShowWin(true);
                            winTimeoutRef.current = setTimeout(() => {
                                setShowWin(false);
                                winTimeoutRef.current = null;
                            }, 3000);
                        }
                    }
                }
            }, [pegsRemaining, score, highScores, currentLevelIndex, initialPegCount, checkForNoMoves, solvedLevels, bestMoves, moveCount]);

            const handleCellClick = useCallback((row, col) => {
                if (gameState !== GameState.PLAYING || animatingMove || isPaused) return;

                const cell = board[row][col];

                if (cell === true) { // A peg was clicked
                    setSelectedPeg(prev => (prev && prev.row === row && prev.col === col) ? null : { row, col });
                    setHoveredTarget(null); // Clear ghost trail on peg selection change
                } else if (cell === false) { // An empty hole was clicked
                    if (selectedPeg) {
                        const start = selectedPeg;
                        const end = { row, col };

                        const dr = end.row - start.row;
                        const dc = end.col - start.col;

                        const jumpedRow = start.row + dr / 2;
                        const jumpedCol = start.col + dc / 2;

                        const levelDirections = LEVELS[currentLevelIndex].directions;
                        const isValidJump = levelDirections.some(([jdr, jdc]) => dr === jdr && dc === jdc);

                        if (isValidJump && board[jumpedRow] && board[jumpedRow][jumpedCol] === true) {
                            if (!isTimerRunning) setIsTimerRunning(true);
                            // Clear any active hint highlight
                            setHintHighlight(null);
                            if (hintTimeoutRef.current) { clearTimeout(hintTimeoutRef.current); hintTimeoutRef.current = null; }

                            // Feature 2: Push current state to history before the move
                            setHistoryStack(prev => [...prev, {
                                board: board.map(r => [...r]),
                                pegsRemaining,
                                score,
                                moveCount,
                                time: timeRef.current
                            }]);

                            const now = Date.now();
                            const isRapidMove = lastMoveTimestamp.current > 0 && (now - lastMoveTimestamp.current) < RAPID_MOVE_THRESHOLD_MS;
                            lastMoveTimestamp.current = now;

                            const newBoard = board.map(r => [...r]);
                            newBoard[start.row][start.col] = false;
                            newBoard[end.row][end.col] = true;
                            newBoard[jumpedRow][jumpedCol] = false;

                            // Feature 5: Start animation
                            setAnimatingMove({ from: start, to: end, jumped: { row: jumpedRow, col: jumpedCol } });
                            setSelectedPeg(null);

                            // After animation duration, apply the actual board change
                            setTimeout(() => {
                                applyMove(newBoard, start, end, jumpedRow, jumpedCol, isRapidMove);
                            }, 370);
                        }
                    }
                }
            }, [board, selectedPeg, gameState, pegsRemaining, isTimerRunning, score, highScores, currentLevelIndex, initialPegCount, checkForNoMoves, animatingMove, moveCount, applyMove, isPaused]);

            // Feature 2: Undo handler
            const handleUndo = useCallback(() => {
                if (historyStack.length === 0 || animatingMove) return;
                const prevState = historyStack[historyStack.length - 1];
                setHistoryStack(prev => prev.slice(0, -1));
                setBoard(prevState.board);
                setPegsRemaining(prevState.pegsRemaining);
                setScore(prevState.score);
                setMoveCount(prevState.moveCount);
                setTime(prevState.time);
                timeRef.current = prevState.time;
                setSelectedPeg(null);
                setGameState(GameState.PLAYING);
                if (historyStack.length === 1) {
                    // Undoing the very first move, stop timer
                    setIsTimerRunning(false);
                    lastMoveTimestamp.current = 0;
                }
            }, [historyStack, animatingMove]);

            // Feature 8: Pause/Resume handler
            const handlePause = useCallback(() => {
                if (gameState !== GameState.PLAYING) return;
                setIsPaused(true);
                setIsTimerRunning(false);
            }, [gameState]);

            const handleResume = useCallback(() => {
                setIsPaused(false);
                if (historyStack.length > 0) {
                    setIsTimerRunning(true);
                }
            }, [historyStack]);

            // Feature 3: Hint handler - find a valid move and highlight it
            const handleHint = useCallback(() => {
                if (hintsRemaining <= 0 || gameState !== GameState.PLAYING || animatingMove || isPaused) return;
                // Clear any existing hint
                if (hintTimeoutRef.current) {
                    clearTimeout(hintTimeoutRef.current);
                }
                // Find a valid move
                const levelDirections = LEVELS[currentLevelIndex].directions;
                for (let r = 0; r < board.length; r++) {
                    for (let c = 0; c < board[r].length; c++) {
                        if (board[r][c] === true) {
                            for (const [dr, dc] of levelDirections) {
                                const endR = r + dr, endC = c + dc;
                                const midR = r + dr / 2, midC = c + dc / 2;
                                if (board[endR] && board[endR][endC] === false && board[midR] && board[midR][midC] === true) {
                                    setHintsRemaining(h => h - 1);
                                    setHintHighlight({ source: { row: r, col: c }, target: { row: endR, col: endC } });
                                    hintTimeoutRef.current = setTimeout(() => {
                                        setHintHighlight(null);
                                        hintTimeoutRef.current = null;
                                    }, 1800);
                                    return;
                                }
                            }
                        }
                    }
                }
            }, [hintsRemaining, gameState, animatingMove, board, currentLevelIndex, isPaused]);

            // Keyboard handler for peg/hole interaction
            const handleCellKeyDown = useCallback((e, row, col) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleCellClick(row, col);
                }
            }, [handleCellClick]);

            const getGameStatusMessage = () => {
                switch (gameState) {
                    case GameState.PLAYING: return `Pegs: ${pegsRemaining}`;
                    case GameState.WON: return 'You Win!';
                    case GameState.LOST: return 'No more moves!';
                    default: return '';
                }
            };

            const getGameStatusAria = () => {
                switch (gameState) {
                    case GameState.PLAYING: return `Playing. ${pegsRemaining} of ${initialPegCount} pegs remaining. ${moveCount} moves made.`;
                    case GameState.WON: return `Congratulations! You won with a score of ${score} in ${moveCount} moves!`;
                    case GameState.LOST: return `Game over. No more moves available. ${pegsRemaining} pegs remaining after ${moveCount} moves.`;
                    default: return '';
                }
            };

            // Feature 5: Helper to get cell position for animation
            const getCellPosition = useCallback((row, col) => {
                if (!boardRef.current) return { x: 0, y: 0 };
                const boardEl = boardRef.current;
                const rows = boardEl.querySelectorAll('[role="row"]');
                if (!rows[row]) return { x: 0, y: 0 };
                const cells = rows[row].querySelectorAll('[role="gridcell"]');
                if (!cells[col]) return { x: 0, y: 0 };
                const cellRect = cells[col].getBoundingClientRect();
                const boardRect = boardEl.getBoundingClientRect();
                return {
                    x: cellRect.left - boardRect.left + cellRect.width / 2,
                    y: cellRect.top - boardRect.top + cellRect.height / 2
                };
            }, []);

            return (
                <div className="min-h-screen w-full bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-white relative overflow-hidden flex flex-col items-center justify-center p-4">
                    <div className="absolute inset-0" aria-hidden="true">
                        <div className="absolute top-20 left-20 w-32 h-32 bg-purple-500 rounded-full blur-3xl opacity-20 animate-pulse"></div>
                        <div className="absolute top-40 right-32 w-24 h-24 bg-cyan-500 rounded-full blur-2xl opacity-30 animate-pulse"></div>
                    </div>

                    <main className="relative z-10 flex flex-col items-center w-full max-w-2xl" role="main">
                        <div className="flex items-center justify-center gap-3 mb-2">
                            <h1 className="text-4xl sm:text-5xl font-black text-center bg-gradient-to-r from-pink-400 via-purple-400 to-cyan-400 bg-clip-text text-transparent">
                                Peg Jumper
                            </h1>
                            <button
                                ref={howToPlayTriggerRef}
                                onClick={() => setShowHowToPlay(true)}
                                className="min-w-[44px] min-h-[44px] rounded-full border border-purple-500/50 bg-purple-500/10 text-purple-300 hover:bg-purple-500/30 hover:text-white transition-all flex items-center justify-center text-lg flex-shrink-0"
                                aria-label="How to Play"
                                title="How to Play"
                            >
                                &#10067;
                            </button>
                        </div>
                        <HowToPlayModal isOpen={showHowToPlay} onClose={() => setShowHowToPlay(false)} triggerRef={howToPlayTriggerRef} />

                        <nav aria-label="Level selection" className="flex flex-wrap justify-center gap-2 mb-4">
                            {LEVELS.map((level, index) => {
                                const difficulty = getLevelDifficulty(level);
                                return (
                                    <button
                                        key={level.name}
                                        onClick={() => initializeBoard(index)}
                                        aria-pressed={currentLevelIndex === index}
                                        aria-label={`${level.name} - ${difficulty.label} difficulty`}
                                        className={`px-4 py-2 text-sm font-bold rounded-lg transition-all transform hover:scale-105 min-h-[44px] relative ${currentLevelIndex === index ? 'bg-cyan-500 text-white shadow-lg shadow-cyan-500/50' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} ${solvedLevels[index] ? 'solved-level-btn' : ''}`}
                                    >
                                        {solvedLevels[index] && <span className="absolute -top-1.5 -right-1.5 text-yellow-400 text-sm" aria-label="Solved">&#9733;</span>}
                                        <span className="flex items-center gap-1.5">
                                            {level.name}
                                            <span className={`inline-block w-2 h-2 rounded-full ${difficulty.dotColor} flex-shrink-0`} title={difficulty.label} aria-hidden="true" />
                                            <span className={`text-xs font-semibold ${difficulty.color}`}>{difficulty.label}</span>
                                        </span>
                                    </button>
                                );
                            })}
                        </nav>

                        <div className="w-full bg-black/20 p-3 rounded-lg mb-4" aria-label="Game statistics">
                            <div className="flex justify-between items-center text-lg">
                                <div className="text-left">
                                    <div>Score: <span className="font-bold text-cyan-400" aria-label={`Score: ${score}`}>{score}</span></div>
                                    <div>High Score: <span className="font-bold text-yellow-400" aria-label={`High score: ${highScores[currentLevelIndex] || 0}`}>{highScores[currentLevelIndex] || 0}</span></div>
                                </div>
                                <div
                                    className="text-center text-2xl font-semibold text-white"
                                    role="status"
                                    aria-live="polite"
                                    aria-label={getGameStatusAria()}
                                >
                                    {getGameStatusMessage()}
                                </div>
                                <div className="text-right">Time: <span className="font-bold text-pink-400" aria-label={`Time: ${Math.floor(time / 60)} minutes ${time % 60} seconds`}>{new Date(time * 1000).toISOString().substring(14, 19)}</span></div>
                            </div>
                            <div className="flex justify-between items-center mt-2 pt-2 border-t border-white/10 text-sm text-purple-200">
                                <div>Moves: <span className="font-bold text-white">{moveCount}</span></div>
                                <div>Pegs: <span className="font-bold text-white">{pegsRemaining}</span> / <span className="text-purple-300">{initialPegCount}</span></div>
                                <div className="text-purple-400">
                                    {bestMoves[currentLevelIndex]
                                        ? <>Best: <span className="font-bold text-green-400">{bestMoves[currentLevelIndex]} moves</span></>
                                        : <>Best possible: <span className="font-bold text-green-400">1 peg</span></>
                                    }
                                </div>
                            </div>
                        </div>

                        <div
                            ref={boardRef}
                            className="bg-black/40 backdrop-blur-sm rounded-2xl p-4 border border-cyan-400/30 shadow-2xl min-h-[320px] flex flex-col justify-center items-center relative"
                            role="grid"
                            aria-label={`${LEVELS[currentLevelIndex].name} game board`}
                        >
                            {board.map((row, rowIndex) => (
                                <div key={rowIndex} className="flex justify-center" role="row">
                                    {row.map((cell, colIndex) => {
                                        if (cell === null) return <div key={colIndex} className="min-w-[44px] min-h-[44px]" role="gridcell" aria-hidden="true" />;
                                        const isSelected = selectedPeg && selectedPeg.row === rowIndex && selectedPeg.col === colIndex;
                                        const isValidTarget = cell === false && validTargets.has(`${rowIndex},${colIndex}`);

                                        // Feature 5: Determine animation classes
                                        let animClass = '';
                                        if (animatingMove) {
                                            if (animatingMove.jumped.row === rowIndex && animatingMove.jumped.col === colIndex) {
                                                animClass = 'peg-shrink-fade';
                                            }
                                        }

                                        // During animation, show peg at origin (it will be hidden by the flying peg overlay)
                                        // and hide the destination (it hasn't "arrived" yet visually)
                                        const isAnimFrom = animatingMove && animatingMove.from.row === rowIndex && animatingMove.from.col === colIndex;
                                        const isAnimTo = animatingMove && animatingMove.to.row === rowIndex && animatingMove.to.col === colIndex;

                                        // Feature 3: Hint highlight classes
                                        const isHintSource = hintHighlight && hintHighlight.source.row === rowIndex && hintHighlight.source.col === colIndex;
                                        const isHintTarget = hintHighlight && hintHighlight.target.row === rowIndex && hintHighlight.target.col === colIndex;

                                        return (
                                            <div key={colIndex} role="gridcell" className={isHintSource ? 'hint-source-pulse' : isHintTarget ? 'hint-target-pulse' : ''}>
                                                {cell ? (
                                                    <Peg
                                                        isSelected={isSelected}
                                                        onClick={() => handleCellClick(rowIndex, colIndex)}
                                                        onKeyDown={(e) => handleCellKeyDown(e, rowIndex, colIndex)}
                                                        rowIndex={rowIndex}
                                                        colIndex={colIndex}
                                                        animClass={animClass}
                                                        hidden={isAnimFrom}
                                                    />
                                                ) : (
                                                    <Hole
                                                        onClick={() => handleCellClick(rowIndex, colIndex)}
                                                        onKeyDown={(e) => handleCellKeyDown(e, rowIndex, colIndex)}
                                                        rowIndex={rowIndex}
                                                        colIndex={colIndex}
                                                        isValidTarget={isValidTarget}
                                                        onMouseEnter={() => isValidTarget ? setHoveredTarget({ row: rowIndex, col: colIndex }) : null}
                                                        onMouseLeave={() => setHoveredTarget(null)}
                                                    />
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            ))}
                            {animatingMove && <FlyingPeg from={animatingMove.from} to={animatingMove.to} getCellPosition={getCellPosition} />}
                            {/* Feature 8: Pause overlay */}
                            {isPaused && (
                                <div className="absolute inset-0 z-40 bg-gray-900/95 backdrop-blur-md rounded-2xl flex flex-col items-center justify-center gap-4">
                                    <div className="text-5xl" aria-hidden="true">&#9208;</div>
                                    <div className="text-2xl font-black text-white">PAUSED</div>
                                    <div className="text-purple-300 text-sm">Game board hidden</div>
                                    <button
                                        onClick={handleResume}
                                        className="mt-2 px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-400 hover:to-emerald-400 rounded-lg font-bold text-lg text-white transition-all transform hover:scale-105 min-h-[44px]"
                                    >
                                        &#9654; Resume
                                    </button>
                                </div>
                            )}
                            {/* Feature 4: Ghost Trail Preview */}
                            {selectedPeg && hoveredTarget && validTargets.has(`${hoveredTarget.row},${hoveredTarget.col}`) && (() => {
                                const dr = hoveredTarget.row - selectedPeg.row;
                                const dc = hoveredTarget.col - selectedPeg.col;
                                const jumpedRow = selectedPeg.row + dr / 2;
                                const jumpedCol = selectedPeg.col + dc / 2;
                                return <GhostTrail from={selectedPeg} to={hoveredTarget} jumped={{ row: jumpedRow, col: jumpedCol }} getCellPosition={getCellPosition} />;
                            })()}
                        </div>

                        <div className="mt-6 flex flex-wrap gap-3 justify-center">
                            {/* Feature 8: Pause/Resume button */}
                            <button
                                onClick={isPaused ? handleResume : handlePause}
                                disabled={gameState !== GameState.PLAYING && !isPaused}
                                className={`px-5 py-3 rounded-lg font-bold text-lg transition-all transform hover:scale-105 min-h-[44px] ${gameState !== GameState.PLAYING && !isPaused ? 'bg-gray-700 text-gray-500 cursor-not-allowed' : isPaused ? 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-400 hover:to-emerald-400 text-white' : 'bg-gradient-to-r from-slate-500 to-gray-600 hover:from-slate-400 hover:to-gray-500 text-white'}`}
                                aria-label={isPaused ? 'Resume game' : 'Pause game'}
                            >
                                {isPaused ? <><span aria-hidden="true">&#9654;</span> Resume</> : <><span aria-hidden="true">&#10074;&#10074;</span> Pause</>}
                            </button>
                            <button
                                onClick={handleHint}
                                disabled={hintsRemaining <= 0 || gameState !== GameState.PLAYING || !!animatingMove || isPaused}
                                className={`px-5 py-3 rounded-lg font-bold text-lg transition-all transform hover:scale-105 min-h-[44px] ${hintsRemaining <= 0 || gameState !== GameState.PLAYING || animatingMove || isPaused ? 'bg-gray-700 text-gray-500 cursor-not-allowed' : 'bg-gradient-to-r from-yellow-500 to-amber-500 hover:from-yellow-400 hover:to-amber-400 text-white'}`}
                                aria-label={`Get hint. ${hintsRemaining} hints remaining`}
                            >
                                &#128161; Hint ({hintsRemaining})
                            </button>
                            <button
                                onClick={handleUndo}
                                disabled={historyStack.length === 0 || !!animatingMove}
                                className={`px-6 py-3 rounded-lg font-bold text-lg transition-all transform hover:scale-105 min-h-[44px] ${historyStack.length === 0 || animatingMove ? 'bg-gray-700 text-gray-500 cursor-not-allowed' : 'bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-400 hover:to-orange-400 text-white'}`}
                                aria-label={`Undo last move${historyStack.length > 0 ? ` (${historyStack.length} moves to undo)` : ''}`}
                            >
                                &#8630; Undo
                            </button>
                            <button onClick={() => initializeBoard(currentLevelIndex)}
                                className="px-8 py-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-bold text-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105 min-h-[44px]"
                                aria-label={`Reset ${LEVELS[currentLevelIndex].name} level`}
                            >
                                Reset Level
                            </button>
                        </div>
                    </main>

                    <Celebration show={showWin} pegsRemaining={pegsRemaining} />
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<PegJumperGame />);
    </script>
</body>
</html>
