<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Peg Jumper - Jump pegs to leave just one in this classic board puzzle.">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Peg Jumper">
    <meta property="og:title" content="Peg Jumper">
    <meta property="og:description" content="Jump pegs to leave just one in this classic board puzzle.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Peg Jumper - Pro Edition</title>
    <!-- React and Babel for JSX transpilation -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes validTargetPulse {
            0%, 100% { box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.5), 0 0 8px rgba(74, 222, 128, 0.3); border-color: rgba(74, 222, 128, 0.7); }
            50% { box-shadow: 0 0 0 4px rgba(74, 222, 128, 0.8), 0 0 16px rgba(74, 222, 128, 0.5); border-color: rgba(74, 222, 128, 1); }
        }
        .valid-target-hole {
            animation: validTargetPulse 1s ease-in-out infinite;
            border-color: rgba(74, 222, 128, 0.7) !important;
            background: rgba(74, 222, 128, 0.15) !important;
        }
        @keyframes pegShrinkFade {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        .peg-shrink-fade {
            animation: pegShrinkFade 0.35s ease-in forwards;
        }
        .peg-flying {
            position: absolute;
            z-index: 100;
            transition: left 0.35s ease-in-out, top 0.35s ease-in-out;
            pointer-events: none;
        }
        .solved-level-btn {
            border: 2px solid #fbbf24 !important;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }
        button:focus-visible,
        [role="button"]:focus-visible,
        a:focus-visible {
            outline: 3px solid #00ffff;
            outline-offset: 2px;
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body class="bg-gray-900">
  <a href="../../"
     aria-label="Back to main menu"
     style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;min-width:44px;display:flex;align-items:center;gap:6px;"
     onmouseover="this.style.background='rgba(0,0,0,0.9)'"
     onmouseout="this.style.background='rgba(0,0,0,0.7)'"
  >&#x1F3E0; Menu</a>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- GAME CONSTANTS & DATA ---

        // Represents the shape of various peg boards.
        // 1: Valid peg position, null: Not a playable position.
        const LEVELS = [
            {
                name: "Triangle",
                layout: [
                    [null, null, null, null, 1, null, null, null, null],
                    [null, null, null, 1, null, 1, null, null, null],
                    [null, null, 1, null, 1, null, 1, null, null],
                    [null, 1, null, 1, null, 1, null, 1, null],
                    [1, null, 1, null, 1, null, 1, null, 1],
                ],
                initialEmpty: { row: 0, col: 4 },
                directions: [[0,4],[0,-4],[4,0],[-4,0],[2,2],[2,-2],[-2,2],[-2,-2]]
            },
            {
                name: "Cross",
                layout: [
                    [null, null, 1, 1, 1, null, null],
                    [null, null, 1, 1, 1, null, null],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [null, null, 1, 1, 1, null, null],
                    [null, null, 1, 1, 1, null, null],
                ],
                initialEmpty: { row: 3, col: 3 },
                directions: [[0,2],[0,-2],[2,0],[-2,0]]
            },
            {
                name: "Triple Triangle",
                layout: [
                    [null, null, 1, null, 1, null, 1, null, null],
                    [null, 1, null, 1, null, 1, null, 1, null],
                    [1, null, 1, null, 1, null, 1, null, 1],
                    [null, null, null, 1, null, 1, null, null, null],
                    [null, null, 1, null, 1, null, 1, null, null],
                ],
                initialEmpty: { row: 2, col: 4 },
                directions: [[0,4],[0,-4],[4,0],[-4,0],[2,2],[2,-2],[-2,2],[-2,-2]]
            },
            {
                name: "Rectangle",
                layout: [
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1],
                ],
                initialEmpty: { row: 1, col: 2 },
                directions: [[0,2],[0,-2],[2,0],[-2,0]]
            }
        ];

        const GameState = {
            PLAYING: 'playing',
            WON: 'won',
            LOST: 'lost'
        };

        const RAPID_MOVE_BONUS = 50;
        const RAPID_MOVE_THRESHOLD_MS = 2500;

        // --- SAFE LOCALSTORAGE HELPERS ---
        function safeGetItem(key) {
            try {
                return localStorage.getItem(key);
            } catch (e) {
                console.warn('localStorage read failed:', e);
                return null;
            }
        }

        function safeSetItem(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                console.warn('localStorage write failed:', e);
            }
        }

        // --- HELPER & UI COMPONENTS ---

        const Celebration = ({ show }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 pointer-events-none z-50 flex items-center justify-center"
                     role="status"
                     aria-live="assertive"
                     aria-label="Congratulations, you won!"
                >
                    <div className="text-8xl animate-bounce" aria-hidden="true">&#x1F3C6;</div>
                    <div className="absolute inset-0 bg-gradient-to-r from-yellow-400/20 via-pink-400/20 to-purple-400/20 animate-pulse" aria-hidden="true"></div>
                </div>
            );
        };

        const Peg = ({ onClick, onKeyDown, isSelected, rowIndex, colIndex, animClass, hidden }) => (
            <div
                className="min-w-[44px] min-h-[44px] flex items-center justify-center cursor-pointer"
                onClick={onClick}
                onKeyDown={onKeyDown}
                role="button"
                tabIndex={0}
                aria-label={`Peg at row ${rowIndex + 1}, column ${colIndex + 1}${isSelected ? ', selected' : ''}`}
                aria-pressed={isSelected}
            >
                <div
                    className={`w-8 h-8 sm:w-9 sm:h-9 rounded-full bg-gradient-to-br from-cyan-400 to-blue-600 shadow-lg shadow-cyan-400/70 transition-all duration-200 pointer-events-none ${isSelected ? 'border-4 border-yellow-400 animate-pulse ring-2 ring-yellow-400/50' : 'border-2 border-cyan-400/30'} ${animClass || ''}`}
                    style={hidden ? { opacity: 0 } : undefined}
                    aria-hidden="true"
                />
            </div>
        );

        const Hole = ({ onClick, onKeyDown, rowIndex, colIndex, isValidTarget }) => (
            <div
                className="min-w-[44px] min-h-[44px] flex items-center justify-center cursor-pointer"
                onClick={onClick}
                onKeyDown={onKeyDown}
                role="button"
                tabIndex={0}
                aria-label={`Empty hole at row ${rowIndex + 1}, column ${colIndex + 1}${isValidTarget ? ', valid move target' : ''}`}
            >
                <div className={`w-6 h-6 sm:w-7 sm:h-7 rounded-full shadow-inner border-2 transition-colors pointer-events-none ${isValidTarget ? 'valid-target-hole bg-gray-800' : 'bg-gray-800 border-purple-500/30 hover:border-purple-500'}`} aria-hidden="true" />
            </div>
        );

        const HowToPlayModal = ({ isOpen, onClose, triggerRef }) => {
            const closeButtonRef = useRef(null);
            const gotItButtonRef = useRef(null);
            const modalRef = useRef(null);

            // Focus trap and focus management
            useEffect(() => {
                if (!isOpen) return;

                // Focus the close button on open
                const timer = setTimeout(() => {
                    if (gotItButtonRef.current) gotItButtonRef.current.focus();
                }, 50);

                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        onClose();
                        return;
                    }
                    // Trap focus within modal
                    if (e.key === 'Tab' && modalRef.current) {
                        const focusable = modalRef.current.querySelectorAll(
                            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                        );
                        const first = focusable[0];
                        const last = focusable[focusable.length - 1];
                        if (e.shiftKey && document.activeElement === first) {
                            e.preventDefault();
                            last.focus();
                        } else if (!e.shiftKey && document.activeElement === last) {
                            e.preventDefault();
                            first.focus();
                        }
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => {
                    clearTimeout(timer);
                    document.removeEventListener('keydown', handleKeyDown);
                    // Return focus to trigger element
                    if (triggerRef && triggerRef.current) {
                        triggerRef.current.focus();
                    }
                };
            }, [isOpen, onClose, triggerRef]);

            if (!isOpen) return null;
            return (
                <div
                    className="fixed inset-0 z-50 flex items-center justify-center p-4"
                    onClick={onClose}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="how-to-play-title"
                >
                    <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" aria-hidden="true" />
                    <div
                        ref={modalRef}
                        className="relative bg-gray-900 border border-purple-500/50 rounded-2xl p-6 max-w-sm w-full shadow-2xl shadow-purple-500/20"
                        style={{ animation: 'fadeIn 0.3s ease-out' }}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <button
                            ref={closeButtonRef}
                            onClick={onClose}
                            className="absolute top-3 right-3 text-purple-300 hover:text-white transition-colors text-2xl leading-none min-w-[44px] min-h-[44px] flex items-center justify-center rounded-lg"
                            aria-label="Close instructions"
                        >
                            &times;
                        </button>
                        <h2 id="how-to-play-title" className="text-2xl font-black bg-gradient-to-r from-pink-400 via-purple-400 to-cyan-400 bg-clip-text text-transparent mb-4">
                            How to Play
                        </h2>
                        <ul className="text-purple-100/90 text-sm space-y-3 list-none">
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span><strong className="text-cyan-300">Click a peg</strong> to select it, then click an <strong className="text-cyan-300">empty hole</strong> two spaces away to jump.</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>The peg you <strong className="text-pink-300">jump over</strong> is removed from the board.</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Goal: remove as many pegs as possible. Ideally, leave <strong className="text-yellow-300">just 1 peg</strong>!</span>
                            </li>
                            <li className="flex gap-2">
                                <span className="text-cyan-400 mt-0.5" aria-hidden="true">&#9654;</span>
                                <span>Jump over adjacent pegs into empty holes along <strong className="text-cyan-300">valid paths</strong>.</span>
                            </li>
                        </ul>
                        <button
                            ref={gotItButtonRef}
                            onClick={onClose}
                            className="mt-5 w-full py-3 rounded-lg font-bold text-white bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 transition-all min-h-[44px]"
                        >
                            Got it!
                        </button>
                    </div>
                </div>
            );
        };

        // Feature 5: Flying peg animation component
        const FlyingPeg = ({ from, to, getCellPosition }) => {
            const [style, setStyle] = useState({});
            const pegRef = useRef(null);

            useEffect(() => {
                const fromPos = getCellPosition(from.row, from.col);
                const toPos = getCellPosition(to.row, to.col);

                // Start at the origin position
                setStyle({
                    left: fromPos.x - 18,
                    top: fromPos.y - 18,
                    width: 36,
                    height: 36
                });

                // Trigger the transition to the destination after a frame
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setStyle({
                            left: toPos.x - 18,
                            top: toPos.y - 18,
                            width: 36,
                            height: 36
                        });
                    });
                });
            }, [from, to, getCellPosition]);

            return (
                <div
                    ref={pegRef}
                    className="peg-flying rounded-full bg-gradient-to-br from-cyan-400 to-blue-600 shadow-lg shadow-cyan-400/70 border-2 border-yellow-400"
                    style={style}
                    aria-hidden="true"
                />
            );
        };

        // --- MAIN PEG JUMPER GAME COMPONENT ---
        const PegJumperGame = () => {
            const [currentLevelIndex, setCurrentLevelIndex] = useState(0);
            const [board, setBoard] = useState([]);
            const [selectedPeg, setSelectedPeg] = useState(null);
            const [gameState, setGameState] = useState(GameState.PLAYING);
            const [pegsRemaining, setPegsRemaining] = useState(0);
            const [initialPegCount, setInitialPegCount] = useState(0);
            const [showWin, setShowWin] = useState(false);
            const [showHowToPlay, setShowHowToPlay] = useState(false);

            // Scoring and Timer State
            const [score, setScore] = useState(0);
            const [highScores, setHighScores] = useState({});
            const [time, setTime] = useState(0);
            const [isTimerRunning, setIsTimerRunning] = useState(false);
            const lastMoveTimestamp = useRef(0);
            const timerRef = useRef(null);
            const timeRef = useRef(0);
            const winTimeoutRef = useRef(null);
            const howToPlayTriggerRef = useRef(null);

            // Feature 2: Multi-step undo history stack
            const [historyStack, setHistoryStack] = useState([]);

            // Feature 3: Move counter
            const [moveCount, setMoveCount] = useState(0);

            // Feature 4: Solved levels persistence
            const [solvedLevels, setSolvedLevels] = useState({});

            // Feature 5: Animation state
            const [animatingMove, setAnimatingMove] = useState(null); // {from, to, jumped}
            const boardRef = useRef(null);

            // Load high scores and solved levels from localStorage on mount
            useEffect(() => {
                const saved = safeGetItem('pegJumperHighScores');
                if (saved) {
                    try {
                        setHighScores(JSON.parse(saved));
                    } catch (e) {
                        console.warn('Could not parse high scores:', e);
                    }
                }
                const savedSolved = safeGetItem('pegJumperSolvedLevels');
                if (savedSolved) {
                    try {
                        setSolvedLevels(JSON.parse(savedSolved));
                    } catch (e) {
                        console.warn('Could not parse solved levels:', e);
                    }
                }
            }, []);

            // Feature 1: Compute valid move targets for selected peg
            const getValidTargets = useCallback((currentBoard, selected, levelIndex) => {
                const targets = new Set();
                if (!selected || !currentBoard.length) return targets;
                const levelDirections = LEVELS[levelIndex].directions;
                const { row, col } = selected;
                for (const [dr, dc] of levelDirections) {
                    const endR = row + dr, endC = col + dc;
                    const midR = row + dr / 2, midC = col + dc / 2;
                    if (currentBoard[endR] && currentBoard[endR][endC] === false &&
                        currentBoard[midR] && currentBoard[midR][midC] === true) {
                        targets.add(`${endR},${endC}`);
                    }
                }
                return targets;
            }, []);

            const validTargets = selectedPeg ? getValidTargets(board, selectedPeg, currentLevelIndex) : new Set();

            // Timer effect
            useEffect(() => {
                if (isTimerRunning) {
                    timerRef.current = setInterval(() => {
                        setTime(prevTime => {
                            const newTime = prevTime + 1;
                            timeRef.current = newTime;
                            return newTime;
                        });
                    }, 1000);
                } else {
                    clearInterval(timerRef.current);
                }
                return () => clearInterval(timerRef.current);
            }, [isTimerRunning]);

            // Cleanup win celebration timeout on unmount or level change
            useEffect(() => {
                return () => {
                    if (winTimeoutRef.current) {
                        clearTimeout(winTimeoutRef.current);
                        winTimeoutRef.current = null;
                    }
                };
            }, []);

            const initializeBoard = useCallback((levelIndex) => {
                // Clear any pending win timeout from previous game
                if (winTimeoutRef.current) {
                    clearTimeout(winTimeoutRef.current);
                    winTimeoutRef.current = null;
                }

                const level = LEVELS[levelIndex];
                let pegCount = 0;
                const newBoard = level.layout.map(row =>
                    row.map(cell => {
                        if (cell === 1) {
                            pegCount++;
                            return true; // true represents a peg
                        }
                        return null; // null for invalid spots
                    })
                );

                const { row, col } = level.initialEmpty;
                if (newBoard[row] && newBoard[row][col] === true) {
                    newBoard[row][col] = false;
                    pegCount--;
                }

                setBoard(newBoard);
                setInitialPegCount(pegCount);
                setPegsRemaining(pegCount);
                setGameState(GameState.PLAYING);
                setSelectedPeg(null);
                setShowWin(false);
                setCurrentLevelIndex(levelIndex);

                // Reset score and timer
                setScore(0);
                setTime(0);
                timeRef.current = 0;
                setIsTimerRunning(false);
                lastMoveTimestamp.current = 0;

                // Reset history, moves, animation
                setHistoryStack([]);
                setMoveCount(0);
                setAnimatingMove(null);

            }, []);

            useEffect(() => {
                initializeBoard(0);
            }, [initializeBoard]);

            // --- Game Logic ---

            const checkForNoMoves = useCallback((currentBoard, levelIndex) => {
                const levelDirections = LEVELS[levelIndex].directions;
                for (let r = 0; r < currentBoard.length; r++) {
                    for (let c = 0; c < currentBoard[r].length; c++) {
                        if (currentBoard[r][c] === true) { // It's a peg
                             for (const [dr, dc] of levelDirections) {
                                const endR = r + dr, endC = c + dc;
                                const midR = r + dr / 2, midC = c + dc / 2;
                                if (currentBoard[endR] && currentBoard[endR][endC] === false && currentBoard[midR] && currentBoard[midR][midC] === true) {
                                    return false; // Found a possible move
                                }
                            }
                        }
                    }
                }
                return true; // No moves found
            }, []);

            // Feature 5: Apply board changes after animation completes
            const applyMove = useCallback((newBoard, start, end, jumpedRow, jumpedCol, isRapidMove) => {
                const newPegsRemaining = pegsRemaining - 1;
                setPegsRemaining(newPegsRemaining);
                setBoard(newBoard);
                setSelectedPeg(null);
                setMoveCount(mc => mc + 1);
                setAnimatingMove(null);

                // Check for win/loss condition
                if (newPegsRemaining === 1) {
                    setGameState(GameState.WON);
                    setIsTimerRunning(false);
                    setShowWin(true);
                    winTimeoutRef.current = setTimeout(() => {
                        setShowWin(false);
                        winTimeoutRef.current = null;
                    }, 4000);
                    const rapidBonus = isRapidMove ? RAPID_MOVE_BONUS : 0;
                    const currentScore = score + rapidBonus;
                    const finalScore = Math.max(0, currentScore + (initialPegCount * 100) - (timeRef.current * 10));
                    setScore(finalScore);
                    if (finalScore > (highScores[currentLevelIndex] || 0)) {
                        const newHighScores = {...highScores, [currentLevelIndex]: finalScore};
                        setHighScores(newHighScores);
                        safeSetItem('pegJumperHighScores', JSON.stringify(newHighScores));
                    }
                    // Feature 4: Mark level as solved
                    const newSolved = {...solvedLevels, [currentLevelIndex]: true};
                    setSolvedLevels(newSolved);
                    safeSetItem('pegJumperSolvedLevels', JSON.stringify(newSolved));
                } else {
                    if (isRapidMove) {
                        setScore(s => s + RAPID_MOVE_BONUS);
                    }
                    if (checkForNoMoves(newBoard, currentLevelIndex)) {
                        setGameState(GameState.LOST);
                        setIsTimerRunning(false);
                    }
                }
            }, [pegsRemaining, score, highScores, currentLevelIndex, initialPegCount, checkForNoMoves, solvedLevels]);

            const handleCellClick = useCallback((row, col) => {
                if (gameState !== GameState.PLAYING || animatingMove) return;

                const cell = board[row][col];

                if (cell === true) { // A peg was clicked
                    setSelectedPeg(prev => (prev && prev.row === row && prev.col === col) ? null : { row, col });
                } else if (cell === false) { // An empty hole was clicked
                    if (selectedPeg) {
                        const start = selectedPeg;
                        const end = { row, col };

                        const dr = end.row - start.row;
                        const dc = end.col - start.col;

                        const jumpedRow = start.row + dr / 2;
                        const jumpedCol = start.col + dc / 2;

                        const levelDirections = LEVELS[currentLevelIndex].directions;
                        const isValidJump = levelDirections.some(([jdr, jdc]) => dr === jdr && dc === jdc);

                        if (isValidJump && board[jumpedRow] && board[jumpedRow][jumpedCol] === true) {
                            if (!isTimerRunning) setIsTimerRunning(true);

                            // Feature 2: Push current state to history before the move
                            setHistoryStack(prev => [...prev, {
                                board: board.map(r => [...r]),
                                pegsRemaining,
                                score,
                                moveCount,
                                time: timeRef.current
                            }]);

                            const now = Date.now();
                            const isRapidMove = lastMoveTimestamp.current > 0 && (now - lastMoveTimestamp.current) < RAPID_MOVE_THRESHOLD_MS;
                            lastMoveTimestamp.current = now;

                            const newBoard = board.map(r => [...r]);
                            newBoard[start.row][start.col] = false;
                            newBoard[end.row][end.col] = true;
                            newBoard[jumpedRow][jumpedCol] = false;

                            // Feature 5: Start animation
                            setAnimatingMove({ from: start, to: end, jumped: { row: jumpedRow, col: jumpedCol } });
                            setSelectedPeg(null);

                            // After animation duration, apply the actual board change
                            setTimeout(() => {
                                applyMove(newBoard, start, end, jumpedRow, jumpedCol, isRapidMove);
                            }, 370);
                        }
                    }
                }
            }, [board, selectedPeg, gameState, pegsRemaining, isTimerRunning, score, highScores, currentLevelIndex, initialPegCount, checkForNoMoves, animatingMove, moveCount, applyMove]);

            // Feature 2: Undo handler
            const handleUndo = useCallback(() => {
                if (historyStack.length === 0 || animatingMove) return;
                const prevState = historyStack[historyStack.length - 1];
                setHistoryStack(prev => prev.slice(0, -1));
                setBoard(prevState.board);
                setPegsRemaining(prevState.pegsRemaining);
                setScore(prevState.score);
                setMoveCount(prevState.moveCount);
                setTime(prevState.time);
                timeRef.current = prevState.time;
                setSelectedPeg(null);
                setGameState(GameState.PLAYING);
                if (historyStack.length === 1) {
                    // Undoing the very first move, stop timer
                    setIsTimerRunning(false);
                    lastMoveTimestamp.current = 0;
                }
            }, [historyStack, animatingMove]);

            // Keyboard handler for peg/hole interaction
            const handleCellKeyDown = useCallback((e, row, col) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleCellClick(row, col);
                }
            }, [handleCellClick]);

            const getGameStatusMessage = () => {
                switch (gameState) {
                    case GameState.PLAYING: return `Pegs: ${pegsRemaining}`;
                    case GameState.WON: return 'You Win!';
                    case GameState.LOST: return 'No more moves!';
                    default: return '';
                }
            };

            const getGameStatusAria = () => {
                switch (gameState) {
                    case GameState.PLAYING: return `Playing. ${pegsRemaining} of ${initialPegCount} pegs remaining. ${moveCount} moves made.`;
                    case GameState.WON: return `Congratulations! You won with a score of ${score} in ${moveCount} moves!`;
                    case GameState.LOST: return `Game over. No more moves available. ${pegsRemaining} pegs remaining after ${moveCount} moves.`;
                    default: return '';
                }
            };

            // Feature 5: Helper to get cell position for animation
            const getCellPosition = useCallback((row, col) => {
                if (!boardRef.current) return { x: 0, y: 0 };
                const boardEl = boardRef.current;
                const rows = boardEl.querySelectorAll('[role="row"]');
                if (!rows[row]) return { x: 0, y: 0 };
                const cells = rows[row].querySelectorAll('[role="gridcell"]');
                if (!cells[col]) return { x: 0, y: 0 };
                const cellRect = cells[col].getBoundingClientRect();
                const boardRect = boardEl.getBoundingClientRect();
                return {
                    x: cellRect.left - boardRect.left + cellRect.width / 2,
                    y: cellRect.top - boardRect.top + cellRect.height / 2
                };
            }, []);

            return (
                <div className="min-h-screen w-full bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-white relative overflow-hidden flex flex-col items-center justify-center p-4">
                    <div className="absolute inset-0" aria-hidden="true">
                        <div className="absolute top-20 left-20 w-32 h-32 bg-purple-500 rounded-full blur-3xl opacity-20 animate-pulse"></div>
                        <div className="absolute top-40 right-32 w-24 h-24 bg-cyan-500 rounded-full blur-2xl opacity-30 animate-pulse"></div>
                    </div>

                    <main className="relative z-10 flex flex-col items-center w-full max-w-2xl" role="main">
                        <div className="flex items-center justify-center gap-3 mb-2">
                            <h1 className="text-4xl sm:text-5xl font-black text-center bg-gradient-to-r from-pink-400 via-purple-400 to-cyan-400 bg-clip-text text-transparent">
                                Peg Jumper
                            </h1>
                            <button
                                ref={howToPlayTriggerRef}
                                onClick={() => setShowHowToPlay(true)}
                                className="min-w-[44px] min-h-[44px] rounded-full border border-purple-500/50 bg-purple-500/10 text-purple-300 hover:bg-purple-500/30 hover:text-white transition-all flex items-center justify-center text-lg flex-shrink-0"
                                aria-label="How to Play"
                                title="How to Play"
                            >
                                &#10067;
                            </button>
                        </div>
                        <HowToPlayModal isOpen={showHowToPlay} onClose={() => setShowHowToPlay(false)} triggerRef={howToPlayTriggerRef} />

                        <nav aria-label="Level selection" className="flex flex-wrap justify-center gap-2 mb-4">
                            {LEVELS.map((level, index) => (
                                <button
                                    key={level.name}
                                    onClick={() => initializeBoard(index)}
                                    aria-pressed={currentLevelIndex === index}
                                    className={`px-4 py-2 text-sm font-bold rounded-lg transition-all transform hover:scale-105 min-h-[44px] relative ${currentLevelIndex === index ? 'bg-cyan-500 text-white shadow-lg shadow-cyan-500/50' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} ${solvedLevels[index] ? 'solved-level-btn' : ''}`}
                                >
                                    {solvedLevels[index] && <span className="absolute -top-1.5 -right-1.5 text-yellow-400 text-sm" aria-label="Solved">&#9733;</span>}
                                    {level.name}
                                </button>
                            ))}
                        </nav>

                        <div className="w-full bg-black/20 p-3 rounded-lg mb-4" aria-label="Game statistics">
                            <div className="flex justify-between items-center text-lg">
                                <div className="text-left">
                                    <div>Score: <span className="font-bold text-cyan-400" aria-label={`Score: ${score}`}>{score}</span></div>
                                    <div>High Score: <span className="font-bold text-yellow-400" aria-label={`High score: ${highScores[currentLevelIndex] || 0}`}>{highScores[currentLevelIndex] || 0}</span></div>
                                </div>
                                <div
                                    className="text-center text-2xl font-semibold text-white"
                                    role="status"
                                    aria-live="polite"
                                    aria-label={getGameStatusAria()}
                                >
                                    {getGameStatusMessage()}
                                </div>
                                <div className="text-right">Time: <span className="font-bold text-pink-400" aria-label={`Time: ${Math.floor(time / 60)} minutes ${time % 60} seconds`}>{new Date(time * 1000).toISOString().substring(14, 19)}</span></div>
                            </div>
                            <div className="flex justify-between items-center mt-2 pt-2 border-t border-white/10 text-sm text-purple-200">
                                <div>Moves: <span className="font-bold text-white">{moveCount}</span></div>
                                <div>Pegs: <span className="font-bold text-white">{pegsRemaining}</span> / <span className="text-purple-300">{initialPegCount}</span></div>
                                <div className="text-purple-400">Best possible: <span className="font-bold text-green-400">1 peg</span></div>
                            </div>
                        </div>

                        <div
                            ref={boardRef}
                            className="bg-black/40 backdrop-blur-sm rounded-2xl p-4 border border-cyan-400/30 shadow-2xl min-h-[320px] flex flex-col justify-center items-center relative"
                            role="grid"
                            aria-label={`${LEVELS[currentLevelIndex].name} game board`}
                        >
                            {board.map((row, rowIndex) => (
                                <div key={rowIndex} className="flex justify-center" role="row">
                                    {row.map((cell, colIndex) => {
                                        if (cell === null) return <div key={colIndex} className="min-w-[44px] min-h-[44px]" role="gridcell" aria-hidden="true" />;
                                        const isSelected = selectedPeg && selectedPeg.row === rowIndex && selectedPeg.col === colIndex;
                                        const isValidTarget = cell === false && validTargets.has(`${rowIndex},${colIndex}`);

                                        // Feature 5: Determine animation classes
                                        let animClass = '';
                                        if (animatingMove) {
                                            if (animatingMove.jumped.row === rowIndex && animatingMove.jumped.col === colIndex) {
                                                animClass = 'peg-shrink-fade';
                                            }
                                        }

                                        // During animation, show peg at origin (it will be hidden by the flying peg overlay)
                                        // and hide the destination (it hasn't "arrived" yet visually)
                                        const isAnimFrom = animatingMove && animatingMove.from.row === rowIndex && animatingMove.from.col === colIndex;
                                        const isAnimTo = animatingMove && animatingMove.to.row === rowIndex && animatingMove.to.col === colIndex;

                                        return (
                                            <div key={colIndex} role="gridcell">
                                                {cell ? (
                                                    <Peg
                                                        isSelected={isSelected}
                                                        onClick={() => handleCellClick(rowIndex, colIndex)}
                                                        onKeyDown={(e) => handleCellKeyDown(e, rowIndex, colIndex)}
                                                        rowIndex={rowIndex}
                                                        colIndex={colIndex}
                                                        animClass={animClass}
                                                        hidden={isAnimFrom}
                                                    />
                                                ) : (
                                                    <Hole
                                                        onClick={() => handleCellClick(rowIndex, colIndex)}
                                                        onKeyDown={(e) => handleCellKeyDown(e, rowIndex, colIndex)}
                                                        rowIndex={rowIndex}
                                                        colIndex={colIndex}
                                                        isValidTarget={isValidTarget}
                                                    />
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            ))}
                            {animatingMove && <FlyingPeg from={animatingMove.from} to={animatingMove.to} getCellPosition={getCellPosition} />}
                        </div>

                        <div className="mt-6 flex gap-3">
                            <button
                                onClick={handleUndo}
                                disabled={historyStack.length === 0 || !!animatingMove}
                                className={`px-6 py-3 rounded-lg font-bold text-lg transition-all transform hover:scale-105 min-h-[44px] ${historyStack.length === 0 || animatingMove ? 'bg-gray-700 text-gray-500 cursor-not-allowed' : 'bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-400 hover:to-orange-400 text-white'}`}
                                aria-label={`Undo last move${historyStack.length > 0 ? ` (${historyStack.length} moves to undo)` : ''}`}
                            >
                                &#8630; Undo
                            </button>
                            <button onClick={() => initializeBoard(currentLevelIndex)}
                                className="px-8 py-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-bold text-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105 min-h-[44px]"
                                aria-label={`Reset ${LEVELS[currentLevelIndex].name} level`}
                            >
                                Reset Level
                            </button>
                        </div>
                    </main>

                    <Celebration show={showWin} />
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<PegJumperGame />);
    </script>
</body>
</html>
