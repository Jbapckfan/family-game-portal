<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Spelling Bee - How many words can you make with 7 letters?">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Spelling Bee">
    <title>Spelling Bee</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* ===== THEME VARIABLES ===== */
        :root {
            --bg-primary: #0a0a1a;
            --bg-grad1: rgba(120, 40, 200, 0.08);
            --bg-grad2: rgba(0, 200, 200, 0.06);
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --text-dim: #3f3f5a;
            --text-dimmer: #475569;
            --accent-purple: #8b5cf6;
            --accent-purple-dim: rgba(139, 92, 246, 0.25);
            --accent-purple-bg: rgba(139, 92, 246, 0.08);
            --accent-purple-border: rgba(139, 92, 246, 0.3);
            --accent-gold: #fbbf24;
            --accent-green: #34d399;
            --panel-bg: rgba(139, 92, 246, 0.06);
            --panel-border: rgba(139, 92, 246, 0.15);
            --modal-bg: linear-gradient(135deg, #1e1b4b, #1a1a3e);
            --modal-border: rgba(139, 92, 246, 0.35);
            --chip-bg: rgba(139, 92, 246, 0.1);
            --chip-border: rgba(139, 92, 246, 0.25);
            --tooltip-bg: rgba(15, 15, 35, 0.97);
            --bar-bg: rgba(255,255,255,0.06);
            --bar-border: rgba(255,255,255,0.05);
            --back-btn-bg: rgba(10, 10, 26, 0.85);
            --hex-outer-bg: linear-gradient(135deg, #6d28d9, #7c3aed, #8b5cf6);
            --hex-outer-color: #f3e8ff;
            --hex-outer-shadow: rgba(139, 92, 246, 0.6);
            --hex-center-bg: linear-gradient(135deg, #fbbf24, #f59e0b, #d97706);
            --hex-center-color: #1a1a2e;
            --scanline-color: rgba(0,0,0,0.02);
            --divider-color: rgba(139,92,246,0.3);
            --stat-bg: rgba(0,0,0,0.2);
            --word-filter-bg: rgba(139,92,246,0.08);
            --word-filter-active-bg: rgba(139,92,246,0.3);
            --word-filter-color: #a78bfa;
            --dist-bar-bg: rgba(139,92,246,0.12);
            --dist-bar-fill: #8b5cf6;
            --dist-bar-found: #34d399;
        }
        :root.light-theme {
            --bg-primary: #faf7f2;
            --bg-grad1: rgba(120, 40, 200, 0.03);
            --bg-grad2: rgba(0, 200, 200, 0.02);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --text-dim: #94a3b8;
            --text-dimmer: #94a3b8;
            --accent-purple: #7c3aed;
            --accent-purple-dim: rgba(124, 58, 237, 0.2);
            --accent-purple-bg: rgba(124, 58, 237, 0.06);
            --accent-purple-border: rgba(124, 58, 237, 0.25);
            --accent-gold: #d97706;
            --accent-green: #059669;
            --panel-bg: rgba(124, 58, 237, 0.04);
            --panel-border: rgba(124, 58, 237, 0.12);
            --modal-bg: linear-gradient(135deg, #f8f5ff, #f0f0ff);
            --modal-border: rgba(124, 58, 237, 0.25);
            --chip-bg: rgba(124, 58, 237, 0.08);
            --chip-border: rgba(124, 58, 237, 0.2);
            --tooltip-bg: rgba(255, 255, 255, 0.97);
            --bar-bg: rgba(0,0,0,0.06);
            --bar-border: rgba(0,0,0,0.08);
            --back-btn-bg: rgba(255, 255, 255, 0.9);
            --hex-outer-bg: linear-gradient(135deg, #a78bfa, #8b5cf6, #7c3aed);
            --hex-outer-color: #ffffff;
            --hex-outer-shadow: rgba(124, 58, 237, 0.3);
            --hex-center-bg: linear-gradient(135deg, #fbbf24, #f59e0b, #d97706);
            --hex-center-color: #1a1a2e;
            --scanline-color: rgba(0,0,0,0.005);
            --divider-color: rgba(124,58,237,0.15);
            --stat-bg: rgba(0,0,0,0.04);
            --word-filter-bg: rgba(124,58,237,0.06);
            --word-filter-active-bg: rgba(124,58,237,0.2);
            --word-filter-color: #7c3aed;
            --dist-bar-bg: rgba(124,58,237,0.08);
            --dist-bar-fill: #7c3aed;
            --dist-bar-found: #059669;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-primary);
            background-image:
                radial-gradient(ellipse at 20% 50%, var(--bg-grad1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 50%, var(--bg-grad2) 0%, transparent 50%);
            margin: 0; padding: 0; overflow-x: hidden;
            color: var(--text-primary); min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            transition: background 0.3s, color 0.3s;
        }
        .font-title { font-family: 'Fredoka One', cursive; }

        /* ===== HEXAGON BUTTONS ===== */
        .hex-btn {
            width: 74px; height: 82px;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; font-weight: 700;
            cursor: pointer; user-select: none; -webkit-user-drag: none;
            position: absolute; text-transform: uppercase;
            letter-spacing: 1px;
            transition: filter 0.15s;
        }
        .hex-btn:hover { filter: brightness(1.25); }
        .hex-btn:active { filter: brightness(0.85); }
        .hex-center {
            background: var(--hex-center-bg);
            color: var(--hex-center-color);
            text-shadow: 0 1px 2px rgba(0,0,0,0.15);
            box-shadow: inset 0 0 0 3px rgba(255,255,255,0.15);
        }
        .hex-center::after {
            content: '';
            position: absolute; inset: 0;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: radial-gradient(ellipse at 30% 30%, rgba(255,255,255,0.3), transparent 60%);
            pointer-events: none;
        }
        .hex-outer {
            background: var(--hex-outer-bg);
            color: var(--hex-outer-color);
            text-shadow: 0 0 10px var(--hex-outer-shadow);
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
        }
        .hex-outer::after {
            content: '';
            position: absolute; inset: 0;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: radial-gradient(ellipse at 30% 30%, rgba(255,255,255,0.15), transparent 60%);
            pointer-events: none;
        }

        /* Hex grid container */
        .hex-grid {
            position: relative;
            width: 240px; height: 250px;
            margin: 0 auto;
        }
        .hex-pos-c  { left: 50%; top: 50%; transform: translate(-50%, -50%); }
        .hex-pos-0  { left: 50%; top: 50%; transform: translate(-117%, -137%); }
        .hex-pos-1  { left: 50%; top: 50%; transform: translate(17%, -137%); }
        .hex-pos-2  { left: 50%; top: 50%; transform: translate(82%, -50%); }
        .hex-pos-3  { left: 50%; top: 50%; transform: translate(17%, 37%); }
        .hex-pos-4  { left: 50%; top: 50%; transform: translate(-117%, 37%); }
        .hex-pos-5  { left: 50%; top: 50%; transform: translate(-182%, -50%); }

        /* ===== ANIMATIONS ===== */
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes letterBounce {
            0% { transform: translateY(0) scale(1); }
            30% { transform: translateY(-6px) scale(1.15); }
            60% { transform: translateY(2px) scale(0.95); }
            100% { transform: translateY(0) scale(1); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            15% { transform: translateX(-10px); }
            30% { transform: translateX(10px); }
            45% { transform: translateX(-7px); }
            60% { transform: translateX(7px); }
            75% { transform: translateX(-3px); }
            90% { transform: translateX(3px); }
        }
        @keyframes slideUp {
            from { transform: translateY(12px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-12px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes wordGlow {
            0% { text-shadow: none; color: #e2e8f0; }
            30% { text-shadow: 0 0 20px #34d399; color: #34d399; }
            100% { text-shadow: none; color: #34d399; }
        }
        @keyframes pangramGlow {
            0% { text-shadow: none; }
            20% { text-shadow: 0 0 30px #fbbf24, 0 0 60px #ec4899; }
            100% { text-shadow: 0 0 10px rgba(251,191,36,0.3); }
        }
        @keyframes pangramWave {
            0% { transform: scale(1) rotate(0deg); }
            15% { transform: scale(1.15) rotate(-2deg); }
            30% { transform: scale(1.15) rotate(2deg); }
            45% { transform: scale(1.1) rotate(-1deg); }
            60% { transform: scale(1.05) rotate(1deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-25px) scale(1.3); opacity: 0.9; }
            100% { transform: translateY(-50px) scale(1); opacity: 0; }
        }
        @keyframes confettiDrop {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        @keyframes sparkle {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(90deg); opacity: 0.8; }
            100% { transform: scale(0) rotate(180deg); opacity: 0; }
        }
        @keyframes starBurst {
            0% { transform: translate(0, 0) scale(0); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(1); opacity: 0; }
        }
        @keyframes rainbowBg {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
            50% { box-shadow: 0 0 30px 10px rgba(251, 191, 36, 0.3); }
        }
        @keyframes rankUpPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.1); }
            70% { transform: scale(0.95); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        @keyframes hexShuffle {
            0% { transform: var(--from); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(0.7); opacity: 0.3; }
            100% { transform: var(--to); opacity: 1; }
        }

        .shake-anim { animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97); }
        .letter-bounce { animation: letterBounce 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .word-glow { animation: wordGlow 0.6s ease-out; }
        .pangram-wave { animation: pangramWave 0.8s cubic-bezier(0.34, 1.56, 0.64, 1); }

        /* ===== TOAST ===== */
        .toast {
            position: fixed; top: 70px; left: 50%; transform: translateX(-50%);
            padding: 12px 28px; border-radius: 14px;
            font-weight: 700; font-size: 17px; z-index: 100;
            animation: bounceIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
            white-space: nowrap;
        }
        .toast-error {
            background: rgba(30, 15, 15, 0.95);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.4);
            box-shadow: 0 8px 32px rgba(239, 68, 68, 0.2);
        }
        .toast-success {
            background: rgba(15, 30, 20, 0.95);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.4);
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.2);
        }
        .toast-pangram {
            background: linear-gradient(90deg, #78350f, #831843, #4c1d95, #164e63, #78350f);
            background-size: 300% 100%;
            animation: bounceIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), rainbowBg 3s linear infinite;
            color: white; font-size: 20px;
            border: 2px solid rgba(251, 191, 36, 0.6);
            box-shadow: 0 8px 40px rgba(245, 158, 11, 0.35);
        }
        .toast-rankup {
            background: rgba(20, 15, 30, 0.95);
            color: #fbbf24;
            border: 2px solid rgba(251, 191, 36, 0.5);
            box-shadow: 0 8px 40px rgba(251, 191, 36, 0.25);
            font-size: 20px;
            animation: rankUpPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* ===== SCORE FLOAT ===== */
        .score-float {
            position: absolute; z-index: 50;
            font-weight: 800; font-size: 24px;
            color: #fbbf24;
            animation: scoreFloat 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.8), 0 2px 4px rgba(0,0,0,0.3);
        }

        /* ===== PROGRESS BAR ===== */
        .rank-bar-wrap {
            position: relative;
            height: 10px;
            background: var(--bar-bg);
            border-radius: 999px;
            overflow: visible;
            border: 1px solid var(--bar-border);
        }
        .rank-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, #8b5cf6, #06b6d4, #34d399, #fbbf24);
            background-size: 200% 100%;
            animation: shimmer 3s linear infinite;
            transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
        }
        .rank-fill::after {
            content: '';
            position: absolute; right: 0; top: -3px; bottom: -3px; width: 4px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255,255,255,0.6), 0 0 20px rgba(251,191,36,0.4);
        }
        .rank-dot {
            width: 6px; height: 6px;
            border-radius: 50%;
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.15);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .rank-dot.active {
            width: 10px; height: 10px;
            background: #fbbf24;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.7);
        }
        .rank-dot.just-reached {
            animation: pulseGlow 1s ease-in-out 3;
        }

        /* ===== WORD CHIPS ===== */
        .word-chip {
            display: inline-block;
            padding: 4px 12px;
            margin: 3px;
            border-radius: 999px;
            font-size: 13px; font-weight: 600;
            background: var(--chip-bg);
            border: 1px solid var(--chip-border);
            animation: slideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }
        .word-chip:hover {
            background: rgba(139, 92, 246, 0.2);
            transform: translateY(-1px);
        }
        .word-chip.pangram {
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.15), rgba(236, 72, 153, 0.15));
            border-color: rgba(251, 191, 36, 0.5);
            color: #fbbf24; font-weight: 700;
        }
        .word-chip.latest {
            animation: bounceIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.5);
        }
        .word-chip.revealed {
            opacity: 0.5;
            font-style: italic;
            background: rgba(100, 116, 139, 0.1);
            border-color: rgba(100, 116, 139, 0.2);
            color: #64748b;
            cursor: default;
            animation: slideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .word-chip.revealed:hover {
            background: rgba(100, 116, 139, 0.15);
            transform: none;
        }

        /* ===== DEFINITION TOOLTIP ===== */
        .def-tooltip {
            position: fixed;
            z-index: 600;
            max-width: 300px;
            padding: 12px 16px;
            background: var(--tooltip-bg);
            border: 1px solid var(--modal-border);
            border-radius: 12px;
            font-size: 13px;
            color: #c4b5fd;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(139, 92, 246, 0.1);
            animation: bounceIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: auto;
        }
        .def-tooltip .def-word {
            font-weight: 700;
            color: var(--accent-gold);
            font-size: 15px;
            margin-bottom: 4px;
            text-transform: capitalize;
        }
        .def-tooltip .def-pos {
            font-style: italic;
            color: var(--accent-purple);
            font-size: 12px;
            margin-bottom: 2px;
        }
        .def-tooltip .def-text {
            color: var(--text-primary);
        }
        .def-tooltip .def-close {
            position: absolute;
            top: 6px; right: 10px;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 16px;
            line-height: 1;
        }
        .def-tooltip .def-close:hover {
            color: var(--text-primary);
        }

        /* ===== CURRENT WORD ===== */
        .current-word {
            font-size: 30px; font-weight: 700;
            letter-spacing: 4px; min-height: 44px;
            text-transform: uppercase;
        }
        .current-letter {
            display: inline-block;
            animation: letterBounce 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .center-highlight {
            color: var(--accent-gold);
            text-shadow: 0 0 12px rgba(251, 191, 36, 0.5);
        }

        /* ===== BUTTONS ===== */
        .game-btn {
            padding: 12px 22px; border-radius: 999px;
            font-weight: 700; font-size: 15px;
            border: 2px solid var(--accent-purple-dim);
            background: var(--accent-purple-bg);
            color: var(--accent-purple); cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .game-btn:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: #8b5cf6;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.2);
        }
        .game-btn:active { transform: scale(0.92) !important; }
        .game-btn-enter {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            border-color: #8b5cf6; color: white;
        }
        .game-btn-enter:hover {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.35);
        }

        /* ===== CONFETTI ===== */
        .confetti-piece {
            position: fixed; width: 8px; height: 12px;
            z-index: 200; pointer-events: none;
            animation: confettiDrop var(--dur) linear forwards;
            animation-delay: var(--delay);
            border-radius: 2px;
        }

        /* ===== SPARKLE BURST ===== */
        .sparkle-particle {
            position: absolute;
            width: 6px; height: 6px; border-radius: 50%;
            pointer-events: none;
            animation: starBurst 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* ===== BACK BUTTON ===== */
        .back-btn {
            position: fixed; top: 12px; left: 12px;
            padding: 6px 14px;
            background: var(--back-btn-bg);
            border: 1px solid var(--accent-purple-border);
            border-radius: 10px; color: var(--accent-purple);
            text-decoration: none; font-size: 14px; font-weight: 600;
            z-index: 200; backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .back-btn:hover {
            border-color: var(--accent-purple); color: var(--text-primary);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.2);
        }

        /* ===== SCANLINE ===== */
        .scanline {
            position: fixed; inset: 0;
            background: repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--scanline-color) 1px, rgba(0,0,0,0) 2px);
            pointer-events: none; z-index: 1000;
        }

        /* ===== MODAL ===== */
        .modal-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 500; backdrop-filter: blur(6px);
        }
        .modal-box {
            background: var(--modal-bg);
            border: 1px solid var(--modal-border);
            border-radius: 20px; padding: 28px;
            max-width: 400px; width: 90%;
            box-shadow: 0 25px 70px rgba(0,0,0,0.5), 0 0 40px rgba(139, 92, 246, 0.1);
            animation: bounceIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* ===== WORDS PANEL ===== */
        .words-panel { max-height: 0; overflow: hidden; transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .words-panel.open { max-height: 400px; overflow-y: auto; }

        /* ===== MODE TOGGLE ===== */
        .mode-toggle {
            display: inline-flex; border-radius: 999px;
            border: 1px solid var(--accent-purple-border);
            overflow: hidden; background: var(--accent-purple-bg);
        }
        .mode-btn {
            padding: 7px 18px; font-size: 13px; font-weight: 700;
            cursor: pointer; border: none; background: transparent;
            color: var(--text-muted); font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.25s;
        }
        .mode-btn.active {
            background: var(--accent-purple-dim);
            color: var(--text-primary);
        }

        /* ===== SHUFFLE ICON ===== */
        .shuffle-icon {
            display: inline-block;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .shuffle-icon.spinning { transform: rotate(360deg); }

        /* ===== RANK UP BANNER ===== */
        .rank-banner {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 16px; text-align: center; z-index: 150;
            background: linear-gradient(180deg, rgba(251, 191, 36, 0.15), transparent);
            animation: slideDown 0.5s ease-out;
            pointer-events: none;
        }
        .rank-banner-text {
            font-size: 28px; font-weight: 800;
            background: linear-gradient(90deg, #fbbf24, #f59e0b, #ec4899, #8b5cf6);
            background-size: 200% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 2s linear infinite;
        }

        /* ===== SPRINT TIMER ===== */
        .sprint-timer {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 16px;
            border-radius: 999px;
            font-size: 22px;
            font-weight: 800;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 2px;
            border: 2px solid rgba(6, 182, 212, 0.4);
            background: rgba(6, 182, 212, 0.08);
            color: #06b6d4;
        }
        .sprint-timer.warning {
            border-color: rgba(245, 158, 11, 0.5);
            background: rgba(245, 158, 11, 0.08);
            color: #f59e0b;
            animation: pulseGlow 1s ease-in-out infinite;
        }
        .sprint-timer.danger {
            border-color: rgba(239, 68, 68, 0.5);
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            animation: pulseGlow 0.5s ease-in-out infinite;
        }

        /* ===== SPRINT FINAL SCREEN ===== */
        .sprint-final-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
            z-index: 500; backdrop-filter: blur(8px);
        }
        .sprint-final-box {
            background: linear-gradient(135deg, #1e1b4b, #0f172a);
            border: 2px solid rgba(6, 182, 212, 0.4);
            border-radius: 24px; padding: 32px;
            max-width: 380px; width: 90%;
            text-align: center;
            box-shadow: 0 25px 70px rgba(0,0,0,0.6), 0 0 60px rgba(6, 182, 212, 0.1);
            animation: bounceIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .sprint-stat {
            display: flex; justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 15px;
        }
        .sprint-stat-label { color: #94a3b8; }
        .sprint-stat-value { color: #e2e8f0; font-weight: 700; }

        /* ===== HINT PANEL ===== */
        .hint-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 12px;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            padding: 4px 0;
        }
        .hint-letter {
            font-weight: 800;
            color: var(--accent-gold);
            font-size: 16px;
            text-transform: uppercase;
        }
        .hint-detail {
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* ===== ANIMATED HEX SHUFFLE ===== */
        .hex-animated {
            transition: transform 0.45s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.45s;
        }

        /* ===== WORD FILTER TABS ===== */
        .word-filter-tabs {
            display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; padding: 2px 0;
        }
        .word-filter-tab {
            padding: 2px 10px; border-radius: 999px; font-size: 12px; font-weight: 700;
            cursor: pointer; border: 1px solid var(--accent-purple-border);
            background: var(--word-filter-bg); color: var(--word-filter-color);
            font-family: 'Rajdhani', sans-serif; text-transform: uppercase;
            transition: all 0.15s; letter-spacing: 0.5px;
        }
        .word-filter-tab:hover { background: var(--word-filter-active-bg); }
        .word-filter-tab.active {
            background: var(--word-filter-active-bg); color: white;
            border-color: var(--accent-purple);
        }

        /* ===== WORD LENGTH DISTRIBUTION ===== */
        .dist-row {
            display: flex; align-items: center; gap: 8px; margin: 3px 0; font-size: 12px;
        }
        .dist-label { width: 28px; text-align: right; font-weight: 700; color: var(--text-secondary); flex-shrink: 0; }
        .dist-bar-outer {
            flex: 1; height: 14px; background: var(--dist-bar-bg); border-radius: 7px;
            overflow: hidden; position: relative;
        }
        .dist-bar-inner {
            height: 100%; border-radius: 7px; transition: width 0.5s cubic-bezier(0.34,1.56,0.64,1);
            position: absolute; left: 0; top: 0;
        }
        .dist-bar-total { background: var(--dist-bar-fill); opacity: 0.25; }
        .dist-bar-found { background: var(--dist-bar-found); z-index: 1; }
        .dist-count { width: 42px; font-size: 11px; color: var(--text-muted); flex-shrink: 0; }

        /* ===== STATS MODAL ===== */
        .stat-card {
            background: var(--stat-bg); border-radius: 12px; padding: 10px 14px;
            margin: 6px 0; display: flex; justify-content: space-between; align-items: center;
        }
        .stat-card-label { color: var(--text-secondary); font-size: 14px; }
        .stat-card-value { color: var(--accent-gold); font-weight: 800; font-size: 18px; }

        /* ===== TWO-LETTER HINT GRID ===== */
        .two-letter-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 4px; max-height: 280px; overflow-y: auto; padding: 4px 0;
        }
        .two-letter-cell {
            text-align: center; padding: 5px 4px; border-radius: 8px;
            background: var(--stat-bg); font-size: 12px;
        }
        .two-letter-pair { font-weight: 800; color: var(--accent-gold); text-transform: uppercase; }
        .two-letter-count { color: var(--text-secondary); font-size: 11px; }

        /* ===== HINT TABS ===== */
        .hint-tab-bar { display: flex; gap: 0; margin-bottom: 14px; border-radius: 10px; overflow: hidden;
            border: 1px solid var(--accent-purple-border); }
        .hint-tab { flex: 1; padding: 7px 0; text-align: center; font-size: 13px; font-weight: 700;
            cursor: pointer; background: transparent; border: none; color: var(--text-muted);
            font-family: 'Rajdhani', sans-serif; text-transform: uppercase; transition: all 0.2s; }
        .hint-tab.active { background: var(--accent-purple-dim); color: white; }

        /* ===== THEME TOGGLE ===== */
        .theme-toggle-btn {
            width: 32px; height: 32px; border-radius: 50%;
            border: 1px solid var(--accent-purple-border);
            background: var(--accent-purple-bg); color: var(--word-filter-color);
            cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .theme-toggle-btn:hover { background: var(--accent-purple-dim); }

        /* ===== MUTE TOGGLE ===== */
        .mute-toggle-btn {
            width: 32px; height: 32px; border-radius: 50%;
            border: 1px solid var(--accent-purple-border);
            background: var(--accent-purple-bg); color: var(--word-filter-color);
            cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .mute-toggle-btn:hover { background: var(--accent-purple-dim); }

        /* ===== STREAK BADGE ===== */
        .streak-badge {
            display: inline-flex; align-items: center; gap: 5px;
            padding: 4px 14px; border-radius: 999px;
            font-size: 13px; font-weight: 800;
            background: linear-gradient(135deg, rgba(251,191,36,0.12), rgba(245,158,11,0.08));
            border: 1px solid rgba(251,191,36,0.35);
            color: #fbbf24;
            animation: bounceIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-shadow: 0 0 8px rgba(251,191,36,0.3);
            letter-spacing: 0.5px;
            cursor: default;
        }
        .streak-badge .streak-fire { font-size: 15px; }
        .streak-badge .streak-num {
            font-size: 17px; font-weight: 900;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .streak-badge-best {
            font-size: 11px; color: var(--text-muted); font-weight: 600;
            margin-left: 2px;
        }

        /* ===== PRACTICE MODE ===== */
        .practice-indicator {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 5px 14px; border-radius: 999px;
            font-size: 12px; font-weight: 700;
            background: rgba(52, 211, 153, 0.08);
            border: 1px solid rgba(52, 211, 153, 0.3);
            color: #34d399;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .practice-toggle {
            display: inline-flex; border-radius: 999px;
            border: 1px solid var(--accent-purple-border);
            overflow: hidden; background: var(--accent-purple-bg);
            margin-left: 0;
        }
        .practice-toggle-btn {
            padding: 5px 14px; font-size: 11px; font-weight: 700;
            cursor: pointer; border: none; background: transparent;
            color: var(--text-muted); font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase; letter-spacing: 0.5px;
            transition: all 0.25s;
        }
        .practice-toggle-btn.active {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
        }
        .practice-toggle-btn.standard-active {
            background: var(--accent-purple-dim);
            color: var(--text-primary);
        }

        /* ===== LOADING SCREEN ===== */
        .loading-screen {
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            min-height: 60vh; gap: 20px;
        }
        .loading-spinner {
            width: 48px; height: 48px;
            border: 4px solid rgba(139, 92, 246, 0.15);
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 400px) {
            .hex-btn { width: 62px; height: 68px; font-size: 20px; }
            .hex-grid { width: 200px; height: 210px; }
            .current-word { font-size: 24px; letter-spacing: 3px; }
        }
        @media (min-width: 500px) {
            .hex-btn { width: 82px; height: 90px; font-size: 26px; }
            .hex-grid { width: 265px; height: 275px; }
        }
    </style>
</head>
<body>
    <a href="../../" class="back-btn">&#x1F3E0; Menu</a>
    <div class="scanline"></div>
    <div id="root"></div>

    <script>
    // =================== PUZZLES DATA (loaded async, with inline fallback) ===================
    const FALLBACK_PUZZLES = [{"letters":["e","g","h","o","p","u"],"center":"l","words":["elle","elope","ghoul","glee","glop","glue","glug","goggle","gull","gulp","heel","hele","hell","hellhole","hello","help","hole","holl","hoople","hull","hulu","loge","logo","loll","loop","loophole","lope","loup","luge","lull","lulu","lupe","ogle","peel","peele","peephole","pell","people","plop","plough","plug","plughole","pole","poll","polo","pool","pull","pulp","ululu"],"pangrams":["plughole"],"maxScore":124,"wordCount":49},{"letters":["b","g","i","l","n","o"],"center":"t","words":["bigot","bint","biting","blot","blotting","blotto","bolt","bolting","bonito","boot","booting","botong","bott","bottling","gilt","glint","ignition","ingot","into","lilt","lint","loot","lotion","lotto","nito","notion","obit","onto","otto","tiling","till","tilt","tilting","ting","tingling","tint","titi","toil","toiling","toit","toll","tolling","tong","tool","tooling","toon","toot","toto"],"pangrams":["blotting","bolting","bottling"],"maxScore":184,"wordCount":48},{"letters":["a","c","f","l","u","y"],"center":"t","words":["actual","actually","atta","catty","cult","cutty","fact","factual","factually","faculty","fatal","fatally","fatty","fault","faulty","flat","flatly","lata","tact","tactful","tactfully","taffy","taft","tala","talc","tall","tally","tatta","tatty","tatu","taut","tuff","tuft","tula","tutu"],"pangrams":["factually","faculty","tactfully"],"maxScore":154,"wordCount":35}];

    let PUZZLES = FALLBACK_PUZZLES;
    let puzzlesLoaded = false;
    let puzzlesLoadError = false;

    async function loadPuzzles() {
        try {
            const resp = await fetch('puzzles.json');
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            const data = await resp.json();
            if (Array.isArray(data) && data.length > 0) {
                PUZZLES = data;
                puzzlesLoaded = true;
                return true;
            }
            throw new Error('Invalid data');
        } catch (e) {
            console.warn('Failed to load puzzles.json, using fallback:', e);
            PUZZLES = FALLBACK_PUZZLES;
            puzzlesLoaded = true;
            puzzlesLoadError = true;
            return false;
        }
    }
    </script>

    <script>
    // =================== SOUND EFFECTS ENGINE ===================
    const SoundManager = {
        ctx: null,
        muted: false,
        init() {
            if (!this.ctx) {
                try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
                catch(e) { console.warn('Web Audio not available'); }
            }
            if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
        },
        play(type) {
            if (this.muted) return;
            this.init();
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            switch(type) {
                case 'letter': {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(600 + Math.random() * 200, t);
                    g.gain.setValueAtTime(0.08, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(t); o.stop(t + 0.1);
                    break;
                }
                case 'accept': {
                    [523, 659, 784].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.type = 'sine';
                        o.frequency.setValueAtTime(freq, t + i * 0.08);
                        g.gain.setValueAtTime(0.1, t + i * 0.08);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.15);
                        o.connect(g); g.connect(this.ctx.destination);
                        o.start(t + i * 0.08); o.stop(t + i * 0.08 + 0.15);
                    });
                    break;
                }
                case 'reject': {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'square';
                    o.frequency.setValueAtTime(200, t);
                    o.frequency.linearRampToValueAtTime(150, t + 0.2);
                    g.gain.setValueAtTime(0.06, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(t); o.stop(t + 0.25);
                    break;
                }
                case 'pangram': {
                    [523, 659, 784, 1047, 1319].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.type = 'sine';
                        o.frequency.setValueAtTime(freq, t + i * 0.1);
                        g.gain.setValueAtTime(0.12, t + i * 0.1);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.1 + 0.3);
                        o.connect(g); g.connect(this.ctx.destination);
                        o.start(t + i * 0.1); o.stop(t + i * 0.1 + 0.3);
                    });
                    break;
                }
                case 'rankup': {
                    [440, 554, 659, 880].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.type = 'triangle';
                        o.frequency.setValueAtTime(freq, t + i * 0.12);
                        g.gain.setValueAtTime(0.1, t + i * 0.12);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.12 + 0.35);
                        o.connect(g); g.connect(this.ctx.destination);
                        o.start(t + i * 0.12); o.stop(t + i * 0.12 + 0.35);
                    });
                    break;
                }
            }
        },
        setMuted(m) { this.muted = m; }
    };
    </script>

    <script type="text/babel">
    const { useState, useEffect, useCallback, useRef, useMemo } = React;

    // =================== CONFIG ===================
    const RANKS = [
        { name: 'Beginner',   pct: 0,    emoji: '' },
        { name: 'Good Start', pct: 0.02, emoji: '&#x2B50;' },
        { name: 'Moving Up',  pct: 0.05, emoji: '&#x1F31F;' },
        { name: 'Good',       pct: 0.08, emoji: '&#x1F44D;' },
        { name: 'Solid',      pct: 0.15, emoji: '&#x1F4AA;' },
        { name: 'Nice',       pct: 0.25, emoji: '&#x1F525;' },
        { name: 'Great',      pct: 0.40, emoji: '&#x1F389;' },
        { name: 'Amazing',    pct: 0.50, emoji: '&#x1F680;' },
        { name: 'Genius',     pct: 0.70, emoji: '&#x1F9E0;' },
        { name: 'Queen Bee',  pct: 1.00, emoji: '&#x1F41D;' },
    ];

    const RANK_EMOJIS = ['', '\u2B50', '\u{1F31F}', '\u{1F44D}', '\u{1F4AA}', '\u{1F525}', '\u{1F389}', '\u{1F680}', '\u{1F9E0}', '\u{1F41D}'];

    function getRank(score, max) {
        if (!max) return { idx: 0, ...RANKS[0] };
        const pct = score / max;
        let idx = 0;
        for (let i = 0; i < RANKS.length; i++) {
            if (pct >= RANKS[i].pct) idx = i;
        }
        return { idx, ...RANKS[idx] };
    }

    function getNextRank(score, max) {
        if (!max) return null;
        const pct = score / max;
        for (const r of RANKS) {
            if (pct < r.pct) return r;
        }
        return null;
    }

    function scoreWord(word, allLetters) {
        const all = new Set(allLetters);
        const wl = new Set(word);
        const isPangram = allLetters.length >= 7 && [...all].every(l => wl.has(l));
        let pts = word.length === 4 ? 1 : word.length;
        if (isPangram) pts += 7;
        return { pts, isPangram };
    }

    function getDailyIdx() {
        const d = Math.floor((Date.now() - new Date(2025,0,1)) / 86400000);
        return ((d % PUZZLES.length) + PUZZLES.length) % PUZZLES.length;
    }

    function loadSave(idx, mode) {
        try { return JSON.parse(localStorage.getItem(`sb-${mode}-${idx}`)) || []; }
        catch { return []; }
    }
    function writeSave(idx, mode, words) {
        try { localStorage.setItem(`sb-${mode}-${idx}`, JSON.stringify(words)); } catch {}
    }

    // =================== DEFINITION CACHE ===================
    const definitionCache = {};

    async function fetchDefinition(word) {
        if (definitionCache[word]) return definitionCache[word];
        try {
            const resp = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if (!resp.ok) throw new Error('Not found');
            const data = await resp.json();
            if (data && data[0] && data[0].meanings && data[0].meanings[0]) {
                const meaning = data[0].meanings[0];
                const result = {
                    word: data[0].word,
                    partOfSpeech: meaning.partOfSpeech || '',
                    definition: meaning.definitions[0]?.definition || 'No definition available.',
                };
                definitionCache[word] = result;
                return result;
            }
            throw new Error('No meanings');
        } catch (e) {
            const result = { word, partOfSpeech: '', definition: 'Definition not available.' };
            definitionCache[word] = result;
            return result;
        }
    }

    // =================== NUMBER WORDS HELPER ===================
    function numWord(n) {
        const words = ['zero','one','two','three','four','five','six','seven','eight','nine','ten',
                       'eleven','twelve','thirteen','fourteen','fifteen'];
        return n <= 15 ? words[n] : String(n);
    }

    // =================== PERSONAL STATS ===================
    function loadStats() {
        try { return JSON.parse(localStorage.getItem('sb-personal-stats')) || getDefaultStats(); }
        catch { return getDefaultStats(); }
    }
    function getDefaultStats() {
        return { totalWords: 0, totalPangrams: 0, puzzlesPlayed: 0, rankSum: 0, longestWord: '', sessions: [] };
    }
    function saveStats(stats) {
        try { localStorage.setItem('sb-personal-stats', JSON.stringify(stats)); } catch {}
    }

    // =================== THEME PERSISTENCE ===================
    function loadTheme() {
        try { return localStorage.getItem('sb-theme') || 'dark'; } catch { return 'dark'; }
    }
    function saveTheme(theme) {
        try { localStorage.setItem('sb-theme', theme); } catch {}
    }

    // =================== MUTE PERSISTENCE ===================
    function loadMuted() {
        try { return localStorage.getItem('sb-muted') === 'true'; } catch { return false; }
    }
    function saveMuted(m) {
        try { localStorage.setItem('sb-muted', String(m)); } catch {}
    }

    // =================== STREAK PERSISTENCE ===================
    function getDefaultStreak() {
        return { currentStreak: 0, bestStreak: 0, lastGeniusDate: null };
    }
    function loadStreak() {
        try { return JSON.parse(localStorage.getItem('sb-genius-streak')) || getDefaultStreak(); }
        catch { return getDefaultStreak(); }
    }
    function saveStreak(streak) {
        try { localStorage.setItem('sb-genius-streak', JSON.stringify(streak)); } catch {}
    }
    function getTodayDateStr() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }
    function getYesterdayDateStr() {
        const d = new Date();
        d.setDate(d.getDate() - 1);
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }
    function updateStreakForGenius(streakData) {
        const today = getTodayDateStr();
        const yesterday = getYesterdayDateStr();
        if (streakData.lastGeniusDate === today) {
            // Already recorded genius today, no change
            return streakData;
        }
        const updated = { ...streakData };
        if (streakData.lastGeniusDate === yesterday) {
            // Consecutive day! Extend streak
            updated.currentStreak = streakData.currentStreak + 1;
        } else {
            // Streak broken or first time
            updated.currentStreak = 1;
        }
        updated.lastGeniusDate = today;
        if (updated.currentStreak > updated.bestStreak) {
            updated.bestStreak = updated.currentStreak;
        }
        saveStreak(updated);
        return updated;
    }

    // =================== COMMON 3-LETTER WORDS (for Practice Mode) ===================
    const COMMON_3_LETTER_WORDS = new Set([
        'ace','act','add','age','ago','aid','aim','air','all','and','ant','any','ape','apt','arc','are','ark','arm',
        'art','ash','ask','ate','awe','axe','bad','bag','ban','bar','bat','bay','bed','bee','bet','bid','big','bin',
        'bit','bog','bow','box','boy','bud','bug','bun','bus','but','buy','cab','cam','can','cap','car','cat','cob',
        'cod','cog','cop','cot','cow','cry','cub','cud','cup','cur','cut','dab','dad','dam','day','den','dew','did',
        'dig','dim','din','dip','doe','dog','don','dot','dry','dub','dud','due','dug','dun','duo','dye','ear','eat',
        'eel','egg','ego','elf','elk','elm','emu','end','era','eve','ewe','eye','fab','fad','fan','far','fat','fax',
        'fed','fee','fen','few','fig','fin','fir','fit','fix','fly','fob','foe','fog','fop','for','fox','fry','fun',
        'fur','gab','gag','gal','gap','gas','gel','gem','get','gig','gin','gnu','gob','god','got','gum','gun','gust',
        'gut','guy','gym','had','hag','ham','has','hat','hay','hen','her','hew','hex','hid','him','hip','his','hit',
        'hob','hod','hog','hop','hot','how','hub','hue','hug','hum','hut','ice','icy','ill','imp','ink','inn','ion',
        'ire','irk','its','ivy','jab','jag','jam','jar','jaw','jay','jet','jig','job','jog','jot','joy','jug','jut',
        'keg','ken','key','kid','kin','kit','lab','lad','lag','lap','law','lay','lea','led','leg','let','lid','lie',
        'lip','lit','log','lot','low','lug','mad','man','map','mar','mat','maw','may','men','met','mid','mix','mob',
        'mod','mop','mow','mud','mug','mum','nab','nag','nap','nay','net','new','nil','nip','nit','nod','nor','not',
        'now','nub','nun','nut','oak','oar','oat','odd','ode','off','oft','ohm','oil','old','one','opt','orb','ore',
        'our','out','owe','owl','own','pad','pal','pan','pap','par','pat','paw','pay','pea','peg','pen','pep','per',
        'pet','pew','pie','pig','pin','pit','ply','pod','pop','pot','pow','pro','pry','pub','pug','pun','pup','pus',
        'put','rag','ram','ran','rap','rat','raw','ray','red','ref','rib','rid','rig','rim','rip','rob','rod','roe',
        'rot','row','rub','rug','rum','run','rut','rye','sac','sad','sag','sap','sat','saw','say','sea','set','sew',
        'she','shy','sin','sip','sir','sis','sit','six','ski','sky','sly','sob','sod','son','sop','sot','sow','soy',
        'spa','spy','sty','sub','sue','sum','sun','sup','tab','tad','tag','tan','tap','tar','tat','tax','tea','ten',
        'the','thy','tic','tie','tin','tip','toe','ton','too','top','tot','tow','toy','try','tub','tug','tun','two',
        'ugh','undo','urn','use','van','vat','vet','vex','via','vie','vim','vow','wad','wag','war','was','wax','way',
        'web','wed','wet','who','why','wig','win','wit','woe','wok','won','woo','wop','wow','yak','yam','yap','yaw',
        'yea','yes','yet','yew','yin','you','yow','zap','zed','zen','zig','zip','zoo'
    ]);

    // Build practice words for a puzzle (standard words + valid 3-letter words from puzzle letters)
    function getPracticeWords(puzzle) {
        const allLetters = new Set([...puzzle.letters, puzzle.center]);
        const practiceList = [];
        // Include all standard puzzle words (no center letter requirement in practice)
        for (const w of puzzle.words) {
            practiceList.push(w);
        }
        // Add valid 3-letter words that can be formed from the puzzle letters
        for (const w of COMMON_3_LETTER_WORDS) {
            if ([...w].every(l => allLetters.has(l))) {
                practiceList.push(w);
            }
        }
        return [...new Set(practiceList)]; // deduplicate
    }

    function scorePracticeWord(word, allLetters) {
        const all = new Set(allLetters);
        const wl = new Set(word);
        const isPangram = allLetters.length >= 7 && [...all].every(l => wl.has(l));
        let pts = word.length <= 4 ? 1 : word.length;
        if (isPangram) pts += 7;
        return { pts, isPangram };
    }

    // =================== HEX POSITION DATA ===================
    const HEX_POSITIONS = [
        { x: -117, y: -137 },  // pos 0
        { x: 17, y: -137 },    // pos 1
        { x: 82, y: -50 },     // pos 2
        { x: 17, y: 37 },      // pos 3
        { x: -117, y: 37 },    // pos 4
        { x: -182, y: -50 },   // pos 5
    ];

    // =================== CONFETTI ===================
    function Confetti({ active }) {
        if (!active) return null;
        const colors = ['#fbbf24','#ec4899','#8b5cf6','#06b6d4','#34d399','#f43f5e','#3b82f6'];
        const pieces = Array.from({ length: 40 }, (_, i) => {
            const style = {
                left: `${Math.random() * 100}%`,
                background: colors[i % colors.length],
                '--dur': `${1.5 + Math.random() * 1.5}s`,
                '--delay': `${Math.random() * 0.5}s`,
                width: `${6 + Math.random() * 6}px`,
                height: `${4 + Math.random() * 10}px`,
                opacity: 0.9,
                transform: `rotate(${Math.random()*360}deg)`,
            };
            return <div key={i} className="confetti-piece" style={style} />;
        });
        return <>{pieces}</>;
    }

    // =================== SPARKLE BURST ===================
    function SparkleBurst({ active }) {
        if (!active) return null;
        const colors = ['#fbbf24','#ec4899','#8b5cf6','#06b6d4','#34d399'];
        const particles = Array.from({ length: 16 }, (_, i) => {
            const angle = (i / 16) * Math.PI * 2;
            const dist = 30 + Math.random() * 50;
            return (
                <div key={i} className="sparkle-particle" style={{
                    left: '50%', top: '50%',
                    background: colors[i % colors.length],
                    boxShadow: `0 0 6px ${colors[i % colors.length]}`,
                    '--tx': `${Math.cos(angle) * dist}px`,
                    '--ty': `${Math.sin(angle) * dist}px`,
                    animationDelay: `${Math.random() * 0.15}s`,
                }} />
            );
        });
        return <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }}>{particles}</div>;
    }

    // =================== TOAST ===================
    function Toast({ data, onDone }) {
        useEffect(() => {
            const t = setTimeout(onDone, data.type === 'pangram' ? 2800 : data.type === 'rankup' ? 2500 : 1400);
            return () => clearTimeout(t);
        }, []);
        return <div className={`toast toast-${data.type}`} dangerouslySetInnerHTML={{ __html: data.message }} />;
    }

    // =================== RANK BANNER ===================
    function RankBanner({ rank, onDone }) {
        useEffect(() => {
            const t = setTimeout(onDone, 2500);
            return () => clearTimeout(t);
        }, []);
        return (
            <div className="rank-banner">
                <div className="rank-banner-text">
                    {RANK_EMOJIS[rank.idx]} {rank.name}! {RANK_EMOJIS[rank.idx]}
                </div>
            </div>
        );
    }

    // =================== RANK BAR ===================
    function RankBar({ score, maxScore, justReachedIdx }) {
        const pct = maxScore > 0 ? Math.min(score / maxScore, 1) : 0;
        const rank = getRank(score, maxScore);
        const next = getNextRank(score, maxScore);

        return (
            <div style={{ padding: '0 4px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 8 }}>
                    <span style={{ fontSize: 20, fontWeight: 800, color: 'var(--accent-gold)',
                                   textShadow: '0 0 12px rgba(251,191,36,0.35)' }}>
                        {RANK_EMOJIS[rank.idx]} {rank.name}
                    </span>
                    <span style={{ fontSize: 14, color: 'var(--text-secondary)' }}>
                        <span style={{ color: 'var(--accent-purple)', fontWeight: 700 }}>{score}</span>
                        {next && <span> / {Math.ceil(maxScore * next.pct)} for {next.name}</span>}
                    </span>
                </div>
                <div className="rank-bar-wrap">
                    <div className="rank-fill" style={{ width: `${Math.max(pct * 100, 1)}%` }} />
                    {RANKS.slice(1).map((r, i) => (
                        <div key={i}
                             className={`rank-dot ${pct >= r.pct ? 'active' : ''} ${justReachedIdx === i + 1 ? 'just-reached' : ''}`}
                             style={{ left: `${r.pct * 100}%` }}
                             title={`${r.name} (${Math.round(r.pct * 100)}%)`}
                        />
                    ))}
                </div>
            </div>
        );
    }

    // =================== DEFINITION TOOLTIP ===================
    function DefinitionTooltip({ defData, position, onClose }) {
        if (!defData || !position) return null;
        return (
            <div className="def-tooltip" style={{ left: position.x, top: position.y }}
                 onClick={e => e.stopPropagation()}>
                <span className="def-close" onClick={onClose}>&times;</span>
                <div className="def-word">{defData.word}</div>
                {defData.partOfSpeech && <div className="def-pos">{defData.partOfSpeech}</div>}
                <div className="def-text">{defData.definition}</div>
            </div>
        );
    }

    // =================== WORDS PANEL (with letter filter) ===================
    function WordsPanel({ found, pangrams, isOpen, onToggle, total, latestWord, revealedWords, onWordClick }) {
        const [filterLetter, setFilterLetter] = useState(null);

        // Get unique first letters from found words
        const firstLetters = useMemo(() => {
            const s = new Set(found.map(w => w[0]));
            return [...s].sort();
        }, [found]);

        // Filter words based on selected letter
        const filteredFound = filterLetter ? found.filter(w => w[0] === filterLetter) : found;
        const filteredRevealed = filterLetter
            ? (revealedWords || []).filter(w => w[0] === filterLetter)
            : (revealedWords || []);

        return (
            <div style={{ marginTop: 14 }}>
                <div onClick={onToggle}
                     style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                              padding: '10px 14px', borderRadius: 14,
                              background: 'var(--panel-bg)', border: '1px solid var(--panel-border)',
                              transition: 'all 0.2s' }}>
                    <span style={{ fontWeight: 700, fontSize: 16 }}>
                        {found.length > 0 ? `${found.length} of ${total} words` : 'No words found yet'}
                    </span>
                    <span style={{ fontSize: 16, transition: 'transform 0.3s cubic-bezier(0.34,1.56,0.64,1)',
                                   transform: isOpen ? 'rotate(180deg)' : 'rotate(0)', color: 'var(--word-filter-color)' }}>
                        &#x25BC;
                    </span>
                </div>
                <div className={`words-panel ${isOpen ? 'open' : ''}`}
                     style={{ padding: isOpen ? '10px 4px' : '0 4px' }}>
                    {found.length === 0 && (!revealedWords || revealedWords.length === 0) ? (
                        <p style={{ textAlign: 'center', color: 'var(--text-dimmer)', fontSize: 14, padding: 16 }}>
                            Type or click letters to make words!
                        </p>
                    ) : (
                        <>
                            {firstLetters.length > 1 && (
                                <div className="word-filter-tabs">
                                    <button className={`word-filter-tab ${filterLetter===null?'active':''}`}
                                            onClick={()=>setFilterLetter(null)}>All</button>
                                    {firstLetters.map(l => (
                                        <button key={l}
                                                className={`word-filter-tab ${filterLetter===l?'active':''}`}
                                                onClick={()=>setFilterLetter(filterLetter===l?null:l)}>
                                            {l.toUpperCase()}
                                        </button>
                                    ))}
                                </div>
                            )}
                            <div style={{ display: 'flex', flexWrap: 'wrap' }}>
                                {filteredFound.map((w, i) => (
                                    <span key={w}
                                          className={`word-chip ${pangrams.includes(w) ? 'pangram' : ''} ${w === latestWord ? 'latest' : ''}`}
                                          onClick={(e) => onWordClick && onWordClick(w, e)}>
                                        {w}
                                    </span>
                                ))}
                                {filteredRevealed.map((w) => (
                                    <span key={'rev-'+w}
                                          className={`word-chip revealed ${pangrams.includes(w) ? 'pangram' : ''}`}>
                                        {w}
                                    </span>
                                ))}
                            </div>
                        </>
                    )}
                </div>
            </div>
        );
    }

    // =================== HINT MODAL (with two-letter pair grid) ===================
    function HintModal({ onClose, puzzle, found }) {
        const [hintTab, setHintTab] = useState('letter');
        const unfound = puzzle.words.filter(w => !found.includes(w));

        // Group by first letter, then by length
        const groups = {};
        for (const w of unfound) {
            const letter = w[0];
            if (!groups[letter]) groups[letter] = {};
            const len = w.length;
            if (!groups[letter][len]) groups[letter][len] = 0;
            groups[letter][len]++;
        }
        const sortedLetters = Object.keys(groups).sort();

        // Two-letter pair groups
        const twoLetterGroups = {};
        for (const w of unfound) {
            const pair = w.slice(0, 2).toUpperCase();
            if (!twoLetterGroups[pair]) twoLetterGroups[pair] = 0;
            twoLetterGroups[pair]++;
        }
        const sortedPairs = Object.keys(twoLetterGroups).sort();

        return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal-box" onClick={e => e.stopPropagation()} style={{ maxWidth: 420 }}>
                    <h2 className="font-title" style={{ fontSize: 24, color: 'var(--accent-gold)', marginBottom: 6, textAlign: 'center' }}>
                        Hints
                    </h2>
                    <p style={{ textAlign: 'center', color: 'var(--text-secondary)', fontSize: 13, marginBottom: 12 }}>
                        {unfound.length} word{unfound.length !== 1 ? 's' : ''} remaining
                    </p>
                    {unfound.length === 0 ? (
                        <p style={{ textAlign: 'center', color: 'var(--accent-green)', fontSize: 16, fontWeight: 700, padding: 20 }}>
                            You found every word! Amazing!
                        </p>
                    ) : (
                        <>
                            <div className="hint-tab-bar">
                                <button className={`hint-tab ${hintTab==='letter'?'active':''}`}
                                        onClick={()=>setHintTab('letter')}>By Letter</button>
                                <button className={`hint-tab ${hintTab==='pair'?'active':''}`}
                                        onClick={()=>setHintTab('pair')}>Two-Letter Pairs</button>
                            </div>
                            {hintTab === 'letter' ? (
                                <div className="hint-grid">
                                    {sortedLetters.map(letter => {
                                        const lengths = Object.keys(groups[letter]).map(Number).sort((a,b) => a - b);
                                        const parts = lengths.map(len => {
                                            const count = groups[letter][len];
                                            return `${numWord(count)} ${len}-letter`;
                                        });
                                        return (
                                            <React.Fragment key={letter}>
                                                <span className="hint-letter">{letter}:</span>
                                                <span className="hint-detail">{parts.join(', ')}</span>
                                            </React.Fragment>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="two-letter-grid">
                                    {sortedPairs.map(pair => (
                                        <div key={pair} className="two-letter-cell">
                                            <div className="two-letter-pair">{pair}</div>
                                            <div className="two-letter-count">{twoLetterGroups[pair]}</div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </>
                    )}
                    <button className="game-btn game-btn-enter" onClick={onClose}
                            style={{ display: 'block', margin: '18px auto 0', width: '100%', fontSize: 16 }}>
                        Got It
                    </button>
                </div>
            </div>
        );
    }

    // =================== RULES MODAL ===================
    function RulesModal({ onClose, puzzle, practiceMode }) {
        return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal-box" onClick={e => e.stopPropagation()}>
                    <h2 className="font-title" style={{ fontSize: 26, color: practiceMode ? '#34d399' : 'var(--accent-gold)', marginBottom: 18, textAlign: 'center' }}>
                        {practiceMode ? 'Practice Mode' : 'How to Play'}
                    </h2>
                    <div style={{ fontSize: 15, lineHeight: 1.8, color: 'var(--text-secondary)' }}>
                        {practiceMode ? (
                            <>
                                <p style={{ marginBottom: 12 }}>Practice making words with relaxed rules! Build your skills before tackling the standard game.</p>
                                <div style={{ background: 'var(--stat-bg)', borderRadius: 12, padding: '12px 16px', marginBottom: 12 }}>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'#34d399'}}>&#x2022;</span> Words must be <b>3+ letters</b></p>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'#34d399'}}>&#x2022;</span> Letters <b>can be reused</b></p>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'#34d399'}}>&#x2022;</span> Center letter is <b>NOT required</b></p>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'#34d399'}}>&#x2022;</span> Scored <b>separately</b> from standard mode</p>
                                </div>
                                <div style={{ background: 'var(--stat-bg)', borderRadius: 12, padding: '12px 16px', marginBottom: 12 }}>
                                    <p style={{ margin: '4px 0', fontWeight: 700, color: '#34d399' }}>Scoring</p>
                                    <p style={{ margin: '4px 0' }}>3 or 4-letter words = <b>1 point</b></p>
                                    <p style={{ margin: '4px 0' }}>Longer words = <b>1 point per letter</b></p>
                                    <p style={{ margin: '4px 0' }}>Pangram (all 7 letters) = <b>+7 bonus!</b></p>
                                </div>
                            </>
                        ) : (
                            <>
                                <p style={{ marginBottom: 12 }}>Make words using the 7 letters. Every word <b>must</b> contain the
                                <span style={{ color: 'var(--accent-gold)', fontWeight: 700 }}> center letter</span>.</p>
                                <div style={{ background: 'var(--stat-bg)', borderRadius: 12, padding: '12px 16px', marginBottom: 12 }}>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'var(--accent-purple)'}}>&#x2022;</span> Words must be <b>4+ letters</b></p>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'var(--accent-purple)'}}>&#x2022;</span> Letters <b>can be reused</b></p>
                                    <p style={{ margin: '4px 0' }}><span style={{color:'var(--accent-purple)'}}>&#x2022;</span> <b>Center letter</b> is required</p>
                                </div>
                                <div style={{ background: 'var(--stat-bg)', borderRadius: 12, padding: '12px 16px', marginBottom: 12 }}>
                                    <p style={{ margin: '4px 0', fontWeight: 700, color: 'var(--accent-gold)' }}>Scoring</p>
                                    <p style={{ margin: '4px 0' }}>4-letter words = <b>1 point</b></p>
                                    <p style={{ margin: '4px 0' }}>Longer words = <b>1 point per letter</b></p>
                                    <p style={{ margin: '4px 0' }}>Pangram (all 7 letters) = <b>+7 bonus!</b></p>
                                </div>
                                <p style={{ textAlign: 'center', fontSize: 13, color: 'var(--text-muted)' }}>
                                    This puzzle: <b>{puzzle.wordCount}</b> words &bull; <b>{puzzle.pangrams.length}</b> pangram{puzzle.pangrams.length!==1?'s':''} &bull; max <b>{puzzle.maxScore}</b> pts
                                </p>
                            </>
                        )}
                    </div>
                    <button className="game-btn game-btn-enter" onClick={onClose}
                            style={{ display: 'block', margin: '18px auto 0', width: '100%', fontSize: 16 }}>
                        Let's Go!
                    </button>
                </div>
            </div>
        );
    }

    // =================== PERSONAL STATS MODAL ===================
    function StatsModal({ onClose, stats, streakData }) {
        const avgRank = stats.puzzlesPlayed > 0
            ? RANKS[Math.min(Math.round(stats.rankSum / stats.puzzlesPlayed), RANKS.length - 1)].name
            : 'N/A';
        return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal-box" onClick={e => e.stopPropagation()} style={{ maxWidth: 380 }}>
                    <h2 className="font-title" style={{ fontSize: 24, color: 'var(--accent-gold)', marginBottom: 16, textAlign: 'center' }}>
                        Your Stats
                    </h2>
                    <div className="stat-card">
                        <span className="stat-card-label">Puzzles Played</span>
                        <span className="stat-card-value">{stats.puzzlesPlayed}</span>
                    </div>
                    <div className="stat-card">
                        <span className="stat-card-label">Total Words Found</span>
                        <span className="stat-card-value">{stats.totalWords}</span>
                    </div>
                    <div className="stat-card">
                        <span className="stat-card-label">Total Pangrams</span>
                        <span className="stat-card-value">{stats.totalPangrams}</span>
                    </div>
                    <div className="stat-card">
                        <span className="stat-card-label">Average Rank</span>
                        <span className="stat-card-value">{avgRank}</span>
                    </div>
                    <div className="stat-card">
                        <span className="stat-card-label">Longest Word</span>
                        <span className="stat-card-value" style={{ textTransform: 'uppercase', fontSize: 15, letterSpacing: 1 }}>
                            {stats.longestWord || '--'}
                        </span>
                    </div>
                    {streakData && (
                        <>
                            <div style={{ marginTop: 12, marginBottom: 4, fontSize: 14, fontWeight: 700,
                                          color: 'var(--accent-gold)', textAlign: 'center', textTransform: 'uppercase',
                                          letterSpacing: 1 }}>
                                {'\u{1F525}'} Genius Streak
                            </div>
                            <div className="stat-card">
                                <span className="stat-card-label">Current Streak</span>
                                <span className="stat-card-value">{streakData.currentStreak} day{streakData.currentStreak !== 1 ? 's' : ''}</span>
                            </div>
                            <div className="stat-card">
                                <span className="stat-card-label">Best Streak</span>
                                <span className="stat-card-value">{streakData.bestStreak} day{streakData.bestStreak !== 1 ? 's' : ''}</span>
                            </div>
                        </>
                    )}
                    <button className="game-btn game-btn-enter" onClick={onClose}
                            style={{ display: 'block', margin: '18px auto 0', width: '100%', fontSize: 16 }}>
                        Close
                    </button>
                </div>
            </div>
        );
    }

    // =================== WORD LENGTH DISTRIBUTION ===================
    function WordLengthDistribution({ puzzle, found }) {
        // Build length distribution data
        const allByLen = {};
        const foundByLen = {};
        for (const w of puzzle.words) {
            const len = w.length;
            allByLen[len] = (allByLen[len] || 0) + 1;
        }
        for (const w of found) {
            const len = w.length;
            foundByLen[len] = (foundByLen[len] || 0) + 1;
        }
        const lengths = Object.keys(allByLen).map(Number).sort((a,b) => a - b);
        const maxCount = Math.max(...Object.values(allByLen), 1);

        return (
            <div style={{ marginTop: 12, padding: '10px 14px', borderRadius: 14,
                          background: 'var(--panel-bg)', border: '1px solid var(--panel-border)' }}>
                <div style={{ fontSize: 13, fontWeight: 700, color: 'var(--text-secondary)', marginBottom: 8,
                              textTransform: 'uppercase', letterSpacing: 1 }}>
                    Word Lengths
                </div>
                {lengths.map(len => {
                    const total = allByLen[len];
                    const foundCount = foundByLen[len] || 0;
                    const totalPct = (total / maxCount) * 100;
                    const foundPct = (foundCount / maxCount) * 100;
                    return (
                        <div key={len} className="dist-row">
                            <span className="dist-label">{len}</span>
                            <div className="dist-bar-outer">
                                <div className="dist-bar-inner dist-bar-total" style={{ width: `${totalPct}%` }} />
                                <div className="dist-bar-inner dist-bar-found" style={{ width: `${foundPct}%` }} />
                            </div>
                            <span className="dist-count">{foundCount}/{total}</span>
                        </div>
                    );
                })}
            </div>
        );
    }

    // =================== SPRINT FINAL SCREEN ===================
    function SprintFinalScreen({ score, wordsFound, maxScore, totalWords, pangrams, onPlayAgain, onExit }) {
        const rank = getRank(score, maxScore);
        return (
            <div className="sprint-final-overlay" onClick={onExit}>
                <div className="sprint-final-box" onClick={e => e.stopPropagation()}>
                    <div style={{ fontSize: 42, marginBottom: 4 }}>&#x23F1;&#xFE0F;</div>
                    <h2 className="font-title" style={{ fontSize: 28, color: '#06b6d4', marginBottom: 4 }}>
                        Time's Up!
                    </h2>
                    <p style={{ color: '#94a3b8', fontSize: 14, marginBottom: 20 }}>Sprint Complete</p>

                    <div style={{ fontSize: 48, fontWeight: 800, color: '#fbbf24',
                                  textShadow: '0 0 30px rgba(251,191,36,0.4)', marginBottom: 4 }}>
                        {score}
                    </div>
                    <div style={{ fontSize: 14, color: '#94a3b8', marginBottom: 20 }}>points</div>

                    <div style={{ background: 'rgba(0,0,0,0.2)', borderRadius: 14, padding: '12px 18px', marginBottom: 20 }}>
                        <div className="sprint-stat">
                            <span className="sprint-stat-label">Words Found</span>
                            <span className="sprint-stat-value">{wordsFound} / {totalWords}</span>
                        </div>
                        <div className="sprint-stat">
                            <span className="sprint-stat-label">Pangrams</span>
                            <span className="sprint-stat-value">{pangrams}</span>
                        </div>
                        <div className="sprint-stat">
                            <span className="sprint-stat-label">Rank Achieved</span>
                            <span className="sprint-stat-value">{RANK_EMOJIS[rank.idx]} {rank.name}</span>
                        </div>
                        <div className="sprint-stat" style={{ borderBottom: 'none' }}>
                            <span className="sprint-stat-label">Score %</span>
                            <span className="sprint-stat-value">{maxScore > 0 ? Math.round((score / maxScore) * 100) : 0}%</span>
                        </div>
                    </div>

                    <div style={{ display: 'flex', gap: 10 }}>
                        <button className="game-btn" onClick={onExit} style={{ flex: 1 }}>
                            Back
                        </button>
                        <button className="game-btn game-btn-enter" onClick={onPlayAgain} style={{ flex: 1 }}>
                            Sprint Again
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =================== MAIN APP ===================
    function App() {
        const [loading, setLoading] = useState(true);
        const [mode, setMode] = useState('daily');
        const [randomIdx, setRandomIdx] = useState(() => Math.floor(Math.random() * PUZZLES.length));
        const [sprintIdx, setSprintIdx] = useState(() => Math.floor(Math.random() * PUZZLES.length));

        // Sprint state
        const [sprintActive, setSprintActive] = useState(false);
        const [sprintTimeLeft, setSprintTimeLeft] = useState(180);
        const [sprintFinished, setSprintFinished] = useState(false);
        const [sprintFinalStats, setSprintFinalStats] = useState(null);
        const sprintTimerRef = useRef(null);

        const pidx = mode === 'daily' ? getDailyIdx() : mode === 'sprint' ? sprintIdx : randomIdx;
        const puzzle = PUZZLES[pidx];
        const allLetters = useMemo(() => puzzle ? [...puzzle.letters, puzzle.center] : [], [pidx]);
        const letterSet = useMemo(() => new Set(allLetters), [allLetters]);

        const [word, setWord] = useState('');
        const [found, setFound] = useState(() => loadSave(pidx, mode));
        const [shuffleOrder, setShuffleOrder] = useState([0,1,2,3,4,5]);
        const [toast, setToast] = useState(null);
        const [floats, setFloats] = useState([]);
        const [sparkles, setSparkles] = useState(false);
        const [confetti, setConfetti] = useState(false);
        const [wordsOpen, setWordsOpen] = useState(false);
        const [showRules, setShowRules] = useState(false);
        const [showHints, setShowHints] = useState(false);
        const [shaking, setShaking] = useState(false);
        const [shuffleSpin, setShuffleSpin] = useState(false);
        const [rankBanner, setRankBanner] = useState(null);
        const [latestWord, setLatestWord] = useState('');
        const [justReachedIdx, setJustReachedIdx] = useState(-1);
        const [pressedHex, setPressedHex] = useState(null);
        const [revealedWords, setRevealedWords] = useState([]);
        const [answersRevealed, setAnswersRevealed] = useState(false);

        // Definition tooltip state
        const [defData, setDefData] = useState(null);
        const [defPos, setDefPos] = useState(null);
        const [defLoading, setDefLoading] = useState(false);

        // Feature: Theme toggle (Feature 6)
        const [theme, setTheme] = useState(() => loadTheme());

        // Feature: Sound mute toggle (Feature 2)
        const [muted, setMuted] = useState(() => {
            const m = loadMuted();
            SoundManager.setMuted(m);
            return m;
        });

        // Feature: Personal stats (Feature 3)
        const [personalStats, setPersonalStats] = useState(() => loadStats());
        const [showStats, setShowStats] = useState(false);
        const statsTrackedRef = useRef(new Set());

        // Feature: Animated hex shuffle (Feature 4)
        const [hexAnimating, setHexAnimating] = useState(false);
        const prevShuffleRef = useRef([0,1,2,3,4,5]);

        // Feature: Genius Streak Counter
        const [streakData, setStreakData] = useState(() => loadStreak());
        const streakRecordedRef = useRef(false);

        // Feature: Practice Mode
        const [practiceMode, setPracticeMode] = useState(false);
        const [practiceFound, setPracticeFound] = useState([]);
        const practiceWordsRef = useRef([]);

        // Apply theme to document
        useEffect(() => {
            if (theme === 'light') {
                document.documentElement.classList.add('light-theme');
            } else {
                document.documentElement.classList.remove('light-theme');
            }
        }, [theme]);

        function toggleTheme() {
            const newTheme = theme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
            saveTheme(newTheme);
        }

        function toggleMute() {
            const newMuted = !muted;
            setMuted(newMuted);
            SoundManager.setMuted(newMuted);
            saveMuted(newMuted);
            if (!newMuted) SoundManager.init();
        }

        // Load puzzles on mount
        useEffect(() => {
            loadPuzzles().then(() => {
                setLoading(false);
                // Re-initialize random index with full puzzle set
                setRandomIdx(Math.floor(Math.random() * PUZZLES.length));
                setSprintIdx(Math.floor(Math.random() * PUZZLES.length));
            });
        }, []);

        // Compute practice word list when puzzle changes
        useEffect(() => {
            if (puzzle) {
                practiceWordsRef.current = getPracticeWords(puzzle);
            }
        }, [pidx]);

        // Load practice save when puzzle or practice mode changes
        useEffect(() => {
            if (practiceMode) {
                setPracticeFound(loadSave(pidx, 'practice'));
            }
        }, [pidx, practiceMode]);

        // Save practice progress
        useEffect(() => {
            if (practiceMode) {
                writeSave(pidx, 'practice', practiceFound);
            }
        }, [practiceFound, pidx, practiceMode]);

        // Compute score (standard)
        const score = useMemo(() => {
            let s = 0;
            for (const w of found) { s += scoreWord(w, allLetters).pts; }
            return s;
        }, [found, allLetters]);

        // Compute practice score
        const practiceScore = useMemo(() => {
            let s = 0;
            for (const w of practiceFound) { s += scorePracticeWord(w, allLetters).pts; }
            return s;
        }, [practiceFound, allLetters]);

        // Save (not in sprint mode)
        useEffect(() => {
            if (mode !== 'sprint') writeSave(pidx, mode, found);
        }, [found, pidx, mode]);

        // Reload on puzzle change
        useEffect(() => {
            if (mode === 'sprint') {
                setFound([]);
            } else {
                setFound(loadSave(pidx, mode));
            }
            setWord('');
            setToast(null);
            setLatestWord('');
            setJustReachedIdx(-1);
            setRevealedWords([]);
            setAnswersRevealed(false);
            setDefData(null);
            setPracticeFound(loadSave(pidx, 'practice'));
            streakRecordedRef.current = false;
        }, [pidx, mode]);

        // Check if daily puzzle already has Genius rank on load (for streak tracking)
        useEffect(() => {
            if (mode === 'daily' && !streakRecordedRef.current && puzzle) {
                const loadedFound = loadSave(pidx, 'daily');
                let loadedScore = 0;
                for (const w of loadedFound) { loadedScore += scoreWord(w, allLetters).pts; }
                const loadedRank = getRank(loadedScore, puzzle.maxScore);
                if (loadedRank.name === 'Genius' || loadedRank.name === 'Queen Bee') {
                    streakRecordedRef.current = true;
                    const newStreakData = updateStreakForGenius(streakData);
                    setStreakData(newStreakData);
                }
            }
        }, [mode, pidx, loading]);

        // Sprint timer
        useEffect(() => {
            if (mode === 'sprint' && sprintActive && !sprintFinished) {
                sprintTimerRef.current = setInterval(() => {
                    setSprintTimeLeft(prev => {
                        if (prev <= 1) {
                            clearInterval(sprintTimerRef.current);
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
                return () => clearInterval(sprintTimerRef.current);
            }
        }, [mode, sprintActive, sprintFinished]);

        // End sprint when timer hits 0
        useEffect(() => {
            if (mode === 'sprint' && sprintActive && sprintTimeLeft <= 0 && !sprintFinished) {
                setSprintFinished(true);
                setSprintActive(false);
                clearInterval(sprintTimerRef.current);
                const pangramCount = found.filter(w => puzzle.pangrams.includes(w)).length;
                setSprintFinalStats({
                    score,
                    wordsFound: found.length,
                    maxScore: puzzle.maxScore,
                    totalWords: puzzle.wordCount,
                    pangrams: pangramCount,
                });
            }
        }, [sprintTimeLeft, sprintActive, sprintFinished, mode]);

        // Close definition tooltip on outside click
        useEffect(() => {
            const handler = () => { setDefData(null); setDefPos(null); };
            if (defData) {
                window.addEventListener('click', handler);
                return () => window.removeEventListener('click', handler);
            }
        }, [defData]);

        // Keyboard
        useEffect(() => {
            const h = (e) => {
                if (showRules || showHints || showStats || sprintFinished) return;
                if (mode === 'sprint' && !sprintActive) return;
                const k = e.key.toLowerCase();
                if (k === 'enter') { e.preventDefault(); submitWord(); }
                else if (k === 'backspace') { e.preventDefault(); setWord(p => p.slice(0,-1)); }
                else if (k === ' ') { e.preventDefault(); doShuffle(); }
                else if (k.length === 1 && /[a-z]/.test(k)) {
                    if (letterSet.has(k)) { setWord(p => p + k); SoundManager.play('letter'); }
                    else { triggerShake(); }
                }
            };
            window.addEventListener('keydown', h);
            return () => window.removeEventListener('keydown', h);
        });

        function addLetter(l) {
            if (mode === 'sprint' && !sprintActive) return;
            setWord(p => p + l);
            setPressedHex(l);
            setTimeout(() => setPressedHex(null), 200);
            SoundManager.play('letter');
        }

        function triggerShake() {
            setShaking(true); setTimeout(() => setShaking(false), 500);
            SoundManager.play('reject');
        }

        function showMsg(message, type) { setToast({ message, type, id: Date.now() }); }

        function submitWord() {
            if (mode === 'sprint' && !sprintActive) return;
            const w = word.toLowerCase().trim();
            if (!w) return;
            setWord('');

            // Practice mode has relaxed rules
            if (practiceMode) {
                if (w.length < 3) { showMsg('Too short! (3+ letters)', 'error'); triggerShake(); return; }
                if ([...w].some(l => !letterSet.has(l))) { showMsg('Invalid letter!', 'error'); triggerShake(); return; }
                if (practiceFound.includes(w)) { showMsg('Already found!', 'error'); triggerShake(); return; }
                // Check against practice word list (standard words + 3-letter words)
                if (!practiceWordsRef.current.includes(w)) { showMsg('Not in word list', 'error'); triggerShake(); return; }

                // Valid practice word!
                const { pts, isPangram } = scorePracticeWord(w, allLetters);

                if (isPangram) {
                    showMsg(`&#x1F31F; PANGRAM! +${pts} &#x1F31F;`, 'pangram');
                    setSparkles(true); setTimeout(() => setSparkles(false), 800);
                    setConfetti(true); setTimeout(() => setConfetti(false), 3000);
                    SoundManager.play('pangram');
                } else {
                    const msgs = pts === 1
                        ? ['Nice!', 'Good!', 'Yes!', 'Got it!', 'Yep!']
                        : pts <= 5
                        ? ['Great! +' + pts, 'Sweet! +' + pts, 'Solid! +' + pts]
                        : ['Amazing! +' + pts, 'Brilliant! +' + pts, 'Superb! +' + pts];
                    showMsg(msgs[Math.floor(Math.random() * msgs.length)], 'success');
                    SoundManager.play('accept');
                }

                setFloats(p => [...p, { id: Date.now(), pts }]);
                setTimeout(() => setFloats(p => p.slice(1)), 1100);

                const newPracticeFound = [...practiceFound, w].sort();
                setPracticeFound(newPracticeFound);
                setLatestWord(w);
                setTimeout(() => setLatestWord(''), 2000);
                return;
            }

            // Standard mode validation
            if (w.length < 4) { showMsg('Too short!', 'error'); triggerShake(); return; }
            if (!w.includes(puzzle.center)) {
                showMsg(`Missing center letter <b>${puzzle.center.toUpperCase()}</b>`, 'error');
                triggerShake(); return;
            }
            if ([...w].some(l => !letterSet.has(l))) { showMsg('Invalid letter!', 'error'); triggerShake(); return; }
            if (found.includes(w)) { showMsg('Already found!', 'error'); triggerShake(); return; }
            if (!puzzle.words.includes(w)) { showMsg('Not in word list', 'error'); triggerShake(); return; }

            // Valid!
            const { pts, isPangram } = scoreWord(w, allLetters);
            const oldRank = getRank(score, puzzle.maxScore);

            if (isPangram) {
                showMsg(`&#x1F31F; PANGRAM! +${pts} &#x1F31F;`, 'pangram');
                setSparkles(true); setTimeout(() => setSparkles(false), 800);
                setConfetti(true); setTimeout(() => setConfetti(false), 3000);
                SoundManager.play('pangram');
            } else {
                const msgs = pts === 1
                    ? ['Nice!', 'Good!', 'Yes!', 'Got it!', 'Yep!']
                    : pts <= 5
                    ? ['Great! +' + pts, 'Sweet! +' + pts, 'Solid! +' + pts]
                    : ['Amazing! +' + pts, 'Brilliant! +' + pts, 'Superb! +' + pts];
                showMsg(msgs[Math.floor(Math.random() * msgs.length)], 'success');
                SoundManager.play('accept');
            }

            // Score float
            setFloats(p => [...p, { id: Date.now(), pts }]);
            setTimeout(() => setFloats(p => p.slice(1)), 1100);

            const newFound = [...found, w].sort();
            setFound(newFound);
            setLatestWord(w);
            setTimeout(() => setLatestWord(''), 2000);

            // Remove from revealed if it was there
            if (revealedWords.includes(w)) {
                setRevealedWords(prev => prev.filter(rw => rw !== w));
            }

            // Feature 3: Update personal stats
            const updatedStats = { ...personalStats };
            updatedStats.totalWords++;
            if (isPangram) updatedStats.totalPangrams++;
            if (!updatedStats.longestWord || w.length > updatedStats.longestWord.length) {
                updatedStats.longestWord = w;
            }
            // Track unique puzzle sessions
            const sessionKey = `${mode}-${pidx}`;
            if (!statsTrackedRef.current.has(sessionKey)) {
                statsTrackedRef.current.add(sessionKey);
                updatedStats.puzzlesPlayed++;
            }
            setPersonalStats(updatedStats);
            saveStats(updatedStats);

            // Check rank up
            const newScore = score + pts;
            const newRank = getRank(newScore, puzzle.maxScore);
            if (newRank.idx > oldRank.idx) {
                setJustReachedIdx(newRank.idx);
                SoundManager.play('rankup');
                setTimeout(() => {
                    setRankBanner(newRank);
                    if (newRank.name === 'Genius' || newRank.name === 'Queen Bee') {
                        setConfetti(true);
                        setTimeout(() => setConfetti(false), 4000);
                    }
                }, 500);
                setTimeout(() => setJustReachedIdx(-1), 4000);

                // Update avg rank in stats
                const rankStats = { ...updatedStats };
                rankStats.rankSum = (rankStats.rankSum || 0) + newRank.idx;
                setPersonalStats(rankStats);
                saveStats(rankStats);

                // Feature: Streak - track genius in daily mode
                if (mode === 'daily' && (newRank.name === 'Genius' || newRank.name === 'Queen Bee') && !streakRecordedRef.current) {
                    streakRecordedRef.current = true;
                    const newStreakData = updateStreakForGenius(streakData);
                    setStreakData(newStreakData);
                }
            }
        }

        function doShuffle() {
            setShuffleSpin(true);
            setTimeout(() => setShuffleSpin(false), 500);
            prevShuffleRef.current = [...shuffleOrder];
            setHexAnimating(true);
            setShuffleOrder(prev => {
                const a = [...prev];
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            });
            setTimeout(() => setHexAnimating(false), 500);
        }

        function newRandom() {
            let i; do { i = Math.floor(Math.random() * PUZZLES.length); } while (i === randomIdx);
            setRandomIdx(i);
        }

        // Sprint functions
        function startSprint() {
            const idx = Math.floor(Math.random() * PUZZLES.length);
            setSprintIdx(idx);
            setSprintTimeLeft(180);
            setSprintActive(true);
            setSprintFinished(false);
            setSprintFinalStats(null);
            setFound([]);
            setWord('');
            setRevealedWords([]);
            setAnswersRevealed(false);
        }

        function sprintAgain() {
            startSprint();
        }

        function exitSprint() {
            setSprintFinished(false);
            setSprintFinalStats(null);
            setMode('daily');
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function getTimerClass() {
            if (sprintTimeLeft <= 30) return 'sprint-timer danger';
            if (sprintTimeLeft <= 60) return 'sprint-timer warning';
            return 'sprint-timer';
        }

        // Definition lookup handler
        function handleWordClick(w, e) {
            e.stopPropagation();
            const rect = e.target.getBoundingClientRect();
            let x = rect.left;
            let y = rect.bottom + 8;
            // Keep tooltip on screen
            if (x + 300 > window.innerWidth) x = window.innerWidth - 310;
            if (x < 10) x = 10;
            if (y + 100 > window.innerHeight) y = rect.top - 80;

            setDefPos({ x, y });
            setDefData({ word: w, partOfSpeech: '', definition: 'Loading...' });
            setDefLoading(true);

            fetchDefinition(w).then(result => {
                setDefData(result);
                setDefLoading(false);
            });
        }

        // Show Answers logic
        const rank = getRank(score, puzzle ? puzzle.maxScore : 0);
        const foundPct = puzzle ? found.length / puzzle.wordCount : 0;
        const canRevealAnswers = !answersRevealed && (foundPct >= 0.5 || rank.name === 'Queen Bee');

        function handleRevealAnswers() {
            if (window.confirm('Are you sure you want to reveal all remaining words? This cannot be undone.')) {
                const unfound = puzzle.words.filter(w => !found.includes(w)).sort();
                setRevealedWords(unfound);
                setAnswersRevealed(true);
                setWordsOpen(true);
            }
        }

        // Loading screen
        if (loading || !puzzle) {
            return (
                <div className="loading-screen">
                    <div className="loading-spinner" />
                    <div style={{ color: 'var(--accent-purple)', fontSize: 18, fontWeight: 600 }}>Loading puzzles...</div>
                </div>
            );
        }

        return (
            <div style={{ maxWidth: 440, margin: '0 auto', padding: '56px 16px 30px', position: 'relative' }}>
                {/* Title */}
                <div style={{ textAlign: 'center', marginBottom: 6 }}>
                    <h1 className="font-title" style={{
                        fontSize: 34, color: 'var(--accent-gold)',
                        textShadow: '0 0 25px rgba(251,191,36,0.35), 0 0 50px rgba(251,191,36,0.15)',
                        marginBottom: 2, lineHeight: 1.2
                    }}>
                        &#x1F41D; Spelling Bee
                    </h1>
                    <p style={{ fontSize: 13, color: 'var(--text-muted)', margin: 0 }}>
                        How many words can you spell?
                    </p>
                </div>

                {/* Mode + Help + Theme + Mute + Stats */}
                <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 8, marginBottom: 14, flexWrap: 'wrap' }}>
                    <div className="mode-toggle">
                        <button className={`mode-btn ${mode==='daily'?'active':''}`} onClick={()=>{setMode('daily');setWord('');setDefData(null);}}>
                            Daily
                        </button>
                        <button className={`mode-btn ${mode==='random'?'active':''}`} onClick={()=>{setMode('random');setWord('');setDefData(null);}}>
                            Free Play
                        </button>
                        <button className={`mode-btn ${mode==='sprint'?'active':''}`} onClick={()=>{setMode('sprint');setWord('');setDefData(null);setPracticeMode(false);if(!sprintActive){startSprint();}}}>
                            Sprint
                        </button>
                    </div>
                    <button onClick={() => setShowRules(true)}
                            style={{ width: 32, height: 32, borderRadius: '50%', border: '1px solid var(--accent-purple-border)',
                                     background: 'var(--accent-purple-bg)', color: 'var(--word-filter-color)', cursor: 'pointer',
                                     fontSize: 17, fontWeight: 700, display: 'flex', alignItems: 'center', justifyContent: 'center',
                                     fontFamily: 'serif', transition: 'all 0.2s' }}>
                        ?
                    </button>
                    <button className="theme-toggle-btn" onClick={toggleTheme} title={theme==='dark'?'Switch to light theme':'Switch to dark theme'}>
                        {theme === 'dark' ? '\u2600\uFE0F' : '\u{1F319}'}
                    </button>
                    <button className="mute-toggle-btn" onClick={toggleMute} title={muted?'Unmute':'Mute'}>
                        {muted ? '\u{1F507}' : '\u{1F50A}'}
                    </button>
                    <button className="mute-toggle-btn" onClick={() => setShowStats(true)} title="Your Stats"
                            style={{ fontSize: 14 }}>
                        {'\u{1F4CA}'}
                    </button>
                </div>

                {/* Practice Mode Toggle + Streak Badge Row */}
                {mode !== 'sprint' && (
                    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 10, marginBottom: 12, flexWrap: 'wrap' }}>
                        <div className="practice-toggle">
                            <button className={`practice-toggle-btn ${!practiceMode ? 'standard-active' : ''}`}
                                    onClick={() => { setPracticeMode(false); setWord(''); }}>
                                Standard
                            </button>
                            <button className={`practice-toggle-btn ${practiceMode ? 'active' : ''}`}
                                    onClick={() => { setPracticeMode(true); setWord(''); }}>
                                Practice
                            </button>
                        </div>
                        {practiceMode && (
                            <span className="practice-indicator">
                                3+ letters &bull; no center required
                            </span>
                        )}
                        {!practiceMode && mode === 'daily' && streakData.currentStreak > 0 && (
                            <div className="streak-badge" title={`Best streak: ${streakData.bestStreak} day${streakData.bestStreak !== 1 ? 's' : ''}`}>
                                <span className="streak-fire">{'\u{1F525}'}</span>
                                <span className="streak-num">{streakData.currentStreak}</span>
                                <span>day{streakData.currentStreak !== 1 ? 's' : ''}</span>
                                {streakData.bestStreak > streakData.currentStreak && (
                                    <span className="streak-badge-best">(best: {streakData.bestStreak})</span>
                                )}
                            </div>
                        )}
                    </div>
                )}

                {/* Sprint Timer */}
                {mode === 'sprint' && sprintActive && (
                    <div style={{ textAlign: 'center', marginBottom: 12 }}>
                        <div className={getTimerClass()}>
                            &#x23F1;&#xFE0F; {formatTime(sprintTimeLeft)}
                        </div>
                    </div>
                )}

                {/* Sprint Start Screen (if sprint mode but not active and not finished) */}
                {mode === 'sprint' && !sprintActive && !sprintFinished && (
                    <div style={{ textAlign: 'center', padding: '30px 0' }}>
                        <div style={{ fontSize: 48, marginBottom: 12 }}>&#x23F1;&#xFE0F;</div>
                        <h2 className="font-title" style={{ fontSize: 24, color: '#06b6d4', marginBottom: 8 }}>Sprint Mode</h2>
                        <p style={{ color: '#94a3b8', fontSize: 15, marginBottom: 20, lineHeight: 1.6 }}>
                            Score as many points as you can in <b style={{color:'#06b6d4'}}>3 minutes</b>!
                        </p>
                        <button className="game-btn game-btn-enter" onClick={startSprint} style={{ fontSize: 18, padding: '14px 40px' }}>
                            Start Sprint
                        </button>
                    </div>
                )}

                {/* Main game area (show for daily/random, or sprint when active) */}
                {(mode !== 'sprint' || sprintActive) && (
                    <>
                        {/* Rank Bar (standard) or Practice Score */}
                        {practiceMode ? (
                            <div style={{ padding: '0 4px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 8 }}>
                                    <span style={{ fontSize: 18, fontWeight: 800, color: '#34d399',
                                                   textShadow: '0 0 12px rgba(52,211,153,0.35)' }}>
                                        {'\u{1F331}'} Practice Mode
                                    </span>
                                    <span style={{ fontSize: 14, color: 'var(--text-secondary)' }}>
                                        <span style={{ color: '#34d399', fontWeight: 700 }}>{practiceScore}</span> pts
                                        {' \u2022 '}
                                        <span style={{ color: '#34d399', fontWeight: 700 }}>{practiceFound.length}</span> words
                                    </span>
                                </div>
                                <div style={{ height: 6, borderRadius: 999, background: 'var(--bar-bg)',
                                              border: '1px solid var(--bar-border)' }}>
                                    <div style={{ height: '100%', borderRadius: 999, width: `${Math.min((practiceFound.length / Math.max(practiceWordsRef.current.length, 1)) * 100, 100)}%`,
                                                  background: 'linear-gradient(90deg, #34d399, #06b6d4)', transition: 'width 0.5s' }} />
                                </div>
                            </div>
                        ) : (
                            <RankBar score={score} maxScore={puzzle.maxScore} justReachedIdx={justReachedIdx} />
                        )}

                        {/* Current Word */}
                        <div style={{ textAlign: 'center', margin: '20px 0 6px', position: 'relative', minHeight: 52 }}>
                            <div className={`current-word ${shaking ? 'shake-anim' : ''}`}>
                                {word.length === 0 ? (
                                    <span style={{ color: 'var(--text-dim)', fontSize: 20, fontWeight: 400, letterSpacing: 1 }}>
                                        Type or click letters...
                                    </span>
                                ) : (
                                    [...word].map((l, i) => (
                                        <span key={`${i}-${word.length}`}
                                              className={`current-letter ${!practiceMode && l===puzzle.center ? 'center-highlight' : ''}`}>
                                            {l.toUpperCase()}
                                        </span>
                                    ))
                                )}
                            </div>
                            <div style={{ height: 2, margin: '6px auto 0', width: '65%', maxWidth: 260,
                                          background: 'linear-gradient(90deg, transparent, var(--divider-color), transparent)' }} />

                            {/* Score floats */}
                            {floats.map(f => (
                                <div key={f.id} className="score-float" style={{ left: '50%', top: '30%', transform: 'translateX(-50%)' }}>
                                    +{f.pts}
                                </div>
                            ))}

                            <SparkleBurst active={sparkles} />
                        </div>

                        {/* Honeycomb with animated shuffle */}
                        <div className="hex-grid" style={{ margin: '14px auto 18px' }}>
                            <div className={`hex-btn ${practiceMode ? 'hex-outer' : 'hex-center'} hex-pos-c ${pressedHex===puzzle.center?'pressed':''}`}
                                 draggable="false" onDragStart={e => e.preventDefault()}
                                 onClick={() => addLetter(puzzle.center)}>
                                {puzzle.center.toUpperCase()}
                            </div>
                            {puzzle.letters.map((letter, letterIdx) => {
                                // Find which visual position this letter occupies
                                const visualPos = shuffleOrder.indexOf(letterIdx);
                                const pos = HEX_POSITIONS[visualPos];
                                return (
                                    <div key={letter}
                                         className={`hex-btn hex-outer ${hexAnimating ? 'hex-animated' : ''} ${pressedHex===letter?'pressed':''}`}
                                         style={{
                                             left: '50%', top: '50%',
                                             transform: `translate(${pos.x}%, ${pos.y}%)`,
                                             transition: hexAnimating ? 'transform 0.45s cubic-bezier(0.34, 1.56, 0.64, 1)' : 'filter 0.15s',
                                         }}
                                         draggable="false" onDragStart={e => e.preventDefault()}
                                         onClick={() => addLetter(letter)}>
                                        {letter.toUpperCase()}
                                    </div>
                                );
                            })}
                        </div>

                        {/* Action Buttons */}
                        <div style={{ display: 'flex', justifyContent: 'center', gap: 10, marginTop: 4 }}>
                            <button className="game-btn" onClick={() => setWord(p => p.slice(0,-1))}>
                                Delete
                            </button>
                            <button className="game-btn" onClick={doShuffle} title="Shuffle (Space)">
                                <span className={`shuffle-icon ${shuffleSpin?'spinning':''}`}>&#x21BB;</span> Shuffle
                            </button>
                            <button className="game-btn game-btn-enter" onClick={submitWord}>
                                Enter
                            </button>
                        </div>

                        {/* Secondary buttons row: Hint + New Puzzle (random) + Show Answers */}
                        <div style={{ display: 'flex', justifyContent: 'center', gap: 10, marginTop: 10, flexWrap: 'wrap' }}>
                            {mode !== 'sprint' && !practiceMode && (
                                <button className="game-btn" onClick={() => setShowHints(true)} style={{ fontSize: 12 }}>
                                    &#x1F4A1; Hint
                                </button>
                            )}
                            {mode === 'random' && (
                                <button className="game-btn" onClick={newRandom} style={{ fontSize: 12 }}>
                                    &#x1F504; New Puzzle
                                </button>
                            )}
                            {mode !== 'sprint' && !practiceMode && canRevealAnswers && (
                                <button className="game-btn" onClick={handleRevealAnswers}
                                        style={{ fontSize: 12, borderColor: 'rgba(100,116,139,0.4)', color: '#94a3b8' }}>
                                    &#x1F441; Show Answers
                                </button>
                            )}
                        </div>

                        {/* Words Panel */}
                        <WordsPanel found={practiceMode ? practiceFound : found} pangrams={puzzle.pangrams}
                                    isOpen={wordsOpen} onToggle={() => setWordsOpen(p => !p)}
                                    total={practiceMode ? practiceWordsRef.current.length : puzzle.wordCount}
                                    latestWord={latestWord}
                                    revealedWords={!practiceMode && answersRevealed ? revealedWords : []}
                                    onWordClick={handleWordClick} />

                        {/* Word Length Distribution (Feature 7) - standard mode only */}
                        {!practiceMode && found.length > 0 && (
                            <WordLengthDistribution puzzle={puzzle} found={found} />
                        )}

                        {/* Puzzle Info */}
                        <div style={{ textAlign: 'center', marginTop: 16, fontSize: 12, color: 'var(--text-dim)' }}>
                            Puzzle #{pidx + 1} &bull;{' '}
                            {practiceMode ? (
                                <>{practiceWordsRef.current.length} practice words</>
                            ) : (
                                <>{puzzle.wordCount} words &bull;{' '}
                                {puzzle.pangrams.length} pangram{puzzle.pangrams.length !== 1 ? 's' : ''} &bull;{' '}
                                Max {puzzle.maxScore} pts</>
                            )}
                            {puzzlesLoadError && <span style={{ color: '#f59e0b' }}> (offline mode)</span>}
                        </div>
                    </>
                )}

                {/* Toast */}
                {toast && <Toast key={toast.id} data={toast} onDone={() => setToast(null)} />}

                {/* Rank Banner */}
                {rankBanner && <RankBanner rank={rankBanner} onDone={() => setRankBanner(null)} />}

                {/* Confetti */}
                <Confetti active={confetti} />

                {/* Rules Modal */}
                {showRules && <RulesModal onClose={() => setShowRules(false)} puzzle={puzzle} practiceMode={practiceMode} />}

                {/* Hint Modal */}
                {showHints && <HintModal onClose={() => setShowHints(false)} puzzle={puzzle} found={found} />}

                {/* Stats Modal (Feature 3) */}
                {showStats && <StatsModal onClose={() => setShowStats(false)} stats={personalStats} streakData={streakData} />}

                {/* Definition Tooltip */}
                {defData && <DefinitionTooltip defData={defData} position={defPos} onClose={() => { setDefData(null); setDefPos(null); }} />}

                {/* Sprint Final Screen */}
                {sprintFinished && sprintFinalStats && (
                    <SprintFinalScreen
                        score={sprintFinalStats.score}
                        wordsFound={sprintFinalStats.wordsFound}
                        maxScore={sprintFinalStats.maxScore}
                        totalWords={sprintFinalStats.totalWords}
                        pangrams={sprintFinalStats.pangrams}
                        onPlayAgain={sprintAgain}
                        onExit={exitSprint}
                    />
                )}
            </div>
        );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
