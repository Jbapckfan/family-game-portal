<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Spelling Bee - How many words can you make with 7 letters?">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Spelling Bee">
    <title>Spelling Bee</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Rajdhani', sans-serif;
            background: #0a0a1a;
            background-image:
                radial-gradient(ellipse at 20% 50%, rgba(120, 40, 200, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 50%, rgba(0, 200, 200, 0.06) 0%, transparent 50%);
            margin: 0; padding: 0; overflow-x: hidden;
            color: #e2e8f0; min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }
        .font-title { font-family: 'Fredoka One', cursive; }

        /* ===== HEXAGON BUTTONS ===== */
        .hex-btn {
            width: 74px; height: 82px;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; font-weight: 700;
            cursor: pointer; user-select: none; -webkit-user-drag: none;
            position: absolute; text-transform: uppercase;
            letter-spacing: 1px;
            transition: filter 0.15s;
        }
        .hex-btn:hover { filter: brightness(1.25); }
        .hex-btn:active { filter: brightness(0.85); }
        .hex-center {
            background: linear-gradient(135deg, #fbbf24, #f59e0b, #d97706);
            color: #1a1a2e;
            text-shadow: 0 1px 2px rgba(0,0,0,0.15);
            box-shadow: inset 0 0 0 3px rgba(255,255,255,0.15);
        }
        .hex-center::after {
            content: '';
            position: absolute; inset: 0;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: radial-gradient(ellipse at 30% 30%, rgba(255,255,255,0.3), transparent 60%);
            pointer-events: none;
        }
        .hex-outer {
            background: linear-gradient(135deg, #6d28d9, #7c3aed, #8b5cf6);
            color: #f3e8ff;
            text-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
        }
        .hex-outer::after {
            content: '';
            position: absolute; inset: 0;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: radial-gradient(ellipse at 30% 30%, rgba(255,255,255,0.15), transparent 60%);
            pointer-events: none;
        }

        /* Hex grid container */
        .hex-grid {
            position: relative;
            width: 240px; height: 250px;
            margin: 0 auto;
        }
        .hex-pos-c  { left: 50%; top: 50%; transform: translate(-50%, -50%); }
        .hex-pos-0  { left: 50%; top: 50%; transform: translate(-117%, -137%); }
        .hex-pos-1  { left: 50%; top: 50%; transform: translate(17%, -137%); }
        .hex-pos-2  { left: 50%; top: 50%; transform: translate(82%, -50%); }
        .hex-pos-3  { left: 50%; top: 50%; transform: translate(17%, 37%); }
        .hex-pos-4  { left: 50%; top: 50%; transform: translate(-117%, 37%); }
        .hex-pos-5  { left: 50%; top: 50%; transform: translate(-182%, -50%); }

        /* ===== ANIMATIONS ===== */
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes letterBounce {
            0% { transform: translateY(0) scale(1); }
            30% { transform: translateY(-6px) scale(1.15); }
            60% { transform: translateY(2px) scale(0.95); }
            100% { transform: translateY(0) scale(1); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            15% { transform: translateX(-10px); }
            30% { transform: translateX(10px); }
            45% { transform: translateX(-7px); }
            60% { transform: translateX(7px); }
            75% { transform: translateX(-3px); }
            90% { transform: translateX(3px); }
        }
        @keyframes slideUp {
            from { transform: translateY(12px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-12px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes wordGlow {
            0% { text-shadow: none; color: #e2e8f0; }
            30% { text-shadow: 0 0 20px #34d399; color: #34d399; }
            100% { text-shadow: none; color: #34d399; }
        }
        @keyframes pangramGlow {
            0% { text-shadow: none; }
            20% { text-shadow: 0 0 30px #fbbf24, 0 0 60px #ec4899; }
            100% { text-shadow: 0 0 10px rgba(251,191,36,0.3); }
        }
        @keyframes pangramWave {
            0% { transform: scale(1) rotate(0deg); }
            15% { transform: scale(1.15) rotate(-2deg); }
            30% { transform: scale(1.15) rotate(2deg); }
            45% { transform: scale(1.1) rotate(-1deg); }
            60% { transform: scale(1.05) rotate(1deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-25px) scale(1.3); opacity: 0.9; }
            100% { transform: translateY(-50px) scale(1); opacity: 0; }
        }
        @keyframes confettiDrop {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        @keyframes sparkle {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(90deg); opacity: 0.8; }
            100% { transform: scale(0) rotate(180deg); opacity: 0; }
        }
        @keyframes starBurst {
            0% { transform: translate(0, 0) scale(0); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(1); opacity: 0; }
        }
        @keyframes rainbowBg {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
            50% { box-shadow: 0 0 30px 10px rgba(251, 191, 36, 0.3); }
        }
        @keyframes rankUpPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.1); }
            70% { transform: scale(0.95); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        @keyframes hexShuffle {
            0% { transform: var(--from); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(0.7); opacity: 0.3; }
            100% { transform: var(--to); opacity: 1; }
        }

        .shake-anim { animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97); }
        .letter-bounce { animation: letterBounce 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .word-glow { animation: wordGlow 0.6s ease-out; }
        .pangram-wave { animation: pangramWave 0.8s cubic-bezier(0.34, 1.56, 0.64, 1); }

        /* ===== TOAST ===== */
        .toast {
            position: fixed; top: 70px; left: 50%; transform: translateX(-50%);
            padding: 12px 28px; border-radius: 14px;
            font-weight: 700; font-size: 17px; z-index: 100;
            animation: bounceIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
            white-space: nowrap;
        }
        .toast-error {
            background: rgba(30, 15, 15, 0.95);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.4);
            box-shadow: 0 8px 32px rgba(239, 68, 68, 0.2);
        }
        .toast-success {
            background: rgba(15, 30, 20, 0.95);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.4);
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.2);
        }
        .toast-pangram {
            background: linear-gradient(90deg, #78350f, #831843, #4c1d95, #164e63, #78350f);
            background-size: 300% 100%;
            animation: bounceIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), rainbowBg 3s linear infinite;
            color: white; font-size: 20px;
            border: 2px solid rgba(251, 191, 36, 0.6);
            box-shadow: 0 8px 40px rgba(245, 158, 11, 0.35);
        }
        .toast-rankup {
            background: rgba(20, 15, 30, 0.95);
            color: #fbbf24;
            border: 2px solid rgba(251, 191, 36, 0.5);
            box-shadow: 0 8px 40px rgba(251, 191, 36, 0.25);
            font-size: 20px;
            animation: rankUpPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* ===== SCORE FLOAT ===== */
        .score-float {
            position: absolute; z-index: 50;
            font-weight: 800; font-size: 24px;
            color: #fbbf24;
            animation: scoreFloat 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.8), 0 2px 4px rgba(0,0,0,0.3);
        }

        /* ===== PROGRESS BAR ===== */
        .rank-bar-wrap {
            position: relative;
            height: 10px;
            background: rgba(255,255,255,0.06);
            border-radius: 999px;
            overflow: visible;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .rank-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, #8b5cf6, #06b6d4, #34d399, #fbbf24);
            background-size: 200% 100%;
            animation: shimmer 3s linear infinite;
            transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
        }
        .rank-fill::after {
            content: '';
            position: absolute; right: 0; top: -3px; bottom: -3px; width: 4px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255,255,255,0.6), 0 0 20px rgba(251,191,36,0.4);
        }
        .rank-dot {
            width: 6px; height: 6px;
            border-radius: 50%;
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.15);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .rank-dot.active {
            width: 10px; height: 10px;
            background: #fbbf24;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.7);
        }
        .rank-dot.just-reached {
            animation: pulseGlow 1s ease-in-out 3;
        }

        /* ===== WORD CHIPS ===== */
        .word-chip {
            display: inline-block;
            padding: 4px 12px;
            margin: 3px;
            border-radius: 999px;
            font-size: 13px; font-weight: 600;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.25);
            animation: slideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }
        .word-chip:hover {
            background: rgba(139, 92, 246, 0.2);
            transform: translateY(-1px);
        }
        .word-chip.pangram {
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.15), rgba(236, 72, 153, 0.15));
            border-color: rgba(251, 191, 36, 0.5);
            color: #fbbf24; font-weight: 700;
        }
        .word-chip.latest {
            animation: bounceIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.5);
        }
        .word-chip.revealed {
            opacity: 0.5;
            font-style: italic;
            background: rgba(100, 116, 139, 0.1);
            border-color: rgba(100, 116, 139, 0.2);
            color: #64748b;
            cursor: default;
            animation: slideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .word-chip.revealed:hover {
            background: rgba(100, 116, 139, 0.15);
            transform: none;
        }

        /* ===== DEFINITION TOOLTIP ===== */
        .def-tooltip {
            position: fixed;
            z-index: 600;
            max-width: 300px;
            padding: 12px 16px;
            background: rgba(15, 15, 35, 0.97);
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 12px;
            font-size: 13px;
            color: #c4b5fd;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(139, 92, 246, 0.1);
            animation: bounceIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: auto;
        }
        .def-tooltip .def-word {
            font-weight: 700;
            color: #fbbf24;
            font-size: 15px;
            margin-bottom: 4px;
            text-transform: capitalize;
        }
        .def-tooltip .def-pos {
            font-style: italic;
            color: #8b5cf6;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .def-tooltip .def-text {
            color: #e2e8f0;
        }
        .def-tooltip .def-close {
            position: absolute;
            top: 6px; right: 10px;
            cursor: pointer;
            color: #64748b;
            font-size: 16px;
            line-height: 1;
        }
        .def-tooltip .def-close:hover {
            color: #e2e8f0;
        }

        /* ===== CURRENT WORD ===== */
        .current-word {
            font-size: 30px; font-weight: 700;
            letter-spacing: 4px; min-height: 44px;
            text-transform: uppercase;
        }
        .current-letter {
            display: inline-block;
            animation: letterBounce 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .center-highlight {
            color: #fbbf24;
            text-shadow: 0 0 12px rgba(251, 191, 36, 0.5);
        }

        /* ===== BUTTONS ===== */
        .game-btn {
            padding: 12px 22px; border-radius: 999px;
            font-weight: 700; font-size: 15px;
            border: 2px solid rgba(139, 92, 246, 0.4);
            background: rgba(139, 92, 246, 0.08);
            color: #c4b5fd; cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .game-btn:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: #8b5cf6;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.2);
        }
        .game-btn:active { transform: scale(0.92) !important; }
        .game-btn-enter {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            border-color: #8b5cf6; color: white;
        }
        .game-btn-enter:hover {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.35);
        }

        /* ===== CONFETTI ===== */
        .confetti-piece {
            position: fixed; width: 8px; height: 12px;
            z-index: 200; pointer-events: none;
            animation: confettiDrop var(--dur) linear forwards;
            animation-delay: var(--delay);
            border-radius: 2px;
        }

        /* ===== SPARKLE BURST ===== */
        .sparkle-particle {
            position: absolute;
            width: 6px; height: 6px; border-radius: 50%;
            pointer-events: none;
            animation: starBurst 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* ===== BACK BUTTON ===== */
        .back-btn {
            position: fixed; top: 12px; left: 12px;
            padding: 6px 14px;
            background: rgba(10, 10, 26, 0.85);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 10px; color: #a78bfa;
            text-decoration: none; font-size: 14px; font-weight: 600;
            z-index: 200; backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .back-btn:hover {
            border-color: #8b5cf6; color: #c4b5fd;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.2);
        }

        /* ===== SCANLINE ===== */
        .scanline {
            position: fixed; inset: 0;
            background: repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.02) 1px, rgba(0,0,0,0) 2px);
            pointer-events: none; z-index: 1000;
        }

        /* ===== MODAL ===== */
        .modal-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 500; backdrop-filter: blur(6px);
        }
        .modal-box {
            background: linear-gradient(135deg, #1e1b4b, #1a1a3e);
            border: 1px solid rgba(139, 92, 246, 0.35);
            border-radius: 20px; padding: 28px;
            max-width: 400px; width: 90%;
            box-shadow: 0 25px 70px rgba(0,0,0,0.5), 0 0 40px rgba(139, 92, 246, 0.1);
            animation: bounceIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* ===== WORDS PANEL ===== */
        .words-panel { max-height: 0; overflow: hidden; transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .words-panel.open { max-height: 400px; overflow-y: auto; }

        /* ===== MODE TOGGLE ===== */
        .mode-toggle {
            display: inline-flex; border-radius: 999px;
            border: 1px solid rgba(139, 92, 246, 0.25);
            overflow: hidden; background: rgba(139, 92, 246, 0.05);
        }
        .mode-btn {
            padding: 7px 18px; font-size: 13px; font-weight: 700;
            cursor: pointer; border: none; background: transparent;
            color: #7c7c9a; font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.25s;
        }
        .mode-btn.active {
            background: rgba(139, 92, 246, 0.25);
            color: white;
        }

        /* ===== SHUFFLE ICON ===== */
        .shuffle-icon {
            display: inline-block;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .shuffle-icon.spinning { transform: rotate(360deg); }

        /* ===== RANK UP BANNER ===== */
        .rank-banner {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 16px; text-align: center; z-index: 150;
            background: linear-gradient(180deg, rgba(251, 191, 36, 0.15), transparent);
            animation: slideDown 0.5s ease-out;
            pointer-events: none;
        }
        .rank-banner-text {
            font-size: 28px; font-weight: 800;
            background: linear-gradient(90deg, #fbbf24, #f59e0b, #ec4899, #8b5cf6);
            background-size: 200% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 2s linear infinite;
        }

        /* ===== SPRINT TIMER ===== */
        .sprint-timer {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 16px;
            border-radius: 999px;
            font-size: 22px;
            font-weight: 800;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 2px;
            border: 2px solid rgba(6, 182, 212, 0.4);
            background: rgba(6, 182, 212, 0.08);
            color: #06b6d4;
        }
        .sprint-timer.warning {
            border-color: rgba(245, 158, 11, 0.5);
            background: rgba(245, 158, 11, 0.08);
            color: #f59e0b;
            animation: pulseGlow 1s ease-in-out infinite;
        }
        .sprint-timer.danger {
            border-color: rgba(239, 68, 68, 0.5);
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            animation: pulseGlow 0.5s ease-in-out infinite;
        }

        /* ===== SPRINT FINAL SCREEN ===== */
        .sprint-final-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
            z-index: 500; backdrop-filter: blur(8px);
        }
        .sprint-final-box {
            background: linear-gradient(135deg, #1e1b4b, #0f172a);
            border: 2px solid rgba(6, 182, 212, 0.4);
            border-radius: 24px; padding: 32px;
            max-width: 380px; width: 90%;
            text-align: center;
            box-shadow: 0 25px 70px rgba(0,0,0,0.6), 0 0 60px rgba(6, 182, 212, 0.1);
            animation: bounceIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .sprint-stat {
            display: flex; justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 15px;
        }
        .sprint-stat-label { color: #94a3b8; }
        .sprint-stat-value { color: #e2e8f0; font-weight: 700; }

        /* ===== HINT PANEL ===== */
        .hint-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 12px;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            padding: 4px 0;
        }
        .hint-letter {
            font-weight: 800;
            color: #fbbf24;
            font-size: 16px;
            text-transform: uppercase;
        }
        .hint-detail {
            color: #c4b5fd;
            line-height: 1.6;
        }

        /* ===== LOADING SCREEN ===== */
        .loading-screen {
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            min-height: 60vh; gap: 20px;
        }
        .loading-spinner {
            width: 48px; height: 48px;
            border: 4px solid rgba(139, 92, 246, 0.15);
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 400px) {
            .hex-btn { width: 62px; height: 68px; font-size: 20px; }
            .hex-grid { width: 200px; height: 210px; }
            .current-word { font-size: 24px; letter-spacing: 3px; }
        }
        @media (min-width: 500px) {
            .hex-btn { width: 82px; height: 90px; font-size: 26px; }
            .hex-grid { width: 265px; height: 275px; }
        }
    </style>
</head>
<body>
    <a href="../../" class="back-btn">&#x1F3E0; Menu</a>
    <div class="scanline"></div>
    <div id="root"></div>

    <script>
    // =================== PUZZLES DATA (loaded async, with inline fallback) ===================
    const FALLBACK_PUZZLES = [{"letters":["a","d","f","h","n","s"],"center":"t","words":["anta","antas","ants","daft","data","fantast","fantasts","fast","fasts","fats","hadst","haft","hafts","handfast","handfasts","handstand","handstands","hant","hants","hast","hath","hats","natant","shaft","shafts","shat","snath","snaths","staff","staffs","stand","stands","stash","stat","statant","stats","tads","tans","tass","tats","than","that"],"pangrams":["handfast","handfasts"],"maxScore":176,"wordCount":42},{"letters":["d","e","g","i","l","n"],"center":"c","words":["cede","ceded","cedi","ceding","ceil","ceiled","ceiling","ceilinged","cell","celled","celli","celling","cilice","cine","cline","cling","clinged","clinging","clinic","decide","decided","deciding","decile","decline","declined","declining","deice","deiced","deicide","deicing","dice","diced","dicing","diligence","edenic","genic","iced","icicle","icicled","icing","incidence","incline","inclined","inclining","indigence","lenience","lice","licence","licenced","licencee","licencing","negligence","nice","niece"],"pangrams":["ceilinged","clinged","declining","diligence"],"maxScore":347,"wordCount":54},{"letters":["b","c","e","i","n","v"],"center":"l","words":["beeline","belie","believe","belive","bell","belle","bevel","bible","bile","bill","billie","bleb","blin","blini","ceil","celeb","cell","celli","cilice","civil","cline","clinic","eleven","enliven","evil","evincible","icicle","incivil","incline","invincible","leben","lenience","levee","level","levin","libel","libelee","libellee","lice","licence","licencee","lien","lieve","line","linen","linin","linn","live","liven","nellie","nibble","nielli","nill","veil","vile","vill","villein","villi","vincible"],"pangrams":["evincible","invincible","vincible"],"maxScore":294,"wordCount":59}];

    let PUZZLES = FALLBACK_PUZZLES;
    let puzzlesLoaded = false;
    let puzzlesLoadError = false;

    async function loadPuzzles() {
        try {
            const resp = await fetch('puzzles.json');
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            const data = await resp.json();
            if (Array.isArray(data) && data.length > 0) {
                PUZZLES = data;
                puzzlesLoaded = true;
                return true;
            }
            throw new Error('Invalid data');
        } catch (e) {
            console.warn('Failed to load puzzles.json, using fallback:', e);
            PUZZLES = FALLBACK_PUZZLES;
            puzzlesLoaded = true;
            puzzlesLoadError = true;
            return false;
        }
    }
    </script>

    <script type="text/babel">
    const { useState, useEffect, useCallback, useRef, useMemo } = React;

    // =================== CONFIG ===================
    const RANKS = [
        { name: 'Beginner',   pct: 0,    emoji: '' },
        { name: 'Good Start', pct: 0.02, emoji: '&#x2B50;' },
        { name: 'Moving Up',  pct: 0.05, emoji: '&#x1F31F;' },
        { name: 'Good',       pct: 0.08, emoji: '&#x1F44D;' },
        { name: 'Solid',      pct: 0.15, emoji: '&#x1F4AA;' },
        { name: 'Nice',       pct: 0.25, emoji: '&#x1F525;' },
        { name: 'Great',      pct: 0.40, emoji: '&#x1F389;' },
        { name: 'Amazing',    pct: 0.50, emoji: '&#x1F680;' },
        { name: 'Genius',     pct: 0.70, emoji: '&#x1F9E0;' },
        { name: 'Queen Bee',  pct: 1.00, emoji: '&#x1F41D;' },
    ];

    const RANK_EMOJIS = ['', '\u2B50', '\u{1F31F}', '\u{1F44D}', '\u{1F4AA}', '\u{1F525}', '\u{1F389}', '\u{1F680}', '\u{1F9E0}', '\u{1F41D}'];

    function getRank(score, max) {
        if (!max) return { idx: 0, ...RANKS[0] };
        const pct = score / max;
        let idx = 0;
        for (let i = 0; i < RANKS.length; i++) {
            if (pct >= RANKS[i].pct) idx = i;
        }
        return { idx, ...RANKS[idx] };
    }

    function getNextRank(score, max) {
        if (!max) return null;
        const pct = score / max;
        for (const r of RANKS) {
            if (pct < r.pct) return r;
        }
        return null;
    }

    function scoreWord(word, allLetters) {
        const all = new Set(allLetters);
        const wl = new Set(word);
        const isPangram = allLetters.length >= 7 && [...all].every(l => wl.has(l));
        let pts = word.length === 4 ? 1 : word.length;
        if (isPangram) pts += 7;
        return { pts, isPangram };
    }

    function getDailyIdx() {
        const d = Math.floor((Date.now() - new Date(2025,0,1)) / 86400000);
        return ((d % PUZZLES.length) + PUZZLES.length) % PUZZLES.length;
    }

    function loadSave(idx, mode) {
        try { return JSON.parse(localStorage.getItem(`sb-${mode}-${idx}`)) || []; }
        catch { return []; }
    }
    function writeSave(idx, mode, words) {
        try { localStorage.setItem(`sb-${mode}-${idx}`, JSON.stringify(words)); } catch {}
    }

    // =================== DEFINITION CACHE ===================
    const definitionCache = {};

    async function fetchDefinition(word) {
        if (definitionCache[word]) return definitionCache[word];
        try {
            const resp = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if (!resp.ok) throw new Error('Not found');
            const data = await resp.json();
            if (data && data[0] && data[0].meanings && data[0].meanings[0]) {
                const meaning = data[0].meanings[0];
                const result = {
                    word: data[0].word,
                    partOfSpeech: meaning.partOfSpeech || '',
                    definition: meaning.definitions[0]?.definition || 'No definition available.',
                };
                definitionCache[word] = result;
                return result;
            }
            throw new Error('No meanings');
        } catch (e) {
            const result = { word, partOfSpeech: '', definition: 'Definition not available.' };
            definitionCache[word] = result;
            return result;
        }
    }

    // =================== NUMBER WORDS HELPER ===================
    function numWord(n) {
        const words = ['zero','one','two','three','four','five','six','seven','eight','nine','ten',
                       'eleven','twelve','thirteen','fourteen','fifteen'];
        return n <= 15 ? words[n] : String(n);
    }

    // =================== CONFETTI ===================
    function Confetti({ active }) {
        if (!active) return null;
        const colors = ['#fbbf24','#ec4899','#8b5cf6','#06b6d4','#34d399','#f43f5e','#3b82f6'];
        const pieces = Array.from({ length: 40 }, (_, i) => {
            const style = {
                left: `${Math.random() * 100}%`,
                background: colors[i % colors.length],
                '--dur': `${1.5 + Math.random() * 1.5}s`,
                '--delay': `${Math.random() * 0.5}s`,
                width: `${6 + Math.random() * 6}px`,
                height: `${4 + Math.random() * 10}px`,
                opacity: 0.9,
                transform: `rotate(${Math.random()*360}deg)`,
            };
            return <div key={i} className="confetti-piece" style={style} />;
        });
        return <>{pieces}</>;
    }

    // =================== SPARKLE BURST ===================
    function SparkleBurst({ active }) {
        if (!active) return null;
        const colors = ['#fbbf24','#ec4899','#8b5cf6','#06b6d4','#34d399'];
        const particles = Array.from({ length: 16 }, (_, i) => {
            const angle = (i / 16) * Math.PI * 2;
            const dist = 30 + Math.random() * 50;
            return (
                <div key={i} className="sparkle-particle" style={{
                    left: '50%', top: '50%',
                    background: colors[i % colors.length],
                    boxShadow: `0 0 6px ${colors[i % colors.length]}`,
                    '--tx': `${Math.cos(angle) * dist}px`,
                    '--ty': `${Math.sin(angle) * dist}px`,
                    animationDelay: `${Math.random() * 0.15}s`,
                }} />
            );
        });
        return <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }}>{particles}</div>;
    }

    // =================== TOAST ===================
    function Toast({ data, onDone }) {
        useEffect(() => {
            const t = setTimeout(onDone, data.type === 'pangram' ? 2800 : data.type === 'rankup' ? 2500 : 1400);
            return () => clearTimeout(t);
        }, []);
        return <div className={`toast toast-${data.type}`} dangerouslySetInnerHTML={{ __html: data.message }} />;
    }

    // =================== RANK BANNER ===================
    function RankBanner({ rank, onDone }) {
        useEffect(() => {
            const t = setTimeout(onDone, 2500);
            return () => clearTimeout(t);
        }, []);
        return (
            <div className="rank-banner">
                <div className="rank-banner-text">
                    {RANK_EMOJIS[rank.idx]} {rank.name}! {RANK_EMOJIS[rank.idx]}
                </div>
            </div>
        );
    }

    // =================== RANK BAR ===================
    function RankBar({ score, maxScore, justReachedIdx }) {
        const pct = maxScore > 0 ? Math.min(score / maxScore, 1) : 0;
        const rank = getRank(score, maxScore);
        const next = getNextRank(score, maxScore);

        return (
            <div style={{ padding: '0 4px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 8 }}>
                    <span style={{ fontSize: 20, fontWeight: 800, color: '#fbbf24',
                                   textShadow: '0 0 12px rgba(251,191,36,0.35)' }}>
                        {RANK_EMOJIS[rank.idx]} {rank.name}
                    </span>
                    <span style={{ fontSize: 14, color: '#94a3b8' }}>
                        <span style={{ color: '#c4b5fd', fontWeight: 700 }}>{score}</span>
                        {next && <span> / {Math.ceil(maxScore * next.pct)} for {next.name}</span>}
                    </span>
                </div>
                <div className="rank-bar-wrap">
                    <div className="rank-fill" style={{ width: `${Math.max(pct * 100, 1)}%` }} />
                    {RANKS.slice(1).map((r, i) => (
                        <div key={i}
                             className={`rank-dot ${pct >= r.pct ? 'active' : ''} ${justReachedIdx === i + 1 ? 'just-reached' : ''}`}
                             style={{ left: `${r.pct * 100}%` }}
                             title={`${r.name} (${Math.round(r.pct * 100)}%)`}
                        />
                    ))}
                </div>
            </div>
        );
    }

    // =================== DEFINITION TOOLTIP ===================
    function DefinitionTooltip({ defData, position, onClose }) {
        if (!defData || !position) return null;
        return (
            <div className="def-tooltip" style={{ left: position.x, top: position.y }}
                 onClick={e => e.stopPropagation()}>
                <span className="def-close" onClick={onClose}>&times;</span>
                <div className="def-word">{defData.word}</div>
                {defData.partOfSpeech && <div className="def-pos">{defData.partOfSpeech}</div>}
                <div className="def-text">{defData.definition}</div>
            </div>
        );
    }

    // =================== WORDS PANEL ===================
    function WordsPanel({ found, pangrams, isOpen, onToggle, total, latestWord, revealedWords, onWordClick }) {
        return (
            <div style={{ marginTop: 14 }}>
                <div onClick={onToggle}
                     style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                              padding: '10px 14px', borderRadius: 14,
                              background: 'rgba(139,92,246,0.06)', border: '1px solid rgba(139,92,246,0.15)',
                              transition: 'all 0.2s' }}>
                    <span style={{ fontWeight: 700, fontSize: 16 }}>
                        {found.length > 0 ? `${found.length} of ${total} words` : 'No words found yet'}
                    </span>
                    <span style={{ fontSize: 16, transition: 'transform 0.3s cubic-bezier(0.34,1.56,0.64,1)',
                                   transform: isOpen ? 'rotate(180deg)' : 'rotate(0)', color: '#a78bfa' }}>
                        &#x25BC;
                    </span>
                </div>
                <div className={`words-panel ${isOpen ? 'open' : ''}`}
                     style={{ padding: isOpen ? '10px 4px' : '0 4px' }}>
                    {found.length === 0 && (!revealedWords || revealedWords.length === 0) ? (
                        <p style={{ textAlign: 'center', color: '#475569', fontSize: 14, padding: 16 }}>
                            Type or click letters to make words!
                        </p>
                    ) : (
                        <div style={{ display: 'flex', flexWrap: 'wrap' }}>
                            {found.map((w, i) => (
                                <span key={w}
                                      className={`word-chip ${pangrams.includes(w) ? 'pangram' : ''} ${w === latestWord ? 'latest' : ''}`}
                                      onClick={(e) => onWordClick && onWordClick(w, e)}>
                                    {w}
                                </span>
                            ))}
                            {revealedWords && revealedWords.map((w) => (
                                <span key={'rev-'+w}
                                      className={`word-chip revealed ${pangrams.includes(w) ? 'pangram' : ''}`}>
                                    {w}
                                </span>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // =================== HINT MODAL ===================
    function HintModal({ onClose, puzzle, found }) {
        const unfound = puzzle.words.filter(w => !found.includes(w));
        // Group by first letter, then by length
        const groups = {};
        for (const w of unfound) {
            const letter = w[0];
            if (!groups[letter]) groups[letter] = {};
            const len = w.length;
            if (!groups[letter][len]) groups[letter][len] = 0;
            groups[letter][len]++;
        }
        const sortedLetters = Object.keys(groups).sort();

        return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal-box" onClick={e => e.stopPropagation()} style={{ maxWidth: 420 }}>
                    <h2 className="font-title" style={{ fontSize: 24, color: '#fbbf24', marginBottom: 6, textAlign: 'center' }}>
                        Hints
                    </h2>
                    <p style={{ textAlign: 'center', color: '#94a3b8', fontSize: 13, marginBottom: 16 }}>
                        {unfound.length} word{unfound.length !== 1 ? 's' : ''} remaining
                    </p>
                    {unfound.length === 0 ? (
                        <p style={{ textAlign: 'center', color: '#34d399', fontSize: 16, fontWeight: 700, padding: 20 }}>
                            You found every word! Amazing!
                        </p>
                    ) : (
                        <div className="hint-grid">
                            {sortedLetters.map(letter => {
                                const lengths = Object.keys(groups[letter]).map(Number).sort((a,b) => a - b);
                                const parts = lengths.map(len => {
                                    const count = groups[letter][len];
                                    return `${numWord(count)} ${len}-letter`;
                                });
                                return (
                                    <React.Fragment key={letter}>
                                        <span className="hint-letter">{letter}:</span>
                                        <span className="hint-detail">{parts.join(', ')}</span>
                                    </React.Fragment>
                                );
                            })}
                        </div>
                    )}
                    <button className="game-btn game-btn-enter" onClick={onClose}
                            style={{ display: 'block', margin: '18px auto 0', width: '100%', fontSize: 16 }}>
                        Got It
                    </button>
                </div>
            </div>
        );
    }

    // =================== RULES MODAL ===================
    function RulesModal({ onClose, puzzle }) {
        return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal-box" onClick={e => e.stopPropagation()}>
                    <h2 className="font-title" style={{ fontSize: 26, color: '#fbbf24', marginBottom: 18, textAlign: 'center' }}>
                        How to Play
                    </h2>
                    <div style={{ fontSize: 15, lineHeight: 1.8, color: '#c4b5fd' }}>
                        <p style={{ marginBottom: 12 }}>Make words using the 7 letters. Every word <b>must</b> contain the
                        <span style={{ color: '#fbbf24', fontWeight: 700 }}> center letter</span>.</p>
                        <div style={{ background: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: '12px 16px', marginBottom: 12 }}>
                            <p style={{ margin: '4px 0' }}><span style={{color:'#a78bfa'}}>&#x2022;</span> Words must be <b>4+ letters</b></p>
                            <p style={{ margin: '4px 0' }}><span style={{color:'#a78bfa'}}>&#x2022;</span> Letters <b>can be reused</b></p>
                            <p style={{ margin: '4px 0' }}><span style={{color:'#a78bfa'}}>&#x2022;</span> <b>Center letter</b> is required</p>
                        </div>
                        <div style={{ background: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: '12px 16px', marginBottom: 12 }}>
                            <p style={{ margin: '4px 0', fontWeight: 700, color: '#fbbf24' }}>Scoring</p>
                            <p style={{ margin: '4px 0' }}>4-letter words = <b>1 point</b></p>
                            <p style={{ margin: '4px 0' }}>Longer words = <b>1 point per letter</b></p>
                            <p style={{ margin: '4px 0' }}>Pangram (all 7 letters) = <b>+7 bonus!</b></p>
                        </div>
                        <p style={{ textAlign: 'center', fontSize: 13, color: '#64748b' }}>
                            This puzzle: <b>{puzzle.wordCount}</b> words &bull; <b>{puzzle.pangrams.length}</b> pangram{puzzle.pangrams.length!==1?'s':''} &bull; max <b>{puzzle.maxScore}</b> pts
                        </p>
                    </div>
                    <button className="game-btn game-btn-enter" onClick={onClose}
                            style={{ display: 'block', margin: '18px auto 0', width: '100%', fontSize: 16 }}>
                        Let's Go!
                    </button>
                </div>
            </div>
        );
    }

    // =================== SPRINT FINAL SCREEN ===================
    function SprintFinalScreen({ score, wordsFound, maxScore, totalWords, pangrams, onPlayAgain, onExit }) {
        const rank = getRank(score, maxScore);
        return (
            <div className="sprint-final-overlay" onClick={onExit}>
                <div className="sprint-final-box" onClick={e => e.stopPropagation()}>
                    <div style={{ fontSize: 42, marginBottom: 4 }}>&#x23F1;&#xFE0F;</div>
                    <h2 className="font-title" style={{ fontSize: 28, color: '#06b6d4', marginBottom: 4 }}>
                        Time's Up!
                    </h2>
                    <p style={{ color: '#94a3b8', fontSize: 14, marginBottom: 20 }}>Sprint Complete</p>

                    <div style={{ fontSize: 48, fontWeight: 800, color: '#fbbf24',
                                  textShadow: '0 0 30px rgba(251,191,36,0.4)', marginBottom: 4 }}>
                        {score}
                    </div>
                    <div style={{ fontSize: 14, color: '#94a3b8', marginBottom: 20 }}>points</div>

                    <div style={{ background: 'rgba(0,0,0,0.2)', borderRadius: 14, padding: '12px 18px', marginBottom: 20 }}>
                        <div className="sprint-stat">
                            <span className="sprint-stat-label">Words Found</span>
                            <span className="sprint-stat-value">{wordsFound} / {totalWords}</span>
                        </div>
                        <div className="sprint-stat">
                            <span className="sprint-stat-label">Pangrams</span>
                            <span className="sprint-stat-value">{pangrams}</span>
                        </div>
                        <div className="sprint-stat">
                            <span className="sprint-stat-label">Rank Achieved</span>
                            <span className="sprint-stat-value">{RANK_EMOJIS[rank.idx]} {rank.name}</span>
                        </div>
                        <div className="sprint-stat" style={{ borderBottom: 'none' }}>
                            <span className="sprint-stat-label">Score %</span>
                            <span className="sprint-stat-value">{maxScore > 0 ? Math.round((score / maxScore) * 100) : 0}%</span>
                        </div>
                    </div>

                    <div style={{ display: 'flex', gap: 10 }}>
                        <button className="game-btn" onClick={onExit} style={{ flex: 1 }}>
                            Back
                        </button>
                        <button className="game-btn game-btn-enter" onClick={onPlayAgain} style={{ flex: 1 }}>
                            Sprint Again
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =================== MAIN APP ===================
    function App() {
        const [loading, setLoading] = useState(true);
        const [mode, setMode] = useState('daily');
        const [randomIdx, setRandomIdx] = useState(() => Math.floor(Math.random() * PUZZLES.length));
        const [sprintIdx, setSprintIdx] = useState(() => Math.floor(Math.random() * PUZZLES.length));

        // Sprint state
        const [sprintActive, setSprintActive] = useState(false);
        const [sprintTimeLeft, setSprintTimeLeft] = useState(180); // 3 minutes in seconds
        const [sprintFinished, setSprintFinished] = useState(false);
        const [sprintFinalStats, setSprintFinalStats] = useState(null);
        const sprintTimerRef = useRef(null);

        const pidx = mode === 'daily' ? getDailyIdx() : mode === 'sprint' ? sprintIdx : randomIdx;
        const puzzle = PUZZLES[pidx];
        const allLetters = useMemo(() => puzzle ? [...puzzle.letters, puzzle.center] : [], [pidx]);
        const letterSet = useMemo(() => new Set(allLetters), [allLetters]);

        const [word, setWord] = useState('');
        const [found, setFound] = useState(() => loadSave(pidx, mode));
        const [shuffleOrder, setShuffleOrder] = useState([0,1,2,3,4,5]);
        const [toast, setToast] = useState(null);
        const [floats, setFloats] = useState([]);
        const [sparkles, setSparkles] = useState(false);
        const [confetti, setConfetti] = useState(false);
        const [wordsOpen, setWordsOpen] = useState(false);
        const [showRules, setShowRules] = useState(false);
        const [showHints, setShowHints] = useState(false);
        const [shaking, setShaking] = useState(false);
        const [shuffleSpin, setShuffleSpin] = useState(false);
        const [rankBanner, setRankBanner] = useState(null);
        const [latestWord, setLatestWord] = useState('');
        const [justReachedIdx, setJustReachedIdx] = useState(-1);
        const [pressedHex, setPressedHex] = useState(null);
        const [revealedWords, setRevealedWords] = useState([]);
        const [answersRevealed, setAnswersRevealed] = useState(false);

        // Definition tooltip state
        const [defData, setDefData] = useState(null);
        const [defPos, setDefPos] = useState(null);
        const [defLoading, setDefLoading] = useState(false);

        // Load puzzles on mount
        useEffect(() => {
            loadPuzzles().then(() => {
                setLoading(false);
                // Re-initialize random index with full puzzle set
                setRandomIdx(Math.floor(Math.random() * PUZZLES.length));
                setSprintIdx(Math.floor(Math.random() * PUZZLES.length));
            });
        }, []);

        // Compute score
        const score = useMemo(() => {
            let s = 0;
            for (const w of found) { s += scoreWord(w, allLetters).pts; }
            return s;
        }, [found, allLetters]);

        // Save (not in sprint mode)
        useEffect(() => {
            if (mode !== 'sprint') writeSave(pidx, mode, found);
        }, [found, pidx, mode]);

        // Reload on puzzle change
        useEffect(() => {
            if (mode === 'sprint') {
                setFound([]);
            } else {
                setFound(loadSave(pidx, mode));
            }
            setWord('');
            setToast(null);
            setLatestWord('');
            setJustReachedIdx(-1);
            setRevealedWords([]);
            setAnswersRevealed(false);
            setDefData(null);
        }, [pidx, mode]);

        // Sprint timer
        useEffect(() => {
            if (mode === 'sprint' && sprintActive && !sprintFinished) {
                sprintTimerRef.current = setInterval(() => {
                    setSprintTimeLeft(prev => {
                        if (prev <= 1) {
                            clearInterval(sprintTimerRef.current);
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
                return () => clearInterval(sprintTimerRef.current);
            }
        }, [mode, sprintActive, sprintFinished]);

        // End sprint when timer hits 0
        useEffect(() => {
            if (mode === 'sprint' && sprintActive && sprintTimeLeft <= 0 && !sprintFinished) {
                setSprintFinished(true);
                setSprintActive(false);
                clearInterval(sprintTimerRef.current);
                const pangramCount = found.filter(w => puzzle.pangrams.includes(w)).length;
                setSprintFinalStats({
                    score,
                    wordsFound: found.length,
                    maxScore: puzzle.maxScore,
                    totalWords: puzzle.wordCount,
                    pangrams: pangramCount,
                });
            }
        }, [sprintTimeLeft, sprintActive, sprintFinished, mode]);

        // Close definition tooltip on outside click
        useEffect(() => {
            const handler = () => { setDefData(null); setDefPos(null); };
            if (defData) {
                window.addEventListener('click', handler);
                return () => window.removeEventListener('click', handler);
            }
        }, [defData]);

        // Keyboard
        useEffect(() => {
            const h = (e) => {
                if (showRules || showHints || sprintFinished) return;
                if (mode === 'sprint' && !sprintActive) return;
                const k = e.key.toLowerCase();
                if (k === 'enter') { e.preventDefault(); submitWord(); }
                else if (k === 'backspace') { e.preventDefault(); setWord(p => p.slice(0,-1)); }
                else if (k === ' ') { e.preventDefault(); doShuffle(); }
                else if (k.length === 1 && /[a-z]/.test(k)) {
                    if (letterSet.has(k)) { setWord(p => p + k); }
                    else { triggerShake(); }
                }
            };
            window.addEventListener('keydown', h);
            return () => window.removeEventListener('keydown', h);
        });

        function addLetter(l) {
            if (mode === 'sprint' && !sprintActive) return;
            setWord(p => p + l);
            setPressedHex(l);
            setTimeout(() => setPressedHex(null), 200);
        }

        function triggerShake() { setShaking(true); setTimeout(() => setShaking(false), 500); }

        function showMsg(message, type) { setToast({ message, type, id: Date.now() }); }

        function submitWord() {
            if (mode === 'sprint' && !sprintActive) return;
            const w = word.toLowerCase().trim();
            if (!w) return;
            setWord('');

            if (w.length < 4) { showMsg('Too short!', 'error'); triggerShake(); return; }
            if (!w.includes(puzzle.center)) {
                showMsg(`Missing center letter <b>${puzzle.center.toUpperCase()}</b>`, 'error');
                triggerShake(); return;
            }
            if ([...w].some(l => !letterSet.has(l))) { showMsg('Invalid letter!', 'error'); triggerShake(); return; }
            if (found.includes(w)) { showMsg('Already found!', 'error'); triggerShake(); return; }
            if (!puzzle.words.includes(w)) { showMsg('Not in word list', 'error'); triggerShake(); return; }

            // Valid!
            const { pts, isPangram } = scoreWord(w, allLetters);
            const oldRank = getRank(score, puzzle.maxScore);

            if (isPangram) {
                showMsg(`&#x1F31F; PANGRAM! +${pts} &#x1F31F;`, 'pangram');
                setSparkles(true); setTimeout(() => setSparkles(false), 800);
                setConfetti(true); setTimeout(() => setConfetti(false), 3000);
            } else {
                const msgs = pts === 1
                    ? ['Nice!', 'Good!', 'Yes!', 'Got it!', 'Yep!']
                    : pts <= 5
                    ? ['Great! +' + pts, 'Sweet! +' + pts, 'Solid! +' + pts]
                    : ['Amazing! +' + pts, 'Brilliant! +' + pts, 'Superb! +' + pts];
                showMsg(msgs[Math.floor(Math.random() * msgs.length)], 'success');
            }

            // Score float
            setFloats(p => [...p, { id: Date.now(), pts }]);
            setTimeout(() => setFloats(p => p.slice(1)), 1100);

            const newFound = [...found, w].sort();
            setFound(newFound);
            setLatestWord(w);
            setTimeout(() => setLatestWord(''), 2000);

            // Remove from revealed if it was there
            if (revealedWords.includes(w)) {
                setRevealedWords(prev => prev.filter(rw => rw !== w));
            }

            // Check rank up
            const newScore = score + pts;
            const newRank = getRank(newScore, puzzle.maxScore);
            if (newRank.idx > oldRank.idx) {
                setJustReachedIdx(newRank.idx);
                setTimeout(() => {
                    setRankBanner(newRank);
                    if (newRank.name === 'Genius' || newRank.name === 'Queen Bee') {
                        setConfetti(true);
                        setTimeout(() => setConfetti(false), 4000);
                    }
                }, 500);
                setTimeout(() => setJustReachedIdx(-1), 4000);
            }
        }

        function doShuffle() {
            setShuffleSpin(true);
            setTimeout(() => setShuffleSpin(false), 500);
            setShuffleOrder(prev => {
                const a = [...prev];
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            });
        }

        function newRandom() {
            let i; do { i = Math.floor(Math.random() * PUZZLES.length); } while (i === randomIdx);
            setRandomIdx(i);
        }

        // Sprint functions
        function startSprint() {
            const idx = Math.floor(Math.random() * PUZZLES.length);
            setSprintIdx(idx);
            setSprintTimeLeft(180);
            setSprintActive(true);
            setSprintFinished(false);
            setSprintFinalStats(null);
            setFound([]);
            setWord('');
            setRevealedWords([]);
            setAnswersRevealed(false);
        }

        function sprintAgain() {
            startSprint();
        }

        function exitSprint() {
            setSprintFinished(false);
            setSprintFinalStats(null);
            setMode('daily');
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function getTimerClass() {
            if (sprintTimeLeft <= 30) return 'sprint-timer danger';
            if (sprintTimeLeft <= 60) return 'sprint-timer warning';
            return 'sprint-timer';
        }

        // Definition lookup handler
        function handleWordClick(w, e) {
            e.stopPropagation();
            const rect = e.target.getBoundingClientRect();
            let x = rect.left;
            let y = rect.bottom + 8;
            // Keep tooltip on screen
            if (x + 300 > window.innerWidth) x = window.innerWidth - 310;
            if (x < 10) x = 10;
            if (y + 100 > window.innerHeight) y = rect.top - 80;

            setDefPos({ x, y });
            setDefData({ word: w, partOfSpeech: '', definition: 'Loading...' });
            setDefLoading(true);

            fetchDefinition(w).then(result => {
                setDefData(result);
                setDefLoading(false);
            });
        }

        // Show Answers logic
        const rank = getRank(score, puzzle ? puzzle.maxScore : 0);
        const foundPct = puzzle ? found.length / puzzle.wordCount : 0;
        const canRevealAnswers = !answersRevealed && (foundPct >= 0.5 || rank.name === 'Queen Bee');

        function handleRevealAnswers() {
            if (window.confirm('Are you sure you want to reveal all remaining words? This cannot be undone.')) {
                const unfound = puzzle.words.filter(w => !found.includes(w)).sort();
                setRevealedWords(unfound);
                setAnswersRevealed(true);
                setWordsOpen(true);
            }
        }

        // Loading screen
        if (loading || !puzzle) {
            return (
                <div className="loading-screen">
                    <div className="loading-spinner" />
                    <div style={{ color: '#a78bfa', fontSize: 18, fontWeight: 600 }}>Loading puzzles...</div>
                </div>
            );
        }

        const outerLetters = shuffleOrder.map(i => puzzle.letters[i]);

        return (
            <div style={{ maxWidth: 440, margin: '0 auto', padding: '56px 16px 30px', position: 'relative' }}>
                {/* Title */}
                <div style={{ textAlign: 'center', marginBottom: 6 }}>
                    <h1 className="font-title" style={{
                        fontSize: 34, color: '#fbbf24',
                        textShadow: '0 0 25px rgba(251,191,36,0.35), 0 0 50px rgba(251,191,36,0.15)',
                        marginBottom: 2, lineHeight: 1.2
                    }}>
                        &#x1F41D; Spelling Bee
                    </h1>
                    <p style={{ fontSize: 13, color: '#64748b', margin: 0 }}>
                        How many words can you spell?
                    </p>
                </div>

                {/* Mode + Help */}
                <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 12, marginBottom: 14 }}>
                    <div className="mode-toggle">
                        <button className={`mode-btn ${mode==='daily'?'active':''}`} onClick={()=>{setMode('daily');setWord('');setDefData(null);}}>
                            Daily
                        </button>
                        <button className={`mode-btn ${mode==='random'?'active':''}`} onClick={()=>{setMode('random');setWord('');setDefData(null);}}>
                            Free Play
                        </button>
                        <button className={`mode-btn ${mode==='sprint'?'active':''}`} onClick={()=>{setMode('sprint');setWord('');setDefData(null);if(!sprintActive){startSprint();}}}>
                            Sprint
                        </button>
                    </div>
                    <button onClick={() => setShowRules(true)}
                            style={{ width: 32, height: 32, borderRadius: '50%', border: '1px solid rgba(139,92,246,0.3)',
                                     background: 'rgba(139,92,246,0.08)', color: '#a78bfa', cursor: 'pointer',
                                     fontSize: 17, fontWeight: 700, display: 'flex', alignItems: 'center', justifyContent: 'center',
                                     fontFamily: 'serif', transition: 'all 0.2s' }}>
                        ?
                    </button>
                </div>

                {/* Sprint Timer */}
                {mode === 'sprint' && sprintActive && (
                    <div style={{ textAlign: 'center', marginBottom: 12 }}>
                        <div className={getTimerClass()}>
                            &#x23F1;&#xFE0F; {formatTime(sprintTimeLeft)}
                        </div>
                    </div>
                )}

                {/* Sprint Start Screen (if sprint mode but not active and not finished) */}
                {mode === 'sprint' && !sprintActive && !sprintFinished && (
                    <div style={{ textAlign: 'center', padding: '30px 0' }}>
                        <div style={{ fontSize: 48, marginBottom: 12 }}>&#x23F1;&#xFE0F;</div>
                        <h2 className="font-title" style={{ fontSize: 24, color: '#06b6d4', marginBottom: 8 }}>Sprint Mode</h2>
                        <p style={{ color: '#94a3b8', fontSize: 15, marginBottom: 20, lineHeight: 1.6 }}>
                            Score as many points as you can in <b style={{color:'#06b6d4'}}>3 minutes</b>!
                        </p>
                        <button className="game-btn game-btn-enter" onClick={startSprint} style={{ fontSize: 18, padding: '14px 40px' }}>
                            Start Sprint
                        </button>
                    </div>
                )}

                {/* Main game area (show for daily/random, or sprint when active) */}
                {(mode !== 'sprint' || sprintActive) && (
                    <>
                        {/* Rank Bar */}
                        <RankBar score={score} maxScore={puzzle.maxScore} justReachedIdx={justReachedIdx} />

                        {/* Current Word */}
                        <div style={{ textAlign: 'center', margin: '20px 0 6px', position: 'relative', minHeight: 52 }}>
                            <div className={`current-word ${shaking ? 'shake-anim' : ''}`}>
                                {word.length === 0 ? (
                                    <span style={{ color: '#3f3f5a', fontSize: 20, fontWeight: 400, letterSpacing: 1 }}>
                                        Type or click letters...
                                    </span>
                                ) : (
                                    [...word].map((l, i) => (
                                        <span key={`${i}-${word.length}`}
                                              className={`current-letter ${l===puzzle.center ? 'center-highlight' : ''}`}>
                                            {l.toUpperCase()}
                                        </span>
                                    ))
                                )}
                            </div>
                            <div style={{ height: 2, margin: '6px auto 0', width: '65%', maxWidth: 260,
                                          background: 'linear-gradient(90deg, transparent, rgba(139,92,246,0.3), transparent)' }} />

                            {/* Score floats */}
                            {floats.map(f => (
                                <div key={f.id} className="score-float" style={{ left: '50%', top: '30%', transform: 'translateX(-50%)' }}>
                                    +{f.pts}
                                </div>
                            ))}

                            <SparkleBurst active={sparkles} />
                        </div>

                        {/* Honeycomb */}
                        <div className="hex-grid" style={{ margin: '14px auto 18px' }}>
                            <div className={`hex-btn hex-center hex-pos-c ${pressedHex===puzzle.center?'pressed':''}`}
                                 draggable="false" onDragStart={e => e.preventDefault()}
                                 onClick={() => addLetter(puzzle.center)}>
                                {puzzle.center.toUpperCase()}
                            </div>
                            {outerLetters.map((l, i) => (
                                <div key={`${l}-${i}`}
                                     className={`hex-btn hex-outer hex-pos-${i} ${pressedHex===l?'pressed':''}`}
                                     draggable="false" onDragStart={e => e.preventDefault()}
                                     onClick={() => addLetter(l)}>
                                    {l.toUpperCase()}
                                </div>
                            ))}
                        </div>

                        {/* Action Buttons */}
                        <div style={{ display: 'flex', justifyContent: 'center', gap: 10, marginTop: 4 }}>
                            <button className="game-btn" onClick={() => setWord(p => p.slice(0,-1))}>
                                Delete
                            </button>
                            <button className="game-btn" onClick={doShuffle} title="Shuffle (Space)">
                                <span className={`shuffle-icon ${shuffleSpin?'spinning':''}`}>&#x21BB;</span> Shuffle
                            </button>
                            <button className="game-btn game-btn-enter" onClick={submitWord}>
                                Enter
                            </button>
                        </div>

                        {/* Secondary buttons row: Hint + New Puzzle (random) + Show Answers */}
                        <div style={{ display: 'flex', justifyContent: 'center', gap: 10, marginTop: 10, flexWrap: 'wrap' }}>
                            {mode !== 'sprint' && (
                                <button className="game-btn" onClick={() => setShowHints(true)} style={{ fontSize: 12 }}>
                                    &#x1F4A1; Hint
                                </button>
                            )}
                            {mode === 'random' && (
                                <button className="game-btn" onClick={newRandom} style={{ fontSize: 12 }}>
                                    &#x1F504; New Puzzle
                                </button>
                            )}
                            {mode !== 'sprint' && canRevealAnswers && (
                                <button className="game-btn" onClick={handleRevealAnswers}
                                        style={{ fontSize: 12, borderColor: 'rgba(100,116,139,0.4)', color: '#94a3b8' }}>
                                    &#x1F441; Show Answers
                                </button>
                            )}
                        </div>

                        {/* Words Panel */}
                        <WordsPanel found={found} pangrams={puzzle.pangrams}
                                    isOpen={wordsOpen} onToggle={() => setWordsOpen(p => !p)}
                                    total={puzzle.wordCount} latestWord={latestWord}
                                    revealedWords={answersRevealed ? revealedWords : []}
                                    onWordClick={handleWordClick} />

                        {/* Puzzle Info */}
                        <div style={{ textAlign: 'center', marginTop: 16, fontSize: 12, color: '#3f3f5a' }}>
                            Puzzle #{pidx + 1} &bull; {puzzle.wordCount} words &bull;{' '}
                            {puzzle.pangrams.length} pangram{puzzle.pangrams.length !== 1 ? 's' : ''} &bull;{' '}
                            Max {puzzle.maxScore} pts
                            {puzzlesLoadError && <span style={{ color: '#f59e0b' }}> (offline mode)</span>}
                        </div>
                    </>
                )}

                {/* Toast */}
                {toast && <Toast key={toast.id} data={toast} onDone={() => setToast(null)} />}

                {/* Rank Banner */}
                {rankBanner && <RankBanner rank={rankBanner} onDone={() => setRankBanner(null)} />}

                {/* Confetti */}
                <Confetti active={confetti} />

                {/* Rules Modal */}
                {showRules && <RulesModal onClose={() => setShowRules(false)} puzzle={puzzle} />}

                {/* Hint Modal */}
                {showHints && <HintModal onClose={() => setShowHints(false)} puzzle={puzzle} found={found} />}

                {/* Definition Tooltip */}
                {defData && <DefinitionTooltip defData={defData} position={defPos} onClose={() => { setDefData(null); setDefPos(null); }} />}

                {/* Sprint Final Screen */}
                {sprintFinished && sprintFinalStats && (
                    <SprintFinalScreen
                        score={sprintFinalStats.score}
                        wordsFound={sprintFinalStats.wordsFound}
                        maxScore={sprintFinalStats.maxScore}
                        totalWords={sprintFinalStats.totalWords}
                        pangrams={sprintFinalStats.pangrams}
                        onPlayAgain={sprintAgain}
                        onExit={exitSprint}
                    />
                )}
            </div>
        );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
