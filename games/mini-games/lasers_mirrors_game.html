<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Lasers and Mirrors - Aim lasers and place mirrors to hit targets in this optics puzzle.">
    <meta name="theme-color" content="#050510">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta property="og:title" content="Lasers and Mirrors">
    <meta property="og:description" content="Aim lasers and place mirrors to hit targets in this optics puzzle.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>Lasers and Mirrors - Premium Physics Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
            background: radial-gradient(circle at center, #2d4aa7 0%, #1e2b73 40%, #0f1547 100%);
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 80%, rgba(0, 255, 204, 0.06) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 20, 147, 0.06) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(138, 43, 226, 0.04) 0%, transparent 50%);
            animation: ambientPulse 8s ease-in-out infinite alternate;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes ambientPulse {
            0% { opacity: 0.6; }
            100% { opacity: 1.0; }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) translateX(0px);
                opacity: 0;
            }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% {
                transform: translateY(-10vh) translateX(20px);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes hintPulse {
            0% { transform: translate(-50%, -50%) scale(0.7); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.4; }
            100% { transform: translate(-50%, -50%) scale(0.7); opacity: 0.8; }
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 3;
        }

        .ui-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            padding: 16px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        .level-panel {
            top: max(10px, env(safe-area-inset-top));
            left: 20px;
            z-index: 10;
            padding: 12px 16px;
        }

        .controls-panel {
            top: max(10px, env(safe-area-inset-top));
            right: 20px;
            z-index: 10;
        }

        .score-text {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: #00ffcc;
            text-shadow:
                0 0 10px #00ffcc,
                0 2px 4px rgba(0, 0, 0, 0.3);
            filter: drop-shadow(0 0 8px rgba(0, 255, 204, 0.7));
            margin-bottom: 8px;
        }

        .level-text {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: #ffffff;
            text-shadow:
                0 0 10px #7799ff,
                0 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 8px;
        }

        .instruction-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.4;
        }

        .move-counter {
            font-size: 13px;
            font-weight: 600;
            color: #ffcc00;
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.6);
            margin-top: 6px;
            margin-bottom: 4px;
        }

        .game-button {
            background: linear-gradient(135deg, rgba(0, 255, 204, 0.2) 0%, rgba(0, 255, 204, 0.1) 100%);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            color: #00ffcc;
            padding: 8px 16px;
            min-height: 44px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.1s ease-in-out;
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.7);
            margin: 4px;
        }

        .game-button:hover {
            background: linear-gradient(135deg, rgba(0, 255, 204, 0.3) 0%, rgba(0, 255, 204, 0.15) 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 255, 204, 0.3);
        }

        .game-button:active {
            transform: scale(0.95);
        }

        .game-button.hint-btn {
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.2) 0%, rgba(255, 204, 0, 0.1) 100%);
            border-color: rgba(255, 204, 0, 0.3);
            color: #ffcc00;
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.7);
            font-size: 12px;
            padding: 6px 12px;
            min-height: 36px;
        }

        .game-button.hint-btn:hover {
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.3) 0%, rgba(255, 204, 0, 0.15) 100%);
            box-shadow: 0 4px 12px rgba(255, 204, 0, 0.3);
        }

        .game-button.hint-btn:disabled {
            opacity: 0.3;
            cursor: default;
            transform: none;
            box-shadow: none;
        }

        .game-button.levels-btn {
            background: linear-gradient(135deg, rgba(119, 153, 255, 0.2) 0%, rgba(119, 153, 255, 0.1) 100%);
            border-color: rgba(119, 153, 255, 0.3);
            color: #7799ff;
            text-shadow: 0 0 8px rgba(119, 153, 255, 0.7);
            font-size: 12px;
            padding: 6px 12px;
            min-height: 36px;
        }

        .game-button.levels-btn:hover {
            background: linear-gradient(135deg, rgba(119, 153, 255, 0.3) 0%, rgba(119, 153, 255, 0.15) 100%);
            box-shadow: 0 4px 12px rgba(119, 153, 255, 0.3);
        }

        .mute-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #ffffff;
            padding: 4px 10px;
            min-height: 32px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.1s ease-in-out;
            margin: 4px;
            display: inline-block;
        }

        .mute-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
        }

        .mute-btn.muted {
            opacity: 0.5;
        }

        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 28px;
            font-weight: 700;
            color: #00ffcc;
            text-shadow:
                0 0 30px #00ffcc,
                0 0 60px rgba(0, 255, 204, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.5);
            filter: drop-shadow(0 0 16px rgba(0, 255, 204, 0.8));
            z-index: 15;
            opacity: 0;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
            background: rgba(0, 0, 0, 0.5);
            padding: 16px 32px;
            border-radius: 16px;
            border: 2px solid rgba(0, 255, 204, 0.4);
            backdrop-filter: blur(8px);
            pointer-events: none;
            text-align: center;
        }

        .win-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .win-stars {
            font-size: 36px;
            display: block;
            margin-top: 8px;
            filter: none;
        }

        .win-moves {
            font-size: 14px;
            display: block;
            margin-top: 4px;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: none;
            filter: none;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        canvas:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: -2px;
        }

        canvas.drag-mode {
            cursor: move;
        }

        .laser-source {
            animation: pulse 2s infinite;
        }

        .target {
            animation: pulse 1.5s infinite;
        }

        /* Level Select Overlay */
        .level-select-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.92);
            backdrop-filter: blur(12px);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .level-select-overlay.active {
            display: flex;
        }

        .level-select-title {
            font-size: 28px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 20px rgba(119, 153, 255, 0.6);
            margin-bottom: 24px;
            letter-spacing: 2px;
        }

        .level-select-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            max-width: 560px;
            padding: 0 20px;
        }

        @media (max-width: 500px) {
            .level-select-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        .level-select-card {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            border: 2px solid rgba(119, 153, 255, 0.3);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .level-select-card:hover:not(.locked) {
            border-color: rgba(0, 255, 204, 0.6);
            background: linear-gradient(135deg, rgba(0, 255, 204, 0.1) 0%, rgba(0, 255, 204, 0.04) 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(0, 255, 204, 0.2);
        }

        .level-select-card.locked {
            opacity: 0.35;
            cursor: default;
            border-color: rgba(255, 255, 255, 0.1);
        }

        .level-select-card.current {
            border-color: rgba(0, 255, 204, 0.7);
            box-shadow: 0 0 16px rgba(0, 255, 204, 0.3), inset 0 0 12px rgba(0, 255, 204, 0.08);
        }

        .level-card-number {
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(119, 153, 255, 0.5);
        }

        .level-card-name {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
            text-align: center;
            padding: 0 4px;
        }

        .level-card-stars {
            margin-top: 6px;
            font-size: 16px;
            letter-spacing: 2px;
        }

        .level-card-lock {
            font-size: 24px;
            opacity: 0.6;
        }

        .level-select-close {
            margin-top: 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #ffffff;
            padding: 10px 32px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            min-height: 44px;
            transition: all 0.15s ease;
        }

        .level-select-close:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
        }

        /* Mirror toolbar - horizontal bar at the bottom of the screen */
        .mirror-toolbar {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 0px);
            left: 0;
            width: 100%;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(0deg, rgba(15, 21, 71, 0.95) 0%, rgba(15, 21, 71, 0.7) 100%);
            backdrop-filter: blur(12px);
            border-top: 1px solid rgba(119, 153, 255, 0.25);
            z-index: 20;
            padding: 0 16px;
        }

        .mirror-slots-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
        }

        .mirror-slot {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(119, 153, 255, 0.3);
            border-radius: 12px;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
        }

        .mirror-slot:hover {
            background: rgba(119, 153, 255, 0.15);
            border-color: rgba(119, 153, 255, 0.5);
            transform: translateY(-2px);
        }

        .mirror-slot.empty {
            opacity: 0.3;
            cursor: default;
            background: rgba(255, 255, 255, 0.03);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .mirror-slot.empty:hover {
            transform: none;
            background: rgba(255, 255, 255, 0.03);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .mirror-slot.next-to-place {
            border-color: rgba(0, 255, 204, 0.7);
            box-shadow: 0 0 12px rgba(0, 255, 204, 0.4), inset 0 0 8px rgba(0, 255, 204, 0.1);
            animation: slotPulse 1.5s ease-in-out infinite;
        }

        @keyframes slotPulse {
            0%, 100% { box-shadow: 0 0 12px rgba(0, 255, 204, 0.4), inset 0 0 8px rgba(0, 255, 204, 0.1); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 204, 0.6), inset 0 0 12px rgba(0, 255, 204, 0.2); }
        }

        .mirror-slot.dragging {
            opacity: 0.4;
            transform: scale(0.9);
            border-style: dashed;
        }

        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            filter: drop-shadow(0 0 12px rgba(119, 153, 255, 0.8));
            opacity: 0.9;
        }

        .mirror-actual {
            display: block;
            width: 44px;
            height: 44px;
        }

        button:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
  <a href="../../" style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">&#x1F3E0; Menu</a>
    <div class="game-container">
        <div class="ui-panel level-panel" style="left:80px;">
            <div class="level-text" id="levelText">LEVEL 1: FIRST BOUNCE</div>
            <div class="level-progress" id="levelProgress" style="font-size:11px;color:rgba(255,255,255,0.6);margin-bottom:4px;"></div>
            <div class="move-counter" id="moveCounter">MOVES: 0 / PAR: 1</div>
            <div class="instruction-text">
                Double-click/tap to place mirror &bull; Drag to reposition &bull; Delete key: return to storage<br>
                <span style="opacity:0.7">Keyboard: Arrow keys cycle mirrors &bull; R/Space rotate &bull; Tab for UI</span>
            </div>
        </div>

        <div class="ui-panel controls-panel">
            <div style="display:flex;gap:4px;flex-wrap:wrap;align-items:center;">
                <button class="game-button" onclick="resetGame()" aria-label="Reset level">&#x21BA; RESET</button>
                <button class="game-button" onclick="fireLaser()" aria-label="Fire laser">&#x26A1; FIRE</button>
                <button class="mute-btn" id="muteBtn" onclick="toggleMute()" aria-label="Toggle sound">&#x1F50A;</button>
            </div>
            <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:4px;">
                <button class="game-button levels-btn" onclick="showLevelSelect()" aria-label="Level select">&#x1F4CB; LEVELS</button>
                <button class="game-button hint-btn" id="hintBtn" onclick="useHint()" aria-label="Get hint">&#x1F4A1; HINT (2)</button>
            </div>
            <div class="score-text" id="modeIndicator" style="margin-top: 8px; font-size: 12px;">READY</div>
        </div>

        <div class="win-message" id="winMessage" aria-live="assertive">
            TARGET ACQUIRED!
            <span class="win-stars" id="winStars"></span>
            <span class="win-moves" id="winMoves"></span>
        </div>

        <!-- Level Select Overlay -->
        <div class="level-select-overlay" id="levelSelectOverlay">
            <div class="level-select-title">SELECT LEVEL</div>
            <div class="level-select-grid" id="levelSelectGrid"></div>
            <button class="level-select-close" onclick="hideLevelSelect()">BACK TO GAME</button>
        </div>

        <canvas id="gameCanvas" role="application" aria-label="Lasers and Mirrors interactive game board" tabindex="0"></canvas>

        <!-- Bottom horizontal mirror toolbar -->
        <div class="mirror-toolbar" role="toolbar" aria-label="Mirror inventory">
            <div id="mirrorSlots" class="mirror-slots-row">
                <!-- Mirror slots will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size to full screen minus bottom toolbar (DPI-aware)
        const dpr = window.devicePixelRatio || 1;
        let canvasCSSWidth = window.innerWidth;
        let canvasCSSHeight = window.innerHeight - 80;
        canvas.width = canvasCSSWidth * dpr;
        canvas.height = canvasCSSHeight * dpr;
        canvas.style.width = canvasCSSWidth + 'px';
        canvas.style.height = canvasCSSHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        let currentLevel = 0;
        let highestUnlockedLevel = 0;
        let keyboardMirrorIndex = -1; // Index into gameState.mirrors for keyboard focus
        let backgroundParticleInterval = null;

        // === IMPROVEMENT 1: Move counter & star ratings ===
        let moveCount = 0;
        let levelStars = {}; // { levelIndex: starCount } persisted in localStorage

        // === IMPROVEMENT 3: Hint system ===
        let hintsRemaining = 2;
        let activeHint = null; // { x, y, startTime }

        // === IMPROVEMENT 5: Sound system ===
        let audioCtx = null;
        let isMuted = false;

        // --- Level persistence ---
        const PROGRESS_KEY = 'lasersMirrorsProgress';

        function saveProgress() {
            try {
                const data = {
                    currentLevel: currentLevel,
                    highestUnlocked: highestUnlockedLevel,
                    levelStars: levelStars
                };
                localStorage.setItem(PROGRESS_KEY, JSON.stringify(data));
            } catch (e) {
                // localStorage unavailable (private browsing, quota, etc.)
            }
        }

        function loadProgress() {
            try {
                const raw = localStorage.getItem(PROGRESS_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (typeof data.currentLevel === 'number' &&
                        data.currentLevel >= 0 &&
                        data.currentLevel < LEVELS.length) {
                        currentLevel = data.currentLevel;
                    }
                    if (typeof data.highestUnlocked === 'number' &&
                        data.highestUnlocked >= 0 &&
                        data.highestUnlocked < LEVELS.length) {
                        highestUnlockedLevel = data.highestUnlocked;
                    }
                    if (data.levelStars && typeof data.levelStars === 'object') {
                        levelStars = data.levelStars;
                    }
                }
                // Load mute preference
                const muteRaw = localStorage.getItem('lasersMirrorsMuted');
                if (muteRaw === 'true') {
                    isMuted = true;
                    const muteBtn = document.getElementById('muteBtn');
                    if (muteBtn) {
                        muteBtn.textContent = '\u{1F507}';
                        muteBtn.classList.add('muted');
                    }
                }
            } catch (e) {
                // localStorage unavailable or corrupt
            }
        }

        // Level definitions -- all use only 45deg and -45deg mirrors for clean, predictable reflections.
        const M45 = Math.PI / 4;
        const M_45 = -Math.PI / 4;

        const LEVELS = [
            {
                name: "FIRST BOUNCE",
                par: 1,
                laser: { xPct: 0.05, yPct: 0.5, angle: 0 },
                target: { xPct: 0.5, yPct: 0.1 },
                obstacles: [],
                mirrors: [
                    { angle: M_45, length: 55 }
                ]
            },
            {
                name: "DOWN BELOW",
                par: 1,
                laser: { xPct: 0.05, yPct: 0.2, angle: 0 },
                target: { xPct: 0.45, yPct: 0.85 },
                obstacles: [],
                mirrors: [
                    { angle: M45, length: 55 }
                ]
            },
            {
                name: "UP AND OVER",
                par: 2,
                laser: { xPct: 0.05, yPct: 0.7, angle: 0 },
                target: { xPct: 0.85, yPct: 0.2 },
                obstacles: [
                    { xPct: 0.45, yPct: 0.35, wPct: 0.04, hPct: 0.65 }
                ],
                mirrors: [
                    { angle: M_45, length: 55 },
                    { angle: M_45, length: 55 }
                ]
            },
            {
                name: "THE DETOUR",
                par: 2,
                laser: { xPct: 0.05, yPct: 0.2, angle: 0 },
                target: { xPct: 0.85, yPct: 0.75 },
                obstacles: [
                    { xPct: 0.4, yPct: 0.0, wPct: 0.04, hPct: 0.55 }
                ],
                mirrors: [
                    { angle: M45, length: 55 },
                    { angle: M45, length: 55 }
                ]
            },
            {
                name: "BOOMERANG",
                par: 2,
                laser: { xPct: 0.05, yPct: 0.8, angle: 0 },
                target: { xPct: 0.12, yPct: 0.12 },
                obstacles: [
                    { xPct: 0.0, yPct: 0.45, wPct: 0.55, hPct: 0.04 }
                ],
                mirrors: [
                    { angle: M_45, length: 55 },
                    { angle: M45, length: 55 }
                ]
            },
            {
                name: "ZIGZAG",
                par: 3,
                laser: { xPct: 0.05, yPct: 0.2, angle: 0 },
                target: { xPct: 0.85, yPct: 0.2 },
                obstacles: [
                    { xPct: 0.3, yPct: 0.0, wPct: 0.04, hPct: 0.55 },
                    { xPct: 0.6, yPct: 0.45, wPct: 0.04, hPct: 0.55 }
                ],
                mirrors: [
                    { angle: M45, length: 55 },
                    { angle: M45, length: 55 },
                    { angle: M_45, length: 55 }
                ]
            },
            {
                name: "THE STAIRCASE",
                par: 4,
                laser: { xPct: 0.05, yPct: 0.7, angle: 0 },
                target: { xPct: 0.92, yPct: 0.7 },
                obstacles: [
                    { xPct: 0.22, yPct: 0.35, wPct: 0.04, hPct: 0.65 },
                    { xPct: 0.48, yPct: 0.0, wPct: 0.04, hPct: 0.55 },
                    { xPct: 0.74, yPct: 0.35, wPct: 0.04, hPct: 0.65 }
                ],
                mirrors: [
                    { angle: M_45, length: 55 },
                    { angle: M_45, length: 55 },
                    { angle: M45, length: 55 },
                    { angle: M45, length: 55 }
                ]
            },
            {
                name: "THE GAUNTLET",
                par: 5,
                laser: { xPct: 0.05, yPct: 0.15, angle: 0 },
                target: { xPct: 0.92, yPct: 0.85 },
                obstacles: [
                    { xPct: 0.18, yPct: 0.0, wPct: 0.04, hPct: 0.5 },
                    { xPct: 0.36, yPct: 0.5, wPct: 0.04, hPct: 0.5 },
                    { xPct: 0.54, yPct: 0.0, wPct: 0.04, hPct: 0.5 },
                    { xPct: 0.72, yPct: 0.5, wPct: 0.04, hPct: 0.5 }
                ],
                mirrors: [
                    { angle: M45, length: 55 },
                    { angle: M45, length: 55 },
                    { angle: M_45, length: 55 },
                    { angle: M_45, length: 55 },
                    { angle: M45, length: 55 }
                ]
            }
        ];

        let gameState = {
            laserSource: null,
            target: null,
            mirrors: [],
            obstacles: [],
            selectedMirror: null,
            isDragging: false,
            mouse: { x: 0, y: 0 },
            particles: [],
            won: false,
            laserPath: [],
            laserBeam: null,
            mirrorInventory: []
        };

        // ================================================================
        // IMPROVEMENT 5: Web Audio API Sound Effects
        // ================================================================
        function initAudio() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                // Web Audio not supported
            }
        }

        // Ensure AudioContext is created on first user gesture
        function ensureAudio() {
            if (!audioCtx) initAudio();
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playClinkSound() {
            if (isMuted || !audioCtx) return;
            try {
                const now = audioCtx.currentTime;
                // Metallic clink: short burst with high-frequency content
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc1.type = 'square';
                osc1.frequency.setValueAtTime(2400, now);
                osc1.frequency.exponentialRampToValueAtTime(800, now + 0.08);

                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(4800, now);
                osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.06);

                filter.type = 'highpass';
                filter.frequency.setValueAtTime(1000, now);

                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + 0.12);
                osc2.stop(now + 0.12);
            } catch (e) {}
        }

        function playLaserZapSound(segmentCount) {
            if (isMuted || !audioCtx) return;
            try {
                const now = audioCtx.currentTime;
                const duration = Math.min(0.3 + segmentCount * 0.08, 0.8);

                // Electric zap: noise-like with frequency sweep
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(80, now + duration);

                osc2.type = 'square';
                osc2.frequency.setValueAtTime(60, now);
                osc2.frequency.linearRampToValueAtTime(40, now + duration);

                // Modulate with LFO for buzzing
                const lfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();
                lfo.type = 'sine';
                lfo.frequency.setValueAtTime(30, now);
                lfoGain.gain.setValueAtTime(50, now);
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);

                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(400, now);
                filter.Q.setValueAtTime(2, now);

                gain.gain.setValueAtTime(0.08, now);
                gain.gain.setValueAtTime(0.1, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                lfo.start(now);
                osc.start(now);
                osc2.start(now);
                lfo.stop(now + duration);
                osc.stop(now + duration);
                osc2.stop(now + duration);
            } catch (e) {}
        }

        function playChimeSound() {
            if (isMuted || !audioCtx) return;
            try {
                const now = audioCtx.currentTime;
                // Satisfying chime: harmonious ascending tones
                const freqs = [523.25, 659.25, 783.99, 1046.5]; // C5, E5, G5, C6
                freqs.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, now);

                    const startTime = now + i * 0.08;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.12, startTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + 0.5);
                });
            } catch (e) {}
        }

        function playThudSound() {
            if (isMuted || !audioCtx) return;
            try {
                const now = audioCtx.currentTime;
                // Thud: low frequency drop
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);

                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.2);
            } catch (e) {}
        }

        function toggleMute() {
            ensureAudio();
            isMuted = !isMuted;
            const muteBtn = document.getElementById('muteBtn');
            if (isMuted) {
                muteBtn.textContent = '\u{1F507}';
                muteBtn.classList.add('muted');
            } else {
                muteBtn.textContent = '\u{1F50A}';
                muteBtn.classList.remove('muted');
            }
            try {
                localStorage.setItem('lasersMirrorsMuted', isMuted ? 'true' : 'false');
            } catch (e) {}
        }

        // ================================================================
        // IMPROVEMENT 1: Star calculation helpers
        // ================================================================
        function calculateStars(moves, par) {
            if (moves <= par) return 3;
            if (moves <= par + 2) return 2;
            return 1;
        }

        function getStarString(count) {
            const filled = '\u2605'; // filled star
            const empty = '\u2606';  // empty star
            let s = '';
            for (let i = 0; i < 3; i++) {
                s += (i < count) ? filled : empty;
            }
            return s;
        }

        function updateMoveCounter() {
            const level = LEVELS[currentLevel];
            const el = document.getElementById('moveCounter');
            el.textContent = `MOVES: ${moveCount} / PAR: ${level.par}`;
            if (moveCount <= level.par) {
                el.style.color = '#00ffcc';
            } else if (moveCount <= level.par + 2) {
                el.style.color = '#ffcc00';
            } else {
                el.style.color = '#ff6b6b';
            }
        }

        function incrementMoveCount() {
            moveCount++;
            updateMoveCounter();
        }

        // ================================================================
        // IMPROVEMENT 2: Level Select Screen
        // ================================================================
        function showLevelSelect() {
            const overlay = document.getElementById('levelSelectOverlay');
            const grid = document.getElementById('levelSelectGrid');
            grid.innerHTML = '';

            LEVELS.forEach((level, i) => {
                const card = document.createElement('div');
                card.className = 'level-select-card';
                const isUnlocked = i <= highestUnlockedLevel;
                const isCurrent = i === currentLevel;

                if (!isUnlocked) card.classList.add('locked');
                if (isCurrent) card.classList.add('current');

                if (isUnlocked) {
                    const numEl = document.createElement('div');
                    numEl.className = 'level-card-number';
                    numEl.textContent = i + 1;
                    card.appendChild(numEl);

                    const nameEl = document.createElement('div');
                    nameEl.className = 'level-card-name';
                    nameEl.textContent = level.name;
                    card.appendChild(nameEl);

                    const savedStars = levelStars[i];
                    if (savedStars) {
                        const starsEl = document.createElement('div');
                        starsEl.className = 'level-card-stars';
                        starsEl.textContent = getStarString(savedStars);
                        starsEl.style.color = '#ffcc00';
                        card.appendChild(starsEl);
                    }

                    card.addEventListener('click', () => {
                        hideLevelSelect();
                        loadLevel(i);
                    });
                } else {
                    const lockEl = document.createElement('div');
                    lockEl.className = 'level-card-lock';
                    lockEl.textContent = '\u{1F512}';
                    card.appendChild(lockEl);

                    const numEl = document.createElement('div');
                    numEl.className = 'level-card-name';
                    numEl.textContent = 'LEVEL ' + (i + 1);
                    card.appendChild(numEl);
                }

                grid.appendChild(card);
            });

            overlay.classList.add('active');
        }

        function hideLevelSelect() {
            document.getElementById('levelSelectOverlay').classList.remove('active');
        }

        // ================================================================
        // IMPROVEMENT 3: Hint System
        // ================================================================
        function useHint() {
            ensureAudio();
            if (hintsRemaining <= 0 || gameState.won) return;

            hintsRemaining--;
            const hintBtn = document.getElementById('hintBtn');
            hintBtn.textContent = '\u{1F4A1} HINT (' + hintsRemaining + ')';
            if (hintsRemaining <= 0) {
                hintBtn.disabled = true;
            }

            // Determine hint zone: find where the next mirror should roughly go
            // Strategy: trace the laser and find where it ends (hits boundary/obstacle)
            // The hint zone is the quadrant/area near where the beam terminates
            const hintPos = computeHintPosition();
            if (hintPos) {
                // Add some randomness so it's a general area, not exact
                const jitterX = (Math.random() - 0.5) * canvasCSSWidth * 0.12;
                const jitterY = (Math.random() - 0.5) * canvasCSSHeight * 0.12;
                activeHint = {
                    x: Math.max(40, Math.min(canvasCSSWidth - 40, hintPos.x + jitterX)),
                    y: Math.max(40, Math.min(canvasCSSHeight - 40, hintPos.y + jitterY)),
                    startTime: Date.now(),
                    duration: 2500
                };
            }
        }

        function computeHintPosition() {
            // Trace the current laser beam and find where it stops
            // The hint should point to the area near the beam's termination point
            // (which is where the player likely needs to place the next mirror)
            if (!gameState.laserBeam || gameState.laserBeam.segments.length === 0) return null;

            const segments = gameState.laserBeam.segments;
            const lastSeg = segments[segments.length - 1];

            // If the beam already hits the target, no hint needed
            if (gameState.won) return null;

            // The end of the last segment is where the beam terminates
            // A good hint is partway between the beam end and the target
            const endX = lastSeg.endX;
            const endY = lastSeg.endY;
            const targetX = gameState.target.x;
            const targetY = gameState.target.y;

            // Hint at a point roughly near the beam endpoint, biased toward needing to redirect
            // Use a point about 60% from beam end toward a midpoint
            const midX = (endX + targetX) / 2;
            const midY = (endY + targetY) / 2;
            return {
                x: endX * 0.4 + midX * 0.6,
                y: endY * 0.4 + midY * 0.6
            };
        }

        function drawHintCircle() {
            if (!activeHint) return;
            const elapsed = Date.now() - activeHint.startTime;
            if (elapsed > activeHint.duration) {
                activeHint = null;
                return;
            }

            const progress = elapsed / activeHint.duration;
            const alpha = Math.sin(progress * Math.PI) * 0.5; // fade in and out
            const pulseScale = 0.8 + 0.4 * Math.sin(elapsed / 200); // pulsing
            const radius = 60 * pulseScale;

            ctx.save();
            ctx.globalAlpha = alpha;

            // Outer glow
            const gradient = ctx.createRadialGradient(
                activeHint.x, activeHint.y, 0,
                activeHint.x, activeHint.y, radius
            );
            gradient.addColorStop(0, 'rgba(255, 204, 0, 0.3)');
            gradient.addColorStop(0.6, 'rgba(255, 204, 0, 0.1)');
            gradient.addColorStop(1, 'transparent');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(activeHint.x, activeHint.y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Ring
            ctx.strokeStyle = 'rgba(255, 204, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.arc(activeHint.x, activeHint.y, radius * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();
        }

        // ================================================================
        // Game Classes
        // ================================================================

        // Laser Source class
        class LaserSource {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.radius = 15;
                this.color = '#ff1493';
            }

            draw() {
                // Draw glow
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 3);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.5, this.color + '80');
                gradient.addColorStop(1, 'transparent');

                ctx.save();
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Draw laser source
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Draw direction indicator
                const dirX = this.x + Math.cos(this.angle) * (this.radius + 10);
                const dirY = this.y + Math.sin(this.angle) * (this.radius + 10);

                ctx.save();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(this.x + Math.cos(this.angle) * this.radius,
                          this.y + Math.sin(this.angle) * this.radius);
                ctx.lineTo(dirX, dirY);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Target class
        class Target {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.color = '#00ffcc';
                this.hit = false;
            }

            checkHit(x, y) {
                const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                return distance <= this.radius;
            }

            draw() {
                const t = Date.now() / 1000;

                if (this.hit) {
                    const pulse = 0.8 + 0.2 * Math.sin(t * 10);
                    const glowRadius = this.radius * (3 + Math.sin(t * 8) * 0.8);

                    const hitGlow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRadius);
                    hitGlow.addColorStop(0, '#ffffff');
                    hitGlow.addColorStop(0.3, '#00ffcc');
                    hitGlow.addColorStop(0.6, '#00ffcc60');
                    hitGlow.addColorStop(1, 'transparent');

                    ctx.save();
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = hitGlow;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    ctx.save();
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#00ffcc';
                    ctx.shadowBlur = 30;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    const ringPhase = (t * 3) % 1;
                    ctx.save();
                    ctx.strokeStyle = '#00ffcc';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 1 - ringPhase;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 + ringPhase * 2), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    return;
                }

                const idlePulse = 1 + 0.05 * Math.sin(t * 2);

                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2 * idlePulse);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.5, this.color + '60');
                gradient.addColorStop(1, 'transparent');

                ctx.save();
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 1.5 * idlePulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.save();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;

                for (let i = 1; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, (this.radius / 3) * i * idlePulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();

                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Mirror class -- IMPROVEMENT 4: stores percentage-based positions
        class Mirror {
            constructor(x, y, angle, length, id) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.length = length;
                this.id = id;
                this.isSelected = false;
                this.color = '#7799ff';
                this.isPlaced = false;
                this.originalInventoryIndex = -1;
                // IMPROVEMENT 4: Store position as percentages for resize handling
                this.xPct = x / canvasCSSWidth;
                this.yPct = y / canvasCSSHeight;
            }

            // IMPROVEMENT 4: Update percentage when position changes
            updatePercentage() {
                this.xPct = this.x / canvasCSSWidth;
                this.yPct = this.y / canvasCSSHeight;
            }

            // IMPROVEMENT 4: Restore pixel position from percentages after resize
            restoreFromPercentage(newWidth, newHeight) {
                this.x = this.xPct * newWidth;
                this.y = this.yPct * newHeight;
            }

            getEndpoints() {
                const halfLength = this.length / 2;
                return {
                    x1: this.x - Math.cos(this.angle) * halfLength,
                    y1: this.y - Math.sin(this.angle) * halfLength,
                    x2: this.x + Math.cos(this.angle) * halfLength,
                    y2: this.y + Math.sin(this.angle) * halfLength
                };
            }

            reflect(rayAngle) {
                const mirrorVecX = Math.cos(this.angle);
                const mirrorVecY = Math.sin(this.angle);

                const normalX = -mirrorVecY;
                const normalY = mirrorVecX;

                const incidentX = Math.cos(rayAngle);
                const incidentY = Math.sin(rayAngle);

                const dotProduct = incidentX * normalX + incidentY * normalY;

                const reflectedX = incidentX - 2 * dotProduct * normalX;
                const reflectedY = incidentY - 2 * dotProduct * normalY;

                return Math.atan2(reflectedY, reflectedX);
            }

            intersectsRay(startX, startY, angle) {
                const endpoints = this.getEndpoints();

                const rayDx = Math.cos(angle);
                const rayDy = Math.sin(angle);

                const mirrorDx = endpoints.x2 - endpoints.x1;
                const mirrorDy = endpoints.y2 - endpoints.y1;

                const denominator = rayDx * mirrorDy - rayDy * mirrorDx;

                if (Math.abs(denominator) < 0.000001) return null;

                const toMirrorX = endpoints.x1 - startX;
                const toMirrorY = endpoints.y1 - startY;

                const t = (toMirrorX * mirrorDy - toMirrorY * mirrorDx) / denominator;
                const u = (toMirrorX * rayDy - toMirrorY * rayDx) / denominator;

                if (t > 0 && u >= 0 && u <= 1) {
                    return {
                        x: startX + t * rayDx,
                        y: startY + t * rayDy,
                        distance: t
                    };
                }

                return null;
            }

            containsPoint(x, y) {
                const endpoints = this.getEndpoints();
                const distance = this.distanceToLineSegment(x, y, endpoints.x1, endpoints.y1, endpoints.x2, endpoints.y2);
                return distance <= 8;
            }

            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = dx * dx + dy * dy;

                if (length === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);

                const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / length));
                const closestX = x1 + t * dx;
                const closestY = y1 + t * dy;

                return Math.sqrt((px - closestX) ** 2 + (py - closestY) ** 2);
            }

            draw() {
                const endpoints = this.getEndpoints();

                const isSelected = this.isSelected;
                const alpha = this.isPlaced ? 1.0 : 0.6;

                const glowIntensity = this.length / 60;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = isSelected ? 25 * glowIntensity : 15 * glowIntensity;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = isSelected ? 8 : 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(endpoints.x1, endpoints.y1);
                ctx.lineTo(endpoints.x2, endpoints.y2);
                ctx.stroke();
                ctx.restore();

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, this.length / 30);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(endpoints.x1, endpoints.y1);
                ctx.lineTo(endpoints.x2, endpoints.y2);
                ctx.stroke();
                ctx.restore();

                const kbIndex = gameState.mirrors.indexOf(this);
                if (kbIndex !== -1 && kbIndex === keyboardMirrorIndex) {
                    ctx.save();
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 12;
                    ctx.setLineDash([4, 3]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.length / 2 + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                if (isSelected) {
                    ctx.save();
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                if (this.isPlaced) {
                    const normalX = -Math.sin(this.angle);
                    const normalY = Math.cos(this.angle);
                    const normalLength = 15;

                    for (let side = -1; side <= 1; side += 2) {
                        const normalEndX = this.x + normalX * normalLength * side;
                        const normalEndY = this.y + normalY * normalLength * side;

                        ctx.save();
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.3;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(normalEndX, normalEndY);
                        ctx.stroke();

                        ctx.setLineDash([]);
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(normalEndX, normalEndY, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#ff6b6b';
            }

            intersectsRay(startX, startY, angle) {
                const rays = [
                    { x1: this.x, y1: this.y, x2: this.x + this.width, y2: this.y },
                    { x1: this.x + this.width, y1: this.y, x2: this.x + this.width, y2: this.y + this.height },
                    { x1: this.x + this.width, y1: this.y + this.height, x2: this.x, y2: this.y + this.height },
                    { x1: this.x, y1: this.y + this.height, x2: this.x, y2: this.y }
                ];

                let closestIntersection = null;
                let minDistance = Infinity;

                rays.forEach(edge => {
                    const intersection = this.lineIntersection(
                        startX, startY,
                        startX + Math.cos(angle) * 1000, startY + Math.sin(angle) * 1000,
                        edge.x1, edge.y1, edge.x2, edge.y2
                    );

                    if (intersection) {
                        const distance = Math.sqrt((intersection.x - startX) ** 2 + (intersection.y - startY) ** 2);
                        if (distance < minDistance && distance > 1) {
                            minDistance = distance;
                            closestIntersection = { ...intersection, distance };
                        }
                    }
                });

                return closestIntersection;
            }

            lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < 0.0001) return null;

                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: x1 + t * (x2 - x1),
                        y: y1 + t * (y2 - y1)
                    };
                }

                return null;
            }

            draw() {
                ctx.save();
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = this.color + '60';
                ctx.fillRect(this.x - 3, this.y - 3, this.width + 6, this.height + 6);
                ctx.restore();

                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.restore();

                ctx.save();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        }

        // Laser Beam class
        class LaserBeam {
            constructor() {
                this.segments = [];
                this.particles = [];
                this.hitObstacle = false; // Track if laser hit an obstacle
            }

            calculate() {
                this.segments = [];
                this.hitObstacle = false;

                let currentX = gameState.laserSource.x + Math.cos(gameState.laserSource.angle) * gameState.laserSource.radius;
                let currentY = gameState.laserSource.y + Math.sin(gameState.laserSource.angle) * gameState.laserSource.radius;
                let currentAngle = gameState.laserSource.angle;
                let maxReflections = 20;
                let reflectionCount = 0;

                while (reflectionCount < maxReflections) {
                    let closestIntersection = null;
                    let closestDistance = Infinity;
                    let intersectedObject = null;

                    const allObjects = [...gameState.mirrors.filter(m => m.isPlaced), ...gameState.obstacles];

                    allObjects.forEach(obj => {
                        const intersection = obj.intersectsRay(currentX, currentY, currentAngle);
                        if (intersection && intersection.distance > 0.1 && intersection.distance < closestDistance) {
                            closestDistance = intersection.distance;
                            closestIntersection = intersection;
                            intersectedObject = obj;
                        }
                    });

                    const boundaryIntersection = this.getBoundaryIntersection(currentX, currentY, currentAngle);
                    if (boundaryIntersection && boundaryIntersection.distance > 0.1 && boundaryIntersection.distance < closestDistance) {
                        closestDistance = boundaryIntersection.distance;
                        closestIntersection = boundaryIntersection;
                        intersectedObject = null;
                    }

                    if (closestIntersection) {
                        this.segments.push({
                            startX: currentX,
                            startY: currentY,
                            endX: closestIntersection.x,
                            endY: closestIntersection.y,
                            angle: currentAngle
                        });

                        if (this.checkTargetHitAlongBeam(currentX, currentY, closestIntersection.x, closestIntersection.y)) {
                            this.winGame();
                            break;
                        }

                        if (!intersectedObject || intersectedObject instanceof Obstacle) {
                            if (intersectedObject instanceof Obstacle) {
                                this.hitObstacle = true;
                            }
                            break;
                        }

                        if (intersectedObject instanceof Mirror) {
                            const reflectedAngle = intersectedObject.reflect(currentAngle);

                            const offsetDistance = 1.0;
                            const reflectedDirX = Math.cos(reflectedAngle);
                            const reflectedDirY = Math.sin(reflectedAngle);

                            currentX = closestIntersection.x + reflectedDirX * offsetDistance;
                            currentY = closestIntersection.y + reflectedDirY * offsetDistance;
                            currentAngle = reflectedAngle;
                            reflectionCount++;

                            this.createReflectionParticles(closestIntersection.x, closestIntersection.y);

                            continue;
                        }
                    } else {
                        const maxDistance = Math.max(canvasCSSWidth, canvasCSSHeight) * 2;
                        const endX = currentX + Math.cos(currentAngle) * maxDistance;
                        const endY = currentY + Math.sin(currentAngle) * maxDistance;

                        this.segments.push({
                            startX: currentX,
                            startY: currentY,
                            endX: endX,
                            endY: endY,
                            angle: currentAngle
                        });

                        if (this.checkTargetHitAlongBeam(currentX, currentY, endX, endY)) {
                            this.winGame();
                        }
                        break;
                    }
                }
            }

            checkTargetHitAlongBeam(startX, startY, endX, endY) {
                const beamLength = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
                if (beamLength === 0) return false;

                const toTargetX = gameState.target.x - startX;
                const toTargetY = gameState.target.y - startY;

                const beamDx = (endX - startX) / beamLength;
                const beamDy = (endY - startY) / beamLength;

                const projection = toTargetX * beamDx + toTargetY * beamDy;

                if (projection < 0 || projection > beamLength) return false;

                const closestX = startX + projection * beamDx;
                const closestY = startY + projection * beamDy;

                const distanceToBeam = Math.sqrt((gameState.target.x - closestX) ** 2 + (gameState.target.y - closestY) ** 2);
                return distanceToBeam <= gameState.target.radius;
            }

            getBoundaryIntersection(x, y, angle) {
                const maxDist = Math.max(canvasCSSWidth, canvasCSSHeight) * 2;
                const endX = x + Math.cos(angle) * maxDist;
                const endY = y + Math.sin(angle) * maxDist;

                let closestIntersection = null;
                let minDistance = Infinity;

                const boundaries = [
                    { x1: 0, y1: 0, x2: canvasCSSWidth, y2: 0 },
                    { x1: canvasCSSWidth, y1: 0, x2: canvasCSSWidth, y2: canvasCSSHeight },
                    { x1: canvasCSSWidth, y1: canvasCSSHeight, x2: 0, y2: canvasCSSHeight },
                    { x1: 0, y1: canvasCSSHeight, x2: 0, y2: 0 }
                ];

                boundaries.forEach(boundary => {
                    const intersection = this.lineIntersection(
                        x, y, endX, endY,
                        boundary.x1, boundary.y1, boundary.x2, boundary.y2
                    );

                    if (intersection) {
                        const distance = Math.sqrt((intersection.x - x) ** 2 + (intersection.y - y) ** 2);
                        if (distance < minDistance && distance > 1) {
                            minDistance = distance;
                            closestIntersection = { ...intersection, distance };
                        }
                    }
                });

                return closestIntersection;
            }

            lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < 0.0001) return null;

                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

                if (t >= 0 && u >= 0 && u <= 1) {
                    return {
                        x: x1 + t * (x2 - x1),
                        y: y1 + t * (y2 - y1)
                    };
                }

                return null;
            }

            createReflectionParticles(x, y) {
                if (prefersReducedMotion) return;
                for (let i = 0; i < 8; i++) {
                    gameState.particles.push(new Particle(
                        x + (Math.random() - 0.5) * 10,
                        y + (Math.random() - 0.5) * 10,
                        '#7799ff'
                    ));
                }
            }

            winGame() {
                if (gameState.won) return;
                gameState.won = true;

                gameState.target.hit = true;

                // IMPROVEMENT 5: Play chime sound on win
                playChimeSound();

                const wonLevel = currentLevel;
                const hasNextLevel = wonLevel < LEVELS.length - 1;
                const nextLevel = hasNextLevel ? wonLevel + 1 : 0;
                const targetX = gameState.target.x;
                const targetY = gameState.target.y;

                // IMPROVEMENT 1: Calculate stars
                const level = LEVELS[wonLevel];
                const stars = calculateStars(moveCount, level.par);
                // Save best stars
                const prevStars = levelStars[wonLevel] || 0;
                if (stars > prevStars) {
                    levelStars[wonLevel] = stars;
                }

                if (hasNextLevel && nextLevel > highestUnlockedLevel) {
                    highestUnlockedLevel = nextLevel;
                }
                saveProgress();

                const winMsg = document.getElementById('winMessage');
                const winStarsEl = document.getElementById('winStars');
                const winMovesEl = document.getElementById('winMoves');

                const mainText = hasNextLevel
                    ? '\u2713 TARGET ACQUIRED!'
                    : '\u{1F389} ALL LEVELS COMPLETE! \u{1F389}';

                winMsg.childNodes[0].textContent = mainText + ' ';
                winStarsEl.textContent = getStarString(stars);
                winStarsEl.style.color = '#ffcc00';
                winMovesEl.textContent = `${moveCount} move${moveCount !== 1 ? 's' : ''} (par: ${level.par})` +
                    (hasNextLevel ? '  \u2192  Level ' + (wonLevel + 2) : '');

                winMsg.classList.add('show');

                if (!prefersReducedMotion) {
                    for (let i = 0; i < 50; i++) {
                        setTimeout(() => {
                            if (gameState.particles) {
                                gameState.particles.push(new Particle(
                                    targetX + (Math.random() - 0.5) * 80,
                                    targetY + (Math.random() - 0.5) * 80,
                                    ['#00ffcc', '#ff1493', '#7799ff', '#ffcc00'][Math.floor(Math.random() * 4)]
                                ));
                            }
                        }, i * 30);
                    }
                }

                setTimeout(() => {
                    winMsg.classList.remove('show');
                    gameState.won = false;
                    loadLevel(nextLevel);
                }, 2200);
            }

            draw() {
                this.segments.forEach((segment, index) => {
                    ctx.save();

                    const colors = ['#ff1493', '#ff6b6b', '#ffaa00', '#00ff88', '#0088ff'];
                    const color = colors[index % colors.length];

                    ctx.shadowColor = color;
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.moveTo(segment.startX, segment.startY);
                    ctx.lineTo(segment.endX, segment.endY);
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(segment.startX, segment.startY);
                    ctx.lineTo(segment.endX, segment.endY);
                    ctx.stroke();
                    ctx.restore();

                    if (!prefersReducedMotion && Math.random() < 0.3) {
                        const t = Math.random();
                        const x = segment.startX + (segment.endX - segment.startX) * t;
                        const y = segment.startY + (segment.endY - segment.startY) * t;

                        gameState.particles.push(new Particle(x, y, color));
                    }
                });
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 60;
                this.maxLife = 60;
                this.color = color;
                this.size = Math.random() * 3 + 1;
            }

            update(dt60) {
                this.x += this.vx * dt60;
                this.y += this.vy * dt60;
                this.vx *= Math.pow(0.98, dt60);
                this.vy *= Math.pow(0.98, dt60);
                this.life -= dt60;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Initialize game
        function loadLevel(levelIndex) {
            currentLevel = levelIndex;
            keyboardMirrorIndex = -1;

            // IMPROVEMENT 1: Reset move counter
            moveCount = 0;

            // IMPROVEMENT 3: Reset hints
            hintsRemaining = 2;
            activeHint = null;
            const hintBtn = document.getElementById('hintBtn');
            if (hintBtn) {
                hintBtn.textContent = '\u{1F4A1} HINT (2)';
                hintBtn.disabled = false;
            }

            saveProgress();
            const level = LEVELS[currentLevel];

            document.getElementById('levelText').textContent =
                `LEVEL ${currentLevel + 1}: ${level.name}`;
            document.getElementById('levelProgress').textContent =
                `${currentLevel + 1} / ${LEVELS.length}  \u2022  ${level.mirrors.length} mirror${level.mirrors.length === 1 ? '' : 's'}`;

            updateMoveCounter();

            gameState.laserSource = new LaserSource(
                canvasCSSWidth * level.laser.xPct,
                canvasCSSHeight * level.laser.yPct,
                level.laser.angle
            );

            gameState.target = new Target(
                canvasCSSWidth * level.target.xPct,
                canvasCSSHeight * level.target.yPct
            );

            gameState.obstacles = level.obstacles.map(o => new Obstacle(
                canvasCSSWidth * o.xPct,
                canvasCSSHeight * o.yPct,
                canvasCSSWidth * o.wPct,
                canvasCSSHeight * o.hPct
            ));

            gameState.mirrorInventory = level.mirrors.map((m, i) => ({
                angle: m.angle,
                length: m.length,
                id: i + 1,
                used: false
            }));

            gameState.mirrors = [];
            gameState.selectedMirror = null;
            gameState.isDragging = false;
            gameState.particles = [];
            gameState.laserBeam = new LaserBeam();

            gameState.won = false;

            createMirrorInventoryUI();

            gameState.laserBeam.calculate();

            createBackgroundParticles();
        }

        function initGame() {
            loadProgress();
            loadLevel(currentLevel);
        }

        function createMirrorInventoryUI() {
            const slotsContainer = document.getElementById('mirrorSlots');
            slotsContainer.innerHTML = '';

            gameState.mirrorInventory.forEach((mirrorData, index) => {
                const slotElement = document.createElement('div');
                slotElement.className = 'mirror-slot';
                slotElement.dataset.index = index;
                slotElement.setAttribute('role', 'button');
                slotElement.setAttribute('aria-label', `Mirror ${index + 1}: ${mirrorData.angle > 0 ? '+45' : '-45'} degrees`);
                slotElement.setAttribute('tabindex', '0');

                const mirrorCanvas = document.createElement('canvas');
                mirrorCanvas.className = 'mirror-actual';
                mirrorCanvas.width = 44;
                mirrorCanvas.height = 44;
                const mirrorCtx = mirrorCanvas.getContext('2d');

                const centerX = 22;
                const centerY = 22;
                const scale = 0.6;
                const halfLength = (mirrorData.length * scale) / 2;

                const x1 = centerX - Math.cos(mirrorData.angle) * halfLength;
                const y1 = centerY - Math.sin(mirrorData.angle) * halfLength;
                const x2 = centerX + Math.cos(mirrorData.angle) * halfLength;
                const y2 = centerY + Math.sin(mirrorData.angle) * halfLength;

                mirrorCtx.shadowColor = '#7799ff';
                mirrorCtx.shadowBlur = 10;
                mirrorCtx.strokeStyle = '#7799ff';
                mirrorCtx.lineWidth = 5;
                mirrorCtx.lineCap = 'round';
                mirrorCtx.beginPath();
                mirrorCtx.moveTo(x1, y1);
                mirrorCtx.lineTo(x2, y2);
                mirrorCtx.stroke();

                mirrorCtx.shadowBlur = 0;
                mirrorCtx.strokeStyle = '#ffffff';
                mirrorCtx.lineWidth = 2.5;
                mirrorCtx.beginPath();
                mirrorCtx.moveTo(x1, y1);
                mirrorCtx.lineTo(x2, y2);
                mirrorCtx.stroke();

                slotElement.appendChild(mirrorCanvas);

                slotElement.addEventListener('mousedown', (e) => {
                    if (!mirrorData.used) {
                        ensureAudio();
                        startDragFromStorage(index, e);
                    }
                });

                slotElement.addEventListener('touchstart', (e) => {
                    if (!mirrorData.used) {
                        ensureAudio();
                        e.preventDefault();
                        const touch = e.touches[0];
                        const touchEvent = {
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            currentTarget: e.currentTarget,
                            preventDefault: function() {}
                        };
                        startDragFromStorage(index, touchEvent, true);
                    }
                });

                slotElement.addEventListener('dblclick', (e) => {
                    if (!mirrorData.used) {
                        ensureAudio();
                        placeMirrorInCenter(index);
                    }
                });

                slotsContainer.appendChild(slotElement);
            });

            updateMirrorStorageUI();
        }

        function placeMirrorInCenter(inventoryIndex) {
            const mirrorData = gameState.mirrorInventory[inventoryIndex];

            const centerX = canvasCSSWidth / 2;
            const centerY = canvasCSSHeight / 2;

            const mirror = new Mirror(
                centerX, centerY,
                mirrorData.angle,
                mirrorData.length,
                mirrorData.id
            );

            mirror.originalInventoryIndex = inventoryIndex;
            mirror.isSelected = true;
            mirror.isPlaced = true;
            mirror.updatePercentage(); // IMPROVEMENT 4

            gameState.mirrors.push(mirror);
            gameState.selectedMirror = mirror;

            mirrorData.used = true;

            // IMPROVEMENT 1: Count the placement as a move
            incrementMoveCount();
            // IMPROVEMENT 5: Play clink sound
            playClinkSound();

            gameState.laserBeam.calculate();

            updateMirrorStorageUI();
        }

        function startDragFromStorage(inventoryIndex, e, isTouch) {
            const mirrorData = gameState.mirrorInventory[inventoryIndex];
            const slotElement = e.currentTarget;

            slotElement.classList.add('dragging');

            const dragGhost = createDragGhost(mirrorData);
            document.body.appendChild(dragGhost);

            updateDragGhost(dragGhost, e.clientX, e.clientY);

            const rect = canvas.getBoundingClientRect();
            const gameX = e.clientX - rect.left;
            const gameY = e.clientY - rect.top;

            const mirror = new Mirror(
                gameX, gameY,
                mirrorData.angle,
                mirrorData.length,
                mirrorData.id
            );

            mirror.originalInventoryIndex = inventoryIndex;
            mirror.isSelected = true;
            mirror.isPlaced = true;

            gameState.mirrors.push(mirror);
            gameState.selectedMirror = mirror;
            gameState.isDragging = true;

            mirrorData.used = true;

            // IMPROVEMENT 1: Count placement as a move
            incrementMoveCount();
            // IMPROVEMENT 5: Play clink sound
            playClinkSound();

            const handleMouseMove = (e) => {
                updateDragGhost(dragGhost, e.clientX, e.clientY);

                const rect = canvas.getBoundingClientRect();
                const gameX = e.clientX - rect.left;
                const gameY = e.clientY - rect.top;

                mirror.x = gameX;
                mirror.y = gameY;
                mirror.updatePercentage(); // IMPROVEMENT 4

                gameState.laserBeam.calculate();
            };

            const handleTouchMove = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                updateDragGhost(dragGhost, touch.clientX, touch.clientY);

                const rect = canvas.getBoundingClientRect();
                const gameX = touch.clientX - rect.left;
                const gameY = touch.clientY - rect.top;

                mirror.x = gameX;
                mirror.y = gameY;
                mirror.updatePercentage(); // IMPROVEMENT 4

                gameState.laserBeam.calculate();
            };

            const handleMouseUp = () => {
                if (dragGhost && dragGhost.parentNode) {
                    dragGhost.parentNode.removeChild(dragGhost);
                }

                slotElement.classList.remove('dragging');

                gameState.isDragging = false;
                mirror.updatePercentage(); // IMPROVEMENT 4: finalize percentage

                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                updateMirrorStorageUI();
                updateUI();
            };

            const handleTouchEnd = () => {
                if (dragGhost && dragGhost.parentNode) {
                    dragGhost.parentNode.removeChild(dragGhost);
                }

                slotElement.classList.remove('dragging');

                gameState.isDragging = false;
                mirror.updatePercentage(); // IMPROVEMENT 4: finalize percentage

                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleTouchEnd);

                updateMirrorStorageUI();
                updateUI();
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            e.preventDefault();
        }

        function createDragGhost(mirrorData) {
            const ghost = document.createElement('div');
            ghost.className = 'drag-ghost';
            ghost.style.width = '44px';
            ghost.style.height = '44px';

            const ghostCanvas = document.createElement('canvas');
            ghostCanvas.width = 44;
            ghostCanvas.height = 44;
            const ghostCtx = ghostCanvas.getContext('2d');

            const centerX = 22;
            const centerY = 22;
            const scale = 0.6;
            const halfLength = (mirrorData.length * scale) / 2;

            const x1 = centerX - Math.cos(mirrorData.angle) * halfLength;
            const y1 = centerY - Math.sin(mirrorData.angle) * halfLength;
            const x2 = centerX + Math.cos(mirrorData.angle) * halfLength;
            const y2 = centerY + Math.sin(mirrorData.angle) * halfLength;

            ghostCtx.shadowColor = '#7799ff';
            ghostCtx.shadowBlur = 12;
            ghostCtx.strokeStyle = '#7799ff';
            ghostCtx.lineWidth = 5;
            ghostCtx.lineCap = 'round';
            ghostCtx.beginPath();
            ghostCtx.moveTo(x1, y1);
            ghostCtx.lineTo(x2, y2);
            ghostCtx.stroke();

            ghostCtx.shadowBlur = 0;
            ghostCtx.strokeStyle = '#ffffff';
            ghostCtx.lineWidth = 2.5;
            ghostCtx.beginPath();
            ghostCtx.moveTo(x1, y1);
            ghostCtx.lineTo(x2, y2);
            ghostCtx.stroke();

            ghost.appendChild(ghostCanvas);
            return ghost;
        }

        function updateDragGhost(ghost, mouseX, mouseY) {
            ghost.style.left = (mouseX - 22) + 'px';
            ghost.style.top = (mouseY - 22) + 'px';
        }

        function updateMirrorStorageUI() {
            const slots = document.querySelectorAll('.mirror-slot');
            let nextMirrorIndex = gameState.mirrorInventory.findIndex(mirror => !mirror.used);

            slots.forEach((slot, index) => {
                slot.classList.remove('empty', 'next-to-place');

                if (gameState.mirrorInventory[index] && gameState.mirrorInventory[index].used) {
                    slot.classList.add('empty');
                } else if (index === nextMirrorIndex) {
                    slot.classList.add('next-to-place');
                }
            });
        }

        function createBackgroundParticles() {
            if (prefersReducedMotion) return;
            if (backgroundParticleInterval) {
                clearInterval(backgroundParticleInterval);
            }
            backgroundParticleInterval = setInterval(() => {
                if (document.querySelectorAll('.particle').length < 50) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * window.innerWidth + 'px';
                    particle.style.animationDuration = (8 + Math.random() * 4) + 's';
                    particle.style.animationDelay = Math.random() * 2 + 's';
                    document.body.appendChild(particle);

                    setTimeout(() => {
                        particle.remove();
                    }, 12000);
                }
            }, 500);
        }

        function updateUI() {
            // UI updates handled by storage system
        }

        function resetGame() {
            ensureAudio();
            // Return mirrors to storage
            gameState.mirrors.forEach(mirror => {
                if (mirror.originalInventoryIndex >= 0) {
                    gameState.mirrorInventory[mirror.originalInventoryIndex].used = false;
                }
            });

            gameState.mirrors = [];
            gameState.selectedMirror = null;
            gameState.isDragging = false;
            gameState.particles = [];
            gameState.laserBeam = new LaserBeam();
            gameState.laserBeam.calculate();

            // IMPROVEMENT 1: Reset move counter
            moveCount = 0;
            updateMoveCounter();

            // IMPROVEMENT 3: Reset hints
            hintsRemaining = 2;
            activeHint = null;
            const hintBtn = document.getElementById('hintBtn');
            if (hintBtn) {
                hintBtn.textContent = '\u{1F4A1} HINT (2)';
                hintBtn.disabled = false;
            }

            updateMirrorStorageUI();
        }

        function fireLaser() {
            ensureAudio();
            gameState.laserBeam.calculate();

            // IMPROVEMENT 5: Play laser sound
            const segCount = gameState.laserBeam.segments.length;
            playLaserZapSound(segCount);

            // IMPROVEMENT 5: Play thud if hit obstacle
            if (gameState.laserBeam.hitObstacle) {
                setTimeout(() => playThudSound(), 100);
            }
        }

        // Event handlers
        let lastTapTime = 0;

        // Track if a mirror was repositioned (dragged after already placed) for move counting
        let dragWasReposition = false;

        canvas.addEventListener('mousedown', (e) => {
            ensureAudio();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            gameState.mouse.x = x;
            gameState.mouse.y = y;

            let clickedMirror = null;
            for (let mirror of gameState.mirrors) {
                if (mirror.containsPoint(x, y)) {
                    clickedMirror = mirror;
                    break;
                }
            }

            if (clickedMirror) {
                if (gameState.selectedMirror) {
                    gameState.selectedMirror.isSelected = false;
                }
                gameState.selectedMirror = clickedMirror;
                clickedMirror.isSelected = true;
                gameState.isDragging = true;
                dragWasReposition = true; // This is a reposition of an existing mirror
            } else {
                if (gameState.selectedMirror) {
                    gameState.selectedMirror.isSelected = false;
                    gameState.selectedMirror = null;
                    gameState.isDragging = false;
                }
                dragWasReposition = false;
            }
        });

        // Double-click handler for rapid mirror placement
        canvas.addEventListener('dblclick', (e) => {
            ensureAudio();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const nextMirrorIndex = gameState.mirrorInventory.findIndex(mirror => !mirror.used);

            if (nextMirrorIndex !== -1) {
                placeNextMirrorAt(nextMirrorIndex, x, y);
            }
        });

        function placeNextMirrorAt(inventoryIndex, x, y) {
            const mirrorData = gameState.mirrorInventory[inventoryIndex];

            const mirror = new Mirror(
                x, y,
                mirrorData.angle,
                mirrorData.length,
                mirrorData.id
            );

            mirror.originalInventoryIndex = inventoryIndex;
            mirror.isSelected = true;
            mirror.isPlaced = true;
            mirror.updatePercentage(); // IMPROVEMENT 4

            if (gameState.selectedMirror) {
                gameState.selectedMirror.isSelected = false;
            }

            gameState.mirrors.push(mirror);
            gameState.selectedMirror = mirror;

            mirrorData.used = true;

            // IMPROVEMENT 1: Count placement as a move
            incrementMoveCount();
            // IMPROVEMENT 5: Play clink sound
            playClinkSound();

            gameState.laserBeam.calculate();

            updateMirrorStorageUI();
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            gameState.mouse.x = x;
            gameState.mouse.y = y;

            if (gameState.selectedMirror && gameState.isDragging) {
                gameState.selectedMirror.x = x;
                gameState.selectedMirror.y = y;
                gameState.selectedMirror.updatePercentage(); // IMPROVEMENT 4

                gameState.laserBeam.calculate();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (gameState.isDragging && dragWasReposition && gameState.selectedMirror) {
                // IMPROVEMENT 1: Count repositioning as a move
                incrementMoveCount();
                // IMPROVEMENT 5: Play clink sound for repositioning
                playClinkSound();
                gameState.selectedMirror.updatePercentage(); // IMPROVEMENT 4: finalize
            }
            gameState.isDragging = false;
            dragWasReposition = false;
        });

        // Touch events for mobile with double-tap support
        canvas.addEventListener('touchstart', (e) => {
            ensureAudio();
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;

            if (tapLength < 500 && tapLength > 0) {
                const nextMirrorIndex = gameState.mirrorInventory.findIndex(mirror => !mirror.used);
                if (nextMirrorIndex !== -1) {
                    placeNextMirrorAt(nextMirrorIndex, x, y);
                }
            } else {
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            }

            lastTapTime = currentTime;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Don't handle keyboard when level select is open
            if (document.getElementById('levelSelectOverlay').classList.contains('active')) return;

            const placedMirrors = gameState.mirrors;

            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                if (placedMirrors.length > 0) {
                    e.preventDefault();
                    keyboardMirrorIndex = (keyboardMirrorIndex + 1) % placedMirrors.length;
                    selectMirrorByKeyboard(keyboardMirrorIndex);
                }
                return;
            }
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                if (placedMirrors.length > 0) {
                    e.preventDefault();
                    keyboardMirrorIndex = keyboardMirrorIndex <= 0
                        ? placedMirrors.length - 1
                        : keyboardMirrorIndex - 1;
                    selectMirrorByKeyboard(keyboardMirrorIndex);
                }
                return;
            }

            if (e.key === 'r' || e.key === 'R' || e.key === ' ') {
                if (gameState.selectedMirror) {
                    e.preventDefault();
                    gameState.selectedMirror.angle += Math.PI / 4;
                    while (gameState.selectedMirror.angle >= Math.PI) {
                        gameState.selectedMirror.angle -= 2 * Math.PI;
                    }
                    gameState.laserBeam.calculate();
                }
                return;
            }

            // Escape closes level select
            if (e.key === 'Escape') {
                hideLevelSelect();
                return;
            }

            if (gameState.selectedMirror) {
                switch(e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (gameState.selectedMirror.originalInventoryIndex >= 0) {
                            gameState.mirrorInventory[gameState.selectedMirror.originalInventoryIndex].used = false;
                        }

                        const index = gameState.mirrors.indexOf(gameState.selectedMirror);
                        if (index > -1) {
                            gameState.mirrors.splice(index, 1);
                            gameState.selectedMirror = null;
                            gameState.isDragging = false;
                            keyboardMirrorIndex = -1;

                            gameState.laserBeam.calculate();

                            updateMirrorStorageUI();
                        }
                        break;
                }
            }
        });

        function selectMirrorByKeyboard(idx) {
            if (gameState.selectedMirror) {
                gameState.selectedMirror.isSelected = false;
            }
            const mirror = gameState.mirrors[idx];
            if (mirror) {
                mirror.isSelected = true;
                gameState.selectedMirror = mirror;
                const modeIndicator = document.getElementById('modeIndicator');
                modeIndicator.textContent = `MIRROR ${idx + 1} SELECTED`;
            }
        }

        // Game loop
        let lastFrameTime = performance.now();
        function gameLoop(now) {
            const dt = Math.min(now - lastFrameTime, 100);
            lastFrameTime = now;
            const dt60 = dt / (1000 / 60);

            ctx.clearRect(0, 0, canvasCSSWidth, canvasCSSHeight);

            canvas.className = gameState.isDragging ? 'drag-mode' : '';

            const modeIndicator = document.getElementById('modeIndicator');
            if (gameState.selectedMirror) {
                modeIndicator.textContent = gameState.isDragging ? 'POSITIONING' : 'SELECTED';
                modeIndicator.style.color = '#7799ff';
            } else {
                modeIndicator.textContent = 'READY';
                modeIndicator.style.color = '#ffffff';
            }

            gameState.particles = gameState.particles.filter(particle => {
                particle.update(dt60);
                return particle.life > 0;
            });

            gameState.obstacles.forEach(obstacle => obstacle.draw());
            gameState.mirrors.forEach(mirror => mirror.draw());
            gameState.laserSource.draw();
            gameState.target.draw();

            if (gameState.laserBeam) {
                gameState.laserBeam.draw();
            }

            gameState.particles.forEach(particle => particle.draw());

            // IMPROVEMENT 3: Draw hint circle if active
            drawHintCircle();

            requestAnimationFrame(gameLoop);
        }

        // IMPROVEMENT 4: Resize handler with mirror percentage restoration
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const currentDpr = window.devicePixelRatio || 1;
                const newCSSWidth = window.innerWidth;
                const newCSSHeight = window.innerHeight - 80;

                canvasCSSWidth = newCSSWidth;
                canvasCSSHeight = newCSSHeight;
                canvas.width = canvasCSSWidth * currentDpr;
                canvas.height = canvasCSSHeight * currentDpr;
                canvas.style.width = canvasCSSWidth + 'px';
                canvas.style.height = canvasCSSHeight + 'px';
                ctx.setTransform(currentDpr, 0, 0, currentDpr, 0, 0);

                // Reposition game elements based on new dimensions
                if (gameState.laserSource) {
                    const level = LEVELS[currentLevel];
                    gameState.laserSource.x = level.laser.xPct * canvasCSSWidth;
                    gameState.laserSource.y = level.laser.yPct * canvasCSSHeight;
                    gameState.target.x = level.target.xPct * canvasCSSWidth;
                    gameState.target.y = level.target.yPct * canvasCSSHeight;
                    gameState.obstacles.forEach((obs, i) => {
                        if (level.obstacles && level.obstacles[i]) {
                            obs.x = level.obstacles[i].xPct * canvasCSSWidth;
                            obs.y = level.obstacles[i].yPct * canvasCSSHeight;
                            obs.width = level.obstacles[i].wPct * canvasCSSWidth;
                            obs.height = level.obstacles[i].hPct * canvasCSSHeight;
                        }
                    });

                    // IMPROVEMENT 4: Restore mirrors from percentage-based positions
                    gameState.mirrors.forEach(mirror => {
                        mirror.restoreFromPercentage(canvasCSSWidth, canvasCSSHeight);
                    });

                    gameState.laserBeam.calculate();
                }
            }, 150);
        });

        // Start game
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
