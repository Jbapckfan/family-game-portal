<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Conquest">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Real-time strategy particle game - conquer the galaxy in epic 4v4 battles!">
    <meta property="og:title" content="Particle Conquest Pro">
    <meta property="og:description" content="Real-time strategy particle game â€” conquer the galaxy!">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Particle Conquest Pro">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- iOS Icons (dynamically generated) -->
    <link rel="apple-touch-icon" id="appleTouchIcon">

    <!-- Splash Screens (iOS) -->

    <title>Particle Conquest Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: system-ui, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
        }

        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            padding-top: max(12px, env(safe-area-inset-top));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            pointer-events: none;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
        
        .player-dot.player { background: #0ff; box-shadow: 0 0 10px #0ff; }
        .player-dot.enemy { background: #f44; box-shadow: 0 0 10px #f44; }
        
        .player-stats {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
        }
        
        .game-status {
            font-size: 13px;
            color: #aaa;
            text-align: center;
        }
        
        /* Abilities Bar */
        .abilities-bar {
            position: fixed;
            bottom: calc(80px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: rgba(30,30,30,0.9);
            border: 2px solid #444;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .ability-btn:hover:not(.cooldown) {
            border-color: #0ff;
            transform: scale(1.1);
        }
        
        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ability-btn .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            transition: height 0.1s linear;
        }
        
        .ability-btn .key-hint {
            font-size: 10px;
            color: #999;
            margin-top: 2px;
        }
        
        .ability-btn.active {
            border-color: #0ff;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Speed Controls */
        .speed-controls {
            position: fixed;
            top: 60px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .speed-btn {
            padding: 6px 12px;
            min-height: 44px;
            min-width: 44px;
            font-size: 12px;
            background: #222;
            border: 1px solid #444;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .speed-btn.active {
            background: #0af;
            color: #000;
            border-color: #0af;
        }
        
        /* Send Percent */
        .send-percent {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .percent-btn {
            padding: 8px 16px;
            font-size: 13px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .percent-btn.active {
            background: #0af;
            color: #000;
            border-color: #0af;
        }
        
        /* Level Info */
        .level-info {
            position: fixed;
            top: 55px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            z-index: 100;
        }
        
        /* Planet Legend */
        .planet-legend {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: max(20px, env(safe-area-inset-left));
            font-size: 10px;
            color: #aaa;
            z-index: 100;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        
        .legend-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid;
        }
        
        /* Menu */
        .menu {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 20px;
        }
        
        .menu h1 {
            font-size: 42px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu .subtitle {
            color: #999;
            font-size: 14px;
            margin-bottom: 30px;
        }
        
        .menu-section {
            margin-bottom: 25px;
            text-align: center;
        }
        
        .menu-section h3 {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 12px;
        }
        
        .difficulty-btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .diff-btn {
            padding: 12px 20px;
            font-size: 14px;
            border: 2px solid #333;
            background: #111;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diff-btn:hover { transform: scale(1.05); }
        .diff-btn.easy { border-color: #4a4; }
        .diff-btn.easy:hover { background: #4a42; }
        .diff-btn.medium { border-color: #aa4; }
        .diff-btn.medium:hover { background: #aa42; }
        .diff-btn.hard { border-color: #a44; }
        .diff-btn.hard:hover { background: #a442; }
        .diff-btn.brutal { border-color: #a0f; }
        .diff-btn.brutal:hover { background: #a0f2; }
        
        .mode-btn {
            padding: 12px 25px;
            font-size: 14px;
            border: 2px solid #555;
            background: #111;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 5px;
        }
        
        .mode-btn:hover { transform: scale(1.05); border-color: #888; }
        .mode-btn.active { border-color: #0ff; background: rgba(0, 255, 255, 0.1); }
        
        .harvest-hud {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 90;
        }
        
        .harvest-title {
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 20px #000;
            margin-bottom: 10px;
        }
        
        .harvest-subtitle {
            font-size: 16px;
            color: #aaa;
        }
        
        .harvest-progress {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
        }
        
        .harvest-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #444;
        }
        
        .harvest-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }
        
        .harvest-bar-fill.player { background: linear-gradient(90deg, #0aa, #0ff); }
        .harvest-bar-fill.enemy { background: linear-gradient(90deg, #a44, #f66); }
        
        .harvest-count {
            font-size: 14px;
            color: #888;
        }
        
        .instructions {
            max-width: 380px;
            text-align: left;
            color: #666;
            font-size: 12px;
            line-height: 1.5;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(255,255,255,0.02);
        }
        
        .instructions h4 {
            color: #888;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
        }
        
        .instructions strong { color: #0ff; }
        .instructions em { color: #f84; font-style: normal; }

        .hidden { visibility: hidden; pointer-events: none; }

        /* Feature Toggles */
        .feature-toggles {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: #111;
            border: 1px solid #333;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .feature-toggle:hover {
            border-color: #555;
        }

        .feature-toggle.active {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.1);
        }

        .feature-toggle .toggle-icon {
            font-size: 16px;
        }

        .feature-toggle .toggle-label {
            color: #888;
            font-size: 12px;
        }

        .feature-toggle.active .toggle-label {
            color: #0ff;
        }

        .feature-toggle .toggle-check {
            width: 16px;
            height: 16px;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: transparent;
        }

        .feature-toggle.active .toggle-check {
            border-color: #0ff;
            background: #0ff;
            color: #000;
        }
        
        /* Result Screen */
        .result-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            overflow: hidden;
        }

        .result-screen::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 400px;
            height: 400px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            opacity: 0.3;
            animation: resultGlow 2s ease-in-out infinite;
        }

        .result-screen.victory::before {
            background: radial-gradient(circle, #0ff 0%, transparent 70%);
        }

        .result-screen.defeat::before {
            background: radial-gradient(circle, #f44 0%, transparent 70%);
        }

        @keyframes resultGlow {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.3; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.5; }
        }

        .result-screen h1 {
            font-size: 52px;
            margin-bottom: 10px;
            letter-spacing: 8px;
            animation: titlePulse 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            z-index: 1;
        }

        @keyframes titlePulse {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(3deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .result-screen.victory h1 {
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff, 0 0 90px #08f;
        }
        .result-screen.defeat h1 {
            color: #f44;
            text-shadow: 0 0 30px #f44, 0 0 60px #f44, 0 0 90px #a00;
        }

        .result-subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .result-screen p {
            color: #aaa;
            font-size: 20px;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }

        .result-stats {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }

        .result-stat {
            text-align: center;
        }

        .result-stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
        }

        .result-stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            position: relative;
            z-index: 1;
        }

        .play-again-btn {
            padding: 14px 40px;
            font-size: 16px;
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .play-again-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .share-btn {
            padding: 14px 25px;
            font-size: 16px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #444;
            color: #fff;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .share-btn:hover {
            border-color: #0ff;
            background: rgba(0,255,255,0.1);
        }

        .menu-link-btn {
            padding: 14px 25px;
            font-size: 16px;
            background: transparent;
            border: 2px solid #333;
            color: #666;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-link-btn:hover {
            border-color: #555;
            color: #888;
        }
        
        /* Floating Combat Text */
        .float-text {
            position: fixed;
            pointer-events: none;
            font-weight: bold;
            font-size: 18px;
            animation: floatUp 1s ease-out forwards;
            z-index: 150;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }
        
        /* Ability tooltip */
        .ability-tooltip {
            position: fixed;
            background: rgba(0,0,0,0.9);
            border: 1px solid #444;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #fff;
            pointer-events: none;
            z-index: 300;
            max-width: 200px;
        }
        
        .ability-tooltip .title {
            color: #0ff;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        /* Pause Button */
        .pause-btn {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            width: 44px;
            height: 44px;
            background: rgba(30, 30, 30, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .pause-btn:hover {
            border-color: #0ff;
            transform: scale(1.1);
        }

        /* Pause Menu */
        .pause-menu {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 250;
            padding: 20px;
        }

        .pause-menu h1 {
            font-size: 48px;
            color: #fff;
            margin-bottom: 10px;
        }

        .pause-menu .pause-subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 30px;
        }

        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 30px;
        }

        .pause-menu-btn {
            padding: 14px 50px;
            font-size: 16px;
            border: 2px solid #444;
            background: #111;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 220px;
            text-align: center;
        }

        .pause-menu-btn:hover {
            border-color: #0ff;
            transform: scale(1.03);
        }

        .pause-menu-btn.primary {
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            font-weight: bold;
        }

        .pause-menu-btn.danger {
            border-color: #a44;
        }

        .pause-menu-btn.danger:hover {
            border-color: #f44;
            background: rgba(255, 68, 68, 0.1);
        }

        /* Pause Settings Section */
        .pause-settings {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            width: 100%;
        }

        .pause-settings h3 {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 15px;
            text-align: center;
        }

        .pause-settings .feature-toggles {
            justify-content: center;
        }

        /* Stats Screen */
        .stats-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
            overflow-y: auto;
        }

        .stats-screen h1 {
            font-size: 36px;
            color: #0ff;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            max-width: 600px;
            width: 100%;
            margin-bottom: 25px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-card .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #0ff;
        }

        .stat-card .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .stats-close-btn {
            padding: 12px 40px;
            font-size: 16px;
            background: #222;
            border: 2px solid #444;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
        }

        .stats-close-btn:hover {
            border-color: #0ff;
        }

        /* Daily Challenges Panel */
        .daily-panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
            max-width: 350px;
            width: 100%;
        }

        .daily-panel h3 {
            color: #ffd700;
            font-size: 14px;
            margin-bottom: 12px;
            text-align: center;
        }

        .challenge-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .challenge-item.completed {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0a0;
        }

        .challenge-icon {
            font-size: 20px;
        }

        .challenge-info {
            flex: 1;
        }

        .challenge-title {
            font-size: 12px;
            color: #fff;
            font-weight: bold;
        }

        .challenge-desc {
            font-size: 10px;
            color: #888;
        }

        .challenge-check {
            font-size: 18px;
            color: #0f0;
        }

        /* Multiplayer Lobby */
        .multiplayer-lobby {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
        }

        .multiplayer-lobby h1 {
            font-size: 36px;
            color: #0ff;
            margin-bottom: 10px;
        }

        .lobby-status {
            color: #888;
            margin-bottom: 25px;
        }

        .room-code-display {
            font-size: 48px;
            font-family: monospace;
            color: #ffd700;
            letter-spacing: 8px;
            background: rgba(255, 215, 0, 0.1);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            margin-bottom: 20px;
        }

        .join-code-input {
            font-size: 24px;
            font-family: monospace;
            text-align: center;
            letter-spacing: 5px;
            background: #111;
            border: 2px solid #444;
            color: #fff;
            padding: 12px 20px;
            border-radius: 10px;
            width: 200px;
            text-transform: uppercase;
        }

        .join-code-input:focus {
            border-color: #0ff;
            outline: none;
        }

        .lobby-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .lobby-btn {
            padding: 12px 30px;
            font-size: 16px;
            border: 2px solid #444;
            background: #111;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
        }

        .lobby-btn:hover {
            border-color: #0ff;
        }

        .lobby-btn.primary {
            background: linear-gradient(135deg, #0ff, #0af);
            border: none;
            color: #000;
            font-weight: bold;
        }

        .lobby-section {
            margin-bottom: 20px;
        }

        .mode-toggle-btns {
            display: flex;
            gap: 10px;
        }

        .mode-toggle-btn, .ai-count-btn {
            padding: 10px 20px;
            font-size: 14px;
            background: #111;
            border: 2px solid #444;
            color: #888;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-toggle-btn:hover, .ai-count-btn:hover {
            border-color: #666;
            color: #fff;
        }

        .mode-toggle-btn.active {
            background: rgba(0, 255, 255, 0.15);
            border-color: #0ff;
            color: #0ff;
        }

        .ai-count-btn.active {
            background: rgba(255, 68, 68, 0.15);
            border-color: #f44;
            color: #f44;
        }

        /* Team Lobby Styles */
        .room-header {
            text-align: center;
            margin-bottom: 15px;
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: #888;
            margin-top: 8px;
        }

        .ping-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4f4;
            animation: pulse 2s infinite;
        }

        .ping-dot.warning { background: #fa0; }
        .ping-dot.bad { background: #f44; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .team-columns {
            display: flex;
            gap: 15px;
            margin: 15px 0;
        }

        .team-col {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 12px;
            min-height: 180px;
        }

        .team-header {
            font-size: 14px;
            margin: 0 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }

        .team-header.team-0 { color: #0ff; border-color: #0ff3; }
        .team-header.team-1 { color: #f44; border-color: #f443; }

        .player-slots {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 100px;
        }

        .player-slot {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 13px;
        }

        .player-slot.is-you {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff3;
        }

        .player-slot.is-ai {
            background: rgba(255, 255, 255, 0.03);
            color: #888;
        }

        .player-slot .player-icon {
            font-size: 16px;
        }

        .player-slot .player-name {
            flex: 1;
        }

        .player-slot .player-ping {
            font-size: 10px;
            color: #666;
        }

        .player-slot .remove-btn {
            background: none;
            border: none;
            color: #f44;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            opacity: 0.6;
        }

        .player-slot .remove-btn:hover {
            opacity: 1;
        }

        .add-ai-btn {
            width: 100%;
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed #444;
            border-radius: 8px;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-ai-btn:hover {
            border-color: #888;
            color: #aaa;
        }

        .player-count {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin: 10px 0;
        }

        .lobby-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .lobby-btn.switch-team {
            background: #222;
        }

        .lobby-btn.start-btn {
            min-width: 140px;
        }

        .lobby-btn.start-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .lobby-btn.start-btn:not(:disabled) {
            animation: readyPulse 1.5s infinite;
        }

        @keyframes readyPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.4); }
            50% { box-shadow: 0 0 20px 5px rgba(0, 255, 255, 0.2); }
        }

        /* Menu buttons for new features */
        .menu-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .menu-action-btn {
            padding: 10px 20px;
            font-size: 13px;
            background: #111;
            border: 1px solid #444;
            color: #aaa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-action-btn:hover {
            border-color: #0ff;
            color: #fff;
        }

        /* Sound toggle */
        .sound-toggle {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            left: max(80px, calc(60px + env(safe-area-inset-left)));
            width: 44px;
            height: 44px;
            background: rgba(30, 30, 30, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sound-toggle:hover {
            border-color: #0ff;
        }

        .sound-toggle.muted {
            color: #666;
        }

        /* Ad-free badge */
        .ad-free-badge {
            position: fixed;
            bottom: max(10px, env(safe-area-inset-bottom));
            right: max(10px, env(safe-area-inset-right));
            font-size: 9px;
            color: #444;
            z-index: 50;
        }

        /* ============================================
           JUICE EFFECTS - Screen transitions, polish
           ============================================ */

        /* Screen transitions */
        .menu, .result-screen, .stats-screen, .multiplayer-lobby, .pause-menu {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .menu.hidden, .result-screen.hidden, .stats-screen.hidden,
        .multiplayer-lobby.hidden, .pause-menu.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        /* Button juice */
        .menu-btn, .percent-btn, .speed-btn, .ability-btn {
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .menu-btn:active, .percent-btn:active {
            transform: scale(0.95) !important;
        }

        /* Achievement toast */
        .achievement-toast {
            position: fixed;
            top: max(20px, env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%) translateY(-120px);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #ffd700;
            border-radius: 16px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 10000;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4), 0 0 60px rgba(255, 215, 0, 0.2);
            opacity: 0;
            transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55), opacity 0.3s ease;
        }

        .achievement-toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .achievement-toast .ach-icon {
            font-size: 40px;
            animation: achPop 0.5s ease 0.3s both;
        }

        .achievement-toast .ach-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .achievement-toast .ach-label {
            font-size: 11px;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .achievement-toast .ach-name {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        @keyframes achPop {
            0% { transform: scale(0) rotate(-20deg); }
            60% { transform: scale(1.3) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* Tutorial overlay */
        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            animation: fadeIn 0.5s ease forwards;
        }

        .tutorial-overlay.allow-interaction {
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
        }

        .tutorial-overlay.allow-interaction .tutorial-box {
            pointer-events: auto;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .tutorial-spotlight {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.85);
            transition: all 0.5s ease;
            pointer-events: none;
        }

        .tutorial-box {
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            border: 2px solid #0ff;
            border-radius: 20px;
            padding: 32px 40px;
            text-align: center;
            max-width: 380px;
            animation: tutorialPop 0.5s ease;
            box-shadow: 0 20px 60px rgba(0, 255, 255, 0.3);
        }

        @keyframes tutorialPop {
            0% { opacity: 0; transform: scale(0.8) translateY(20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        .tutorial-box h2 {
            font-size: 24px;
            color: #fff;
            margin-bottom: 12px;
        }

        .tutorial-box p {
            font-size: 15px;
            color: #aaa;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .tutorial-box .step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tutorial-box .step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            transition: background 0.3s ease;
        }

        .tutorial-box .step-dot.active {
            background: #0ff;
        }

        .tutorial-box .step-dot.done {
            background: #0a8;
        }

        .tutorial-btns {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .tutorial-btn {
            padding: 12px 28px;
            border-radius: 25px;
            border: none;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .tutorial-btn.primary {
            background: linear-gradient(135deg, #0ff, #0af);
            color: #000;
        }

        .tutorial-btn.secondary {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        .tutorial-btn:hover {
            transform: translateY(-2px);
        }

        .tutorial-btn.primary:hover {
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.4);
        }

        /* Difficulty selector */
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Achievement gallery */
        .achievement-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
            padding: 5px;
        }

        .ach-card {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .ach-card.unlocked {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .ach-card.locked {
            opacity: 0.5;
            filter: grayscale(1);
        }

        .ach-card .ach-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .ach-card .ach-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
        }

        .ach-card .ach-desc {
            font-size: 10px;
            color: #888;
        }

        /* Pulse animation for abilities ready */
        @keyframes abilityReady {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.6); }
        }

        .ability-btn:not(.cooldown) {
            animation: abilityReady 2s ease infinite;
        }

        /* Victory/defeat screen animations */
        .result-screen .result-title {
            animation: resultPop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes resultPop {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Selection count indicator */
        .selection-indicator {
            position: fixed;
            bottom: calc(150px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            padding: 8px 20px;
            border-radius: 20px;
            color: #0ff;
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        button:focus-visible, .diff-btn:focus-visible, .ability-btn:focus-visible, .speed-btn:focus-visible {
            outline: 2px solid #0ff;
            outline-offset: 2px;
        }

        /* ============================================
           MINIMAP
           ============================================ */
        #minimapCanvas {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom));
            right: max(20px, env(safe-area-inset-right));
            width: 140px;
            height: 140px;
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 8px;
            background: rgba(0,0,0,0.55);
            z-index: 110;
            pointer-events: none;
        }

        /* ============================================
           RALLY POINT INDICATOR
           ============================================ */
        .rally-hint {
            position: fixed;
            bottom: calc(170px + env(safe-area-inset-bottom));
            right: max(20px, env(safe-area-inset-right));
            font-size: 10px;
            color: #888;
            z-index: 110;
            text-align: right;
            pointer-events: none;
        }

        /* ============================================
           UPGRADE SCREEN (between levels)
           ============================================ */
        .upgrade-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 210;
            padding: 20px;
        }
        .upgrade-screen h1 {
            font-size: 36px;
            color: #0ff;
            margin-bottom: 8px;
            text-shadow: 0 0 20px #0ff;
        }
        .upgrade-screen .upgrade-sub {
            color: #888;
            font-size: 14px;
            margin-bottom: 30px;
        }
        .upgrade-cards {
            display: flex;
            gap: 18px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        .upgrade-card {
            width: 180px;
            padding: 24px 18px;
            background: rgba(255,255,255,0.04);
            border: 2px solid #444;
            border-radius: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.25s;
        }
        .upgrade-card:hover {
            border-color: #0ff;
            transform: translateY(-6px);
            box-shadow: 0 8px 30px rgba(0,255,255,0.25);
        }
        .upgrade-card .upg-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .upgrade-card .upg-name {
            font-size: 15px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 6px;
        }
        .upgrade-card .upg-desc {
            font-size: 12px;
            color: #aaa;
            line-height: 1.4;
        }
        .active-upgrades {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }
        .active-upgrade-tag {
            font-size: 11px;
            padding: 4px 10px;
            background: rgba(0,255,255,0.1);
            border: 1px solid #0ff3;
            border-radius: 12px;
            color: #0ff;
        }

        /* ============================================
           POST-GAME TIMELINE
           ============================================ */
        .timeline-section {
            width: 100%;
            max-width: 500px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }
        .timeline-section h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 10px;
            text-align: center;
            letter-spacing: 1px;
        }
        .timeline-bar {
            position: relative;
            height: 36px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            border: 1px solid #333;
            overflow: hidden;
        }
        .timeline-event {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            cursor: default;
            transition: transform 0.15s;
        }
        .timeline-event:hover {
            transform: translate(-50%, -50%) scale(1.5);
            z-index: 2;
        }
        .timeline-event .tl-tooltip {
            display: none;
            position: absolute;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background: #000;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: #ccc;
        }
        .timeline-event:hover .tl-tooltip { display: block; }

        .sparkline-container {
            height: 50px;
            margin-top: 10px;
            position: relative;
        }
        .sparkline-container canvas {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }

        /* ============================================
           POST-MATCH STATS DASHBOARD
           ============================================ */
        .post-match-dashboard {
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }

        .post-match-dashboard h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: 1px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        @media (max-width: 500px) {
            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .dash-stat {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            padding: 12px 8px;
            text-align: center;
        }

        .dash-stat-value {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 2px;
        }

        .dash-stat-value.cyan { color: #0ff; }
        .dash-stat-value.red { color: #f44; }
        .dash-stat-value.gold { color: #ffd700; }
        .dash-stat-value.green { color: #4f4; }

        .dash-stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .territory-graph-container {
            position: relative;
            height: 80px;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
        }

        .territory-graph-container canvas {
            width: 100%;
            height: 100%;
        }

        .territory-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 6px;
            font-size: 10px;
            color: #888;
        }

        .territory-legend span::before {
            content: '';
            display: inline-block;
            width: 10px;
            height: 3px;
            margin-right: 5px;
            vertical-align: middle;
            border-radius: 1px;
        }

        .territory-legend .tl-player::before { background: #0ff; }
        .territory-legend .tl-enemy::before { background: #f44; }
        .territory-legend .tl-neutral::before { background: #666; }

        /* Adaptive AI indicator */
        .adaptive-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: #888;
            padding: 3px 10px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid #333;
            border-radius: 12px;
            margin-left: 8px;
        }

        .adaptive-indicator .adapt-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .adaptive-indicator .adapt-dot.harder { background: #f44; }
        .adaptive-indicator .adapt-dot.balanced { background: #4f4; }
        .adaptive-indicator .adapt-dot.easier { background: #4af; }

        .result-screen .post-match-dashboard {
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #333 transparent;
        }

        .result-screen .post-match-dashboard::-webkit-scrollbar {
            width: 4px;
        }
        .result-screen .post-match-dashboard::-webkit-scrollbar-track {
            background: transparent;
        }
        .result-screen .post-match-dashboard::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 2px;
        }
    </style>
</head>
<body>
  <a href="../../" style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">ðŸ  Menu</a>
    <canvas id="canvas"></canvas>

    <!-- Pause Button -->
    <button class="pause-btn hidden" id="pauseBtn" title="Pause (P)" aria-label="Pause game">â¸ï¸</button>

    <!-- Pause Menu -->
    <div class="pause-menu hidden" id="pauseMenu">
        <h1>â¸ï¸ PAUSED</h1>
        <p class="pause-subtitle">Game paused - take a breather!</p>

        <div class="pause-menu-buttons">
            <button class="pause-menu-btn primary" id="resumeBtn">â–¶ï¸ Resume</button>
            <button class="pause-menu-btn" id="restartBtn">ðŸ”„ Restart Level</button>
            <button class="pause-menu-btn danger" id="quitBtn">ðŸšª Quit to Menu</button>
        </div>

        <div class="pause-settings">
            <h3>Settings</h3>
            <div class="feature-toggles" id="pauseFeatureToggles">
                <div class="feature-toggle" data-feature="stealth">
                    <span class="toggle-icon">ðŸ‘»</span>
                    <span class="toggle-label">Stealth</span>
                    <span class="toggle-check">âœ“</span>
                </div>
                <div class="feature-toggle" data-feature="comets">
                    <span class="toggle-icon">â˜„ï¸</span>
                    <span class="toggle-label">Comets</span>
                    <span class="toggle-check">âœ“</span>
                </div>
                <div class="feature-toggle" data-feature="fog">
                    <span class="toggle-icon">ðŸŒ«ï¸</span>
                    <span class="toggle-label">Fog</span>
                    <span class="toggle-check">âœ“</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Sound Toggle -->
    <button class="sound-toggle" id="soundToggle" title="Toggle Sound" aria-label="Toggle sound">ðŸ”Š</button>

    <!-- Stats Screen -->
    <div class="stats-screen hidden" id="statsScreen">
        <h1>ðŸ“Š Your Stats</h1>
        <div class="stats-grid" id="statsGrid"></div>
        <button class="stats-close-btn" id="statsCloseBtn">Close</button>
    </div>

    <!-- Multiplayer Lobby -->
    <div class="multiplayer-lobby hidden" id="multiplayerLobby">
        <h1 id="lobbyTitle">ðŸŒ Online Battle</h1>
        <p class="lobby-status" id="lobbyStatus">Choose an option</p>

        <!-- Initial Options (before hosting/joining) -->
        <div id="lobbyInitial">
            <div id="joinCodeContainer">
                <input type="text" class="join-code-input" id="joinCodeInput" placeholder="ENTER CODE" maxlength="6">
            </div>
            <div class="lobby-buttons">
                <button class="lobby-btn" id="lobbyBackBtn">â† Back</button>
                <button class="lobby-btn primary" id="lobbyHostBtn">ðŸŽ® Host Game</button>
                <button class="lobby-btn primary" id="lobbyJoinBtn">ðŸ”— Join Game</button>
            </div>
        </div>

        <!-- Lobby Room (after hosting/joining) -->
        <div id="lobbyRoom" class="hidden">
            <div class="room-header">
                <div class="room-code-display" id="roomCodeDisplay">------</div>
                <p style="color:#888; font-size:11px;">Share code with friends</p>
                <div class="connection-status" id="connectionStatus">
                    <span class="ping-dot"></span>
                    <span id="pingValue">--</span>ms
                </div>
            </div>

            <!-- Game Mode Toggle -->
            <div id="gameModeContainer" class="lobby-section">
                <div class="mode-toggle-btns">
                    <button class="mode-toggle-btn active" data-mpmode="coop">ðŸ¤ Co-op vs AI</button>
                    <button class="mode-toggle-btn" data-mpmode="pvp">âš”ï¸ Team PvP</button>
                </div>
            </div>

            <!-- Team Columns -->
            <div class="team-columns" id="teamColumns">
                <div class="team-col" data-team="0">
                    <h3 class="team-header team-0">ðŸ”µ Team Cyan</h3>
                    <div class="player-slots" id="team0Slots"></div>
                    <button class="add-ai-btn" data-team="0">+ Add AI</button>
                </div>
                <div class="team-col" data-team="1">
                    <h3 class="team-header team-1">ðŸ”´ Team Red</h3>
                    <div class="player-slots" id="team1Slots"></div>
                    <button class="add-ai-btn" data-team="1">+ Add AI</button>
                </div>
            </div>

            <!-- Player Count -->
            <div class="player-count" id="playerCount">
                <span id="humanCount">1</span> Players â€¢ <span id="aiCount">0</span> AI
            </div>

            <!-- Lobby Actions -->
            <div class="lobby-actions">
                <button class="lobby-btn" id="lobbyLeaveBtn">Leave</button>
                <button class="lobby-btn switch-team" id="switchTeamBtn">Switch Team</button>
                <button class="lobby-btn primary start-btn" id="startGameBtn" disabled>Start Game</button>
            </div>
        </div>
    </div>

    <!-- Ad-free Badge -->
    <div class="ad-free-badge">âœ¨ Ad-free â€¢ No login required</div>

    <div class="hud">
        <div class="player-info" aria-label="Player stats">
            <div class="player-dot player"></div>
            <div class="player-stats" id="playerStats">0</div>
            <span style="color:#0ff; font-size:12px; margin-left:5px;">YOU</span>
        </div>
        <div class="game-status" id="gameStatus" role="status" aria-live="polite">Select a planet</div>
        <div class="player-info" aria-label="Enemy stats">
            <span style="color:#f44; font-size:12px; margin-right:5px;">AI</span>
            <div class="player-stats" id="enemyStats">0</div>
            <div class="player-dot enemy"></div>
        </div>
    </div>

    <div class="level-info" id="levelInfo">Level 1<span class="adaptive-indicator hidden" id="adaptiveIndicator"><span class="adapt-dot balanced"></span> <span id="adaptiveLabel">Balanced</span></span></div>

    <div class="harvest-hud hidden" id="harvestHud">
        <div class="harvest-title">ðŸŒ¾ HARVEST PHASE</div>
        <div class="harvest-subtitle">Tap particles â†’ Tap YOUR planet to collect!</div>
    </div>

    <div class="harvest-progress hidden" id="harvestProgress">
        <div style="text-align:center;">
            <div class="harvest-bar"><div class="harvest-bar-fill player" id="playerHarvestBar" style="width:0%"></div></div>
            <div class="harvest-count"><span id="playerHarvested">0</span> collected</div>
        </div>
        <div class="harvest-count" id="remainingParticles">100 remaining</div>
        <div style="text-align:center;">
            <div class="harvest-bar"><div class="harvest-bar-fill enemy" id="enemyHarvestBar" style="width:0%"></div></div>
            <div class="harvest-count"><span id="enemyHarvested">0</span> collected</div>
        </div>
    </div>

    <div class="speed-controls" id="speedControls">
        <button class="speed-btn" data-speed="0.5">Â½x</button>
        <button class="speed-btn active" data-speed="1">1x</button>
        <button class="speed-btn" data-speed="2">2x</button>
        <button class="speed-btn" data-speed="3">3x</button>
    </div>

    <div class="abilities-bar" id="abilitiesBar">
        <button class="ability-btn" data-ability="boost" title="Speed Boost" aria-label="Boost ability">
            âš¡
            <span class="key-hint">1</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="shield" title="Shield" aria-label="Shield ability">
            ðŸ›¡ï¸
            <span class="key-hint">2</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="emp" title="EMP" aria-label="EMP ability">
            ðŸ’¥
            <span class="key-hint">3</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="nuke" title="Nuke" aria-label="Nuke ability">
            â˜¢ï¸
            <span class="key-hint">4</span>
            <div class="cooldown-overlay"></div>
        </button>
        <button class="ability-btn" data-ability="stealth" title="Stealth Attack" id="stealthBtn" style="display:none;" aria-label="Stealth ability">
            ðŸ‘»
            <span class="key-hint">5</span>
            <div class="cooldown-overlay"></div>
        </button>
    </div>

    <div class="send-percent" id="sendPercent">
        <button class="percent-btn" data-pct="25">25%</button>
        <button class="percent-btn" data-pct="50">50%</button>
        <button class="percent-btn active" data-pct="75">75%</button>
        <button class="percent-btn" data-pct="100">ALL</button>
    </div>

    <div class="planet-legend" id="planetLegend">
        <div style="margin-bottom:8px; padding-bottom:5px; border-bottom:1px solid #333;">
            <div class="legend-item"><div class="legend-icon" style="background:#0ff;border-color:#0ff"></div> <span style="color:#0ff">Your planets (cyan ring)</span></div>
            <div class="legend-item"><div class="legend-icon" style="background:#f44;border-color:#f44"></div> <span style="color:#f44">Enemy planets (red ring)</span></div>
            <div class="legend-item"><div class="legend-icon" style="background:#666;border-color:#666"></div> Neutral (gray)</div>
        </div>
        <div class="legend-item"><div class="legend-icon" style="background:#4a4;border-color:#4a4"></div> Factory (2x prod)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#66f;border-color:#66f"></div> Fortress (2x defense)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#a4a;border-color:#a4a"></div> Wormhole (teleport OUT)</div>
        <div class="legend-item"><div class="legend-icon" style="background:#222;border-color:#f44"></div> Black Hole (danger)</div>
        <div style="margin-top:8px; padding-top:5px; border-top:1px solid #333; color:#0ff;">
            <strong>Double-tap</strong> your planet = select ALL
        </div>
    </div>

    <div class="selection-indicator hidden" id="selectionIndicator">0 planets selected</div>

    <!-- Minimap -->
    <canvas id="minimapCanvas" class="hidden" width="140" height="140"></canvas>
    <div class="rally-hint hidden" id="rallyHint">Right-click planet: set rally<br>Shift+right-click: clear rally</div>

    <!-- Upgrade Screen (between levels) -->
    <div class="upgrade-screen hidden" id="upgradeScreen">
        <h1>LEVEL UP!</h1>
        <p class="upgrade-sub">Choose an upgrade for your forces</p>
        <div class="upgrade-cards" id="upgradeCards"></div>
        <div class="active-upgrades" id="activeUpgrades"></div>
    </div>

    <div class="menu" id="menu">
        <h1>ðŸŒ PARTICLE CONQUEST</h1>
        <p class="subtitle">Capture all planets to win</p>
        
        <div class="menu-section">
            <h3>Game Mode</h3>
            <div class="difficulty-btns">
                <button class="mode-btn active" data-mode="classic">âš”ï¸ Classic</button>
                <button class="mode-btn" data-mode="harvest">ðŸŒ¾ Harvest</button>
            </div>
        </div>
        
        <div class="menu-section">
            <h3>Select Difficulty</h3>
            <div class="difficulty-btns">
                <button class="diff-btn easy" data-diff="easy">ðŸŸ¢ Easy</button>
                <button class="diff-btn medium" data-diff="medium">ðŸŸ¡ Medium</button>
                <button class="diff-btn hard" data-diff="hard">ðŸ”´ Hard</button>
                <button class="diff-btn brutal" data-diff="brutal">ðŸ’€ Brutal</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Special Features</h3>
            <div class="feature-toggles">
                <div class="feature-toggle" data-feature="stealth">
                    <span class="toggle-icon">ðŸ‘»</span>
                    <span class="toggle-label">Stealth Attack</span>
                    <span class="toggle-check">âœ“</span>
                </div>
                <div class="feature-toggle" data-feature="comets">
                    <span class="toggle-icon">â˜„ï¸</span>
                    <span class="toggle-label">Comet Showers</span>
                    <span class="toggle-check">âœ“</span>
                </div>
                <div class="feature-toggle" data-feature="fog">
                    <span class="toggle-icon">ðŸŒ«ï¸</span>
                    <span class="toggle-label">Fog of War</span>
                    <span class="toggle-check">âœ“</span>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h4>How to Play</h4>
            <div id="classicInstructions">
                <strong>Tap your planet</strong> â†’ <strong>Tap target</strong> to attack<br>
                <strong>Double-tap</strong> your planet â†’ Select ALL your planets<br>
                <strong>Tap multiple</strong> planets â†’ Unified attack<br><br>
            </div>
            <div id="harvestInstructions" style="display:none;">
                <strong>HARVEST PHASE:</strong> Tap particles â†’ Tap YOUR planet to collect<br>
                Race the AI to gather particles before battle begins!<br><br>
            </div>
            
            <h4>Special Planets</h4>
            <em>Factory</em> â€” Produces 2x faster<br>
            <em>Fortress</em> â€” Takes 50% less damage<br>
            <em>Wormhole</em> â€” Units sent FROM here appear at partner<br>
            <em>Black Hole</em> â€” Destroys nearby particles<br><br>
            
            <h4>Abilities (1-5 keys)</h4>
            âš¡ <strong>Boost</strong> â€” 3x particle speed for 5s<br>
            ðŸ›¡ï¸ <strong>Shield</strong> â€” Protect planet for 8s<br>
            ðŸ’¥ <strong>EMP</strong> â€” Freeze enemy production 6s<br>
            â˜¢ï¸ <strong>Nuke</strong> â€” Destroy 50% units on target<br>
            ðŸ‘» <strong>Stealth</strong> â€” Hide particles for 3s (toggle on)<br><br>

            <h4>Special Features (toggle above)</h4>
            ðŸ‘» <strong>Stealth Attack</strong> â€” Your particles invisible to AI<br>
            â˜„ï¸ <strong>Comet Showers</strong> â€” Destroys flying particles<br>
            ðŸŒ«ï¸ <strong>Fog of War</strong> â€” Limited visibility
        </div>

        <!-- Daily Challenges -->
        <div class="daily-panel" id="dailyPanel">
            <h3>ðŸŽ¯ Daily Challenges</h3>
            <div id="challengesList"></div>
        </div>

        <!-- Menu Actions -->
        <div class="menu-actions">
            <button class="menu-action-btn" id="statsBtn">ðŸ“Š Stats</button>
            <button class="menu-action-btn" id="multiplayerBtn">ðŸŒ Multiplayer</button>
        </div>
    </div>

    <div class="result-screen hidden" id="resultScreen">
        <h1 id="resultTitle">VICTORY!</h1>
        <p class="result-subtitle" id="resultSubtitle"></p>
        <p id="resultText">You conquered the galaxy!</p>
        <div class="result-stats" id="resultStats">
            <div class="result-stat">
                <div class="result-stat-value" id="statTime">0:00</div>
                <div class="result-stat-label">Time</div>
            </div>
            <div class="result-stat">
                <div class="result-stat-value" id="statPlanets">0</div>
                <div class="result-stat-label">Planets</div>
            </div>
            <div class="result-stat">
                <div class="result-stat-value" id="statStreak">0</div>
                <div class="result-stat-label">Streak</div>
            </div>
        </div>
        <!-- Post-Match Stats Dashboard -->
        <div class="post-match-dashboard" id="postMatchDashboard" style="display:none;">
            <h3>Battle Statistics</h3>
            <div class="dashboard-grid" id="dashboardGrid"></div>
            <div class="territory-graph-container">
                <canvas id="territoryGraphCanvas"></canvas>
            </div>
            <div class="territory-legend">
                <span class="tl-player">Your Planets</span>
                <span class="tl-enemy">Enemy Planets</span>
                <span class="tl-neutral">Neutral</span>
            </div>
        </div>

        <!-- Post-Game Timeline -->
        <div class="timeline-section" id="timelineSection" style="display:none;">
            <h3>Battle Timeline</h3>
            <div class="timeline-bar" id="timelineBar"></div>
            <div class="sparkline-container"><canvas id="sparklineCanvas"></canvas></div>
        </div>

        <div class="result-buttons">
            <button class="menu-link-btn" id="menuBtn">Menu</button>
            <button class="play-again-btn" id="playAgainBtn">Continue</button>
            <button class="share-btn" id="shareBtn">Share</button>
        </div>
    </div>

    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;

const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

// ==================== LOCALSTORAGE & STATS SYSTEM ====================
const STORAGE_KEY = 'particleConquestPro';

const defaultStats = {
    gamesPlayed: 0,
    gamesWon: 0,
    gamesLost: 0,
    planetsConquered: 0,
    planetsLost: 0,
    unitsDeployed: 0,
    unitsDestroyed: 0,
    highestLevel: 1,
    totalPlayTime: 0, // in seconds
    abilitiesUsed: 0,
    perfectWins: 0, // wins without losing a planet
    fastestWin: null, // in seconds
    currentStreak: 0,
    bestStreak: 0,
    dailyChallenges: {},
    lastDailyDate: null,
    tutorialComplete: false,
    achievements: [],
    settings: {
        soundEnabled: true,
        musicEnabled: true,
        volume: 0.7
    },
    features: {
        stealth: false,
        comets: false,
        fog: false
    },
    // Adaptive AI: track recent game results for difficulty balancing
    adaptiveAI: {
        recentResults: [], // array of { won: bool, difficulty: string, timestamp: number } (last 20 games)
        currentModifier: 0 // -1 to +1, negative = easier, positive = harder
    }
};

let playerStats = loadStats();

function loadStats() {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            const parsed = JSON.parse(saved);
            return { ...defaultStats, ...parsed, settings: { ...defaultStats.settings, ...parsed.settings }, features: { ...defaultStats.features, ...parsed.features }, adaptiveAI: { ...defaultStats.adaptiveAI, ...(parsed.adaptiveAI || {}) } };
        }
    } catch (e) { console.warn('Failed to load stats:', e); }
    return { ...defaultStats };
}

function saveStats() {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(playerStats));
    } catch (e) { console.warn('Failed to save stats:', e); }
}

// ==================== SOUND EFFECTS SYSTEM ====================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new AudioCtx();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

function playSound(type, options = {}) {
    if (!playerStats.settings.soundEnabled || !audioCtx) return;

    const vol = playerStats.settings.volume * (options.volume || 1);
    const now = audioCtx.currentTime;

    try {
        switch(type) {
            case 'select': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(vol * 0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            }
            case 'attack': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(vol * 0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
                break;
            }
            case 'capture': {
                [0, 0.1, 0.2].forEach((delay, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime([523, 659, 784][i], now + delay);
                    gain.gain.setValueAtTime(vol * 0.25, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.3);
                });
                break;
            }
            case 'lose': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                gain.gain.setValueAtTime(vol * 0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            }
            case 'victory': {
                [0, 0.15, 0.3, 0.45].forEach((delay, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime([523, 659, 784, 1047][i], now + delay);
                    gain.gain.setValueAtTime(vol * 0.3, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.4);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.4);
                });
                break;
            }
            case 'defeat': {
                [0, 0.2, 0.4].forEach((delay, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sawtooth';
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime([300, 200, 100][i], now + delay);
                    gain.gain.setValueAtTime(vol * 0.25, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.3);
                });
                break;
            }
            case 'ability': {
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(600, now);
                osc2.frequency.setValueAtTime(900, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                osc2.frequency.exponentialRampToValueAtTime(1800, now + 0.15);
                gain.gain.setValueAtTime(vol * 0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc2.start(now);
                osc.stop(now + 0.2);
                osc2.stop(now + 0.2);
                break;
            }
            case 'comet': {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, now);
                filter.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                const gain = audioCtx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(vol * 0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                noise.start(now);
                noise.stop(now + 0.5);
                break;
            }
            case 'click': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(1000, now);
                gain.gain.setValueAtTime(vol * 0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
                break;
            }
            case 'achievement': {
                // Triumphant achievement fanfare
                const notes = [
                    { freq: 783.99, delay: 0 },      // G5
                    { freq: 987.77, delay: 0.1 },    // B5
                    { freq: 1174.66, delay: 0.2 },   // D6
                    { freq: 1567.98, delay: 0.35 },  // G6
                ];
                notes.forEach(note => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'triangle';
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.setValueAtTime(note.freq, now + note.delay);
                    gain.gain.setValueAtTime(0, now + note.delay);
                    gain.gain.linearRampToValueAtTime(vol * 0.25, now + note.delay + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + note.delay + 0.5);
                    osc.start(now + note.delay);
                    osc.stop(now + note.delay + 0.5);
                });
                break;
            }
        }
    } catch (e) { console.warn('Sound error:', e); }
}

// ==================== BACKGROUND MUSIC SYSTEM ====================
let musicNodes = null;
let musicPlaying = false;

function startMusic() {
    if (musicPlaying || !playerStats.settings.soundEnabled || !audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();

    try {
        const vol = playerStats.settings.volume * 0.08;

        // Create a simple ambient synth pad
        const masterGain = audioCtx.createGain();
        masterGain.gain.setValueAtTime(0, audioCtx.currentTime);
        masterGain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 2);
        masterGain.connect(audioCtx.destination);

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, audioCtx.currentTime);
        filter.connect(masterGain);

        // Chord notes (Cmaj7 ambient)
        const notes = [130.81, 164.81, 196.00, 246.94]; // C3, E3, G3, B3
        const oscillators = [];
        const gains = [];

        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

            // Add subtle vibrato
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.frequency.setValueAtTime(0.2 + i * 0.1, audioCtx.currentTime);
            lfoGain.gain.setValueAtTime(2, audioCtx.currentTime);
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            lfo.start();

            oscGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
            osc.connect(oscGain);
            oscGain.connect(filter);
            osc.start();

            oscillators.push(osc, lfo);
            gains.push(oscGain);
        });

        // Add subtle bass pulse
        const bassOsc = audioCtx.createOscillator();
        const bassGain = audioCtx.createGain();
        bassOsc.type = 'sine';
        bassOsc.frequency.setValueAtTime(65.41, audioCtx.currentTime); // C2
        bassGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        bassOsc.connect(bassGain);
        bassGain.connect(filter);
        bassOsc.start();
        oscillators.push(bassOsc);
        gains.push(bassGain);

        musicNodes = { oscillators, gains, masterGain, filter };
        musicPlaying = true;

        // Animate filter for movement
        function animateFilter() {
            if (!musicPlaying) return;
            const time = audioCtx.currentTime;
            filter.frequency.setValueAtTime(600 + Math.sin(time * 0.3) * 300, time);
            if (musicPlaying) {
                requestAnimationFrame(animateFilter);
            }
        }
        animateFilter();

    } catch (e) {
        console.warn('Music error:', e);
    }
}

function stopMusic() {
    if (!musicPlaying || !musicNodes) return;

    try {
        const now = audioCtx.currentTime;
        musicNodes.masterGain.gain.linearRampToValueAtTime(0, now + 1);

        setTimeout(() => {
            if (musicNodes) {
                musicNodes.oscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
                musicNodes = null;
            }
        }, 1200);
    } catch (e) {
        console.warn('Stop music error:', e);
    }

    musicPlaying = false;
}

// ==================== DAILY CHALLENGES SYSTEM ====================
function getTodayKey() {
    return new Date().toISOString().split('T')[0];
}

function getDailySeed() {
    const today = getTodayKey();
    let hash = 0;
    for (let i = 0; i < today.length; i++) {
        hash = ((hash << 5) - hash) + today.charCodeAt(i);
        hash |= 0;
    }
    return Math.abs(hash);
}

function generateDailyChallenges() {
    const seed = getDailySeed();
    const challenges = [
        { id: 'speed_demon', title: 'âš¡ Speed Demon', desc: 'Win a game in under 2 minutes', check: (g) => g.gameTime < 120 && g.won, reward: 'Fast fingers!' },
        { id: 'domination', title: 'ðŸ‘‘ Domination', desc: 'Control all planets at once', check: (g) => g.allPlanetsOwned, reward: 'Total control!' },
        { id: 'underdog', title: 'ðŸ• Underdog', desc: 'Win on Hard difficulty', check: (g) => g.difficulty === 'hard' && g.won, reward: 'Against the odds!' },
        { id: 'pacifist_start', title: 'ðŸ•Šï¸ Patient General', desc: 'Win without attacking for first 30 seconds', check: (g) => g.noEarlyAttack && g.won, reward: 'Patience pays!' },
        { id: 'ability_master', title: 'ðŸŽ¯ Ability Master', desc: 'Use 3 different abilities in one game', check: (g) => g.abilitiesUsedTypes >= 3, reward: 'Tactical genius!' },
        { id: 'perfect_win', title: 'ðŸ’Ž Perfect Victory', desc: 'Win without losing any planet', check: (g) => g.perfectWin && g.won, reward: 'Flawless!' },
        { id: 'harvest_king', title: 'ðŸŒ¾ Harvest King', desc: 'Collect 60+ particles in Harvest mode', check: (g) => g.mode === 'harvest' && g.harvested >= 60, reward: 'Master collector!' },
        { id: 'fog_master', title: 'ðŸŒ«ï¸ Fog Master', desc: 'Win with Fog of War enabled', check: (g) => g.fogEnabled && g.won, reward: 'Blind victory!' },
        { id: 'nuke_happy', title: 'â˜¢ï¸ Nuclear Option', desc: 'Use Nuke ability 3 times in one game', check: (g) => g.nukesUsed >= 3, reward: 'Boom!' },
        { id: 'streak', title: 'ðŸ”¥ On Fire', desc: 'Win 3 games in a row', check: (g) => playerStats.currentStreak >= 3, reward: 'Unstoppable!' }
    ];

    // Use seed to pick 3 challenges
    const shuffled = challenges.sort((a, b) => {
        const hashA = (seed * a.id.charCodeAt(0)) % 1000;
        const hashB = (seed * b.id.charCodeAt(0)) % 1000;
        return hashA - hashB;
    });

    return shuffled.slice(0, 3);
}

let dailyChallenges = [];
let currentGameStats = {};

function initDailyChallenges() {
    const today = getTodayKey();
    if (playerStats.lastDailyDate !== today) {
        playerStats.lastDailyDate = today;
        playerStats.dailyChallenges[today] = { completed: [] };
        saveStats();
    }
    dailyChallenges = generateDailyChallenges();
}

function resetCurrentGameStats() {
    currentGameStats = {
        startTime: Date.now(),
        gameTime: 0,
        won: false,
        difficulty: game.difficulty,
        mode: game.mode,
        allPlanetsOwned: false,
        noEarlyAttack: true,
        firstAttackTime: null,
        abilitiesUsedTypes: new Set(),
        perfectWin: true,
        planetsLostThisGame: 0,
        planetsConqueredThisGame: 0,
        harvested: 0,
        fogEnabled: game.features.fog,
        nukesUsed: 0,
        // Post-match dashboard stats
        particlesProduced: 0,
        particlesLost: 0,
        particlesKilled: 0,
        largestArmySent: 0,
        attacksSent: 0,
        lastEnemyActionTime: Date.now(),
        responseTimes: [],
        territoryHistory: [] // { time, playerPlanets, enemyPlanets, neutralPlanets }
    };
    // Start territory tracking
    startTerritoryTracking();
}

// ==================== TERRITORY TRACKING FOR POST-MATCH ====================
let territoryTrackingInterval = null;

function startTerritoryTracking() {
    if (territoryTrackingInterval) clearInterval(territoryTrackingInterval);
    if (!currentGameStats) return;
    currentGameStats.territoryHistory = [];
    territoryTrackingInterval = setInterval(() => {
        if (game.state !== 'playing' && game.state !== 'harvest') return;
        if (!currentGameStats) return;
        const elapsed = (Date.now() - currentGameStats.startTime) / 1000;
        let playerP = 0, enemyP = 0, neutralP = 0;
        for (const p of planets) {
            if (p.type === 'blackhole') continue;
            if (p.owner === PLAYER) playerP++;
            else if (p.owner === ENEMY) enemyP++;
            else neutralP++;
        }
        currentGameStats.territoryHistory.push({
            time: elapsed,
            playerPlanets: playerP,
            enemyPlanets: enemyP,
            neutralPlanets: neutralP
        });
    }, 1500);
}

function stopTerritoryTracking() {
    if (territoryTrackingInterval) { clearInterval(territoryTrackingInterval); territoryTrackingInterval = null; }
}

// ==================== DIFFICULTY-ADAPTIVE AI SYSTEM ====================
// Tracks the player's win rate over recent games and auto-adjusts AI parameters
// so the challenge stays balanced as the player improves.

function updateAdaptiveAI(won) {
    if (!playerStats.adaptiveAI) {
        playerStats.adaptiveAI = { recentResults: [], currentModifier: 0 };
    }

    // Record this game result
    playerStats.adaptiveAI.recentResults.push({
        won: won,
        difficulty: game.difficulty,
        timestamp: Date.now()
    });

    // Keep only the last 20 results
    if (playerStats.adaptiveAI.recentResults.length > 20) {
        playerStats.adaptiveAI.recentResults = playerStats.adaptiveAI.recentResults.slice(-20);
    }

    // Calculate adaptive modifier based on recent performance
    const results = playerStats.adaptiveAI.recentResults;
    if (results.length < 3) {
        playerStats.adaptiveAI.currentModifier = 0;
        return;
    }

    // Weight recent games more heavily
    let weightedWins = 0;
    let totalWeight = 0;
    for (let i = 0; i < results.length; i++) {
        const weight = 1 + (i / results.length); // newer games weigh more
        if (results[i].won) weightedWins += weight;
        totalWeight += weight;
    }
    const weightedWinRate = weightedWins / totalWeight;

    // Calculate streak factor - consecutive wins/losses have extra impact
    let streak = 0;
    for (let i = results.length - 1; i >= 0; i--) {
        if (results[i].won === results[results.length - 1].won) {
            streak++;
        } else break;
    }
    const streakBonus = Math.min(streak * 0.05, 0.25); // up to 0.25 extra from streaks

    // Target win rate is ~55% (slightly favoring player for fun)
    // modifier ranges from -0.6 (much easier) to +0.6 (much harder)
    let modifier = (weightedWinRate - 0.55) * 2;

    // Apply streak bonus in the direction of the modifier
    if (modifier > 0) modifier += streakBonus;
    else if (modifier < 0) modifier -= streakBonus;

    // Clamp to range
    modifier = Math.max(-0.6, Math.min(0.6, modifier));

    // Smooth transition - don't change too fast
    const prevModifier = playerStats.adaptiveAI.currentModifier || 0;
    playerStats.adaptiveAI.currentModifier = prevModifier * 0.3 + modifier * 0.7;
}

// Returns adjusted AI settings based on adaptive modifier
function getAdaptiveAISettings() {
    const baseDiff = DIFFICULTY[game.difficulty];
    const mod = (playerStats.adaptiveAI && playerStats.adaptiveAI.currentModifier) || 0;

    // If modifier is ~0, return base settings unchanged
    if (Math.abs(mod) < 0.05) return baseDiff;

    return {
        aiSpeed: baseDiff.aiSpeed * (1 + mod * 0.5),          // +/- 30% speed
        aiAggression: Math.max(0.1, Math.min(0.95, baseDiff.aiAggression + mod * 0.2)), // +/- 12% aggression
        planets: baseDiff.planets,
        startingUnits: Math.max(15, Math.round(baseDiff.startingUnits * (1 + mod * 0.3))), // +/- 18% starting units
        specialPlanets: baseDiff.specialPlanets,
        // Economy speed multiplier for enemy production
        enemyProductionMult: 1 + mod * 0.35, // +/- 21% production
        // AI decision quality: higher = smarter target selection
        decisionQuality: Math.max(0.3, Math.min(1.0, 0.65 + mod * 0.5))
    };
}

function getAdaptiveLabel() {
    const mod = (playerStats.adaptiveAI && playerStats.adaptiveAI.currentModifier) || 0;
    if (mod > 0.2) return { text: 'Harder', cls: 'harder' };
    if (mod < -0.2) return { text: 'Easier', cls: 'easier' };
    return { text: 'Balanced', cls: 'balanced' };
}

function updateAdaptiveIndicator() {
    const indicator = document.getElementById('adaptiveIndicator');
    const label = document.getElementById('adaptiveLabel');
    const dot = indicator ? indicator.querySelector('.adapt-dot') : null;
    if (!indicator || !label || !dot) return;

    const results = playerStats.adaptiveAI ? playerStats.adaptiveAI.recentResults : [];
    if (results.length < 3) {
        indicator.classList.add('hidden');
        return;
    }

    indicator.classList.remove('hidden');
    const info = getAdaptiveLabel();
    label.textContent = info.text;
    dot.className = 'adapt-dot ' + info.cls;
}

function checkDailyChallenges() {
    const today = getTodayKey();
    if (!playerStats.dailyChallenges[today]) {
        playerStats.dailyChallenges[today] = { completed: [] };
    }

    const completed = playerStats.dailyChallenges[today].completed;
    let newlyCompleted = [];

    dailyChallenges.forEach(challenge => {
        if (!completed.includes(challenge.id) && challenge.check(currentGameStats)) {
            completed.push(challenge.id);
            newlyCompleted.push(challenge);
        }
    });

    if (newlyCompleted.length > 0) {
        saveStats();
        newlyCompleted.forEach(c => {
            showFloatText(W / 2, H / 3, `ðŸ† ${c.title}`, '#ffd700');
        });
    }
}

// ==================== MULTIPLAYER SYSTEM (PeerJS) - 4v4 Support ====================

// Team colors and configuration
const TEAM_COLORS = {
    0: { primary: '#0ff', name: 'Cyan', glow: 'rgba(0,255,255,0.5)' },
    1: { primary: '#f44', name: 'Red', glow: 'rgba(255,68,68,0.5)' },
    2: { primary: '#f90', name: 'Orange', glow: 'rgba(255,153,0,0.5)' },
    3: { primary: '#a4f', name: 'Purple', glow: 'rgba(170,68,255,0.5)' }
};

// Multiplayer state
let peer = null;
let isHost = false;
let multiplayerActive = false;
let roomCode = '';
let myPlayerId = null;
let myPlayerName = localStorage.getItem('playerName') || 'Player';
let mpGameMode = 'coop'; // 'coop' or 'pvp'

// Connection management for multiple players
const connections = new Map(); // peerId -> { conn, player }
let hostConnection = null; // For clients: connection to host

// Lobby state
const lobby = {
    players: [], // { id, name, team, isAI, isHost, ping }
    maxPlayers: 8,
    started: false
};

// Sync state
let syncInterval = null;
let pingInterval = null;
let lastPingTime = 0;
let currentPing = 0;

function generateRoomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
}

async function initPeerJS() {
    return new Promise((resolve, reject) => {
        if (typeof Peer === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load PeerJS'));
            document.head.appendChild(script);
        } else {
            resolve();
        }
    });
}

// ==================== HOST FUNCTIONS ====================

async function hostGame() {
    try {
        await initPeerJS();
        roomCode = generateRoomCode();
        peer = new Peer('pcp-' + roomCode);

        peer.on('open', id => {
            isHost = true;
            myPlayerId = id;

            // Add host to lobby
            lobby.players = [{
                id: myPlayerId,
                name: myPlayerName,
                team: 0,
                isAI: false,
                isHost: true,
                ping: 0
            }];

            showLobbyRoom();
            playSound('click');
        });

        peer.on('connection', handleNewConnection);

        peer.on('error', err => {
            console.error('Peer error:', err);
            document.getElementById('lobbyStatus').textContent = 'Connection error!';
            showFloatText(W / 2, H / 2, 'Connection error!', '#f44');
        });
    } catch (e) {
        console.error('Failed to init multiplayer:', e);
    }
}

function handleNewConnection(conn) {
    if (lobby.players.filter(p => !p.isAI).length >= 8) {
        conn.on('open', () => {
            conn.send({ type: 'error', message: 'Room is full' });
            conn.close();
        });
        return;
    }

    conn.on('open', () => {
        connections.set(conn.peer, { conn, player: null });

        // Wait for player info
        conn.on('data', data => handleHostData(conn.peer, data));
        conn.on('close', () => handlePlayerDisconnect(conn.peer));
    });
}

function handleHostData(peerId, data) {
    const connection = connections.get(peerId);

    switch(data.type) {
        case 'join':
            // New player joining
            const newPlayer = {
                id: peerId,
                name: data.name || 'Player',
                team: getAutoTeam(),
                isAI: false,
                isHost: false,
                ping: 0
            };
            lobby.players.push(newPlayer);
            connection.player = newPlayer;

            playSound('click');

            // Send current lobby state to new player
            broadcastLobbyState();
            updateLobbyUI();
            break;

        case 'switchTeam':
            const player = lobby.players.find(p => p.id === peerId);
            if (player && !lobby.started) {
                player.team = data.team;
                broadcastLobbyState();
                updateLobbyUI();
            }
            break;

        case 'command':
            // Player command during game
            if (lobby.started) {
                executePlayerCommand(peerId, data);
            }
            break;

        case 'pong':
            const pongPlayer = lobby.players.find(p => p.id === peerId);
            if (pongPlayer) {
                pongPlayer.ping = Date.now() - data.t;
            }
            break;
    }
}

function getAutoTeam() {
    // Auto-assign to team with fewer players
    const team0Count = lobby.players.filter(p => p.team === 0).length;
    const team1Count = lobby.players.filter(p => p.team === 1).length;
    return team0Count <= team1Count ? 0 : 1;
}

function broadcastLobbyState() {
    const state = {
        type: 'lobbyState',
        players: lobby.players,
        gameMode: mpGameMode,
        roomCode: roomCode
    };
    broadcast(state);
}

function broadcast(data) {
    for (const [id, { conn }] of connections) {
        if (conn && conn.open) {
            conn.send(data);
        }
    }
}

function handlePlayerDisconnect(peerId) {
    connections.delete(peerId);

    const playerIdx = lobby.players.findIndex(p => p.id === peerId);
    if (playerIdx !== -1) {
        const player = lobby.players[playerIdx];

        if (lobby.started) {
            // During game: convert to AI
            player.isAI = true;
            player.name = 'ðŸ¤– ' + player.name;
            showFloatText(W / 2, 100, `${player.name} disconnected (AI takeover)`, '#fa0');
        } else {
            // In lobby: remove player
            lobby.players.splice(playerIdx, 1);
        }

        broadcastLobbyState();
        updateLobbyUI();
    }
}

// ==================== CLIENT FUNCTIONS ====================

async function joinGame(code) {
    try {
        await initPeerJS();
        roomCode = code.toUpperCase();
        peer = new Peer();

        peer.on('open', id => {
            myPlayerId = id;
            hostConnection = peer.connect('pcp-' + roomCode);

            hostConnection.on('open', () => {
                // Send join request
                hostConnection.send({
                    type: 'join',
                    name: myPlayerName
                });

                isHost = false;
                showLobbyRoom();
                playSound('click');
            });

            hostConnection.on('data', handleClientData);

            hostConnection.on('close', () => {
                showFloatText(W / 2, H / 2, 'Disconnected from host', '#f44');
                endMultiplayerGame();
            });
        });

        peer.on('error', err => {
            console.error('Peer error:', err);
            document.getElementById('lobbyStatus').textContent = 'Room not found!';
            showFloatText(W / 2, H / 2, 'Room not found!', '#f44');
        });
    } catch (e) {
        console.error('Failed to join:', e);
    }
}

function handleClientData(data) {
    switch(data.type) {
        case 'lobbyState':
            lobby.players = data.players;
            mpGameMode = data.gameMode;
            roomCode = data.roomCode;
            updateLobbyUI();
            break;

        case 'gameStart':
            startClientGame(data);
            break;

        case 'tick':
            // Authoritative game state from host
            applyGameTick(data);
            break;

        case 'attack':
            // Attack broadcast from host - spawn particles so all players see attacks
            spawnAttackParticles(data.sourceIdx, data.targetIdx, data.units, data.team);
            break;

        case 'ping':
            hostConnection.send({ type: 'pong', t: data.t });
            break;

        case 'gameEnd':
            const myEndPlayer = lobby.players.find(p => p.id === myPlayerId);
            const myVictory = myEndPlayer && myEndPlayer.team === data.winningTeam;
            endGame(myVictory);
            break;

        case 'error':
            showFloatText(W / 2, H / 2, data.message, '#f44');
            endMultiplayerGame();
            break;
    }
}

function sendToHost(data) {
    if (hostConnection && hostConnection.open) {
        hostConnection.send(data);
    }
}

// ==================== LOBBY UI ====================

function showLobbyRoom() {
    document.getElementById('lobbyInitial').classList.add('hidden');
    document.getElementById('lobbyRoom').classList.remove('hidden');
    document.getElementById('roomCodeDisplay').textContent = roomCode;
    document.getElementById('lobbyStatus').textContent = isHost ? 'Waiting for players...' : 'Connected!';

    // Show/hide host-only elements
    document.querySelectorAll('.add-ai-btn').forEach(btn => {
        btn.style.display = isHost ? 'block' : 'none';
    });
    document.getElementById('gameModeContainer').style.display = isHost ? 'block' : 'none';
    document.getElementById('startGameBtn').style.display = isHost ? 'block' : 'none';

    updateLobbyUI();
    startPingLoop();
}

function updateLobbyUI() {
    const team0Slots = document.getElementById('team0Slots');
    const team1Slots = document.getElementById('team1Slots');

    team0Slots.innerHTML = '';
    team1Slots.innerHTML = '';

    let humanCount = 0;
    let aiCount = 0;

    for (const player of lobby.players) {
        const slot = document.createElement('div');
        slot.className = 'player-slot';
        if (player.id === myPlayerId) slot.classList.add('is-you');
        if (player.isAI) slot.classList.add('is-ai');

        const icon = player.isAI ? 'ðŸ¤–' : (player.isHost ? 'ðŸ‘‘' : 'ðŸ‘¤');
        const pingText = player.isAI ? '' : `<span class="player-ping">${player.ping}ms</span>`;
        const youBadge = player.id === myPlayerId ? ' <span style="color:#0ff;font-size:10px;">(You)</span>' : '';

        let removeBtn = '';
        if (isHost && (player.isAI || (!player.isHost && player.id !== myPlayerId))) {
            removeBtn = `<button class="remove-btn" data-id="${player.id}">âœ•</button>`;
        }

        slot.innerHTML = `
            <span class="player-icon">${icon}</span>
            <span class="player-name">${player.name}${youBadge}</span>
            ${pingText}
            ${removeBtn}
        `;

        if (player.team === 0) {
            team0Slots.appendChild(slot);
        } else {
            team1Slots.appendChild(slot);
        }

        if (player.isAI) aiCount++;
        else humanCount++;
    }

    document.getElementById('humanCount').textContent = humanCount;
    document.getElementById('aiCount').textContent = aiCount;

    // Update start button
    const startBtn = document.getElementById('startGameBtn');
    const canStart = lobby.players.length >= 2 &&
                     lobby.players.filter(p => p.team === 0).length > 0 &&
                     lobby.players.filter(p => p.team === 1).length > 0;
    startBtn.disabled = !canStart;
    startBtn.textContent = canStart ? 'â–¶ Start Game' : 'Need players on both teams';

    // Update status
    if (!lobby.started) {
        document.getElementById('lobbyStatus').textContent =
            `${humanCount} player${humanCount !== 1 ? 's' : ''} connected`;
    }

    // Add click handlers for remove buttons
    document.querySelectorAll('.remove-btn').forEach(btn => {
        btn.onclick = () => removePlayer(btn.dataset.id);
    });
}

function addAI(team) {
    if (!isHost) return;

    const aiCount = lobby.players.filter(p => p.isAI).length;
    if (lobby.players.length >= 8) {
        showFloatText(W / 2, H / 2, 'Room is full!', '#fa0');
        return;
    }

    const aiPlayer = {
        id: 'ai-' + Date.now() + '-' + Math.random().toString(36).substring(2, 6),
        name: `AI ${aiCount + 1}`,
        team: team,
        isAI: true,
        isHost: false,
        ping: 0
    };

    lobby.players.push(aiPlayer);
    playSound('click');
    broadcastLobbyState();
    updateLobbyUI();
}

function removePlayer(playerId) {
    if (!isHost) return;

    const idx = lobby.players.findIndex(p => p.id === playerId);
    if (idx !== -1 && !lobby.players[idx].isHost) {
        const player = lobby.players[idx];

        // If it's a real player, close their connection
        if (!player.isAI && connections.has(playerId)) {
            connections.get(playerId).conn.close();
            connections.delete(playerId);
        }

        lobby.players.splice(idx, 1);
        playSound('click');
        broadcastLobbyState();
        updateLobbyUI();
    }
}

function switchTeam() {
    const myPlayer = lobby.players.find(p => p.id === myPlayerId);
    if (!myPlayer || lobby.started) return;

    const newTeam = myPlayer.team === 0 ? 1 : 0;

    if (isHost) {
        myPlayer.team = newTeam;
        broadcastLobbyState();
        updateLobbyUI();
    } else {
        sendToHost({ type: 'switchTeam', team: newTeam });
    }

    playSound('click');
}

function setGameMode(mode) {
    if (!isHost) return;
    mpGameMode = mode;

    // Update UI
    document.querySelectorAll('.mode-toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mpmode === mode);
    });

    broadcastLobbyState();
    playSound('click');
}

function startPingLoop() {
    if (pingInterval) clearInterval(pingInterval);

    pingInterval = setInterval(() => {
        if (isHost) {
            // Host pings all clients
            lastPingTime = Date.now();
            broadcast({ type: 'ping', t: lastPingTime });
        }
    }, 2000);
}

// ==================== GAME START ====================

function startMultiplayerGame() {
    if (!isHost || lobby.started) return;

    lobby.started = true;
    playSound('ability');

    // Generate game seed
    const gameSeed = roomCode.split('').reduce((a, c) => a + c.charCodeAt(0), 0) + Date.now();

    // Generate level on host
    generateMultiplayerLevel(gameSeed);

    // Hide lobby, show game
    document.getElementById('multiplayerLobby').classList.add('hidden');
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');

    multiplayerActive = true;
    game.state = 'playing';

    // Send game start to all clients
    broadcast({
        type: 'gameStart',
        seed: gameSeed,
        players: lobby.players,
        gameMode: mpGameMode,
        planets: planets.map(p => ({
            x: p.x, y: p.y, size: p.size, type: p.type,
            owner: p.owner, units: p.units
        }))
    });

    // Start game tick loop (host-authoritative)
    startGameTickLoop();

    // Update HUD
    updateMultiplayerHUD();
}

function startClientGame(data) {
    lobby.players = data.players;
    mpGameMode = data.gameMode;

    // Recreate planets from host data
    planets = [];
    flyingParticles = [];
    effects = [];
    comets = [];

    for (const pd of data.planets) {
        // Correctly pass all Planet constructor params: x, y, size, owner, units, type
        const planet = new Planet(pd.x, pd.y, pd.size, pd.owner, pd.units, pd.type);
        planets.push(planet);
    }

    // Hide lobby, show game
    document.getElementById('multiplayerLobby').classList.add('hidden');
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');

    multiplayerActive = true;
    lobby.started = true;
    game.state = 'playing';

    playSound('ability');
    updateMultiplayerHUD();
}

function updateMultiplayerHUD() {
    const myPlayer = lobby.players.find(p => p.id === myPlayerId);
    const myTeam = myPlayer ? myPlayer.team : 0;

    // Count teams
    const team0Count = lobby.players.filter(p => p.team === 0).length;
    const team1Count = lobby.players.filter(p => p.team === 1).length;

    const modeText = mpGameMode === 'coop' ? 'CO-OP' : 'PvP';
    document.getElementById('levelInfo').textContent =
        `${modeText} ${team0Count}v${team1Count}`;
}

// ==================== GAME TICK (HOST-AUTHORITATIVE) ====================

function startGameTickLoop() {
    if (syncInterval) clearInterval(syncInterval);

    syncInterval = setInterval(() => {
        if (!multiplayerActive || !isHost || game.state !== 'playing') {
            clearInterval(syncInterval);
            return;
        }

        // Run AI for AI players
        runMultiplayerAI();

        // Send tick to all clients
        broadcast({
            type: 'tick',
            planets: planets.map(p => ({
                units: Math.floor(p.units),
                owner: p.owner,
                shielded: p.shielded
            })),
            flying: flyingParticles.length
        });

        // Check win condition
        checkMultiplayerWinCondition();

    }, 100); // 10 ticks per second
}

function applyGameTick(data) {
    // Client applies authoritative state from host
    data.planets.forEach((pd, i) => {
        if (planets[i]) {
            // Smooth interpolation for units
            const diff = pd.units - planets[i].units;
            planets[i].units += diff * 0.3;
            planets[i].owner = pd.owner;
            planets[i].shielded = pd.shielded;
        }
    });
}

// Broadcast attack to all clients so they can see particles
function broadcastAttack(sourceIdx, targetIdx, units, team) {
    broadcast({
        type: 'attack',
        sourceIdx,
        targetIdx,
        units,
        team
    });
    // Also execute locally on host
    spawnAttackParticles(sourceIdx, targetIdx, units, team);
}

// Spawn attack particles (used by both host and clients)
function spawnAttackParticles(sourceIdx, targetIdx, units, team) {
    const source = planets[sourceIdx];
    const target = planets[targetIdx];
    if (!source || !target) return;

    for (let i = 0; i < units; i++) {
        setTimeout(() => {
            const angle = Math.random() * Math.PI * 2;
            const dist = source.size + 5;
            flyingParticles.push(new FlyingParticle(
                source.x + Math.cos(angle) * dist,
                source.y + Math.sin(angle) * dist,
                target,
                team
            ));
        }, i * 25);
    }
}

function executePlayerCommand(peerId, data) {
    // Host executes player commands authoritatively
    const player = lobby.players.find(p => p.id === peerId);
    if (!player) return;

    const playerTeam = player.team;

    switch(data.cmd) {
        case 'attack':
            const source = planets[data.sourceIdx];
            const target = planets[data.targetIdx];

            // Validate: player must own source planet (team matches)
            if (!source || !target) return;
            if (source.owner !== playerTeam) return;

            // Execute attack
            const units = Math.floor(source.units * (data.percent / 100));
            if (units < 1) return;

            source.units -= units;

            // Broadcast to all clients so everyone sees the attack
            broadcastAttack(data.sourceIdx, data.targetIdx, units, playerTeam);
            break;
    }
}

function runMultiplayerAI() {
    // Run AI for each AI player
    const aiPlayers = lobby.players.filter(p => p.isAI);

    for (const aiPlayer of aiPlayers) {
        const team = aiPlayer.team;
        const settings = DIFFICULTY[game.difficulty];

        // Find AI-controlled planets
        const aiPlanets = planets.filter(p => p.owner === team && p.units > 8);
        if (aiPlanets.length === 0) continue;

        // Random chance to act
        if (Math.random() > settings.aiAggression * 0.3) continue;

        const source = aiPlanets[Math.floor(Math.random() * aiPlanets.length)];

        // Find best target
        let bestTarget = null;
        let bestScore = -Infinity;

        for (const planet of planets) {
            if (planet === source || planet.type === 'blackhole') continue;

            const dist = Math.sqrt((planet.x - source.x) ** 2 + (planet.y - source.y) ** 2);
            let score = 0;

            if (planet.owner !== team && planet.owner !== -1) {
                // Enemy planet
                score = 100 - planet.units - dist / 15;
                if (planet.shielded) score -= 200;
            } else if (planet.owner === -1) {
                // Neutral
                score = 60 - planet.units - dist / 8;
            } else {
                score = -100; // Same team
            }

            if (score > bestScore) {
                bestScore = score;
                bestTarget = planet;
            }
        }

        if (bestTarget && bestScore > -30) {
            const percent = 50 + Math.random() * 30;
            const units = Math.floor(source.units * (percent / 100));
            source.units -= units;

            // Use broadcastAttack so all clients see AI attacks
            const sourceIdx = planets.indexOf(source);
            const targetIdx = planets.indexOf(bestTarget);
            broadcastAttack(sourceIdx, targetIdx, units, team);
        }
    }
}

function checkMultiplayerWinCondition() {
    // Count planets per team
    const teamPlanets = {};
    const teamFlying = {};

    for (const planet of planets) {
        if (planet.owner >= 0) {
            teamPlanets[planet.owner] = (teamPlanets[planet.owner] || 0) + 1;
        }
    }

    for (const p of flyingParticles) {
        teamFlying[p.owner] = (teamFlying[p.owner] || 0) + 1;
    }

    // Check if team 0 or team 1 has won
    const team0Total = (teamPlanets[0] || 0) + (teamFlying[0] || 0);
    const team1Total = (teamPlanets[1] || 0) + (teamFlying[1] || 0);

    if (team0Total === 0) {
        // Team 1 wins
        broadcastGameEnd(1);
    } else if (team1Total === 0) {
        // Team 0 wins
        broadcastGameEnd(0);
    }
}

function broadcastGameEnd(winningTeam) {
    const myPlayer = lobby.players.find(p => p.id === myPlayerId);
    const victory = myPlayer && myPlayer.team === winningTeam;

    broadcast({ type: 'gameEnd', winningTeam, victory });
    endGame(victory);
}

// ==================== MAP GENERATION ====================

function generateMultiplayerLevel(seed) {
    let s = seed;
    const random = () => { s = (s * 9301 + 49297) % 233280; return s / 233280; };

    planets = [];
    flyingParticles = [];
    effects = [];
    comets = [];

    // Count players per team
    const team0Players = lobby.players.filter(p => p.team === 0);
    const team1Players = lobby.players.filter(p => p.team === 1);
    const totalPlayers = team0Players.length + team1Players.length;

    // Scale planets with player count
    const numPlanets = 8 + (totalPlayers * 2);
    const positions = [];
    const minDist = Math.max(80, 130 - totalPlayers * 5);
    const margin = 70;

    for (let i = 0; i < numPlanets; i++) {
        let x, y, valid;
        let attempts = 0;
        do {
            valid = true;
            x = margin + random() * (W - margin * 2);
            y = margin + random() * (H - margin * 2);
            for (const pos of positions) {
                const dx = x - pos.x, dy = y - pos.y;
                if (Math.sqrt(dx*dx + dy*dy) < minDist) { valid = false; break; }
            }
            attempts++;
        } while (!valid && attempts < 100);

        positions.push({ x, y });
        const size = 22 + random() * 18;
        const units = 8 + Math.floor(random() * 20);
        // Constructor: x, y, size, owner, units, type
        // -1 = neutral in multiplayer
        const planet = new Planet(x, y, size, -1, units, 'normal');
        planets.push(planet);
    }

    // Assign starting planets to each player
    // Team 0 on left, Team 1 on right
    const leftPlanets = [...planets].sort((a, b) => a.x - b.x);
    const rightPlanets = [...planets].sort((a, b) => b.x - a.x);

    for (let i = 0; i < team0Players.length && i < leftPlanets.length; i++) {
        leftPlanets[i].owner = 0;
        leftPlanets[i].units = 25;
    }

    for (let i = 0; i < team1Players.length && i < rightPlanets.length; i++) {
        rightPlanets[i].owner = 1;
        rightPlanets[i].units = 25;
    }

    game.state = 'playing';
}

// ==================== CLIENT COMMAND SENDING ====================

function sendMultiplayerCommand(cmd, data) {
    if (!multiplayerActive) return;

    if (isHost) {
        // Host executes directly
        const myPlayer = lobby.players.find(p => p.id === myPlayerId);
        if (myPlayer) {
            executePlayerCommand(myPlayerId, { cmd, ...data });
        }
    } else {
        // Client sends to host
        sendToHost({ type: 'command', cmd, ...data });
    }
}

// ==================== CLEANUP ====================

function endMultiplayerGame() {
    multiplayerActive = false;
    lobby.started = false;
    lobby.players = [];

    if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
    }
    if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
    }

    connections.clear();
    hostConnection = null;

    if (peer) {
        peer.destroy();
        peer = null;
    }

    document.getElementById('multiplayerLobby').classList.add('hidden');
    document.getElementById('lobbyRoom').classList.add('hidden');
    document.getElementById('lobbyInitial').classList.remove('hidden');
}

function showMultiplayerLobby() {
    const lobbyEl = document.getElementById('multiplayerLobby');
    lobbyEl.classList.remove('hidden');
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('lobbyRoom').classList.add('hidden');
    document.getElementById('lobbyInitial').classList.remove('hidden');
    document.getElementById('lobbyStatus').textContent = 'Choose an option';
    document.getElementById('joinCodeInput').value = '';
}

// Helper for checking team alliance
function isAlly(team1, team2) {
    return team1 === team2;
}

// Check if planet is owned by my team
function isMyPlanet(planet) {
    if (multiplayerActive) {
        const myPlayer = lobby.players.find(p => p.id === myPlayerId);
        return myPlayer && planet.owner === myPlayer.team;
    }
    return planet.owner === PLAYER;
}

// Get my team number
function getMyTeam() {
    if (multiplayerActive) {
        const myPlayer = lobby.players.find(p => p.id === myPlayerId);
        return myPlayer ? myPlayer.team : 0;
    }
    return PLAYER;
}

// Check if an owner value represents my team
function isMyTeamOwner(owner) {
    if (multiplayerActive) {
        return owner === getMyTeam();
    }
    return owner === PLAYER;
}

// Check if an owner value represents an enemy team
function isEnemyTeamOwner(owner) {
    if (multiplayerActive) {
        return owner >= 0 && owner !== getMyTeam();
    }
    return owner === ENEMY;
}

// Game state
const game = {
    state: 'menu', // menu, harvest, playing, paused, ended
    mode: 'classic', // classic, harvest
    difficulty: 'medium',
    level: 1,
    selectedPlanets: [], // Changed to array for multi-select
    sendPercent: 75,
    speed: 1,
    activeAbility: null,
    lastClickTime: 0,
    lastClickedPlanet: null,
    doubleClickThreshold: 300, // ms
    paused: false,
    // Feature toggles
    features: {
        stealth: false,
        comets: false,
        fog: false
    }
};

// ============================================
// JUICE SYSTEM - Screen shake, particles, flash, slowmo
// ============================================
const juice = {
    // Screen shake
    shakeIntensity: 0,
    shakeDuration: 0,
    shakeDecay: 0,

    // Slow motion
    slowMotionScale: 1,
    slowMotionDuration: 0,

    // Screen flash
    flashColor: null,
    flashAlpha: 0,

    // Juice particles (separate from game particles)
    particles: [],

    shake(intensity = 10, duration = 200) {
        if (prefersReducedMotion) return;
        this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
        this.shakeDuration = Math.max(this.shakeDuration, duration);
        this.shakeDecay = this.shakeIntensity / (duration / 1000);
        haptics.medium();
    },

    slowMo(scale = 0.3, duration = 500) {
        if (prefersReducedMotion) return;
        this.slowMotionScale = scale;
        this.slowMotionDuration = duration;
    },

    flash(color = '#fff', alpha = 0.4) {
        if (prefersReducedMotion) return;
        this.flashColor = color;
        this.flashAlpha = alpha;
    },

    burst(x, y, color, count = 20, speed = 150) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new JuiceParticle(x, y, color, speed));
        }
    },

    update(dt) {
        // Update shake
        if (this.shakeDuration > 0) {
            this.shakeDuration -= dt * 1000;
            this.shakeIntensity -= this.shakeDecay * dt;
            if (this.shakeDuration <= 0 || this.shakeIntensity <= 0) {
                this.shakeIntensity = 0;
                this.shakeDuration = 0;
            }
        }

        // Update slowmo
        if (this.slowMotionDuration > 0) {
            this.slowMotionDuration -= dt * 1000;
            if (this.slowMotionDuration <= 0) {
                this.slowMotionScale = 1;
            }
        }

        // Update flash
        if (this.flashAlpha > 0) {
            this.flashAlpha -= dt * 3;
            if (this.flashAlpha < 0) this.flashAlpha = 0;
        }

        // Update particles
        this.particles = this.particles.filter(p => p.update(dt));
    },

    getShakeOffset() {
        if (this.shakeIntensity <= 0) return { x: 0, y: 0 };
        return {
            x: (Math.random() - 0.5) * this.shakeIntensity * 2,
            y: (Math.random() - 0.5) * this.shakeIntensity * 2
        };
    },

    getTimeScale() {
        return this.slowMotionScale;
    },

    draw(ctx, W, H) {
        // Draw particles
        for (const p of this.particles) {
            p.draw(ctx);
        }

        // Draw flash
        if (this.flashAlpha > 0 && this.flashColor) {
            ctx.save();
            ctx.globalAlpha = this.flashAlpha;
            ctx.fillStyle = this.flashColor;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }
    }
};

// Juice particle class
class JuiceParticle {
    constructor(x, y, color, maxSpeed = 150) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * maxSpeed;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1;
        this.decay = 1.5 + Math.random() * 1.5;
        this.size = 2 + Math.random() * 4;
        this.gravity = 50 + Math.random() * 50;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += this.gravity * dt;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life -= this.decay * dt;
        return this.life > 0;
    }

    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// ============================================
// HAPTIC FEEDBACK
// ============================================
const haptics = {
    enabled: true,

    light() {
        if (!this.enabled || !navigator.vibrate) return;
        navigator.vibrate(10);
    },

    medium() {
        if (!this.enabled || !navigator.vibrate) return;
        navigator.vibrate(25);
    },

    heavy() {
        if (!this.enabled || !navigator.vibrate) return;
        navigator.vibrate(50);
    },

    success() {
        if (!this.enabled || !navigator.vibrate) return;
        navigator.vibrate([30, 50, 30, 50, 60]);
    },

    error() {
        if (!this.enabled || !navigator.vibrate) return;
        navigator.vibrate([50, 30, 50]);
    }
};


// ============================================
// ACHIEVEMENT SYSTEM
// ============================================
const achievements = {
    definitions: [
        // Beginner
        { id: 'first_blood', name: 'First Blood', desc: 'Capture your first planet', icon: 'ðŸ©¸', check: s => s.planetsConquered >= 1 },
        { id: 'first_win', name: 'Victor', desc: 'Win your first game', icon: 'ðŸ†', check: s => s.gamesWon >= 1 },

        // Streaks
        { id: 'streak_3', name: 'On Fire', desc: 'Win 3 games in a row', icon: 'ðŸ”¥', check: s => s.bestStreak >= 3 },
        { id: 'streak_5', name: 'Unstoppable', desc: 'Win 5 games in a row', icon: 'âš¡', check: s => s.bestStreak >= 5 },
        { id: 'streak_10', name: 'Legendary', desc: 'Win 10 in a row', icon: 'ðŸ‘‘', check: s => s.bestStreak >= 10 },

        // Speed
        { id: 'speed_2min', name: 'Quick Draw', desc: 'Win in under 2 minutes', icon: 'â±ï¸', check: s => s.fastestWin && s.fastestWin < 120 },
        { id: 'speed_1min', name: 'Blitz', desc: 'Win in under 1 minute', icon: 'ðŸ’¨', check: s => s.fastestWin && s.fastestWin < 60 },
        { id: 'speed_30s', name: 'Speed Demon', desc: 'Win in under 30 seconds', icon: 'ðŸš€', check: s => s.fastestWin && s.fastestWin < 30 },

        // Perfection
        { id: 'perfect_1', name: 'Flawless', desc: 'Win without losing a planet', icon: 'ðŸ’Ž', check: s => s.perfectWins >= 1 },
        { id: 'perfect_5', name: 'Immaculate', desc: '5 perfect wins', icon: 'âœ¨', check: s => s.perfectWins >= 5 },
        { id: 'perfect_10', name: 'Untouchable', desc: '10 perfect wins', icon: 'ðŸŒŸ', check: s => s.perfectWins >= 10 },

        // Volume
        { id: 'conquer_50', name: 'Warlord', desc: 'Capture 50 planets', icon: 'âš”ï¸', check: s => s.planetsConquered >= 50 },
        { id: 'conquer_100', name: 'Conqueror', desc: 'Capture 100 planets', icon: 'ðŸŒ', check: s => s.planetsConquered >= 100 },
        { id: 'conquer_500', name: 'Emperor', desc: 'Capture 500 planets', icon: 'ðŸ‘¸', check: s => s.planetsConquered >= 500 },
        { id: 'games_25', name: 'Regular', desc: 'Play 25 games', icon: 'ðŸŽ¯', check: s => s.gamesPlayed >= 25 },
        { id: 'games_50', name: 'Veteran', desc: 'Play 50 games', icon: 'ðŸŽ–ï¸', check: s => s.gamesPlayed >= 50 },
        { id: 'games_100', name: 'Addicted', desc: 'Play 100 games', icon: 'ðŸŽ®', check: s => s.gamesPlayed >= 100 },

        // Abilities
        { id: 'ability_50', name: 'Gifted', desc: 'Use 50 abilities', icon: 'ðŸ”®', check: s => s.abilitiesUsed >= 50 },
        { id: 'ability_100', name: 'Master', desc: 'Use 100 abilities', icon: 'ðŸ§™', check: s => s.abilitiesUsed >= 100 },

        // Time
        { id: 'time_30m', name: 'Getting Started', desc: 'Play for 30 minutes', icon: 'â°', check: s => s.totalPlayTime >= 1800 },
        { id: 'time_1h', name: 'Dedicated', desc: 'Play for 1 hour', icon: 'ðŸ“…', check: s => s.totalPlayTime >= 3600 },
        { id: 'time_5h', name: 'Committed', desc: 'Play for 5 hours', icon: 'ðŸ’ª', check: s => s.totalPlayTime >= 18000 },

        // Daily
        { id: 'daily_1', name: 'Daily Player', desc: 'Complete a daily challenge', icon: 'ðŸ“†', check: s => countCompletedDailies(s) >= 1 },
        { id: 'daily_10', name: 'Consistent', desc: 'Complete 10 daily challenges', icon: 'ðŸ—“ï¸', check: s => countCompletedDailies(s) >= 10 },

        // Levels
        { id: 'level_5', name: 'Rising Star', desc: 'Reach level 5', icon: 'â­', check: s => s.highestLevel >= 5 },
        { id: 'level_10', name: 'Champion', desc: 'Reach level 10', icon: 'ðŸ…', check: s => s.highestLevel >= 10 },
        { id: 'level_20', name: 'Legend', desc: 'Reach level 20', icon: 'ðŸŒ ', check: s => s.highestLevel >= 20 },
    ],

    unlocked: new Set(),
    toastQueue: [],

    load() {
        this.unlocked = new Set(playerStats.achievements || []);
    },

    check() {
        for (const ach of this.definitions) {
            if (this.unlocked.has(ach.id)) continue;
            if (ach.check && ach.check(playerStats)) {
                this.unlock(ach.id);
            }
        }
    },

    unlock(id) {
        if (this.unlocked.has(id)) return;

        const ach = this.definitions.find(a => a.id === id);
        if (!ach) return;

        this.unlocked.add(id);
        playerStats.achievements = Array.from(this.unlocked);
        saveStats();

        this.showToast(ach);
        playSound('achievement');
        haptics.success();
    },

    showToast(ach) {
        const toast = document.createElement('div');
        toast.className = 'achievement-toast';
        toast.innerHTML = `
            <div class="ach-icon">${ach.icon}</div>
            <div class="ach-info">
                <div class="ach-label">Achievement Unlocked!</div>
                <div class="ach-name">${ach.name}</div>
            </div>
        `;
        document.body.appendChild(toast);

        requestAnimationFrame(() => {
            toast.classList.add('show');
        });

        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 600);
        }, 3500);
    }
};

function countCompletedDailies(stats) {
    let count = 0;
    for (const date in stats.dailyChallenges) {
        count += (stats.dailyChallenges[date].completed || []).length;
    }
    return count;
}

// ============================================
// TUTORIAL SYSTEM
// ============================================
const tutorial = {
    steps: [
        {
            title: "Welcome to Particle Conquest!",
            text: "Conquer all planets to win. Let's learn the basics.",
            waitFor: null
        },
        {
            title: "Your Planets",
            text: "The cyan planets are yours. They generate particles over time.",
            waitFor: null
        },
        {
            title: "Select a Planet",
            text: "Tap one of your planets to select it.",
            waitFor: 'select'
        },
        {
            title: "Attack!",
            text: "Now tap an enemy (red) or neutral (gray) planet to send your particles!",
            waitFor: 'attack'
        },
        {
            title: "Abilities",
            text: "Use special abilities at the bottom for powerful effects. They recharge over time.",
            waitFor: null
        },
        {
            title: "You're Ready!",
            text: "Conquer all enemy planets to win. Good luck, commander!",
            waitFor: null
        }
    ],

    currentStep: 0,
    active: false,
    overlay: null,

    shouldShow() {
        return !playerStats.tutorialComplete && playerStats.gamesPlayed === 0;
    },

    start() {
        if (!this.shouldShow()) return;
        this.active = true;
        this.currentStep = 0;
        this.createOverlay();
        this.showStep();
    },

    createOverlay() {
        this.overlay = document.createElement('div');
        this.overlay.className = 'tutorial-overlay';
        this.updateOverlayContent();
        document.body.appendChild(this.overlay);
    },

    updateOverlayContent() {
        const step = this.steps[this.currentStep];
        const totalSteps = this.steps.length;

        this.overlay.innerHTML = `
            <div class="tutorial-box">
                <div class="step-indicator">
                    ${this.steps.map((_, i) => `
                        <div class="step-dot ${i < this.currentStep ? 'done' : ''} ${i === this.currentStep ? 'active' : ''}"></div>
                    `).join('')}
                </div>
                <h2>${step.title}</h2>
                <p>${step.text}</p>
                <div class="tutorial-btns">
                    ${step.waitFor ? '' : `<button class="tutorial-btn primary" id="tutorialNext">${this.currentStep === totalSteps - 1 ? "Let's Play!" : 'Next'}</button>`}
                    ${this.currentStep === 0 ? `<button class="tutorial-btn secondary" id="tutorialSkip">Skip Tutorial</button>` : ''}
                </div>
                ${step.waitFor ? `<p style="color: #0ff; font-size: 12px; margin-top: 15px;">ðŸ‘† ${step.waitFor === 'select' ? 'Tap your planet' : 'Tap an enemy planet'}</p>` : ''}
            </div>
        `;

        const nextBtn = this.overlay.querySelector('#tutorialNext');
        const skipBtn = this.overlay.querySelector('#tutorialSkip');

        if (nextBtn) {
            nextBtn.onclick = () => this.nextStep();
        }
        if (skipBtn) {
            skipBtn.onclick = () => this.end();
        }
    },

    showStep() {
        this.updateOverlayContent();
        const step = this.steps[this.currentStep];
        if (step.waitFor) {
            this.overlay.classList.add('allow-interaction');
        } else {
            this.overlay.classList.remove('allow-interaction');
        }
    },

    nextStep() {
        playSound('click');
        this.currentStep++;
        if (this.currentStep >= this.steps.length) {
            this.end();
        } else {
            this.showStep();
        }
    },

    onEvent(eventType) {
        if (!this.active) return;
        const step = this.steps[this.currentStep];
        if (step.waitFor === eventType) {
            this.nextStep();
        }
    },

    end() {
        this.active = false;
        playerStats.tutorialComplete = true;
        saveStats();
        if (this.overlay) {
            this.overlay.style.animation = 'fadeIn 0.3s ease reverse forwards';
            setTimeout(() => {
                this.overlay.remove();
                this.overlay = null;
            }, 300);
        }
    }
};

// Comet system
let comets = [];
let lastCometShower = 0;
const COMET_SHOWER_INTERVAL = 15000; // 15 seconds between showers

// Harvest mode particles
let harvestParticles = [];
const HARVEST_PARTICLE_COUNT = 100;

// Abilities
const abilities = {
    boost: { cooldown: 0, maxCooldown: 20, duration: 5, active: false, activeTime: 0 },
    shield: { cooldown: 0, maxCooldown: 25, duration: 8, active: false, targetPlanet: null, activeTime: 0 },
    emp: { cooldown: 0, maxCooldown: 30, duration: 6, active: false, activeTime: 0 },
    nuke: { cooldown: 0, maxCooldown: 35, active: false, activeTime: 0 },
    stealth: { cooldown: 0, maxCooldown: 25, duration: 3, active: false, activeTime: 0 }
};

// Difficulty settings
const DIFFICULTY = {
    easy: { aiSpeed: 0.4, aiAggression: 0.25, planets: 6, startingUnits: 35, specialPlanets: 1 },
    medium: { aiSpeed: 0.7, aiAggression: 0.45, planets: 8, startingUnits: 40, specialPlanets: 2 },
    hard: { aiSpeed: 1.0, aiAggression: 0.65, planets: 10, startingUnits: 50, specialPlanets: 3 },
    brutal: { aiSpeed: 1.4, aiAggression: 0.9, planets: 12, startingUnits: 65, specialPlanets: 4 }
};

// Planet types
const PLANET_TYPES = {
    normal: { productionMult: 1, defenseMult: 1, color: null },
    factory: { productionMult: 2, defenseMult: 1, color: '#44aa44', icon: 'âš™ï¸' },
    fortress: { productionMult: 0.7, defenseMult: 2, color: '#6666ff', icon: 'ðŸ°' },
    wormhole: { productionMult: 0.5, defenseMult: 1, color: '#aa44aa', icon: 'ðŸŒ€' },
    blackhole: { productionMult: 0, defenseMult: 0, color: '#111111', icon: 'âš«' }
};

// Owner constants
const NEUTRAL = 0, PLAYER = 1, ENEMY = 2;

// Helper to convert hex to rgba
function hexToRgba(hex, alpha) {
    hex = hex.replace('#', '');
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Colors
const COLORS = {
    [NEUTRAL]: { main: '#666666', glow: '#444444', particle: '#888888' },
    [PLAYER]: { main: '#00ffff', glow: '#00aaff', particle: '#00ffff' },
    [ENEMY]: { main: '#ff4444', glow: '#ff2222', particle: '#ff6666' }
};

// Team colors for multiplayer (indexes 0-3 for teams, -1 for neutral)
const MP_COLORS = {
    [-1]: { main: '#666666', glow: '#444444', particle: '#888888' }, // Neutral
    [0]: { main: '#00ffff', glow: '#00aaff', particle: '#00ffff' },  // Cyan (Team 1)
    [1]: { main: '#ff4444', glow: '#ff2222', particle: '#ff6666' },  // Red (Team 2)
    [2]: { main: '#ff9900', glow: '#ff7700', particle: '#ffaa44' },  // Orange (Team 3)
    [3]: { main: '#aa44ff', glow: '#8822ff', particle: '#bb66ff' }   // Purple (Team 4)
};

// Get color based on owner (works in both single player and multiplayer)
function getOwnerColor(owner) {
    if (multiplayerActive) {
        return MP_COLORS[owner] || MP_COLORS[-1];
    }
    return COLORS[owner] || COLORS[NEUTRAL];
}

// Get team label for display
function getTeamLabel(owner) {
    if (multiplayerActive) {
        const myPlayer = lobby.players.find(p => p.id === myPlayerId);
        if (myPlayer && myPlayer.team === owner) return 'YOU';
        return owner >= 0 ? `T${owner + 1}` : '';
    }
    if (owner === PLAYER) return 'YOU';
    if (owner === ENEMY) return 'AI';
    return '';
}

let planets = [];
let flyingParticles = [];
let bgParticles = [];
let effects = [];
let wormholePairs = [];

// ==================== RALLY POINT SYSTEM ====================
let rallyPoints = new Map(); // planet index -> target planet index
const RALLY_AUTO_SEND_THRESHOLD = 5;
let longPressTimer = null;
let longPressTarget = null;
const LONG_PRESS_DURATION = 500; // ms for mobile long-press

// ==================== POST-GAME TIMELINE ====================
let gameTimeline = []; // { time: seconds, type: string, icon: string, desc: string }
let unitCountHistory = []; // { time, player, enemy }
let unitHistoryInterval = null;

function pushTimelineEvent(type, icon, desc) {
    if (game.state !== 'playing' && game.state !== 'harvest') return;
    const elapsed = (Date.now() - (currentGameStats.startTime || Date.now())) / 1000;
    gameTimeline.push({ time: elapsed, type, icon, desc });
}

function startUnitTracking() {
    unitCountHistory = [];
    if (unitHistoryInterval) clearInterval(unitHistoryInterval);
    unitHistoryInterval = setInterval(() => {
        if (game.state !== 'playing') return;
        let pUnits = 0, eUnits = 0;
        for (const p of planets) {
            if (p.owner === PLAYER) pUnits += Math.floor(p.units);
            if (p.owner === ENEMY) eUnits += Math.floor(p.units);
        }
        pUnits += flyingParticles.filter(p => p.owner === PLAYER).length;
        eUnits += flyingParticles.filter(p => p.owner === ENEMY).length;
        const elapsed = (Date.now() - (currentGameStats.startTime || Date.now())) / 1000;
        unitCountHistory.push({ time: elapsed, player: pUnits, enemy: eUnits });
    }, 2000);
}

function stopUnitTracking() {
    if (unitHistoryInterval) { clearInterval(unitHistoryInterval); unitHistoryInterval = null; }
}

// ==================== BETWEEN-LEVEL UPGRADE SYSTEM ====================
let chosenUpgrades = []; // array of upgrade ids
const ALL_UPGRADES = [
    { id: 'particle_speed', name: 'Swift Particles', icon: 'ðŸ’¨', desc: '+15% particle speed', apply: () => { upgradeModifiers.particleSpeedMult += 0.15; } },
    { id: 'shield_duration', name: 'Fortified Shields', icon: 'ðŸ›¡ï¸', desc: 'Shield duration +3s', apply: () => { upgradeModifiers.shieldDurationBonus += 3; } },
    { id: 'extra_planet', name: 'Advance Scout', icon: 'ðŸŒ', desc: 'Start with an extra planet', apply: () => { upgradeModifiers.extraStartPlanets += 1; } },
    { id: 'nuke_cooldown', name: 'Rapid Warheads', icon: 'â˜¢ï¸', desc: 'Nuke cooldown -5s', apply: () => { upgradeModifiers.nukeCooldownReduction += 5; } },
    { id: 'production_boost', name: 'Overdrive', icon: 'âš™ï¸', desc: '+20% unit production', apply: () => { upgradeModifiers.productionMult += 0.20; } },
    { id: 'starting_units', name: 'Reinforcements', icon: 'ðŸš€', desc: '+10 starting units', apply: () => { upgradeModifiers.startingUnitsBonus += 10; } },
    { id: 'emp_duration', name: 'EMP Overcharge', icon: 'ðŸ’¥', desc: 'EMP duration +3s', apply: () => { upgradeModifiers.empDurationBonus += 3; } },
    { id: 'boost_duration', name: 'Afterburners', icon: 'âš¡', desc: 'Boost duration +3s', apply: () => { upgradeModifiers.boostDurationBonus += 3; } },
    { id: 'defense_bonus', name: 'Hardened Armor', icon: 'ðŸ°', desc: '+25% planet defense', apply: () => { upgradeModifiers.defenseMult += 0.25; } },
    { id: 'max_units', name: 'Expanded Capacity', icon: 'ðŸ“¦', desc: '+30% max planet units', apply: () => { upgradeModifiers.maxUnitsMult += 0.30; } }
];

let upgradeModifiers = {
    particleSpeedMult: 0,
    shieldDurationBonus: 0,
    nukeCooldownReduction: 0,
    productionMult: 0,
    extraStartPlanets: 0,
    startingUnitsBonus: 0,
    empDurationBonus: 0,
    boostDurationBonus: 0,
    defenseMult: 0,
    maxUnitsMult: 0
};

function resetUpgrades() {
    chosenUpgrades = [];
    upgradeModifiers = {
        particleSpeedMult: 0, shieldDurationBonus: 0, nukeCooldownReduction: 0,
        productionMult: 0, extraStartPlanets: 0, startingUnitsBonus: 0,
        empDurationBonus: 0, boostDurationBonus: 0, defenseMult: 0, maxUnitsMult: 0
    };
}

function applyAllUpgrades() {
    // Reset modifiers
    upgradeModifiers = {
        particleSpeedMult: 0, shieldDurationBonus: 0, nukeCooldownReduction: 0,
        productionMult: 0, extraStartPlanets: 0, startingUnitsBonus: 0,
        empDurationBonus: 0, boostDurationBonus: 0, defenseMult: 0, maxUnitsMult: 0
    };
    for (const id of chosenUpgrades) {
        const upg = ALL_UPGRADES.find(u => u.id === id);
        if (upg) upg.apply();
    }
}

function showUpgradeScreen() {
    // Pick 3 random upgrades not yet maxed
    const available = ALL_UPGRADES.filter(u => {
        const count = chosenUpgrades.filter(id => id === u.id).length;
        return count < 3; // max 3 stacks
    });
    const shuffled = available.sort(() => Math.random() - 0.5).slice(0, 3);
    if (shuffled.length === 0) { proceedToNextLevel(); return; }

    const container = document.getElementById('upgradeCards');
    container.innerHTML = '';
    for (const upg of shuffled) {
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        const stackCount = chosenUpgrades.filter(id => id === upg.id).length;
        card.innerHTML = `
            <div class="upg-icon">${upg.icon}</div>
            <div class="upg-name">${upg.name}${stackCount > 0 ? ' x' + (stackCount+1) : ''}</div>
            <div class="upg-desc">${upg.desc}</div>
        `;
        card.addEventListener('click', () => {
            chosenUpgrades.push(upg.id);
            applyAllUpgrades();
            playSound('ability');
            document.getElementById('upgradeScreen').classList.add('hidden');
            proceedToNextLevel();
        });
        container.appendChild(card);
    }

    // Show active upgrades
    const activeEl = document.getElementById('activeUpgrades');
    if (chosenUpgrades.length > 0) {
        const counts = {};
        for (const id of chosenUpgrades) counts[id] = (counts[id]||0) + 1;
        activeEl.innerHTML = Object.entries(counts).map(([id, ct]) => {
            const u = ALL_UPGRADES.find(a => a.id === id);
            return `<span class="active-upgrade-tag">${u.icon} ${u.name}${ct > 1 ? ' x'+ct : ''}</span>`;
        }).join('');
    } else {
        activeEl.innerHTML = '';
    }

    document.getElementById('upgradeScreen').classList.remove('hidden');
}

function proceedToNextLevel() {
    playerHarvested = 0;
    enemyHarvested = 0;
    resetCurrentGameStats();
    generateLevel();
    startMusic();
}

// ==================== MINIMAP SYSTEM ====================
const minimapCanvas = document.getElementById('minimapCanvas');
const minimapCtx = minimapCanvas.getContext('2d');
const MINIMAP_SIZE = 140;
let discoveredPlanets = new Set(); // indices of planets the player has seen

function updateDiscoveredPlanets() {
    for (let i = 0; i < planets.length; i++) {
        const p = planets[i];
        if (isMyPlanet(p) || !game.features.fog || isVisibleToPlayer(p.x, p.y)) {
            discoveredPlanets.add(i);
        }
    }
}

function drawMinimap() {
    if (game.state !== 'playing' && game.state !== 'harvest') return;

    const mc = minimapCtx;
    mc.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

    // Background
    mc.fillStyle = 'rgba(0,0,0,0.6)';
    mc.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

    const scaleX = MINIMAP_SIZE / W;
    const scaleY = MINIMAP_SIZE / H;

    updateDiscoveredPlanets();

    // Draw planets as dots
    const now = Date.now();
    for (let i = 0; i < planets.length; i++) {
        const p = planets[i];
        // Respect fog of war - only show discovered planets
        if (game.features.fog && !discoveredPlanets.has(i)) continue;

        const mx = p.x * scaleX;
        const my = p.y * scaleY;
        const mr = Math.max(3, p.size * scaleX * 0.6);

        // Color by ownership
        const colors = getOwnerColor(p.owner);
        mc.fillStyle = colors.main;

        // Check for active combat (flying particles targeting this planet)
        const hasCombat = flyingParticles.some(fp => fp.target === p && fp.owner !== p.owner);
        if (hasCombat) {
            // Pulsing effect for combat
            const pulse = 0.5 + Math.sin(now / 150) * 0.5;
            mc.fillStyle = `rgba(255, 255, 100, ${0.5 + pulse * 0.5})`;
            mc.beginPath();
            mc.arc(mx, my, mr + 2 + pulse * 2, 0, Math.PI * 2);
            mc.fill();
            mc.fillStyle = colors.main;
        }

        mc.beginPath();
        mc.arc(mx, my, mr, 0, Math.PI * 2);
        mc.fill();
    }

    // Draw rally point arrows on minimap
    for (const [srcIdx, tgtIdx] of rallyPoints) {
        const src = planets[srcIdx];
        const tgt = planets[tgtIdx];
        if (!src || !tgt) continue;
        mc.strokeStyle = 'rgba(0,255,255,0.5)';
        mc.lineWidth = 1;
        mc.beginPath();
        mc.moveTo(src.x * scaleX, src.y * scaleY);
        mc.lineTo(tgt.x * scaleX, tgt.y * scaleY);
        mc.stroke();
    }

    // Viewport indicator (for future pan/zoom, show full viewport for now)
    mc.strokeStyle = 'rgba(255,255,255,0.5)';
    mc.lineWidth = 1;
    mc.strokeRect(1, 1, MINIMAP_SIZE - 2, MINIMAP_SIZE - 2);
}

// ==================== RENDER TIMELINE ON END SCREEN ====================
function renderTimeline() {
    const section = document.getElementById('timelineSection');
    const bar = document.getElementById('timelineBar');
    if (!gameTimeline.length && !unitCountHistory.length) {
        section.style.display = 'none';
        return;
    }
    section.style.display = 'block';
    bar.innerHTML = '';

    const totalTime = currentGameStats.gameTime || 1;

    // Render event icons
    for (const evt of gameTimeline) {
        const pct = Math.min(100, (evt.time / totalTime) * 100);
        const el = document.createElement('div');
        el.className = 'timeline-event';
        el.style.left = pct + '%';
        el.innerHTML = `${evt.icon}<span class="tl-tooltip">${Math.floor(evt.time)}s - ${evt.desc}</span>`;
        bar.appendChild(el);
    }

    // Render sparkline
    if (unitCountHistory.length > 1) {
        const sparkCanvas = document.getElementById('sparklineCanvas');
        const rect = sparkCanvas.parentElement.getBoundingClientRect();
        sparkCanvas.width = rect.width || 500;
        sparkCanvas.height = 50;
        const sc = sparkCanvas.getContext('2d');
        sc.clearRect(0, 0, sparkCanvas.width, sparkCanvas.height);

        const maxUnits = Math.max(1, ...unitCountHistory.map(h => Math.max(h.player, h.enemy)));
        const w = sparkCanvas.width;
        const h = sparkCanvas.height;

        // Player line (cyan)
        sc.strokeStyle = '#0ff';
        sc.lineWidth = 2;
        sc.beginPath();
        unitCountHistory.forEach((pt, i) => {
            const x = (pt.time / totalTime) * w;
            const y = h - (pt.player / maxUnits) * (h - 4) - 2;
            if (i === 0) sc.moveTo(x, y);
            else sc.lineTo(x, y);
        });
        sc.stroke();

        // Enemy line (red)
        sc.strokeStyle = '#f44';
        sc.lineWidth = 2;
        sc.beginPath();
        unitCountHistory.forEach((pt, i) => {
            const x = (pt.time / totalTime) * w;
            const y = h - (pt.enemy / maxUnits) * (h - 4) - 2;
            if (i === 0) sc.moveTo(x, y);
            else sc.lineTo(x, y);
        });
        sc.stroke();

        // Labels
        sc.fillStyle = '#0ff';
        sc.font = '9px system-ui';
        sc.fillText('You', 4, 10);
        sc.fillStyle = '#f44';
        sc.fillText('AI', 30, 10);
    }
}

// ==================== POST-MATCH STATISTICS DASHBOARD ====================
function renderPostMatchDashboard() {
    const dashboard = document.getElementById('postMatchDashboard');
    const grid = document.getElementById('dashboardGrid');
    if (!dashboard || !grid || !currentGameStats) return;

    dashboard.style.display = 'block';

    // Calculate derived stats
    const gameTime = currentGameStats.gameTime || 1;
    const mins = Math.floor(gameTime / 60);
    const secs = Math.floor(gameTime % 60);
    const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;

    const avgResponse = currentGameStats.responseTimes.length > 0
        ? (currentGameStats.responseTimes.reduce((a, b) => a + b, 0) / currentGameStats.responseTimes.length).toFixed(1)
        : '--';

    const winRate = playerStats.gamesPlayed > 0
        ? Math.round((playerStats.gamesWon / playerStats.gamesPlayed) * 100)
        : 0;

    // Build stats array
    const stats = [
        { value: Math.floor(currentGameStats.particlesProduced), label: 'Units Produced', colorClass: 'cyan' },
        { value: currentGameStats.particlesKilled, label: 'Enemy Killed', colorClass: 'green' },
        { value: currentGameStats.particlesLost, label: 'Units Lost', colorClass: 'red' },
        { value: currentGameStats.planetsConqueredThisGame || 0, label: 'Planets Taken', colorClass: 'cyan' },
        { value: currentGameStats.planetsLostThisGame || 0, label: 'Planets Lost', colorClass: 'red' },
        { value: currentGameStats.largestArmySent || 0, label: 'Largest Army', colorClass: 'gold' },
        { value: avgResponse !== '--' ? avgResponse + 's' : '--', label: 'Avg Response', colorClass: '' },
        { value: currentGameStats.attacksSent || 0, label: 'Attacks Sent', colorClass: '' },
        { value: winRate + '%', label: 'Win Rate', colorClass: winRate > 55 ? 'green' : (winRate < 45 ? 'red' : '') }
    ];

    grid.innerHTML = stats.map(s => `
        <div class="dash-stat">
            <div class="dash-stat-value ${s.colorClass}">${s.value}</div>
            <div class="dash-stat-label">${s.label}</div>
        </div>
    `).join('');

    // Render territory control graph
    renderTerritoryGraph();
}

function renderTerritoryGraph() {
    const canvas = document.getElementById('territoryGraphCanvas');
    if (!canvas || !currentGameStats || !currentGameStats.territoryHistory) return;

    const history = currentGameStats.territoryHistory;
    if (history.length < 2) return;

    const container = canvas.parentElement;
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width || 580;
    canvas.height = rect.height || 80;

    const gc = canvas.getContext('2d');
    gc.clearRect(0, 0, canvas.width, canvas.height);

    const w = canvas.width;
    const h = canvas.height;
    const totalTime = currentGameStats.gameTime || 1;

    // Find total planet count (excluding black holes)
    const totalPlanets = planets.filter(p => p.type !== 'blackhole').length || 1;

    // Draw stacked area chart
    // Bottom: player (cyan), Middle: neutral (gray), Top: enemy (red)
    gc.globalAlpha = 0.4;

    // Player area (cyan, from bottom)
    gc.fillStyle = '#0ff';
    gc.beginPath();
    gc.moveTo(0, h);
    for (let i = 0; i < history.length; i++) {
        const x = (history[i].time / totalTime) * w;
        const playerH = (history[i].playerPlanets / totalPlanets) * h;
        gc.lineTo(x, h - playerH);
    }
    gc.lineTo((history[history.length - 1].time / totalTime) * w, h);
    gc.closePath();
    gc.fill();

    // Enemy area (red, from top)
    gc.fillStyle = '#f44';
    gc.beginPath();
    gc.moveTo(0, 0);
    for (let i = 0; i < history.length; i++) {
        const x = (history[i].time / totalTime) * w;
        const enemyH = (history[i].enemyPlanets / totalPlanets) * h;
        gc.lineTo(x, enemyH);
    }
    gc.lineTo((history[history.length - 1].time / totalTime) * w, 0);
    gc.closePath();
    gc.fill();

    gc.globalAlpha = 1;

    // Draw player territory line
    gc.strokeStyle = '#0ff';
    gc.lineWidth = 2;
    gc.beginPath();
    for (let i = 0; i < history.length; i++) {
        const x = (history[i].time / totalTime) * w;
        const y = h - (history[i].playerPlanets / totalPlanets) * h;
        if (i === 0) gc.moveTo(x, y);
        else gc.lineTo(x, y);
    }
    gc.stroke();

    // Draw enemy territory line
    gc.strokeStyle = '#f44';
    gc.lineWidth = 2;
    gc.beginPath();
    for (let i = 0; i < history.length; i++) {
        const x = (history[i].time / totalTime) * w;
        const y = (history[i].enemyPlanets / totalPlanets) * h;
        if (i === 0) gc.moveTo(x, y);
        else gc.lineTo(x, y);
    }
    gc.stroke();

    // Time labels
    gc.fillStyle = '#555';
    gc.font = '9px system-ui';
    gc.textAlign = 'left';
    gc.fillText('0:00', 3, h - 3);
    gc.textAlign = 'right';
    const endMins = Math.floor(totalTime / 60);
    const endSecs = Math.floor(totalTime % 60);
    gc.fillText(`${endMins}:${endSecs.toString().padStart(2, '0')}`, w - 3, h - 3);

    // Percentage labels at end
    if (history.length > 0) {
        const last = history[history.length - 1];
        const playerPct = Math.round((last.playerPlanets / totalPlanets) * 100);
        const enemyPct = Math.round((last.enemyPlanets / totalPlanets) * 100);
        gc.textAlign = 'right';
        gc.fillStyle = '#0ff';
        gc.font = 'bold 10px system-ui';
        gc.fillText(playerPct + '%', w - 3, h - 14);
        gc.fillStyle = '#f44';
        gc.fillText(enemyPct + '%', w - 3, 14);
    }
}

// ==================== RALLY POINT DRAWING & AUTO-SEND ====================
function drawRallyPoints() {
    for (const [srcIdx, tgtIdx] of rallyPoints) {
        const src = planets[srcIdx];
        const tgt = planets[tgtIdx];
        if (!src || !tgt || !isMyPlanet(src)) continue;

        const dx = tgt.x - src.x;
        const dy = tgt.y - src.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);

        // Thin colored arrow
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 255, 200, 0.4)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(src.x, src.y);
        ctx.lineTo(tgt.x, tgt.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Arrowhead
        const headLen = 12;
        const ax = tgt.x - Math.cos(angle) * (tgt.size + 10);
        const ay = tgt.y - Math.sin(angle) * (tgt.size + 10);
        ctx.fillStyle = 'rgba(0, 255, 200, 0.6)';
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax - headLen * Math.cos(angle - 0.4), ay - headLen * Math.sin(angle - 0.4));
        ctx.lineTo(ax - headLen * Math.cos(angle + 0.4), ay - headLen * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();

        // Small "R" indicator on source planet
        ctx.fillStyle = 'rgba(0, 255, 200, 0.7)';
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('R', src.x + src.size + 12, src.y - src.size - 2);
        ctx.restore();
    }
}

function updateRallyAutoSend(dt) {
    for (const [srcIdx, tgtIdx] of rallyPoints) {
        const src = planets[srcIdx];
        const tgt = planets[tgtIdx];
        if (!src || !tgt) { rallyPoints.delete(srcIdx); continue; }
        if (!isMyPlanet(src)) { rallyPoints.delete(srcIdx); continue; }

        // Auto-send when planet accumulates enough units
        if (src.units >= RALLY_AUTO_SEND_THRESHOLD + 2) {
            const toSend = Math.floor(src.units - 2); // keep 2 on planet
            if (toSend >= RALLY_AUTO_SEND_THRESHOLD) {
                sendUnits(src, tgt, Math.floor((toSend / src.units) * 100));
            }
        }
    }
}

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

// Effects system
class Effect {
    constructor(type, x, y, data = {}) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.data = data;
        this.age = 0;
        this.maxAge = data.duration || 1;
    }
    
    update(dt) {
        this.age += dt;
        return this.age < this.maxAge;
    }
    
    draw() {
        const progress = this.age / this.maxAge;
        
        switch(this.type) {
            case 'capture':
                const radius = this.data.radius * (1 + progress * 2);
                const alpha = 1 - progress;
                ctx.strokeStyle = hexToRgba(this.data.color, alpha);
                ctx.lineWidth = 4 * (1 - progress);
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 2;
                    const dist = radius * 0.8;
                    const px = this.x + Math.cos(angle) * dist;
                    const py = this.y + Math.sin(angle) * dist;
                    ctx.fillStyle = hexToRgba(this.data.color, alpha * 0.78);
                    ctx.beginPath();
                    ctx.arc(px, py, 4 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 'explosion':
                const expRadius = 50 * progress;
                const expAlpha = 1 - progress;
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, expRadius);
                grad.addColorStop(0, `rgba(255, 200, 100, ${expAlpha})`);
                grad.addColorStop(0.5, `rgba(255, 100, 50, ${expAlpha * 0.5})`);
                grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, expRadius, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'shield':
                if (!this.data.planet) return;
                const shieldAlpha = 0.3 + Math.sin(this.age * 10) * 0.1;
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.data.planet.x, this.data.planet.y, this.data.planet.size + 20, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha * 0.5})`;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + this.age;
                    const r = this.data.planet.size + 20;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.data.planet.x + Math.cos(angle) * r,
                        this.data.planet.y + Math.sin(angle) * r
                    );
                    ctx.lineTo(
                        this.data.planet.x + Math.cos(angle + Math.PI/3) * r,
                        this.data.planet.y + Math.sin(angle + Math.PI/3) * r
                    );
                    ctx.stroke();
                }
                break;
                
            case 'wormhole':
                const wAlpha = 0.5 - progress * 0.5;
                ctx.strokeStyle = `rgba(170, 68, 170, ${wAlpha})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 20 + i * 10 + progress * 30, 
                           this.age * 3 + i, this.age * 3 + i + Math.PI);
                    ctx.stroke();
                }
                break;
                
            case 'selectAll':
                // Flash effect when selecting all planets
                const selectAlpha = (1 - progress) * 0.5;
                ctx.strokeStyle = `rgba(0, 255, 255, ${selectAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.data.radius + progress * 50, 0, Math.PI * 2);
                ctx.stroke();
                break;
        }
    }
}

// Planet class
class Planet {
    constructor(x, y, size, owner, units, type = 'normal') {
        this.x = x;
        this.y = y;
        this.size = size;
        this.owner = owner;
        this.units = units;
        this.type = type;
        this.typeData = PLANET_TYPES[type];
        this.maxUnits = Math.floor(size * 3);
        // ENHANCED: Production rate now scales more dramatically with size
        // Larger planets (size ~65) produce ~3x faster than small planets (size ~30)
        this.baseProductionRate = (size * size) / 2000; // Quadratic scaling
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.shielded = false;
        this.shieldTime = 0;
        this.empTime = 0;
        this.wormholePartner = null;
        this.orbitParticles = [];
        this.blackHoleAngle = 0;
        this.selected = false; // Track selection state
        
        const numOrbits = Math.floor(size / 15);
        for (let i = 0; i < numOrbits; i++) {
            this.orbitParticles.push({
                angle: Math.random() * Math.PI * 2,
                distance: size + 10 + Math.random() * 20,
                speed: (0.5 + Math.random() * 0.5) * (Math.random() < 0.5 ? 1 : -1)
            });
        }
    }
    
    get productionRate() {
        const myTeam = getMyTeam();
        const isEnemy = multiplayerActive ? this.owner !== myTeam && this.owner >= 0 : this.owner === ENEMY;
        if (this.empTime > 0 && isEnemy) return 0;
        let rate = this.baseProductionRate * this.typeData.productionMult;
        // Apply upgrade: production bonus for player planets
        const isMine = multiplayerActive ? this.owner === myTeam : this.owner === PLAYER;
        if (isMine && upgradeModifiers.productionMult > 0) {
            rate *= (1 + upgradeModifiers.productionMult);
        }
        // Adaptive AI: adjust enemy production rate based on player performance
        if (isEnemy && !multiplayerActive) {
            const adaptiveSettings = getAdaptiveAISettings();
            if (adaptiveSettings.enemyProductionMult) {
                rate *= adaptiveSettings.enemyProductionMult;
            }
        }
        return rate;
    }

    get defenseMult() {
        let mult = this.typeData.defenseMult;
        if (mult === 0) mult = 0.01;
        if (this.shielded) mult *= 10;
        // Apply upgrade: defense bonus for player planets
        const myTeam = getMyTeam();
        const isMine = multiplayerActive ? this.owner === myTeam : this.owner === PLAYER;
        if (isMine && upgradeModifiers.defenseMult > 0) {
            mult *= (1 + upgradeModifiers.defenseMult);
        }
        return mult;
    }

    get effectiveMaxUnits() {
        let max = this.maxUnits;
        const myTeam = getMyTeam();
        const isMine = multiplayerActive ? this.owner === myTeam : this.owner === PLAYER;
        if (isMine && upgradeModifiers.maxUnitsMult > 0) {
            max *= (1 + upgradeModifiers.maxUnitsMult);
        }
        return max;
    }
    
    update(dt) {
        if (this.shieldTime > 0) {
            this.shieldTime -= dt;
            if (this.shieldTime <= 0) this.shielded = false;
        }
        
        if (this.empTime > 0) {
            this.empTime -= dt;
        }
        
        const isNeutral = multiplayerActive ? this.owner < 0 : this.owner === NEUTRAL;
        if (!isNeutral && this.units < this.effectiveMaxUnits && this.type !== 'blackhole') {
            const produced = this.productionRate * dt;
            this.units += produced;
            // Track production for post-match stats
            if (currentGameStats && this.owner === PLAYER) {
                currentGameStats.particlesProduced += produced;
            }
        }
        
        if (this.type === 'blackhole') {
            this.blackHoleAngle += dt * 2;
        }
        
        this.pulsePhase += dt * 2;
        
        for (const p of this.orbitParticles) {
            p.angle += p.speed * dt;
        }
        
        // Update selection state based on game.selectedPlanets
        this.selected = game.selectedPlanets.includes(this);
    }
    
    draw() {
        const ownerColors = getOwnerColor(this.owner);
        const baseColor = this.typeData.color || ownerColors.main;
        const glowColor = this.typeData.color || ownerColors.glow;
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.05;
        
        // Black hole special rendering
        if (this.type === 'blackhole') {
            const bhGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
            bhGrad.addColorStop(0, '#000');
            bhGrad.addColorStop(0.5, 'rgba(50, 0, 50, 0.8)');
            bhGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = bhGrad;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.53)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size * 1.5, this.size * 0.5, 
                           this.blackHoleAngle + i * 0.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#f44';
            ctx.lineWidth = 2;
            ctx.stroke();
            return;
        }
        
        // Wormhole special rendering
        if (this.type === 'wormhole') {
            ctx.strokeStyle = 'rgba(170, 68, 170, 0.53)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const spiralAngle = this.pulsePhase + i * Math.PI / 2;
                ctx.beginPath();
                for (let t = 0; t < 1; t += 0.05) {
                    const r = this.size * t;
                    const a = spiralAngle + t * Math.PI * 2;
                    const px = this.x + Math.cos(a) * r;
                    const py = this.y + Math.sin(a) * r;
                    if (t === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
        }
        
        // Glow
        const gradient = ctx.createRadialGradient(
            this.x, this.y, this.size * 0.5,
            this.x, this.y, this.size * 2
        );
        gradient.addColorStop(0, hexToRgba(glowColor, 0.25));
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Planet body
        ctx.fillStyle = hexToRgba(baseColor, 0.19);
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = this.type === 'fortress' ? 4 : 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // OWNERSHIP RING
        const isOwned = multiplayerActive ? this.owner >= 0 : this.owner !== NEUTRAL;
        if (isOwned) {
            const ownerColor = getOwnerColor(this.owner).main;
            ctx.strokeStyle = ownerColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = hexToRgba(ownerColor, 0.4);
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
        } else {
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Type indicator
        if (this.typeData.icon) {
            ctx.font = `${this.size * 0.4}px system-ui`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.typeData.icon, this.x, this.y - this.size * 0.5);
        }
        
        // SELECTION RING - Enhanced for multi-select
        if (this.selected) {
            const selectionPulse = (Math.sin(Date.now() / 150) + 1) / 2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 + selectionPulse * 0.3})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Selection glow
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + selectionPulse * 0.2})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // Selection number indicator
            const selIndex = game.selectedPlanets.indexOf(this) + 1;
            if (game.selectedPlanets.length > 1) {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`#${selIndex}`, this.x + this.size + 20, this.y - this.size - 5);
            }
        }
        
        // Shield effect
        if (this.shielded) {
            const shieldAlpha = 0.3 + Math.sin(this.pulsePhase * 3) * 0.1;
            ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 18, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // EMP effect
        if (this.empTime > 0 && this.owner === ENEMY) {
            ctx.strokeStyle = 'rgba(255, 240, 0, 0.53)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 10, this.pulsePhase, this.pulsePhase + Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Orbiting particles
        const orbitColor = getOwnerColor(this.owner).particle;
        ctx.fillStyle = orbitColor;
        for (const p of this.orbitParticles) {
            const px = this.x + Math.cos(p.angle) * p.distance;
            const py = this.y + Math.sin(p.angle) * p.distance;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Unit count - HIDE if planet is in fog and not ours
        // Use try-catch to ensure rendering continues even if visibility check fails
        let planetVisible = true;
        let isMine = false;
        try {
            isMine = isMyPlanet(this);
            planetVisible = isMine || isVisibleToPlayer(this.x, this.y);
        } catch (e) {
            // Fallback: show everything if visibility check fails
            planetVisible = true;
            console.warn('Visibility check error:', e);
        }

        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(14, this.size / 3)}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (planetVisible) {
            // Show real unit count
            ctx.fillText(Math.floor(this.units), this.x, this.y);

            // Production rate indicator (small text showing rate)
            if (this.owner !== NEUTRAL && this.type !== 'blackhole') {
                const rate = this.productionRate.toFixed(1);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '10px system-ui';
                ctx.fillText(`+${rate}/s`, this.x, this.y + this.size * 0.4);
            }
        } else {
            // Planet in fog - show "?" for unit count (still visible but info hidden)
            ctx.fillStyle = 'rgba(150, 150, 150, 0.7)';
            ctx.fillText('?', this.x, this.y);
        }

        // Ownership label - only show if visible
        try {
            const teamLabel = getTeamLabel(this.owner);
            if (teamLabel && planetVisible) {
                ctx.fillStyle = getOwnerColor(this.owner).main;
                ctx.font = 'bold 10px system-ui';
                ctx.fillText(teamLabel, this.x, this.y + this.size + 18);
            }
        } catch (e) {
            // Ignore team label errors
        }
    }
    
    containsPoint(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.size + 20;
    }
}

// Flying particle
class FlyingParticle {
    constructor(x, y, targetPlanet, owner) {
        this.x = x;
        this.y = y;
        this.target = targetPlanet;
        this.owner = owner;
        this.baseSpeed = 150;
        this.trail = [];
        this.stealthTime = 0; // Time remaining in stealth
    }
    
    get speed() {
        let spd = this.baseSpeed;
        const isMyTeam = multiplayerActive
            ? lobby.players.find(p => p.id === myPlayerId)?.team === this.owner
            : this.owner === PLAYER;
        if (isMyTeam && abilities.boost.active) spd *= 3;
        // Apply upgrade: particle speed bonus
        if (isMyTeam && upgradeModifiers.particleSpeedMult > 0) {
            spd *= (1 + upgradeModifiers.particleSpeedMult);
        }
        return spd;
    }
    
    update(dt) {
        // Update stealth timer
        if (this.stealthTime > 0) {
            this.stealthTime -= dt;
        }

        let targetX = this.target.x;
        let targetY = this.target.y;

        // Check for black hole pull
        for (const planet of planets) {
            if (planet.type === 'blackhole') {
                const dx = planet.x - this.x;
                const dy = planet.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    const pullForce = (200 - dist) / 200 * 2;
                    this.x += (dx / dist) * pullForce;
                    this.y += (dy / dist) * pullForce;
                }
                
                if (dist < planet.size) {
                    effects.push(new Effect('explosion', this.x, this.y, { duration: 0.3 }));
                    return false;
                }
            }
        }
        
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < this.target.size) {
            if (this.target.type === 'blackhole') {
                effects.push(new Effect('explosion', this.x, this.y, { duration: 0.3 }));
                return false;
            }
            
            if (this.target.owner === this.owner) {
                this.target.units += 1;
            } else {
                const damage = 1 / this.target.defenseMult;
                this.target.units -= damage;

                // Track particles killed/lost for post-match stats
                if (currentGameStats) {
                    if (this.owner === PLAYER) {
                        // Player particle attacking enemy - enemy "loses" some defense
                        currentGameStats.particlesKilled++;
                        playerStats.unitsDestroyed++;
                    } else if (this.target.owner === PLAYER) {
                        // Enemy particle attacking player planet
                        currentGameStats.particlesLost++;
                    }
                }

                if (this.target.units <= 0) {
                    const prevOwner = this.target.owner;
                    this.target.owner = this.owner;
                    this.target.units = 1;

                    // Track capture stats and play sounds
                    const isMyTeam = multiplayerActive
                        ? lobby.players.find(p => p.id === myPlayerId)?.team === this.owner
                        : this.owner === PLAYER;
                    const wasMyTeam = multiplayerActive
                        ? lobby.players.find(p => p.id === myPlayerId)?.team === prevOwner
                        : prevOwner === PLAYER;

                    if (isMyTeam) {
                        playerStats.planetsConquered++;
                        if (currentGameStats) currentGameStats.planetsConqueredThisGame++;
                        playSound('capture');
                        // Capture juice!
                        const teamColor = getOwnerColor(this.owner).main;
                        juice.shake(12, 200);
                        juice.burst(this.target.x, this.target.y, teamColor, 25, 120);
                        juice.flash(teamColor, 0.2);
                        haptics.heavy();
                        // Timeline event: planet captured
                        pushTimelineEvent('capture', 'ðŸ´', 'Captured a planet');

                        // Check if all planets owned for daily challenge
                        if (!multiplayerActive && planets.every(p => p.owner === PLAYER)) {
                            currentGameStats.allPlanetsOwned = true;
                        }
                        // Check achievements after capture
                        achievements.check();
                    } else if (wasMyTeam) {
                        playerStats.planetsLost++;
                        currentGameStats.perfectWin = false;
                        currentGameStats.planetsLostThisGame++;
                        // Track time of enemy action for response time calculation
                        if (currentGameStats) currentGameStats.lastEnemyActionTime = Date.now();
                        playSound('lose');
                        // Lose planet juice
                        juice.shake(10, 150);
                        juice.burst(this.target.x, this.target.y, '#f44', 20, 100);
                        haptics.error();
                        // Timeline event: planet lost
                        pushTimelineEvent('lost', 'ðŸ’”', 'Lost a planet');
                    }

                    const captureColors = getOwnerColor(this.owner);
                    effects.push(new Effect('capture', this.target.x, this.target.y, {
                        duration: 0.8,
                        radius: this.target.size,
                        color: captureColors.main
                    }));

                    showFloatText(this.target.x, this.target.y, 'CAPTURED!', captureColors.main);
                }
            }
            return false;
        }
        
        this.trail.push({ x: this.x, y: this.y, age: 0 });
        if (this.trail.length > 10) this.trail.shift();
        for (const t of this.trail) t.age += dt;
        
        this.x += (dx / dist) * this.speed * dt;
        this.y += (dy / dist) * this.speed * dt;
        
        this.x += Math.sin(Date.now() / 100 + this.x) * 0.3;
        this.y += Math.cos(Date.now() / 100 + this.y) * 0.3;
        
        return true;
    }
    
    draw() {
        const color = getOwnerColor(this.owner);
        let isMyTeam = false;
        try {
            isMyTeam = multiplayerActive
                ? lobby.players.find(p => p.id === myPlayerId)?.team === this.owner
                : this.owner === PLAYER;
        } catch (e) {
            isMyTeam = this.owner === PLAYER; // Fallback to single player check
        }
        const isStealthed = this.stealthTime > 0 && isMyTeam;

        // FOG OF WAR: Don't draw enemy particles that are in fog
        try {
            if (!isMyTeam && game.features.fog && !isVisibleToPlayer(this.x, this.y)) {
                return; // Skip drawing - particle is hidden in fog
            }
        } catch (e) {
            // If visibility check fails, draw the particle anyway
            console.warn('Particle visibility check error:', e);
        }

        // If stealthed, draw with ghostly effect
        const stealthAlpha = isStealthed ? 0.3 : 1;

        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (1 - i / this.trail.length) * 0.5 * stealthAlpha;
            ctx.fillStyle = hexToRgba(color.particle, alpha);
            ctx.beginPath();
            ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        if (isMyTeam && abilities.boost.active) {
            ctx.fillStyle = `rgba(255, 240, 0, ${0.5 * stealthAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
            ctx.fill();
        }

        // Stealth glow effect
        if (isStealthed) {
            ctx.fillStyle = 'rgba(100, 50, 150, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = hexToRgba(color.particle, stealthAlpha);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = hexToRgba(color.particle, 0.25 * stealthAlpha);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Background particle
class BgParticle {
    constructor() { this.reset(); }

    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = (Math.random() - 0.5) * 15;
        this.vy = (Math.random() - 0.5) * 15;
        this.size = Math.random() * 1.5 + 0.5;
        this.alpha = Math.random() * 0.3 + 0.1;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.x < 0 || this.x > W || this.y < 0 || this.y > H) this.reset();
    }

    draw() {
        ctx.fillStyle = `rgba(100, 150, 200, ${this.alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Comet class for comet showers
class Comet {
    constructor() {
        // Random direction: can come from any edge
        const side = Math.floor(Math.random() * 4);
        const speed = 400 + Math.random() * 300;

        switch(side) {
            case 0: // From top
                this.x = Math.random() * W;
                this.y = -50;
                this.vx = (Math.random() - 0.5) * 200;
                this.vy = speed;
                break;
            case 1: // From bottom
                this.x = Math.random() * W;
                this.y = H + 50;
                this.vx = (Math.random() - 0.5) * 200;
                this.vy = -speed;
                break;
            case 2: // From left
                this.x = -50;
                this.y = Math.random() * H;
                this.vx = speed;
                this.vy = (Math.random() - 0.5) * 200;
                break;
            case 3: // From right
                this.x = W + 50;
                this.y = Math.random() * H;
                this.vx = -speed;
                this.vy = (Math.random() - 0.5) * 200;
                break;
        }

        this.size = 8 + Math.random() * 6;
        this.trail = [];
        this.hitRadius = 30;
    }

    update(dt) {
        // Add trail
        this.trail.push({ x: this.x, y: this.y, age: 0 });
        if (this.trail.length > 20) this.trail.shift();
        for (const t of this.trail) t.age += dt;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Check collision with flying particles (not stealthed ones from player perspective)
        for (let i = flyingParticles.length - 1; i >= 0; i--) {
            const p = flyingParticles[i];
            const dx = p.x - this.x;
            const dy = p.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.hitRadius) {
                // Destroy the particle
                effects.push(new Effect('explosion', p.x, p.y, { duration: 0.3 }));
                flyingParticles.splice(i, 1);
            }
        }

        // Return false when off screen
        return !(this.x < -100 || this.x > W + 100 || this.y < -100 || this.y > H + 100);
    }

    draw() {
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (1 - i / this.trail.length) * 0.6;
            const size = this.size * (1 - i / this.trail.length);

            const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size);
            gradient.addColorStop(0, `rgba(255, 200, 100, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(255, 100, 50, ${alpha * 0.5})`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw comet head
        const headGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
        headGradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
        headGradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');
        headGradient.addColorStop(0.6, 'rgba(255, 100, 50, 0.4)');
        headGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = headGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();

        // Bright core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Spawn comet shower
function spawnCometShower() {
    const numComets = 5 + Math.floor(Math.random() * 8);
    showFloatText(W / 2, 100, 'â˜„ï¸ COMET SHOWER!', '#ff8844');
    playSound('comet');

    for (let i = 0; i < numComets; i++) {
        setTimeout(() => {
            comets.push(new Comet());
        }, i * 150);
    }
}

// Harvest mode particle
class HarvestParticle {
    constructor() {
        this.x = Math.random() * W;
        this.y = 100 + Math.random() * (H - 200);
        this.vx = (Math.random() - 0.5) * 60;
        this.vy = (Math.random() - 0.5) * 60;
        this.size = 6;
        this.grabbed = false;
        this.grabbedBy = null;
        this.targetPlanet = null;
        this.collected = false;
        this.pulsePhase = Math.random() * Math.PI * 2;
    }
    
    update(dt) {
        this.pulsePhase += dt * 5;
        
        if (this.collected) return false;
        
        if (this.grabbed && this.targetPlanet) {
            const dx = this.targetPlanet.x - this.x;
            const dy = this.targetPlanet.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < this.targetPlanet.size) {
                this.targetPlanet.units += 1;
                this.collected = true;
                effects.push(new Effect('capture', this.x, this.y, {
                    duration: 0.3,
                    radius: 10,
                    color: COLORS[this.grabbedBy].main
                }));
                return false;
            }
            
            const speed = 300;
            this.x += (dx / dist) * speed * dt;
            this.y += (dy / dist) * speed * dt;
        } else {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            
            if (this.x < 50 || this.x > W - 50) this.vx *= -1;
            if (this.y < 100 || this.y > H - 100) this.vy *= -1;
            
            this.x = Math.max(50, Math.min(W - 50, this.x));
            this.y = Math.max(100, Math.min(H - 100, this.y));
            
            this.vx += (Math.random() - 0.5) * 20 * dt;
            this.vy += (Math.random() - 0.5) * 20 * dt;
            
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (speed > 80) {
                this.vx = (this.vx / speed) * 80;
                this.vy = (this.vy / speed) * 80;
            }
        }
        
        return true;
    }
    
    draw() {
        if (this.collected) return;
        
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
        
        const glowColor = this.grabbed ? COLORS[this.grabbedBy].main : '#ffffff';
        ctx.fillStyle = hexToRgba(glowColor, 0.3);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2 * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        const coreColor = this.grabbed ? COLORS[this.grabbedBy].main : '#ffffff';
        ctx.fillStyle = coreColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.grabbed && this.targetPlanet) {
            ctx.strokeStyle = hexToRgba(COLORS[this.grabbedBy].main, 0.5);
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.targetPlanet.x, this.targetPlanet.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    containsPoint(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.size * 3;
    }
}

function showFloatText(x, y, text, color) {
    const existingFloats = document.querySelectorAll('.float-text');
    if (existingFloats.length > 10) {
        existingFloats[0].remove();
    }
    const el = document.createElement('div');
    el.className = 'float-text';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function updateSelectionIndicator() {
    const indicator = document.getElementById('selectionIndicator');
    if (game.selectedPlanets.length > 0) {
        indicator.classList.remove('hidden');
        const totalUnits = game.selectedPlanets.reduce((sum, p) => sum + Math.floor(p.units), 0);
        indicator.textContent = `${game.selectedPlanets.length} planet${game.selectedPlanets.length > 1 ? 's' : ''} selected (${totalUnits} units)`;
    } else {
        indicator.classList.add('hidden');
    }
}

function selectAllPlayerPlanets() {
    const myTeam = multiplayerActive
        ? lobby.players.find(p => p.id === myPlayerId)?.team
        : PLAYER;
    game.selectedPlanets = planets.filter(p => p.owner === myTeam && p.units >= 1);
    
    // Visual feedback
    for (const planet of game.selectedPlanets) {
        effects.push(new Effect('selectAll', planet.x, planet.y, {
            duration: 0.4,
            radius: planet.size
        }));
    }
    
    showFloatText(W / 2, H / 2, `ALL ${game.selectedPlanets.length} PLANETS SELECTED!`, '#0ff');
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = `${game.selectedPlanets.length} planets selected - tap target`;
}

function togglePlanetSelection(planet) {
    const index = game.selectedPlanets.indexOf(planet);
    if (index >= 0) {
        // Deselect
        game.selectedPlanets.splice(index, 1);
    } else {
        // Select
        game.selectedPlanets.push(planet);
        playSound('select');
        haptics.light();
        tutorial.onEvent('select');
    }
    updateSelectionIndicator();

    if (game.selectedPlanets.length > 0) {
        document.getElementById('gameStatus').textContent = `${game.selectedPlanets.length} planet${game.selectedPlanets.length > 1 ? 's' : ''} selected - tap target`;
    } else {
        document.getElementById('gameStatus').textContent = 'Select your planet';
    }
}

function generateLevel() {
    const settings = getAdaptiveAISettings();
    const numPlanets = settings.planets + Math.floor(game.level / 2);

    planets = [];
    flyingParticles = [];
    harvestParticles = [];
    effects = [];
    wormholePairs = [];
    comets = [];
    lastCometShower = Date.now(); // Reset comet timer
    game.selectedPlanets = [];
    selectedHarvestParticle = null;

    for (const key in abilities) {
        abilities[key].cooldown = 0;
        abilities[key].active = false;
        if (abilities[key].targetPlanet) abilities[key].targetPlanet = null;
    }

    // Show/hide stealth button based on feature toggle
    document.getElementById('stealthBtn').style.display = game.features.stealth ? 'flex' : 'none';
    
    const positions = [];
    const minDist = 130;
    const margin = 80;
    
    for (let i = 0; i < numPlanets; i++) {
        let x, y, valid, attempts = 0;
        
        do {
            x = margin + Math.random() * (W - margin * 2);
            y = margin + 70 + Math.random() * (H - margin * 2 - 160);
            valid = true;
            
            for (const pos of positions) {
                if (Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2) < minDist) {
                    valid = false;
                    break;
                }
            }
            attempts++;
        } while (!valid && attempts < 100);
        
        positions.push({ x, y });
    }
    
    const specialTypes = ['factory', 'fortress', 'wormhole', 'wormhole', 'blackhole'];
    const numSpecials = Math.min(settings.specialPlanets, Math.max(0, positions.length - 2));
    const specialIndices = [];
    
    const availableIndices = positions.length - 2;
    if (availableIndices > 0) {
        while (specialIndices.length < numSpecials) {
            const idx = 1 + Math.floor(Math.random() * availableIndices);
            if (!specialIndices.includes(idx)) specialIndices.push(idx);
        }
    }
    
    const wormholePlanets = [];
    
    const startUnits = game.mode === 'harvest' ? 5 : settings.startingUnits + upgradeModifiers.startingUnitsBonus;

    for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        const size = 30 + Math.random() * 35;
        let owner = NEUTRAL;
        let units = 10 + Math.random() * 15;
        let type = 'normal';

        if (i === 0) {
            owner = PLAYER;
            units = startUnits;
        } else if (i === positions.length - 1) {
            owner = ENEMY;
            units = game.mode === 'harvest' ? 5 : settings.startingUnits; // enemy doesn't get upgrade bonus
        } else if (specialIndices.includes(i)) {
            type = specialTypes[specialIndices.indexOf(i) % specialTypes.length];
            if (type === 'blackhole') {
                units = 0;
                owner = NEUTRAL;
            }
        }

        const planet = new Planet(pos.x, pos.y, size, owner, units, type);
        planets.push(planet);
        
        if (type === 'wormhole') {
            wormholePlanets.push(planet);
        }
    }
    
    for (let i = 0; i < wormholePlanets.length - 1; i += 2) {
        if (wormholePlanets[i + 1]) {
            wormholePlanets[i].wormholePartner = wormholePlanets[i + 1];
            wormholePlanets[i + 1].wormholePartner = wormholePlanets[i];
        }
    }

    // Apply upgrade: extra starting planets
    if (upgradeModifiers.extraStartPlanets > 0) {
        const neutralPlanets = planets.filter(p => p.owner === NEUTRAL && p.type !== 'blackhole');
        // Sort by distance to first player planet for nearby extras
        const playerPlanet = planets.find(p => p.owner === PLAYER);
        if (playerPlanet) {
            neutralPlanets.sort((a, b) => {
                const dA = Math.sqrt((a.x - playerPlanet.x)**2 + (a.y - playerPlanet.y)**2);
                const dB = Math.sqrt((b.x - playerPlanet.x)**2 + (b.y - playerPlanet.y)**2);
                return dA - dB;
            });
        }
        for (let e = 0; e < upgradeModifiers.extraStartPlanets && e < neutralPlanets.length; e++) {
            neutralPlanets[e].owner = PLAYER;
            neutralPlanets[e].units = Math.max(neutralPlanets[e].units, 15);
        }
    }

    // Reset rally points and timeline for new level
    rallyPoints.clear();
    discoveredPlanets.clear();
    gameTimeline = [];
    startUnitTracking();

    if (game.mode === 'harvest') {
        for (let i = 0; i < HARVEST_PARTICLE_COUNT; i++) {
            harvestParticles.push(new HarvestParticle());
        }
        game.state = 'harvest';
        document.getElementById('harvestHud').classList.remove('hidden');
        document.getElementById('harvestProgress').classList.remove('hidden');
        document.getElementById('abilitiesBar').classList.add('hidden');
        document.getElementById('sendPercent').classList.add('hidden');
        updateHarvestUI();
    } else {
        game.state = 'playing';
        document.getElementById('harvestHud').classList.add('hidden');
        document.getElementById('harvestProgress').classList.add('hidden');
        document.getElementById('abilitiesBar').classList.remove('hidden');
        document.getElementById('sendPercent').classList.remove('hidden');
    }
    
    document.getElementById('levelInfo').textContent = `Level ${game.level} â€¢ ${game.difficulty.toUpperCase()} â€¢ ${game.mode.toUpperCase()}`;
    updateAdaptiveIndicator();
    updateSelectionIndicator();

    // Show minimap and rally hint
    document.getElementById('minimapCanvas').classList.remove('hidden');
    document.getElementById('rallyHint').classList.remove('hidden');
    game._lastMilestone = 0;

    // Start tutorial for first-time players
    if (game.state === 'playing' && game.level === 1) {
        tutorial.start();
    }
}

function initBgParticles() {
    bgParticles = [];
    for (let i = 0; i < 80; i++) {
        bgParticles.push(new BgParticle());
    }
}

let selectedHarvestParticle = null;
let playerHarvested = 0;
let enemyHarvested = 0;
let lastAIHarvest = 0;

function updateHarvestUI() {
    const remaining = harvestParticles.filter(p => !p.grabbed && !p.collected).length;
    const total = HARVEST_PARTICLE_COUNT;
    
    document.getElementById('playerHarvested').textContent = playerHarvested;
    document.getElementById('enemyHarvested').textContent = enemyHarvested;
    document.getElementById('remainingParticles').textContent = remaining + ' remaining';
    document.getElementById('playerHarvestBar').style.width = (playerHarvested / total * 100) + '%';
    document.getElementById('enemyHarvestBar').style.width = (enemyHarvested / total * 100) + '%';
}

function updateHarvestAI(dt) {
    const settings = getAdaptiveAISettings();
    const now = Date.now();
    
    const grabInterval = 800 / settings.aiSpeed;
    if (now - lastAIHarvest < grabInterval) return;
    lastAIHarvest = now;
    
    const available = harvestParticles.filter(p => !p.grabbed && !p.collected);
    if (available.length === 0) return;
    
    const particle = available[Math.floor(Math.random() * available.length)];
    
    const enemyPlanets = planets.filter(p => p.owner === ENEMY);
    if (enemyPlanets.length === 0) return;
    
    let targetPlanet;
    if (Math.random() < 0.7) {
        targetPlanet = enemyPlanets.reduce((a, b) => a.size > b.size ? a : b);
    } else {
        targetPlanet = enemyPlanets[Math.floor(Math.random() * enemyPlanets.length)];
    }
    
    particle.grabbed = true;
    particle.grabbedBy = ENEMY;
    particle.targetPlanet = targetPlanet;
    enemyHarvested++;
    updateHarvestUI();
}

function checkHarvestComplete() {
    const remaining = harvestParticles.filter(p => !p.collected).length;
    
    if (remaining === 0) {
        game.state = 'playing';
        document.getElementById('harvestHud').classList.add('hidden');
        document.getElementById('harvestProgress').classList.add('hidden');
        document.getElementById('abilitiesBar').classList.remove('hidden');
        document.getElementById('sendPercent').classList.remove('hidden');
        document.getElementById('gameStatus').textContent = 'Battle begins! Select your planet';
        showFloatText(W / 2, H / 2, 'âš”ï¸ BATTLE BEGINS!', '#fff');
    }
}

function sendUnits(from, to, percent) {
    const numToSend = Math.floor(from.units * (percent / 100));
    if (numToSend < 1) return;

    from.units -= numToSend;

    // Track match stats for post-match dashboard
    if (currentGameStats && from.owner === PLAYER) {
        currentGameStats.attacksSent++;
        if (numToSend > currentGameStats.largestArmySent) {
            currentGameStats.largestArmySent = numToSend;
        }
        playerStats.unitsDeployed += numToSend;
    }

    let spawnPlanet = from;
    if (from.type === 'wormhole' && from.wormholePartner) {
        spawnPlanet = from.wormholePartner;
        effects.push(new Effect('wormhole', from.x, from.y, { duration: 0.5 }));
        effects.push(new Effect('wormhole', spawnPlanet.x, spawnPlanet.y, { duration: 0.5 }));
    }

    for (let i = 0; i < numToSend; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = spawnPlanet.size + Math.random() * 15;
        const x = spawnPlanet.x + Math.cos(angle) * dist;
        const y = spawnPlanet.y + Math.sin(angle) * dist;

        setTimeout(() => {
            flyingParticles.push(new FlyingParticle(x, y, to, from.owner));
        }, i * 25);
    }
}

// Unified attack from all selected planets
function sendUnifiedAttack(target, percent) {
    if (game.selectedPlanets.length === 0) return;

    playSound('attack');
    juice.shake(5, 100);
    haptics.medium();
    tutorial.onEvent('attack');

    // Track early attack for daily challenge
    if (currentGameStats.firstAttackTime === null) {
        currentGameStats.firstAttackTime = (Date.now() - currentGameStats.startTime) / 1000;
        if (currentGameStats.firstAttackTime < 30) {
            currentGameStats.noEarlyAttack = false;
        }
    }

    // Track response time: how fast player reacted after last enemy action
    if (currentGameStats && currentGameStats.lastEnemyActionTime) {
        const responseTime = (Date.now() - currentGameStats.lastEnemyActionTime) / 1000;
        if (responseTime < 30) { // Only count if reasonably close to the event
            currentGameStats.responseTimes.push(responseTime);
        }
    }

    for (const planet of game.selectedPlanets) {
        if (planet !== target && planet.units >= 1) {
            if (multiplayerActive) {
                // In multiplayer: send command to host (host-authoritative)
                sendMultiplayerCommand('attack', {
                    sourceIdx: planets.indexOf(planet),
                    targetIdx: planets.indexOf(target),
                    percent: percent
                });
            } else {
                // Single player: execute locally
                sendUnits(planet, target, percent);
            }
        }
    }

    // Clear selection after attack
    game.selectedPlanets = [];
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

let lastAIAction = 0;
let lastAIReinforce = 0;
let lastAIPincer = 0;

function updateAI(dt) {
    const settings = getAdaptiveAISettings();
    const now = Date.now();

    // ---- Smarter AI: Reinforce threatened front-line planets ----
    if (now - lastAIReinforce > 2000 / settings.aiSpeed) {
        lastAIReinforce = now;
        aiReinforce(settings);
    }

    // ---- Smarter AI: Coordinated pincer attacks ----
    if (now - lastAIPincer > 3000 / settings.aiSpeed) {
        lastAIPincer = now;
        if (Math.random() < settings.aiAggression * 0.6) {
            aiPincerAttack(settings);
        }
    }

    // ---- Standard AI action (single planet attack) ----
    if (now - lastAIAction < 800 / settings.aiSpeed) return;
    lastAIAction = now;

    const aiPlanets = planets.filter(p => p.owner === ENEMY && p.units > 8);
    if (aiPlanets.length === 0) return;

    if (Math.random() > settings.aiAggression) return;

    // Adaptive: decision quality affects source selection
    // Higher quality = pick strongest planet, lower = random
    const quality = settings.decisionQuality || 0.65;
    let source;
    if (Math.random() < quality) {
        // Smart: pick the planet with most units
        source = aiPlanets.reduce((best, p) => p.units > best.units ? p : best, aiPlanets[0]);
    } else {
        source = aiPlanets[Math.floor(Math.random() * aiPlanets.length)];
    }

    let bestTarget = null;
    let bestScore = -Infinity;

    for (const planet of planets) {
        if (planet === source || planet.type === 'blackhole') continue;

        const dist = Math.sqrt((planet.x - source.x) ** 2 + (planet.y - source.y) ** 2);
        let score = 0;

        if (planet.owner === PLAYER) {
            // (c) AVOID shielded planets entirely
            if (planet.shielded) continue;
            score = 100 - planet.units * planet.defenseMult - dist / 15;
            // Adaptive: smarter targeting - prefer weaker planets more
            if (quality > 0.7) {
                score += (source.units - planet.units) * 0.5;
            }
        } else if (planet.owner === NEUTRAL) {
            score = 60 - planet.units - dist / 8;
            if (planet.type === 'factory') score += 30;
            if (planet.type === 'fortress') score += 20;
            // Adaptive: smarter AI prioritizes strategic planets more
            if (quality > 0.7 && planet.type === 'factory') score += 15;
        } else {
            score = -100; // own planet
        }

        if (planet.type === 'wormhole' && planet.owner !== ENEMY) score += 25;

        // Add randomness inversely proportional to decision quality
        score += (Math.random() - 0.5) * (1 - quality) * 60;

        if (score > bestScore) {
            bestScore = score;
            bestTarget = planet;
        }
    }

    if (bestTarget && bestScore > -30) {
        let percent = 50;
        if (bestTarget.owner === PLAYER && bestTarget.units < source.units * 0.4) percent = 80;
        if (bestTarget.owner === NEUTRAL) percent = Math.min(70, (bestTarget.units + 5) / source.units * 100);

        // Adaptive: higher quality = send more appropriate army sizes
        if (quality > 0.7 && bestTarget.owner === PLAYER) {
            const needed = bestTarget.units * bestTarget.defenseMult + 5;
            percent = Math.min(90, Math.max(40, (needed / source.units) * 100 + 10));
        }

        sendUnits(source, bestTarget, percent);
    }
}

// (a) Reinforce threatened front-line planets from safe rear planets
function aiReinforce(settings) {
    const aiPlanets = planets.filter(p => p.owner === ENEMY);
    if (aiPlanets.length < 2) return;

    // Identify front-line planets (near player planets)
    const playerPlanets = planets.filter(p => p.owner === PLAYER);
    if (playerPlanets.length === 0) return;

    for (const aiP of aiPlanets) {
        // Calculate threat: how close and strong are nearby player planets
        let threat = 0;
        for (const pp of playerPlanets) {
            const dist = Math.sqrt((pp.x - aiP.x)**2 + (pp.y - aiP.y)**2);
            if (dist < 350) {
                threat += (pp.units * (350 - dist)) / 350;
            }
        }
        aiP._aiThreat = threat;

        // Is this planet "safe"? (far from any player planet)
        const nearestPlayerDist = Math.min(...playerPlanets.map(pp =>
            Math.sqrt((pp.x - aiP.x)**2 + (pp.y - aiP.y)**2)
        ));
        aiP._aiSafe = nearestPlayerDist > 300;
    }

    // Find threatened front-line planets with low units
    const threatened = aiPlanets.filter(p => p._aiThreat > 15 && p.units < 25);
    const safe = aiPlanets.filter(p => p._aiSafe && p.units > 15);

    if (threatened.length > 0 && safe.length > 0) {
        // Send reinforcements from safest to most threatened
        threatened.sort((a, b) => b._aiThreat - a._aiThreat);
        safe.sort((a, b) => b.units - a.units);

        const target = threatened[0];
        const source = safe[0];
        if (source !== target && source.units > 10) {
            const percent = Math.min(60, Math.floor((source.units - 5) / source.units * 100));
            sendUnits(source, target, percent);
        }
    }
}

// (b) Coordinate multi-planet pincer attacks
function aiPincerAttack(settings) {
    const quality = settings.decisionQuality || 0.65;
    const aiPlanets = planets.filter(p => p.owner === ENEMY && p.units > 12);
    if (aiPlanets.length < 2) return;

    // Find a good target for a pincer
    const playerPlanets = planets.filter(p => p.owner === PLAYER && !p.shielded);
    if (playerPlanets.length === 0) return;

    // Adaptive: sort targets by weakness (smarter AI picks better targets)
    const sortedTargets = [...playerPlanets];
    if (quality > 0.6) {
        sortedTargets.sort((a, b) => (a.units * a.defenseMult) - (b.units * b.defenseMult));
    }

    for (const target of sortedTargets) {
        // Skip shielded planets entirely
        if (target.shielded) continue;

        // Adaptive: higher quality AI uses wider search radius
        const searchRadius = 350 + quality * 150;

        // Find 2-3 nearby AI planets that could attack together
        const nearby = aiPlanets.filter(ap => {
            const dist = Math.sqrt((ap.x - target.x)**2 + (ap.y - target.y)**2);
            return dist < searchRadius;
        });

        if (nearby.length >= 2) {
            // Check if combined force can overwhelm the target
            const sendPct = 0.5 + quality * 0.15; // higher quality = commit more units
            const totalForce = nearby.reduce((sum, p) => sum + Math.floor(p.units * sendPct), 0);
            const targetDefense = target.units * target.defenseMult;

            // Adaptive: smarter AI requires less overwhelming force
            const forceMultiplier = 1.5 - quality * 0.4;
            if (totalForce > targetDefense * forceMultiplier) {
                // Execute pincer attack from all nearby planets simultaneously
                const pct = Math.round(sendPct * 100);
                for (const attacker of nearby.slice(0, 3)) {
                    sendUnits(attacker, target, pct);
                }
                return; // Only one pincer per tick
            }
        }
    }
}

function updateAbilities(dt) {
    for (const key in abilities) {
        const ab = abilities[key];
        
        if (ab.cooldown > 0) ab.cooldown -= dt;
        
        if (ab.active && ab.activeTime > 0) {
            ab.activeTime -= dt;
            if (ab.activeTime <= 0) {
                ab.active = false;
            }
        }
        
        const btn = document.querySelector(`[data-ability="${key}"]`);
        if (btn) {
            const overlay = btn.querySelector('.cooldown-overlay');
            if (ab.cooldown > 0) {
                btn.classList.add('cooldown');
                overlay.style.height = (ab.cooldown / ab.maxCooldown * 100) + '%';
            } else {
                btn.classList.remove('cooldown');
                overlay.style.height = '0%';
            }
            
            btn.classList.toggle('active', ab.active || game.activeAbility === key);
        }
    }
    
    if (abilities.shield.targetPlanet) {
        if (abilities.shield.targetPlanet.shieldTime <= 0) {
            abilities.shield.targetPlanet = null;
        }
    }
}

function activateAbility(abilityName) {
    const ab = abilities[abilityName];
    if (ab.cooldown > 0) return;

    // Stealth requires the feature to be enabled
    if (abilityName === 'stealth' && !game.features.stealth) return;

    // Track ability usage
    playerStats.abilitiesUsed++;
    if (currentGameStats.abilitiesUsedTypes) {
        currentGameStats.abilitiesUsedTypes.add(abilityName);
    }
    if (abilityName === 'nuke') {
        currentGameStats.nukesUsed = (currentGameStats.nukesUsed || 0) + 1;
    }

    playSound('ability');
    // Timeline event for ability use
    const abilityIcons = { boost: 'âš¡', shield: 'ðŸ›¡ï¸', emp: 'ðŸ’¥', nuke: 'â˜¢ï¸', stealth: 'ðŸ‘»' };
    pushTimelineEvent('ability', abilityIcons[abilityName] || 'âœ¨', `Used ${abilityName}`);

    switch (abilityName) {
        case 'boost':
            ab.active = true;
            ab.activeTime = ab.duration + upgradeModifiers.boostDurationBonus;
            ab.cooldown = ab.maxCooldown;
            showFloatText(W / 2, H / 2, 'âš¡ BOOST ACTIVATED!', '#ff0');
            break;

        case 'stealth':
            ab.active = true;
            ab.activeTime = ab.duration;
            ab.cooldown = ab.maxCooldown;
            // Apply stealth to all current player flying particles
            for (const p of flyingParticles) {
                if (isMyTeamOwner(p.owner)) {
                    p.stealthTime = ab.duration;
                }
            }
            showFloatText(W / 2, H / 2, 'ðŸ‘» STEALTH ACTIVATED!', '#a0a');
            break;

        case 'shield':
        case 'nuke':
        case 'emp':
            game.activeAbility = abilityName;
            document.getElementById('gameStatus').textContent = `Select target for ${abilityName.toUpperCase()}`;
            break;
    }
}

function useAbilityOnTarget(planet) {
    const abilityName = game.activeAbility;
    const ab = abilities[abilityName];
    
    switch (abilityName) {
        case 'shield':
            if (!isMyTeamOwner(planet.owner)) {
                showFloatText(planet.x, planet.y, 'Must target your planet!', '#f44');
                return;
            }
            planet.shielded = true;
            planet.shieldTime = ab.duration + upgradeModifiers.shieldDurationBonus;
            ab.targetPlanet = planet;
            ab.cooldown = ab.maxCooldown;
            showFloatText(planet.x, planet.y, 'ðŸ›¡ï¸ SHIELDED!', '#4af');
            break;

        case 'emp':
            if (!isEnemyTeamOwner(planet.owner)) {
                showFloatText(planet.x, planet.y, 'Must target enemy!', '#f44');
                return;
            }
            for (const p of planets) {
                if (isEnemyTeamOwner(p.owner)) {
                    p.empTime = ab.duration + upgradeModifiers.empDurationBonus;
                }
            }
            ab.cooldown = ab.maxCooldown;
            effects.push(new Effect('explosion', planet.x, planet.y, { duration: 0.5 }));
            showFloatText(planet.x, planet.y, 'ðŸ’¥ EMP!', '#ff0');
            break;
            
        case 'nuke':
            if (isMyTeamOwner(planet.owner) || planet.type === 'blackhole') {
                showFloatText(planet.x, planet.y, "Can't nuke that!", '#f44');
                return;
            }
            const destroyed = Math.floor(planet.units * 0.5);
            planet.units -= destroyed;
            ab.cooldown = Math.max(5, ab.maxCooldown - upgradeModifiers.nukeCooldownReduction);
            effects.push(new Effect('explosion', planet.x, planet.y, { duration: 0.6 }));
            showFloatText(planet.x, planet.y, `â˜¢ï¸ -${destroyed}`, '#f84');
            break;
    }
    
    game.activeAbility = null;
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

function checkWinCondition() {
    // In multiplayer, use the multiplayer-specific win check instead
    if (multiplayerActive) {
        if (isHost) checkMultiplayerWinCondition();
        return;
    }

    const playerPlanets = planets.filter(p => p.owner === PLAYER).length;
    const enemyPlanets = planets.filter(p => p.owner === ENEMY).length;
    const playerFlying = flyingParticles.filter(p => p.owner === PLAYER).length;
    const enemyFlying = flyingParticles.filter(p => p.owner === ENEMY).length;

    if (enemyPlanets === 0 && enemyFlying === 0) {
        endGame(true);
    } else if (playerPlanets === 0 && playerFlying === 0) {
        endGame(false);
    }
}

function endGame(victory) {
    game.state = 'ended';
    stopUnitTracking();
    stopTerritoryTracking();

    // Hide minimap and rally hint
    document.getElementById('minimapCanvas').classList.add('hidden');
    document.getElementById('rallyHint').classList.add('hidden');

    // Update game stats
    currentGameStats.gameTime = (Date.now() - currentGameStats.startTime) / 1000;
    currentGameStats.won = victory;
    currentGameStats.abilitiesUsedTypes = currentGameStats.abilitiesUsedTypes.size;

    // Update player stats
    playerStats.gamesPlayed++;
    playerStats.totalPlayTime += currentGameStats.gameTime;

    if (victory) {
        playerStats.gamesWon++;
        playerStats.currentStreak++;
        if (playerStats.currentStreak > playerStats.bestStreak) {
            playerStats.bestStreak = playerStats.currentStreak;
        }
        if (game.level > playerStats.highestLevel) {
            playerStats.highestLevel = game.level;
        }
        if (currentGameStats.perfectWin) {
            playerStats.perfectWins++;
        }
        if (!playerStats.fastestWin || currentGameStats.gameTime < playerStats.fastestWin) {
            playerStats.fastestWin = currentGameStats.gameTime;
        }
        playSound('victory');
        // Victory juice!
        juice.slowMo(0.2, 800);
        juice.flash('#0ff', 0.5);
        juice.shake(20, 400);
        // Burst from all player planets
        for (const p of planets) {
            if (p.owner === PLAYER) {
                juice.burst(p.x, p.y, '#0ff', 30, 200);
            }
        }
        haptics.success();
    } else {
        playerStats.gamesLost++;
        playerStats.currentStreak = 0;
        playSound('defeat');
        // Defeat juice
        juice.shake(25, 500);
        juice.flash('#f44', 0.4);
        haptics.error();
    }

    // Update adaptive AI difficulty based on result
    if (!multiplayerActive) {
        updateAdaptiveAI(victory);
    }

    // Check achievements
    achievements.check();

    // Save features for next session
    playerStats.features = { ...game.features };
    saveStats();

    // Check daily challenges
    checkDailyChallenges();
    updateDailyChallengesUI();

    const screen = document.getElementById('resultScreen');
    const title = document.getElementById('resultTitle');
    const subtitle = document.getElementById('resultSubtitle');
    const text = document.getElementById('resultText');

    // Format time
    const mins = Math.floor(currentGameStats.gameTime / 60);
    const secs = Math.floor(currentGameStats.gameTime % 60);
    document.getElementById('statTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    document.getElementById('statPlanets').textContent = playerStats.planetsConquered;
    document.getElementById('statStreak').textContent = playerStats.currentStreak;

    if (victory) {
        screen.className = 'result-screen victory';
        title.textContent = 'VICTORY!';
        subtitle.textContent = game.difficulty.toUpperCase();
        text.textContent = `Level ${game.level} conquered!`;

        // Special messages
        if (currentGameStats.perfectWin) {
            text.textContent += ' Perfect win!';
        }
        if (currentGameStats.gameTime < 30) {
            text.textContent = 'SPEEDRUN! ' + text.textContent;
        }

        game.level++;
    } else {
        screen.className = 'result-screen defeat';
        title.textContent = 'DEFEAT';
        subtitle.textContent = `Level ${game.level}`;
        text.textContent = 'The enemy has conquered the galaxy...';
    }

    // Show adaptive AI status in subtitle if active
    if (!multiplayerActive && playerStats.adaptiveAI && playerStats.adaptiveAI.recentResults.length >= 3) {
        const info = getAdaptiveLabel();
        subtitle.textContent += ` | AI: ${info.text}`;
    }

    // Render post-match statistics dashboard
    renderPostMatchDashboard();

    // Render post-game timeline
    renderTimeline();

    screen.classList.remove('hidden');
}

// Share functionality
function shareScore() {
    const won = game.state === 'ended' && playerStats.currentStreak > 0;
    const emoji = won ? 'ðŸ†' : 'ðŸ’¥';
    const streakEmoji = 'ðŸ”¥'.repeat(Math.min(playerStats.currentStreak, 5));

    const text = `${emoji} Particle Conquest Pro ${emoji}
Level ${game.level} | ${game.difficulty.toUpperCase()}
${streakEmoji} ${playerStats.currentStreak} win streak!
ðŸŽ® Play free: ${window.location.href}`;

    if (navigator.share) {
        navigator.share({
            title: 'Particle Conquest Pro',
            text: text,
            url: window.location.href
        }).catch(() => {});
    } else {
        // Fallback: copy to clipboard
        navigator.clipboard.writeText(text).then(() => {
            showFloatText(W/2, H/2, 'Copied to clipboard!', '#0ff');
        }).catch(() => {
            showFloatText(W/2, H/2, 'Share not available', '#f44');
        });
    }
}

function goToMenu() {
    document.getElementById('resultScreen').classList.add('hidden');
    document.getElementById('upgradeScreen').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');
    document.getElementById('pauseBtn').classList.add('hidden');
    document.getElementById('minimapCanvas').classList.add('hidden');
    document.getElementById('rallyHint').classList.add('hidden');
    const dashEl = document.getElementById('postMatchDashboard');
    if (dashEl) dashEl.style.display = 'none';
    game.state = 'menu';
    stopMusic();
    stopUnitTracking();
    stopTerritoryTracking();
    resetUpgrades();
}

function startGame(difficulty) {
    game.difficulty = difficulty;
    game.level = 1;
    game.activeAbility = null;
    game.selectedPlanets = [];
    game.paused = false;
    playerHarvested = 0;
    enemyHarvested = 0;

    // Reset upgrades for new campaign
    resetUpgrades();

    playSound('click');
    initAudio();
    startMusic();

    document.getElementById('menu').classList.add('hidden');
    document.getElementById('resultScreen').classList.add('hidden');
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');
    // Reset post-match dashboard for next game
    const dashEl = document.getElementById('postMatchDashboard');
    if (dashEl) dashEl.style.display = 'none';

    resetCurrentGameStats();
    generateLevel();
}

function pauseGame() {
    if (game.state !== 'playing' && game.state !== 'harvest') return;
    game.paused = true;
    document.getElementById('pauseMenu').classList.remove('hidden');
    document.getElementById('pauseBtn').classList.add('hidden');

    // Sync feature toggles in pause menu
    syncPauseFeatureToggles();
}

function resumeGame() {
    game.paused = false;
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');
}

function restartLevel() {
    game.paused = false;
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.remove('hidden');
    generateLevel();
}

function quitToMenu() {
    game.paused = false;
    game.state = 'menu';
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('pauseBtn').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');

    // Sync main menu feature toggles
    syncMenuFeatureToggles();
}

function syncPauseFeatureToggles() {
    document.querySelectorAll('#pauseFeatureToggles .feature-toggle').forEach(toggle => {
        const feature = toggle.dataset.feature;
        toggle.classList.toggle('active', game.features[feature]);
    });
}

function syncMenuFeatureToggles() {
    document.querySelectorAll('.menu .feature-toggle').forEach(toggle => {
        const feature = toggle.dataset.feature;
        toggle.classList.toggle('active', game.features[feature]);
    });
}

function togglePause() {
    if (game.state !== 'playing' && game.state !== 'harvest') return;

    if (game.paused) {
        resumeGame();
    } else {
        pauseGame();
    }
}

function updateStats() {
    let playerUnits = 0, enemyUnits = 0;
    
    for (const p of planets) {
        if (p.owner === PLAYER) playerUnits += Math.floor(p.units);
        if (p.owner === ENEMY) enemyUnits += Math.floor(p.units);
    }
    
    playerUnits += flyingParticles.filter(p => p.owner === PLAYER).length;
    enemyUnits += flyingParticles.filter(p => p.owner === ENEMY).length;
    
    document.getElementById('playerStats').textContent = playerUnits;
    document.getElementById('enemyStats').textContent = enemyUnits;
}

function drawWormholeConnections() {
    for (const planet of planets) {
        if (planet.type === 'wormhole' && planet.wormholePartner) {
            const partner = planet.wormholePartner;
            
            if (planets.indexOf(planet) > planets.indexOf(partner)) continue;
            
            ctx.strokeStyle = 'rgba(170, 68, 170, 0.27)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 10]);
            ctx.beginPath();
            ctx.moveTo(planet.x, planet.y);
            ctx.lineTo(partner.x, partner.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}

// Draw attack preview lines from all selected planets
function drawAttackPreviewLines(targetX, targetY) {
    for (const planet of game.selectedPlanets) {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(planet.x, planet.y);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Arrow at target
    if (game.selectedPlanets.length > 0) {
        const centerX = game.selectedPlanets.reduce((s, p) => s + p.x, 0) / game.selectedPlanets.length;
        const centerY = game.selectedPlanets.reduce((s, p) => s + p.y, 0) / game.selectedPlanets.length;
        const angle = Math.atan2(targetY - centerY, targetX - centerX);
        
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.moveTo(targetX, targetY);
        ctx.lineTo(targetX - 15 * Math.cos(angle - 0.4), targetY - 15 * Math.sin(angle - 0.4));
        ctx.lineTo(targetX - 15 * Math.cos(angle + 0.4), targetY - 15 * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
    }
}

// Fog of War - using offscreen canvas
let fogCanvas = null;
let fogCtx = null;

function initFogCanvas() {
    fogCanvas = document.createElement('canvas');
    fogCanvas.width = W;
    fogCanvas.height = H;
    fogCtx = fogCanvas.getContext('2d');
}

function drawFogOfWar() {
    if (!game.features.fog) return;

    // Initialize fog canvas if needed
    if (!fogCanvas || fogCanvas.width !== W || fogCanvas.height !== H) {
        initFogCanvas();
    }

    // Clear fog canvas and fill with dark fog (0.7 opacity allows some visibility of enemy positions)
    fogCtx.clearRect(0, 0, W, H);
    fogCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    fogCtx.fillRect(0, 0, W, H);

    // Use destination-out on the FOG canvas to cut visibility holes
    fogCtx.globalCompositeOperation = 'destination-out';

    // Cut visibility around player planets
    for (const planet of planets) {
        if (isMyPlanet(planet)) {
            const visRadius = planet.size * 6;
            const gradient = fogCtx.createRadialGradient(
                planet.x, planet.y, planet.size * 0.5,
                planet.x, planet.y, visRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.6, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            fogCtx.fillStyle = gradient;
            fogCtx.beginPath();
            fogCtx.arc(planet.x, planet.y, visRadius, 0, Math.PI * 2);
            fogCtx.fill();
        }
    }

    // Also reveal around player's flying particles
    const myTeam = getMyTeam();
    for (const p of flyingParticles) {
        if (p.owner === myTeam) {
            const visRadius = 80;
            const gradient = fogCtx.createRadialGradient(
                p.x, p.y, 5,
                p.x, p.y, visRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            fogCtx.fillStyle = gradient;
            fogCtx.beginPath();
            fogCtx.arc(p.x, p.y, visRadius, 0, Math.PI * 2);
            fogCtx.fill();
        }
    }

    // Reset composite operation
    fogCtx.globalCompositeOperation = 'source-over';

    // Draw the fog layer onto the main canvas
    ctx.drawImage(fogCanvas, 0, 0);
}

// Check if a point is visible to the player (for fog of war)
function isVisibleToPlayer(x, y) {
    if (!game.features.fog) return true;

    const myTeam = getMyTeam();

    for (const planet of planets) {
        if (isMyPlanet(planet)) {
            const dx = x - planet.x;
            const dy = y - planet.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < planet.size * 6) return true;
        }
    }

    for (const p of flyingParticles) {
        if (p.owner === myTeam) {
            const dx = x - p.x;
            const dy = y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) return true;
        }
    }

    return false;
}

// Game loop
let lastTime = 0;
let currentTouch = null;

function animate(time) {
    try {
    const realDt = Math.min((time - lastTime) / 1000, 0.1);
    const dt = realDt * game.speed * juice.getTimeScale();
    lastTime = time;

    // Update juice system
    juice.update(realDt);

    // Apply screen shake
    const shake = juice.getShakeOffset();
    ctx.save();
    ctx.translate(shake.x, shake.y);

    ctx.fillStyle = '#000';
    ctx.fillRect(-10, -10, W + 20, H + 20);

    for (const p of bgParticles) {
        p.update(realDt);
        p.draw();
    }
    
    if (game.state === 'harvest') {
        // Only update if not paused
        if (!game.paused) {
            harvestParticles = harvestParticles.filter(p => p.update(dt));
            effects = effects.filter(e => e.update(dt));
            updateHarvestAI(dt);
            checkHarvestComplete();
        }

        // Always draw
        for (const planet of planets) planet.draw();
        for (const p of harvestParticles) p.draw();
        for (const e of effects) e.draw();

        if (selectedHarvestParticle && !selectedHarvestParticle.grabbed) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(selectedHarvestParticle.x, selectedHarvestParticle.y, 20, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw pause overlay hint
        if (game.paused) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, W, H);
        }
    }

    if (game.state === 'playing') {
        // Only update if not paused
        if (!game.paused) {
            for (const planet of planets) planet.update(dt);
            flyingParticles = flyingParticles.filter(p => p.update(dt));
            effects = effects.filter(e => e.update(dt));

            // Update comets
            if (game.features.comets) {
                comets = comets.filter(c => c.update(dt));

                // Spawn comet showers periodically
                const now = Date.now();
                if (now - lastCometShower > COMET_SHOWER_INTERVAL) {
                    lastCometShower = now;
                    spawnCometShower();
                }
            }

            // Run AI only when appropriate:
            // - Single player: always
            // - Co-op multiplayer: only on host
            // - PvP multiplayer: never
            if (!multiplayerActive || (mpGameMode === 'coop' && isHost)) {
                updateAI(dt);
            }
            updateAbilities(realDt);
            // Rally point auto-send
            updateRallyAutoSend(dt);
            checkWinCondition();
            updateStats();

            // Unit milestone timeline events
            {
                let pUnits = 0;
                for (const p of planets) { if (p.owner === PLAYER) pUnits += Math.floor(p.units); }
                pUnits += flyingParticles.filter(p => p.owner === PLAYER).length;
                if (!game._lastMilestone) game._lastMilestone = 0;
                const milestones = [50, 100, 200, 500];
                for (const m of milestones) {
                    if (pUnits >= m && game._lastMilestone < m) {
                        game._lastMilestone = m;
                        pushTimelineEvent('milestone', 'ðŸ“ˆ', `${m}+ total units`);
                    }
                }
            }
        }

        // Always draw
        drawWormholeConnections();

        for (const planet of planets) planet.draw();
        for (const e of effects) e.draw();
        for (const p of flyingParticles) p.draw();

        // Draw comets
        for (const c of comets) c.draw();

        // Draw rally point arrows
        drawRallyPoints();

        // Attack preview lines when planets are selected and mouse is moving
        if (game.selectedPlanets.length > 0 && currentTouch && !game.paused) {
            drawAttackPreviewLines(currentTouch.x, currentTouch.y);
        }

        // Draw fog of war on top
        drawFogOfWar();

        // Draw minimap
        drawMinimap();

        // Draw pause overlay hint
        if (game.paused) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, W, H);
        }
    }
    
    if (game.state === 'menu' || game.state === 'ended') {
        drawWormholeConnections();
        for (const planet of planets) planet.draw();
    }

    // Restore from screen shake
    ctx.restore();

    // Draw juice effects on top (particles, flash)
    juice.draw(ctx, W, H);

    requestAnimationFrame(animate);
    } catch (err) {
        console.error('Game loop error:', err);
        // Show error overlay
        const errDiv = document.createElement('div');
        errDiv.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);color:#ff4444;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:9999;font-family:system-ui;';
        errDiv.innerHTML = '<h2 style="font-size:24px;margin-bottom:16px;">Something went wrong</h2><button onclick="location.reload()" style="padding:12px 24px;background:#0ff;color:#000;border:none;border-radius:8px;font-size:16px;cursor:pointer;">Restart Game</button>';
        document.body.appendChild(errDiv);
    }
}

// Input handling with double-click detection
function handleStart(x, y) {
    // Ignore input when paused
    if (game.paused) return;

    const now = Date.now();

    // Harvest mode input
    if (game.state === 'harvest') {
        if (selectedHarvestParticle && !selectedHarvestParticle.grabbed) {
            for (const planet of planets) {
                if (planet.containsPoint(x, y) && isMyPlanet(planet)) {
                    selectedHarvestParticle.grabbed = true;
                    selectedHarvestParticle.grabbedBy = getMyTeam();
                    selectedHarvestParticle.targetPlanet = planet;
                    playerHarvested++;
                    updateHarvestUI();
                    selectedHarvestParticle = null;
                    document.getElementById('gameStatus').textContent = 'Tap more particles!';
                    return;
                }
            }
        }
        
        for (const particle of harvestParticles) {
            if (!particle.grabbed && !particle.collected && particle.containsPoint(x, y)) {
                selectedHarvestParticle = particle;
                document.getElementById('gameStatus').textContent = 'Now tap YOUR planet to collect!';
                return;
            }
        }
        
        selectedHarvestParticle = null;
        document.getElementById('gameStatus').textContent = 'Tap particles to grab them!';
        return;
    }
    
    if (game.state !== 'playing') return;
    
    // Check if using ability
    if (game.activeAbility) {
        for (const planet of planets) {
            if (planet.containsPoint(x, y)) {
                useAbilityOnTarget(planet);
                return;
            }
        }
        game.activeAbility = null;
        document.getElementById('gameStatus').textContent = 'Select your planet';
        return;
    }
    
    // Check for planet clicks
    for (const planet of planets) {
        if (planet.containsPoint(x, y)) {
            if (isMyPlanet(planet)) {
                // Check for double-click
                const isDoubleClick = (now - game.lastClickTime < game.doubleClickThreshold) && 
                                      game.lastClickedPlanet === planet;
                
                game.lastClickTime = now;
                game.lastClickedPlanet = planet;
                
                if (isDoubleClick) {
                    // Double-click: Select ALL player planets
                    selectAllPlayerPlanets();
                } else {
                    // Single click: Toggle this planet's selection
                    togglePlanetSelection(planet);
                }
            } else {
                // Clicked on non-player planet: This is a target!
                if (game.selectedPlanets.length > 0) {
                    sendUnifiedAttack(planet, game.sendPercent);
                }
            }
            return;
        }
    }
    
    // Clicked on empty space - clear selection
    game.selectedPlanets = [];
    updateSelectionIndicator();
    document.getElementById('gameStatus').textContent = 'Select your planet';
}

function handleEnd(x, y) {
    // Not used for drag anymore, but keep for potential future use
}

function handleMove(x, y) {
    currentTouch = { x, y };
}

// Mouse
canvas.addEventListener('mousedown', e => {
    if (e.button === 0) handleStart(e.clientX, e.clientY);
});
canvas.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));

// Right-click for rally points
canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (game.state !== 'playing' || game.paused) return;
    const x = e.clientX, y = e.clientY;

    // Find clicked planet
    for (let i = 0; i < planets.length; i++) {
        const planet = planets[i];
        if (planet.containsPoint(x, y)) {
            if (isMyPlanet(planet)) {
                if (e.shiftKey) {
                    // Shift+right-click: clear rally for this planet
                    rallyPoints.delete(i);
                    showFloatText(planet.x, planet.y, 'Rally cleared', '#888');
                    playSound('click');
                } else {
                    // Right-click on own planet: start setting rally (need second click for target)
                    game._rallySource = i;
                    document.getElementById('gameStatus').textContent = 'Right-click target planet for rally point';
                    showFloatText(planet.x, planet.y, 'Select rally target...', '#0fc');
                    playSound('select');
                }
            } else if (game._rallySource !== undefined) {
                // Right-click on another planet: set as rally target
                rallyPoints.set(game._rallySource, i);
                showFloatText(planet.x, planet.y, 'Rally set!', '#0fc');
                playSound('click');
                document.getElementById('gameStatus').textContent = 'Rally point set! Auto-sending at 5+ units';
                delete game._rallySource;
            }
            return;
        }
    }

    // Right-click empty space while setting rally: cancel
    if (game._rallySource !== undefined) {
        delete game._rallySource;
        document.getElementById('gameStatus').textContent = 'Rally cancelled';
    }
});

// Touch with long-press for rally points
let touchStartTime = 0;
let touchStartPos = null;
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 0) return;
    const x = e.touches[0].clientX;
    const y = e.touches[0].clientY;
    touchStartTime = Date.now();
    touchStartPos = { x, y };

    // Start long-press timer for rally points
    if (game.state === 'playing' && !game.paused) {
        longPressTimer = setTimeout(() => {
            // Long press detected - check for planet
            for (let i = 0; i < planets.length; i++) {
                const planet = planets[i];
                if (planet.containsPoint(x, y) && isMyPlanet(planet)) {
                    if (game._rallySource !== undefined && game._rallySource !== i) {
                        // Second long-press: set target
                        rallyPoints.set(game._rallySource, i);
                        showFloatText(planet.x, planet.y, 'Rally set!', '#0fc');
                        playSound('click');
                        delete game._rallySource;
                    } else {
                        // First long-press: set source (or long-press on non-own planet to set target)
                        game._rallySource = i;
                        showFloatText(planet.x, planet.y, 'Tap rally target...', '#0fc');
                        playSound('select');
                        haptics.medium();
                    }
                    longPressTarget = planet;
                    return;
                }
                // Long press on non-own planet while rally source is set
                if (planet.containsPoint(x, y) && game._rallySource !== undefined) {
                    rallyPoints.set(game._rallySource, i);
                    showFloatText(planet.x, planet.y, 'Rally set!', '#0fc');
                    playSound('click');
                    delete game._rallySource;
                    longPressTarget = planet;
                    return;
                }
            }
            // Long-press empty space: clear all rallies
            if (game._rallySource === undefined && rallyPoints.size > 0) {
                rallyPoints.clear();
                showFloatText(x, y, 'All rallies cleared', '#888');
                playSound('click');
            }
        }, LONG_PRESS_DURATION);
    }
});
canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    const elapsed = Date.now() - touchStartTime;
    if (elapsed < LONG_PRESS_DURATION && !longPressTarget) {
        // Short tap: normal handling
        if (e.changedTouches.length) {
            handleStart(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        }
    }
    longPressTarget = null;
    if (e.changedTouches.length) handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    // Cancel long-press if finger moves
    if (longPressTimer && touchStartPos && e.touches.length > 0) {
        const dx = e.touches[0].clientX - touchStartPos.x;
        const dy = e.touches[0].clientY - touchStartPos.y;
        if (Math.sqrt(dx*dx + dy*dy) > 15) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }
    if (e.touches.length === 0) return;
    handleMove(e.touches[0].clientX, e.touches[0].clientY);
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    // Pause toggle works in playing and harvest states
    if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
    }

    // Escape can unpause or clear selection
    if (e.key === 'Escape') {
        if (game.paused) {
            resumeGame();
            return;
        }
        if (game.state === 'playing' || game.state === 'harvest') {
            if (game.activeAbility || game.selectedPlanets.length > 0) {
                game.activeAbility = null;
                game.selectedPlanets = [];
                updateSelectionIndicator();
                document.getElementById('gameStatus').textContent = 'Select your planet';
            } else {
                pauseGame();
            }
        }
        return;
    }

    // Other shortcuts only work when not paused and in playing state
    if (game.state !== 'playing' || game.paused) return;

    if (e.key === '1') activateAbility('boost');
    if (e.key === '2') activateAbility('shield');
    if (e.key === '3') activateAbility('emp');
    if (e.key === '4') activateAbility('nuke');
    if (e.key === '5') activateAbility('stealth');
    if (e.key === 'a' || e.key === 'A') selectAllPlayerPlanets();
    if (e.key === 'r' || e.key === 'R') {
        // Clear all rally points
        if (rallyPoints.size > 0) {
            rallyPoints.clear();
            showFloatText(W / 2, H / 2, 'All rallies cleared', '#888');
            playSound('click');
        }
    }
});

// UI Events
document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.mode = this.dataset.mode;
        
        document.getElementById('classicInstructions').style.display = game.mode === 'classic' ? 'block' : 'none';
        document.getElementById('harvestInstructions').style.display = game.mode === 'harvest' ? 'block' : 'none';
    });
});

document.querySelectorAll('.diff-btn').forEach(btn => {
    btn.addEventListener('click', () => startGame(btn.dataset.diff));
});

document.getElementById('playAgainBtn').addEventListener('click', () => {
    document.getElementById('resultScreen').classList.add('hidden');
    // Check if player won - if so, show upgrade screen
    const wasVictory = playerStats.currentStreak > 0 && game.level > 1;
    if (wasVictory) {
        showUpgradeScreen();
    } else {
        // Defeat: restart from level 1 with no upgrades
        resetUpgrades();
        proceedToNextLevel();
    }
});

document.getElementById('shareBtn').addEventListener('click', shareScore);

document.getElementById('menuBtn').addEventListener('click', goToMenu);

document.querySelectorAll('.percent-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.percent-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.sendPercent = parseInt(this.dataset.pct);
    });
});

document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.speed = parseFloat(this.dataset.speed);
    });
});

document.querySelectorAll('.ability-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        activateAbility(this.dataset.ability);
    });
});

// Feature toggles (both main menu and pause menu)
document.querySelectorAll('.feature-toggle').forEach(toggle => {
    toggle.addEventListener('click', function() {
        const feature = this.dataset.feature;
        game.features[feature] = !game.features[feature];

        // Sync all toggles with the same feature
        document.querySelectorAll(`.feature-toggle[data-feature="${feature}"]`).forEach(t => {
            t.classList.toggle('active', game.features[feature]);
        });

        // Update stealth button visibility if toggling stealth
        if (feature === 'stealth') {
            document.getElementById('stealthBtn').style.display = game.features.stealth ? 'flex' : 'none';
        }
    });
});

// Pause button
document.getElementById('pauseBtn').addEventListener('click', pauseGame);

// Pause menu buttons
document.getElementById('resumeBtn').addEventListener('click', resumeGame);
document.getElementById('restartBtn').addEventListener('click', restartLevel);
document.getElementById('quitBtn').addEventListener('click', quitToMenu);

// Sound toggle
document.getElementById('soundToggle').addEventListener('click', function() {
    playerStats.settings.soundEnabled = !playerStats.settings.soundEnabled;
    this.textContent = playerStats.settings.soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
    this.classList.toggle('muted', !playerStats.settings.soundEnabled);
    saveStats();
    if (playerStats.settings.soundEnabled) {
        initAudio();
        playSound('click');
    }
});

// Stats screen
document.getElementById('statsBtn').addEventListener('click', showStatsScreen);
document.getElementById('statsCloseBtn').addEventListener('click', () => {
    document.getElementById('statsScreen').classList.add('hidden');
});

function showStatsScreen() {
    playSound('click');
    const grid = document.getElementById('statsGrid');
    const stats = [
        { value: playerStats.gamesPlayed, label: 'Games Played' },
        { value: playerStats.gamesWon, label: 'Victories' },
        { value: playerStats.gamesLost, label: 'Defeats' },
        { value: playerStats.gamesPlayed > 0 ? Math.round((playerStats.gamesWon / playerStats.gamesPlayed) * 100) + '%' : '0%', label: 'Win Rate' },
        { value: playerStats.highestLevel, label: 'Highest Level' },
        { value: playerStats.currentStreak, label: 'Current Streak' },
        { value: playerStats.bestStreak, label: 'Best Streak' },
        { value: playerStats.planetsConquered, label: 'Planets Conquered' },
        { value: playerStats.perfectWins, label: 'Perfect Wins' },
        { value: playerStats.abilitiesUsed, label: 'Abilities Used' },
        { value: playerStats.fastestWin ? Math.floor(playerStats.fastestWin) + 's' : '-', label: 'Fastest Win' },
        { value: Math.floor(playerStats.totalPlayTime / 60) + 'm', label: 'Total Play Time' }
    ];

    grid.innerHTML = stats.map(s => `
        <div class="stat-card">
            <div class="stat-value">${s.value}</div>
            <div class="stat-label">${s.label}</div>
        </div>
    `).join('');

    document.getElementById('statsScreen').classList.remove('hidden');
}

// Daily challenges UI
function updateDailyChallengesUI() {
    const today = getTodayKey();
    const completed = playerStats.dailyChallenges[today]?.completed || [];
    const list = document.getElementById('challengesList');

    list.innerHTML = dailyChallenges.map(c => {
        const isCompleted = completed.includes(c.id);
        return `
            <div class="challenge-item ${isCompleted ? 'completed' : ''}">
                <span class="challenge-icon">${c.title.split(' ')[0]}</span>
                <div class="challenge-info">
                    <div class="challenge-title">${c.title.split(' ').slice(1).join(' ')}</div>
                    <div class="challenge-desc">${c.desc}</div>
                </div>
                ${isCompleted ? '<span class="challenge-check">âœ“</span>' : ''}
            </div>
        `;
    }).join('');
}

// Multiplayer lobby
document.getElementById('multiplayerBtn').addEventListener('click', () => {
    playSound('click');
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('multiplayerLobby').classList.remove('hidden');
    const roomCodeEl = document.getElementById('joinCodeContainer'); if (roomCodeEl) roomCodeEl.classList.add('hidden');
    document.getElementById('joinCodeContainer').classList.remove('hidden');
    document.getElementById('lobbyTitle').textContent = 'ðŸŒ Multiplayer';
    document.getElementById('lobbyStatus').textContent = 'Host a game or join with a code';
    document.getElementById('joinCodeInput').value = '';
});

document.getElementById('lobbyBackBtn').addEventListener('click', () => {
    playSound('click');
    document.getElementById('multiplayerLobby').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');
    endMultiplayerGame();
});

document.getElementById('lobbyHostBtn').addEventListener('click', () => {
    document.getElementById('lobbyStatus').textContent = 'Creating room...';
    hostGame();
});

document.getElementById('lobbyJoinBtn').addEventListener('click', () => {
    const code = document.getElementById('joinCodeInput').value.trim().toUpperCase();
    if (code.length !== 6) {
        showFloatText(W / 2, H / 2, 'Enter 6-character code', '#f44');
        return;
    }
    document.getElementById('lobbyStatus').textContent = 'Connecting...';
    joinGame(code);
});

// Lobby room event handlers
document.getElementById('lobbyLeaveBtn')?.addEventListener('click', () => {
    playSound('click');
    endMultiplayerGame();
    document.getElementById('menu').classList.remove('hidden');
});

document.getElementById('switchTeamBtn')?.addEventListener('click', () => {
    switchTeam();
});

document.getElementById('startGameBtn')?.addEventListener('click', () => {
    startMultiplayerGame();
});

// Game mode toggle (PvP vs Co-op)
document.querySelectorAll('.mode-toggle-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        setGameMode(btn.dataset.mpmode);
    });
});

// Add AI buttons
document.querySelectorAll('.add-ai-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        addAI(parseInt(btn.dataset.team));
    });
});

// Initialize audio on first interaction
document.addEventListener('click', function initAudioOnce() {
    initAudio();
    document.removeEventListener('click', initAudioOnce);
}, { once: true });

document.addEventListener('touchstart', function initAudioOnce() {
    initAudio();
    document.removeEventListener('touchstart', initAudioOnce);
}, { once: true });

// Load saved settings
function loadSavedSettings() {
    // Apply saved feature toggles
    game.features = { ...playerStats.features };
    document.querySelectorAll('.feature-toggle').forEach(toggle => {
        const feature = toggle.dataset.feature;
        toggle.classList.toggle('active', game.features[feature]);
    });

    // Apply sound setting
    const soundBtn = document.getElementById('soundToggle');
    soundBtn.textContent = playerStats.settings.soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
    soundBtn.classList.toggle('muted', !playerStats.settings.soundEnabled);
}

// ==================== PWA & APP INITIALIZATION ====================

// Generate app icons programmatically
function generateAppIcons() {
    const sizes = [192, 512];
    sizes.forEach(size => {
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = size;
        iconCanvas.height = size;
        const iconCtx = iconCanvas.getContext('2d');

        // Background
        const grad = iconCtx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        grad.addColorStop(0, '#001a33');
        grad.addColorStop(1, '#000011');
        iconCtx.fillStyle = grad;
        iconCtx.fillRect(0, 0, size, size);

        // Outer glow ring
        iconCtx.strokeStyle = '#00ffff';
        iconCtx.lineWidth = size * 0.02;
        iconCtx.shadowColor = '#00ffff';
        iconCtx.shadowBlur = size * 0.1;
        iconCtx.beginPath();
        iconCtx.arc(size/2, size/2, size * 0.35, 0, Math.PI * 2);
        iconCtx.stroke();

        // Center planet
        const planetGrad = iconCtx.createRadialGradient(size*0.45, size*0.45, 0, size/2, size/2, size*0.25);
        planetGrad.addColorStop(0, '#00ffff');
        planetGrad.addColorStop(0.5, '#0088aa');
        planetGrad.addColorStop(1, '#004466');
        iconCtx.fillStyle = planetGrad;
        iconCtx.shadowBlur = size * 0.15;
        iconCtx.beginPath();
        iconCtx.arc(size/2, size/2, size * 0.22, 0, Math.PI * 2);
        iconCtx.fill();

        // Orbiting particles
        iconCtx.shadowBlur = size * 0.05;
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const dist = size * 0.35;
            const px = size/2 + Math.cos(angle) * dist;
            const py = size/2 + Math.sin(angle) * dist;
            iconCtx.fillStyle = i % 2 === 0 ? '#00ffff' : '#ff4444';
            iconCtx.beginPath();
            iconCtx.arc(px, py, size * 0.03, 0, Math.PI * 2);
            iconCtx.fill();
        }

        // Save as blob URL and update link tags
        iconCanvas.toBlob(blob => {
            if (!blob) return;
            const url = URL.createObjectURL(blob);
            // Update apple touch icon for iOS
            if (size === 192) {
                const appleTouchIcon = document.getElementById('appleTouchIcon');
                if (appleTouchIcon) appleTouchIcon.href = url;
            }
        });
    });
}

// Register service worker
async function registerServiceWorker() {
    if ('serviceWorker' in navigator) {
        try {
            const reg = await navigator.serviceWorker.register('sw.js');
            console.log('Service Worker registered:', reg.scope);
        } catch (e) {
            console.log('Service Worker registration failed:', e);
        }
    }
}

// Loading screen
function showLoadingScreen() {
    const loader = document.createElement('div');
    loader.id = 'loadingScreen';
    loader.innerHTML = `
        <style>
            #loadingScreen {
                position: fixed;
                inset: 0;
                background: #000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                transition: opacity 0.5s;
            }
            #loadingScreen.fade-out {
                opacity: 0;
                pointer-events: none;
            }
            .loader-title {
                font-size: 28px;
                font-weight: bold;
                color: #0ff;
                text-shadow: 0 0 20px #0ff;
                margin-bottom: 30px;
                letter-spacing: 3px;
            }
            .loader-ring {
                width: 80px;
                height: 80px;
                border: 4px solid rgba(0,255,255,0.2);
                border-top-color: #0ff;
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
            .loader-text {
                margin-top: 20px;
                color: #666;
                font-size: 14px;
            }
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
        </style>
        <div class="loader-title">PARTICLE CONQUEST</div>
        <div class="loader-ring"></div>
        <div class="loader-text">Loading...</div>
    `;
    document.body.appendChild(loader);
}

function hideLoadingScreen() {
    const loader = document.getElementById('loadingScreen');
    if (loader) {
        loader.classList.add('fade-out');
        setTimeout(() => loader.remove(), 500);
    }
}

// Init
showLoadingScreen();

window.addEventListener('resize', resize);
resize();
initBgParticles();
initDailyChallenges();
updateDailyChallengesUI();
loadSavedSettings();
achievements.load();

// Generate icons and register SW
generateAppIcons();
registerServiceWorker();

// Start game loop and hide loader
setTimeout(() => {
    hideLoadingScreen();
    requestAnimationFrame(animate);
}, 300);
    </script>
</body>
</html>
