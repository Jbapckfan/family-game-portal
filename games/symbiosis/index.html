<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Symbiosis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            overscroll-behavior: none;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
        }
        
        .world {
            position: absolute;
            width: 100%;
            height: 50%;
            overflow: hidden;
        }
        
        #solWorld {
            top: 0;
            background: linear-gradient(180deg, #2a1a3e 0%, #0f0f23 100%);
            border-bottom: 1px solid rgba(255, 107, 53, 0.5);
        }
        
        #lunaWorld {
            bottom: 0;
            background: linear-gradient(180deg, #0f1e3a 0%, #1a2f4a 100%);
            border-top: 1px solid rgba(74, 158, 218, 0.5);
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0f1c 0%, #1a0f2a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }
        
        #startScreen h1 {
            font-size: 60px;
            font-weight: 200;
            letter-spacing: 15px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ff6b35, #4a9eda);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        #startScreen p {
            font-size: 14px;
            opacity: 0.6;
            margin: 10px 0;
            letter-spacing: 2px;
        }
        
        #startButton {
            margin-top: 40px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ff6b35, #4a9eda);
            border: none;
            color: white;
            border-radius: 30px;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        #startButton:active {
            transform: scale(0.95);
        }
        
        .ui-text {
            position: absolute;
            font-size: 11px;
            opacity: 0.4;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 100;
        }
        
        #solHint {
            top: 10px;
            right: 10px;
            color: #ff9558;
        }
        
        #lunaHint {
            bottom: 10px;
            right: 10px;
            color: #66ccff;
        }
        
        #proximityIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #9966ff;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 500;
            letter-spacing: 3px;
        }
        
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        #levelComplete.show {
            transform: translate(-50%, -50%) scale(1);
        }
        
        #levelComplete h2 {
            color: #9966ff;
            margin-bottom: 20px;
            letter-spacing: 3px;
        }
        
        #levelComplete button {
            margin-top: 20px;
            padding: 12px 30px;
            background: linear-gradient(135deg, #ff6b35, #4a9eda);
            border: none;
            color: white;
            border-radius: 20px;
            font-size: 12px;
            letter-spacing: 2px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen">
            <h1>SYMBIOSIS</h1>
            <p>Two souls. Two dimensions. One destiny.</p>
            <p style="font-size: 12px; opacity: 0.4;">Touch to attract â€¢ Drag to guide</p>
            <button id="startButton" onclick="startGame()">BEGIN</button>
        </div>
        
        <div id="solWorld" class="world">
            <canvas id="bgCanvasSol"></canvas>
            <canvas id="gameCanvasSol"></canvas>
            <div id="solHint" class="ui-text">DRAG SOL</div>
        </div>
        
        <div id="lunaWorld" class="world">
            <canvas id="bgCanvasLuna"></canvas>
            <canvas id="gameCanvasLuna"></canvas>
            <div id="lunaHint" class="ui-text">TOUCH TO ATTRACT LUNA</div>
        </div>
        
        <div id="proximityIndicator">RESONANCE</div>
        
        <div id="levelComplete">
            <h2>HARMONIZED</h2>
            <p>Sol and Luna are reunited</p>
            <button onclick="nextLevel()">CONTINUE</button>
        </div>
    </div>
    
    <script>
        // Game state
        const game = {
            sol: {
                x: 100,
                y: 100,
                vx: 0,
                vy: 0,
                radius: 16,
                targetX: 100,
                targetY: 100,
                scaleX: 1,
                scaleY: 1,
                trail: []
            },
            luna: {
                x: 100,
                y: 100,
                vx: 0,
                vy: 0,
                radius: 16,
                targetX: 100,
                targetY: 100,
                scaleX: 1,
                scaleY: 1,
                trail: [],
                frostPatterns: []
            },
            windPower: 0,
            windAngle: 0,
            windParticles: [],
            heatActive: false,
            heatPower: 0,
            iceAlpha: 1,
            bridgeExtension: 0,
            windmillRotation: 0,
            gameStarted: false,
            animTime: 0,
            proximityPower: 0,
            screenShake: { x: 0, y: 0, power: 0 },
            particles: [],
            dimensionalTears: [],
            parallaxLayers: {
                sol: [],
                luna: []
            }
        };
        
        // Canvas references
        const canvases = {
            solGame: null,
            solBg: null,
            lunaGame: null,
            lunaBg: null,
            solCtx: null,
            solBgCtx: null,
            lunaCtx: null,
            lunaBgCtx: null
        };
        
        // Input state
        const input = {
            solDragging: false,
            lunaTouch: { x: -1, y: -1, active: false }
        };
        
        function initCanvases() {
            canvases.solGame = document.getElementById('gameCanvasSol');
            canvases.solBg = document.getElementById('bgCanvasSol');
            canvases.lunaGame = document.getElementById('gameCanvasLuna');
            canvases.lunaBg = document.getElementById('bgCanvasLuna');
            
            canvases.solCtx = canvases.solGame.getContext('2d');
            canvases.solBgCtx = canvases.solBg.getContext('2d');
            canvases.lunaCtx = canvases.lunaGame.getContext('2d');
            canvases.lunaBgCtx = canvases.lunaBg.getContext('2d');
            
            resizeCanvases();
        }
        
        function resizeCanvases() {
            const width = window.innerWidth;
            const height = window.innerHeight / 2;
            
            [canvases.solGame, canvases.solBg, canvases.lunaGame, canvases.lunaBg].forEach(canvas => {
                if (canvas) {
                    canvas.width = width;
                    canvas.height = height;
                }
            });
        }
        
        function startGame() {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 500);
            
            initCanvases();
            initParallaxLayers();
            setupControls();
            game.gameStarted = true;
            requestAnimationFrame(gameLoop);
        }
        
        function initParallaxLayers() {
            // Create parallax layers for depth
            for (let i = 0; i < 3; i++) {
                game.parallaxLayers.sol.push({
                    shapes: [],
                    speed: 0.2 + i * 0.1,
                    opacity: 0.05 + i * 0.02
                });
                
                game.parallaxLayers.luna.push({
                    shapes: [],
                    speed: 0.2 + i * 0.1,
                    opacity: 0.05 + i * 0.02
                });
                
                // Generate random shapes for each layer
                for (let j = 0; j < 10; j++) {
                    game.parallaxLayers.sol[i].shapes.push({
                        x: Math.random() * canvases.solGame.width,
                        y: Math.random() * canvases.solGame.height,
                        size: 20 + Math.random() * 40,
                        rotation: Math.random() * Math.PI * 2
                    });
                    
                    game.parallaxLayers.luna[i].shapes.push({
                        x: Math.random() * canvases.lunaGame.width,
                        y: Math.random() * canvases.lunaGame.height,
                        size: 20 + Math.random() * 40,
                        rotation: Math.random() * Math.PI * 2
                    });
                }
            }
        }
        
        function setupControls() {
            // Sol controls - drag to move
            canvases.solGame.addEventListener('mousedown', handleSolStart);
            canvases.solGame.addEventListener('mousemove', handleSolMove);
            canvases.solGame.addEventListener('mouseup', handleSolEnd);
            canvases.solGame.addEventListener('touchstart', handleSolStart);
            canvases.solGame.addEventListener('touchmove', handleSolMove);
            canvases.solGame.addEventListener('touchend', handleSolEnd);
            
            // Luna controls - touch to attract
            canvases.lunaGame.addEventListener('mousedown', handleLunaStart);
            canvases.lunaGame.addEventListener('mousemove', handleLunaMove);
            canvases.lunaGame.addEventListener('mouseup', handleLunaEnd);
            canvases.lunaGame.addEventListener('touchstart', handleLunaStart);
            canvases.lunaGame.addEventListener('touchmove', handleLunaMove);
            canvases.lunaGame.addEventListener('touchend', handleLunaEnd);
            
            window.addEventListener('resize', resizeCanvases);
        }
        
        function handleSolStart(e) {
            e.preventDefault();
            const rect = canvases.solGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = (touch.clientX - rect.left) * (canvases.solGame.width / rect.width);
            const y = (touch.clientY - rect.top) * (canvases.solGame.height / rect.height);
            
            // Check if clicking on Sol
            const dist = Math.hypot(x - game.sol.x, y - game.sol.y);
            if (dist < game.sol.radius * 2) {
                input.solDragging = true;
            }
        }
        
        function handleSolMove(e) {
            if (!input.solDragging) return;
            e.preventDefault();
            
            const rect = canvases.solGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            game.sol.targetX = (touch.clientX - rect.left) * (canvases.solGame.width / rect.width);
            game.sol.targetY = (touch.clientY - rect.top) * (canvases.solGame.height / rect.height);
        }
        
        function handleSolEnd(e) {
            e.preventDefault();
            input.solDragging = false;
        }
        
        function handleLunaStart(e) {
            e.preventDefault();
            input.lunaTouch.active = true;
            const rect = canvases.lunaGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            input.lunaTouch.x = (touch.clientX - rect.left) * (canvases.lunaGame.width / rect.width);
            input.lunaTouch.y = (touch.clientY - rect.top) * (canvases.lunaGame.height / rect.height);
        }
        
        function handleLunaMove(e) {
            if (!input.lunaTouch.active) return;
            e.preventDefault();
            
            const rect = canvases.lunaGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            input.lunaTouch.x = (touch.clientX - rect.left) * (canvases.lunaGame.width / rect.width);
            input.lunaTouch.y = (touch.clientY - rect.top) * (canvases.lunaGame.height / rect.height);
        }
        
        function handleLunaEnd(e) {
            e.preventDefault();
            input.lunaTouch.active = false;
        }
        
        function update(deltaTime) {
            if (!game.gameStarted) return;
            
            game.animTime += deltaTime;
            
            // Update Sol with momentum physics
            const solAccel = 0.5;
            const solFriction = 0.85;
            
            const dx = game.sol.targetX - game.sol.x;
            const dy = game.sol.targetY - game.sol.y;
            
            game.sol.vx += dx * solAccel * deltaTime;
            game.sol.vy += dy * solAccel * deltaTime;
            const solFrictionDt = Math.pow(solFriction, deltaTime * 60);
            game.sol.vx *= solFrictionDt;
            game.sol.vy *= solFrictionDt;
            
            game.sol.x += game.sol.vx;
            game.sol.y += game.sol.vy;
            
            // Keep Sol in bounds
            game.sol.x = Math.max(game.sol.radius, Math.min(canvases.solGame.width - game.sol.radius, game.sol.x));
            game.sol.y = Math.max(game.sol.radius, Math.min(canvases.solGame.height - game.sol.radius, game.sol.y));
            
            // Update Luna with magnetic attraction
            if (input.lunaTouch.active) {
                const lunaAccel = 0.3;
                const dx = input.lunaTouch.x - game.luna.x;
                const dy = input.lunaTouch.y - game.luna.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 5) {
                    // Stronger attraction when farther away
                    const force = Math.min(1, dist / 200) * lunaAccel;
                    game.luna.vx += (dx / dist) * force * deltaTime * 60;
                    game.luna.vy += (dy / dist) * force * deltaTime * 60;
                }
            }
            
            // Luna physics with ice sliding
            const lunaFriction = 0.94; // Less friction = more sliding
            const lunaFrictionDt = Math.pow(lunaFriction, deltaTime * 60);
            game.luna.vx *= lunaFrictionDt;
            game.luna.vy *= lunaFrictionDt;
            
            game.luna.x += game.luna.vx;
            game.luna.y += game.luna.vy;
            
            // Keep Luna in bounds with bounce
            if (game.luna.x < game.luna.radius || game.luna.x > canvases.lunaGame.width - game.luna.radius) {
                game.luna.vx *= -0.5;
                game.luna.x = Math.max(game.luna.radius, Math.min(canvases.lunaGame.width - game.luna.radius, game.luna.x));
            }
            if (game.luna.y < game.luna.radius || game.luna.y > canvases.lunaGame.height - game.luna.radius) {
                game.luna.vy *= -0.5;
                game.luna.y = Math.max(game.luna.radius, Math.min(canvases.lunaGame.height - game.luna.radius, game.luna.y));
            }
            
            // Update trails
            updateTrail(game.sol, deltaTime);
            updateTrail(game.luna, deltaTime);
            
            // Calculate proximity magnetism
            const proximityDist = Math.hypot(game.sol.x - game.luna.x, game.sol.y - game.luna.y);
            game.proximityPower = Math.max(0, 1 - proximityDist / 200);
            
            if (game.proximityPower > 0.5) {
                // Time dilation effect
                const slowFactor = 0.5 + (1 - game.proximityPower) * 0.5;
                const slowFactorDt = Math.pow(slowFactor, deltaTime * 60);
                game.sol.vx *= slowFactorDt;
                game.sol.vy *= slowFactorDt;
                game.luna.vx *= slowFactorDt;
                game.luna.vy *= slowFactorDt;
                
                // Screen shake
                game.screenShake.power = game.proximityPower * 2;
                
                // Show proximity indicator
                document.getElementById('proximityIndicator').style.opacity = game.proximityPower;
                
                // Create dimensional tear
                if (Math.random() < game.proximityPower * 0.1) {
                    game.dimensionalTears.push({
                        x: (game.sol.x + game.luna.x) / 2,
                        y: (game.sol.y + game.luna.y) / 2,
                        life: 1,
                        size: 20 + Math.random() * 30
                    });
                }
            } else {
                document.getElementById('proximityIndicator').style.opacity = 0;
            }
            
            // Update dimensional tears
            game.dimensionalTears = game.dimensionalTears.filter(tear => {
                tear.life -= deltaTime * 0.5;
                return tear.life > 0;
            });
            
            // Generate wind from Luna's movement
            const lunaSpeed = Math.hypot(game.luna.vx, game.luna.vy);
            game.windPower = lunaSpeed * 2;
            game.windAngle = Math.atan2(game.luna.vy, game.luna.vx);
            
            // Create wind particles
            if (game.windPower > 1 && Math.random() < 0.3) {
                for (let i = 0; i < 3; i++) {
                    game.windParticles.push({
                        x: game.luna.x + (Math.random() - 0.5) * 40,
                        y: game.luna.y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(game.windAngle) * game.windPower * 3 + (Math.random() - 0.5) * 2,
                        vy: Math.sin(game.windAngle) * game.windPower * 3 + (Math.random() - 0.5) * 2,
                        life: 1,
                        size: 2 + Math.random() * 3
                    });
                }
            }
            
            // Update wind particles
            game.windParticles = game.windParticles.filter(p => {
                p.x += p.vx * deltaTime * 60;
                p.y += p.vy * deltaTime * 60;
                const windFrictionDt = Math.pow(0.98, deltaTime * 60);
                p.vx *= windFrictionDt;
                p.vy *= windFrictionDt;
                p.life -= deltaTime;
                return p.life > 0;
            });
            
            // Update windmill
            game.windmillRotation += game.windPower * deltaTime * 2;
            
            // Extend bridge based on windmill
            if (game.windPower > 2) {
                game.bridgeExtension = Math.min(1, game.bridgeExtension + deltaTime);
            } else {
                game.bridgeExtension = Math.max(0, game.bridgeExtension - deltaTime * 0.5);
            }
            
            // Check heat plate collision
            const heatPlateX = canvases.solGame.width - 100;
            const heatPlateY = canvases.solGame.height / 2;
            const heatDist = Math.hypot(game.sol.x - heatPlateX, game.sol.y - heatPlateY);
            game.heatActive = heatDist < 60;
            
            if (game.heatActive) {
                game.heatPower = Math.min(1, game.heatPower + deltaTime * 2);
            } else {
                game.heatPower = Math.max(0, game.heatPower - deltaTime);
            }
            
            // Melt ice based on heat
            if (game.heatPower > 0) {
                game.iceAlpha = Math.max(0, game.iceAlpha - game.heatPower * deltaTime);
            } else {
                game.iceAlpha = Math.min(1, game.iceAlpha + deltaTime * 0.3);
            }
            
            // Add frost patterns where Luna touches
            if (lunaSpeed < 1 && Math.random() < 0.05) {
                game.luna.frostPatterns.push({
                    x: game.luna.x + (Math.random() - 0.5) * 30,
                    y: game.luna.y + (Math.random() - 0.5) * 30,
                    size: 10 + Math.random() * 20,
                    life: 1,
                    growth: 0
                });
            }
            
            // Update frost patterns
            game.luna.frostPatterns = game.luna.frostPatterns.filter(frost => {
                frost.growth = Math.min(1, frost.growth + deltaTime * 0.5);
                frost.life -= deltaTime * 0.1;
                return frost.life > 0;
            });
            
            // Character squash and stretch (lerp factor 0.2 per frame at 60fps)
            const lerpFactor = 1 - Math.pow(1 - 0.2, deltaTime * 60);
            const solSpeed = Math.hypot(game.sol.vx, game.sol.vy);
            const targetScaleX = 1 + solSpeed * 0.02;
            const targetScaleY = 1 - solSpeed * 0.02;
            game.sol.scaleX += (targetScaleX - game.sol.scaleX) * lerpFactor;
            game.sol.scaleY += (targetScaleY - game.sol.scaleY) * lerpFactor;

            const targetScaleXLuna = 1 + lunaSpeed * 0.03;
            const targetScaleYLuna = 1 - lunaSpeed * 0.03;
            game.luna.scaleX += (targetScaleXLuna - game.luna.scaleX) * lerpFactor;
            game.luna.scaleY += (targetScaleYLuna - game.luna.scaleY) * lerpFactor;
            
            // Update screen shake
            if (game.screenShake.power > 0) {
                game.screenShake.x = (Math.random() - 0.5) * game.screenShake.power;
                game.screenShake.y = (Math.random() - 0.5) * game.screenShake.power;
                game.screenShake.power *= Math.pow(0.9, deltaTime * 60);
            }
            
            // Check win condition
            const exitX = canvases.solGame.width - 40;
            const exitY = 40;
            const solAtExit = Math.hypot(game.sol.x - exitX, game.sol.y - exitY) < 30;
            const lunaAtExit = Math.hypot(game.luna.x - exitX, game.luna.y - exitY) < 30;
            
            if (solAtExit && lunaAtExit && game.iceAlpha < 0.1) {
                document.getElementById('levelComplete').classList.add('show');
            }
        }
        
        function updateTrail(character, deltaTime) {
            // Add current position to trail
            character.trail.push({
                x: character.x,
                y: character.y,
                life: 1
            });

            // Update and clean trail (0.02 per frame at 60fps = 1.2 per second)
            character.trail = character.trail.filter(point => {
                point.life -= 1.2 * deltaTime;
                return point.life > 0;
            });
            
            // Limit trail length
            if (character.trail.length > 30) {
                character.trail.shift();
            }
        }
        
        function renderSolWorld() {
            const ctx = canvases.solCtx;
            const bgCtx = canvases.solBgCtx;
            const width = canvases.solGame.width;
            const height = canvases.solGame.height;
            
            // Clear with subtle fade for motion blur
            ctx.fillStyle = 'rgba(15, 15, 35, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Apply screen shake
            ctx.save();
            ctx.translate(game.screenShake.x, game.screenShake.y);
            
            // Render parallax background
            bgCtx.clearRect(0, 0, width, height);
            game.parallaxLayers.sol.forEach(layer => {
                bgCtx.fillStyle = `rgba(255, 107, 53, ${layer.opacity})`;
                layer.shapes.forEach(shape => {
                    bgCtx.save();
                    bgCtx.translate(shape.x - game.sol.x * layer.speed, shape.y - game.sol.y * layer.speed);
                    bgCtx.rotate(shape.rotation + game.animTime * 0.1);
                    bgCtx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);
                    bgCtx.restore();
                });
            });
            
            // Draw chasm
            const gradient = ctx.createLinearGradient(200, 0, 600, 0);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(200, 0, 400, height);
            
            // Draw bridge with glow
            if (game.bridgeExtension > 0) {
                const bridgeWidth = 400 * game.bridgeExtension;
                
                // Bridge glow
                const glow = ctx.createRadialGradient(
                    200 + bridgeWidth/2, height/2, 0,
                    200 + bridgeWidth/2, height/2, bridgeWidth/2 + 40
                );
                glow.addColorStop(0, 'rgba(255, 150, 50, 0.4)');
                glow.addColorStop(1, 'rgba(255, 107, 53, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(180, height/2 - 40, bridgeWidth + 40, 80);
                
                // Bridge body
                ctx.fillStyle = `rgba(255, 140, 60, ${0.6 + Math.sin(game.animTime * 5) * 0.1})`;
                ctx.fillRect(200, height/2 - 20, bridgeWidth, 40);
                
                // Energy lines
                ctx.strokeStyle = '#ffaa55';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(200, height/2);
                ctx.lineTo(200 + bridgeWidth, height/2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw windmill with dynamic rotation
            ctx.save();
            ctx.translate(100, 100);
            
            // Windmill glow
            if (game.windPower > 0) {
                const glowRadius = 30 + game.windPower * 10;
                const windGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                windGlow.addColorStop(0, `rgba(255, 180, 100, ${game.windPower * 0.3})`);
                windGlow.addColorStop(1, 'rgba(255, 107, 53, 0)');
                ctx.fillStyle = windGlow;
                ctx.fillRect(-glowRadius, -glowRadius, glowRadius * 2, glowRadius * 2);
            }
            
            ctx.rotate(game.windmillRotation);
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.fillStyle = `rgba(255, 140, 80, ${0.8 + Math.sin(game.animTime * 3) * 0.2})`;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -40);
                ctx.lineTo(10, -40);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
            
            // Draw heat plate
            const heatX = width - 100;
            const heatY = height / 2;
            
            if (game.heatPower > 0) {
                // Heat waves
                for (let i = 0; i < 3; i++) {
                    const waveRadius = 30 + i * 20 + (game.animTime * 30) % 30;
                    ctx.strokeStyle = `rgba(255, 100, 0, ${game.heatPower * (1 - i / 3) * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(heatX, heatY, waveRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            ctx.fillStyle = game.heatActive ? 
                `rgba(255, 100, 0, ${0.6 + Math.sin(game.animTime * 10) * 0.2})` : 
                'rgba(150, 50, 0, 0.3)';
            ctx.fillRect(heatX - 40, heatY - 30, 80, 60);
            
            // Draw exit portal
            const exitX = width - 40;
            const exitY = 40;
            
            ctx.strokeStyle = `rgba(255, 107, 53, ${0.5 + Math.sin(game.animTime * 3) * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(exitX, exitY, 25, game.animTime, game.animTime + Math.PI * 1.8);
            ctx.stroke();
            
            // Draw Sol's burning trail
            ctx.lineCap = 'round';
            game.sol.trail.forEach((point, index) => {
                if (index === 0) return;
                const prev = game.sol.trail[index - 1];
                
                const gradient = ctx.createLinearGradient(prev.x, prev.y, point.x, point.y);
                gradient.addColorStop(0, `rgba(255, 150, 50, ${prev.life * 0.5})`);
                gradient.addColorStop(1, `rgba(255, 100, 0, ${point.life * 0.3})`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = point.life * 8;
                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            });
            
            // Draw Sol with squash/stretch
            ctx.save();
            ctx.translate(game.sol.x, game.sol.y);
            ctx.scale(game.sol.scaleX, game.sol.scaleY);
            
            // Sol glow
            const solGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, game.sol.radius * 2);
            solGlow.addColorStop(0, '#ffdd00');
            solGlow.addColorStop(0.5, '#ff9900');
            solGlow.addColorStop(1, 'rgba(255, 107, 53, 0.3)');
            
            ctx.fillStyle = solGlow;
            ctx.beginPath();
            ctx.arc(0, 0, game.sol.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Sol core
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, game.sol.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Draw dimensional tears in Sol's world
            game.dimensionalTears.forEach(tear => {
                ctx.save();
                ctx.globalAlpha = tear.life;
                
                const tearGradient = ctx.createRadialGradient(
                    tear.x, tear.y / 2, 0,
                    tear.x, tear.y / 2, tear.size
                );
                tearGradient.addColorStop(0, '#ff00ff');
                tearGradient.addColorStop(0.5, '#9966ff');
                tearGradient.addColorStop(1, 'rgba(153, 102, 255, 0)');
                
                ctx.fillStyle = tearGradient;
                ctx.fillRect(tear.x - tear.size, tear.y / 2 - tear.size, tear.size * 2, tear.size * 2);
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        function renderLunaWorld() {
            const ctx = canvases.lunaCtx;
            const bgCtx = canvases.lunaBgCtx;
            const width = canvases.lunaGame.width;
            const height = canvases.lunaGame.height;
            
            // Clear with fade
            ctx.fillStyle = 'rgba(15, 30, 50, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Apply screen shake
            ctx.save();
            ctx.translate(game.screenShake.x, game.screenShake.y);
            
            // Render parallax background
            bgCtx.clearRect(0, 0, width, height);
            game.parallaxLayers.luna.forEach(layer => {
                bgCtx.fillStyle = `rgba(74, 158, 218, ${layer.opacity})`;
                layer.shapes.forEach(shape => {
                    bgCtx.save();
                    bgCtx.translate(shape.x - game.luna.x * layer.speed, shape.y - game.luna.y * layer.speed);
                    bgCtx.rotate(-shape.rotation - game.animTime * 0.05);
                    bgCtx.beginPath();
                    bgCtx.arc(0, 0, shape.size, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.restore();
                });
            });
            
            // Draw frost patterns
            game.luna.frostPatterns.forEach(frost => {
                ctx.save();
                ctx.globalAlpha = frost.life * 0.3;
                
                const frostGradient = ctx.createRadialGradient(
                    frost.x, frost.y, 0,
                    frost.x, frost.y, frost.size * frost.growth
                );
                frostGradient.addColorStop(0, 'rgba(200, 230, 255, 0.5)');
                frostGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.3)');
                frostGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
                
                ctx.fillStyle = frostGradient;
                ctx.beginPath();
                ctx.arc(frost.x, frost.y, frost.size * frost.growth, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw crystalline structure
                ctx.strokeStyle = `rgba(200, 230, 255, ${frost.life * 0.5})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i;
                    ctx.beginPath();
                    ctx.moveTo(frost.x, frost.y);
                    ctx.lineTo(
                        frost.x + Math.cos(angle) * frost.size * frost.growth,
                        frost.y + Math.sin(angle) * frost.size * frost.growth
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            // Draw ice wall
            if (game.iceAlpha > 0) {
                const iceX = width - 120;
                
                ctx.save();
                ctx.globalAlpha = game.iceAlpha;
                
                // Ice gradient
                const iceGradient = ctx.createLinearGradient(iceX, 0, iceX + 40, 0);
                iceGradient.addColorStop(0, 'rgba(150, 200, 255, 0.6)');
                iceGradient.addColorStop(0.5, 'rgba(180, 220, 255, 0.8)');
                iceGradient.addColorStop(1, 'rgba(150, 200, 255, 0.6)');
                ctx.fillStyle = iceGradient;
                ctx.fillRect(iceX, 0, 40, height);
                
                // Ice cracks when melting
                if (game.iceAlpha < 0.8) {
                    ctx.strokeStyle = `rgba(50, 100, 150, ${1 - game.iceAlpha})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iceX + Math.random() * 40, Math.random() * height);
                        ctx.lineTo(iceX + Math.random() * 40, Math.random() * height);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // Draw visible wind particles
            game.windParticles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life * 0.6;
                
                // Wind streak
                const windGradient = ctx.createLinearGradient(
                    p.x - p.vx * 5, p.y - p.vy * 5,
                    p.x, p.y
                );
                windGradient.addColorStop(0, 'rgba(100, 200, 255, 0)');
                windGradient.addColorStop(1, 'rgba(150, 220, 255, 0.8)');
                
                ctx.strokeStyle = windGradient;
                ctx.lineWidth = p.size;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p.x - p.vx * 10, p.y - p.vy * 10);
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
                
                ctx.restore();
            });
            
            // Draw exit portal
            const exitX = width - 40;
            const exitY = 40;
            
            ctx.strokeStyle = `rgba(74, 158, 218, ${0.5 + Math.sin(game.animTime * 3 + Math.PI) * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(exitX, exitY, 25, -game.animTime, -game.animTime + Math.PI * 1.8);
            ctx.stroke();
            
            // Draw Luna's frost trail
            ctx.lineCap = 'round';
            game.luna.trail.forEach((point, index) => {
                if (index === 0) return;
                const prev = game.luna.trail[index - 1];
                
                const gradient = ctx.createLinearGradient(prev.x, prev.y, point.x, point.y);
                gradient.addColorStop(0, `rgba(150, 200, 255, ${prev.life * 0.3})`);
                gradient.addColorStop(1, `rgba(100, 180, 255, ${point.life * 0.2})`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = point.life * 6;
                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            });
            
            // Draw Luna with squash/stretch
            ctx.save();
            ctx.translate(game.luna.x, game.luna.y);
            ctx.scale(game.luna.scaleX, game.luna.scaleY);
            
            // Luna glow (changes when attracted)
            const lunaGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, game.luna.radius * 2);
            if (input.lunaTouch.active) {
                lunaGlow.addColorStop(0, '#ffffff');
                lunaGlow.addColorStop(0.3, '#00ffff');
                lunaGlow.addColorStop(0.6, '#0099ff');
                lunaGlow.addColorStop(1, 'rgba(0, 150, 255, 0.3)');
            } else {
                lunaGlow.addColorStop(0, '#aaddff');
                lunaGlow.addColorStop(0.5, '#66aaff');
                lunaGlow.addColorStop(1, 'rgba(74, 158, 218, 0.3)');
            }
            
            ctx.fillStyle = lunaGlow;
            ctx.beginPath();
            ctx.arc(0, 0, game.luna.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Luna core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, 0, game.luna.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Draw touch indicator
            if (input.lunaTouch.active) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                
                const touchGradient = ctx.createRadialGradient(
                    input.lunaTouch.x, input.lunaTouch.y, 0,
                    input.lunaTouch.x, input.lunaTouch.y, 40
                );
                touchGradient.addColorStop(0, 'rgba(0, 200, 255, 0.5)');
                touchGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                
                ctx.fillStyle = touchGradient;
                ctx.beginPath();
                ctx.arc(input.lunaTouch.x, input.lunaTouch.y, 40, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            // Draw dimensional tears in Luna's world
            game.dimensionalTears.forEach(tear => {
                ctx.save();
                ctx.globalAlpha = tear.life;
                
                const tearGradient = ctx.createRadialGradient(
                    tear.x, height - tear.y / 2, 0,
                    tear.x, height - tear.y / 2, tear.size
                );
                tearGradient.addColorStop(0, '#ff00ff');
                tearGradient.addColorStop(0.5, '#9966ff');
                tearGradient.addColorStop(1, 'rgba(153, 102, 255, 0)');
                
                ctx.fillStyle = tearGradient;
                ctx.fillRect(tear.x - tear.size, height - tear.y / 2 - tear.size, tear.size * 2, tear.size * 2);
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        function nextLevel() {
            document.getElementById('levelComplete').classList.remove('show');
            
            // Reset positions
            game.sol.x = 100;
            game.sol.y = 100;
            game.sol.targetX = 100;
            game.sol.targetY = 100;
            game.sol.vx = 0;
            game.sol.vy = 0;
            game.sol.trail = [];
            
            game.luna.x = 100;
            game.luna.y = 100;
            game.luna.vx = 0;
            game.luna.vy = 0;
            game.luna.trail = [];
            game.luna.frostPatterns = [];
            
            game.windPower = 0;
            game.windParticles = [];
            game.heatPower = 0;
            game.iceAlpha = 1;
            game.bridgeExtension = 0;
            game.windmillRotation = 0;
            game.dimensionalTears = [];
        }
        
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.033); // Cap at 30fps minimum
            lastTime = currentTime;
            
            update(deltaTime);
            renderSolWorld();
            renderLunaWorld();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Prevent scrolling
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        window.addEventListener('resize', resizeCanvases);
    </script>
</body>
</html>