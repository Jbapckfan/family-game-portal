<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="description" content="Symbiosis - A dual-world physics puzzle where two souls must cooperate across dimensions to reunite.">
    <meta name="theme-color" content="#0a0f1c">
    <meta property="og:title" content="Symbiosis - Dual World Puzzle">
    <meta property="og:description" content="Guide Sol and Luna through parallel dimensions in this physics puzzle game.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Symbiosis">
    <title>Symbiosis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            overscroll-behavior: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
        }

        .world {
            position: absolute;
            width: 100%;
            height: 50%;
            overflow: hidden;
        }

        #solWorld {
            top: 0;
            background: linear-gradient(180deg, #2a1a3e 0%, #0f0f23 100%);
            border-bottom: 1px solid rgba(255, 107, 53, 0.5);
        }

        #lunaWorld {
            bottom: 0;
            background: linear-gradient(180deg, #0f1e3a 0%, #1a2f4a 100%);
            border-top: 1px solid rgba(74, 158, 218, 0.5);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0f1c 0%, #1a0f2a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        #startScreen h1 {
            font-size: 60px;
            font-weight: 200;
            letter-spacing: 15px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ff6b35, #4a9eda);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #startScreen p {
            font-size: 14px;
            opacity: 0.8;
            margin: 10px 0;
            letter-spacing: 2px;
        }

        #startButton {
            margin-top: 40px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ff6b35, #4a9eda);
            border: none;
            color: white;
            border-radius: 30px;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #startButton:active {
            transform: scale(0.95);
        }

        .ui-text {
            position: absolute;
            font-size: 11px;
            opacity: 0.75;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 100;
        }

        #solHint {
            top: calc(10px + env(safe-area-inset-top));
            right: calc(10px + env(safe-area-inset-right));
            color: #ff9558;
        }

        #lunaHint {
            bottom: calc(10px + env(safe-area-inset-bottom));
            right: calc(10px + env(safe-area-inset-right));
            color: #66ccff;
        }

        #proximityIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #9966ff;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 500;
            letter-spacing: 3px;
        }

        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #levelComplete.show {
            transform: translate(-50%, -50%) scale(1);
        }

        #levelComplete h2 {
            color: #9966ff;
            margin-bottom: 10px;
            letter-spacing: 3px;
        }

        #levelComplete .stars-display {
            font-size: 36px;
            margin: 10px 0;
            letter-spacing: 8px;
        }

        #levelComplete .time-display {
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            margin: 8px 0;
            letter-spacing: 1px;
        }

        #levelComplete .best-time-display {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            margin: 4px 0 15px 0;
            letter-spacing: 1px;
        }

        #levelComplete button {
            margin-top: 10px;
            padding: 12px 30px;
            min-height: 44px;
            background: linear-gradient(135deg, #ff6b35, #4a9eda);
            border: none;
            color: white;
            border-radius: 20px;
            font-size: 12px;
            letter-spacing: 2px;
            cursor: pointer;
        }

        #levelIndicator {
            position: absolute;
            top: calc(10px + env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 2px;
            pointer-events: none;
            z-index: 500;
            text-align: center;
        }

        #levelIndicator .level-stars {
            font-size: 10px;
            letter-spacing: 2px;
            display: block;
            margin-top: 2px;
        }

        #timerDisplay {
            position: absolute;
            top: calc(30px + env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: rgba(255,255,255,0.4);
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 500;
            font-variant-numeric: tabular-nums;
        }

        #muteButton {
            position: fixed;
            top: calc(12px + env(safe-area-inset-top));
            right: calc(12px + env(safe-area-inset-right));
            z-index: 9999;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        #muteButton:hover {
            background: rgba(0,0,0,0.9);
        }

        #tutorialOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 800;
            display: none;
        }

        #tutorialOverlay.active {
            display: block;
        }

        #tutorialText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 16px 28px;
            border-radius: 14px;
            font-size: 14px;
            letter-spacing: 1.5px;
            text-align: center;
            border: 1px solid rgba(153, 102, 255, 0.4);
            max-width: 80%;
            line-height: 1.6;
            transition: opacity 0.4s;
        }

        #tutorialText .tutorial-sub {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 6px;
            display: block;
        }

        /* Level Select Overlay */
        #levelSelectOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 15, 28, 0.97);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            transition: opacity 0.4s;
        }

        #levelSelectOverlay.show {
            display: flex;
        }

        #levelSelectOverlay h2 {
            font-size: 24px;
            font-weight: 200;
            letter-spacing: 6px;
            margin-bottom: 30px;
            color: #9966ff;
        }

        .level-select-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 16px;
            max-width: 400px;
        }

        .level-select-btn {
            width: 90px;
            height: 90px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: #fff;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background 0.2s;
            font-family: inherit;
        }

        .level-select-btn:active {
            transform: scale(0.93);
        }

        .level-select-btn.unlocked {
            background: rgba(153, 102, 255, 0.15);
            border-color: rgba(153, 102, 255, 0.4);
        }

        .level-select-btn.unlocked:hover {
            background: rgba(153, 102, 255, 0.3);
        }

        .level-select-btn.locked {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .level-select-btn .ls-num {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .level-select-btn .ls-name {
            font-size: 8px;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-top: 2px;
        }

        .level-select-btn .ls-stars {
            font-size: 12px;
            letter-spacing: 2px;
            margin-top: 4px;
            color: #ffcc00;
        }

        .level-select-btn .ls-time {
            font-size: 8px;
            opacity: 0.5;
            margin-top: 1px;
        }

        #levelSelectBack {
            margin-top: 30px;
            padding: 12px 30px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            border-radius: 20px;
            font-size: 12px;
            letter-spacing: 2px;
            cursor: pointer;
            font-family: inherit;
        }

        /* Reset Level Button */
        #resetButton {
            position: fixed;
            top: calc(12px + env(safe-area-inset-top));
            left: calc(70px + env(safe-area-inset-left));
            z-index: 9999;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            min-height: 44px;
            min-width: 44px;
            display: none;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        #resetButton:hover {
            background: rgba(0,0,0,0.9);
        }

        @media (prefers-reduced-motion: reduce) {
          *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
          }
        }

        button:focus-visible, #startButton:focus-visible {
          outline: 2px solid #fff;
          outline-offset: 4px;
        }
    </style>
</head>
<body>
  <a href="../../" style="position:fixed;top:12px;left:12px;z-index:9999;background:rgba(0,0,0,0.7);color:#fff;text-decoration:none;padding:8px 14px;border-radius:10px;font-family:-apple-system,BlinkMacSystemFont,sans-serif;font-size:14px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.15);transition:background 0.2s;min-height:44px;display:flex;align-items:center;gap:6px;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">&#x1F3E0; Menu</a>
  <button id="muteButton" aria-label="Toggle audio mute">&#x1F50A;</button>
  <button id="resetButton" aria-label="Restart level">&#x21BB;</button>
    <div id="gameContainer">
        <div id="startScreen">
            <h1>SYMBIOSIS</h1>
            <p>Two souls. Two dimensions. One destiny.</p>
            <p style="font-size: 12px; opacity: 0.7;">Touch to attract &bull; Drag to guide</p>
            <button id="startButton">BEGIN</button>
            <button id="levelSelectButton" style="margin-top:14px;padding:10px 30px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);color:white;border-radius:20px;font-size:11px;letter-spacing:2px;cursor:pointer;display:none;font-family:inherit;">LEVEL SELECT</button>
        </div>

        <div id="levelSelectOverlay">
            <h2>SELECT LEVEL</h2>
            <div class="level-select-grid" id="levelSelectGrid"></div>
            <button id="levelSelectBack">BACK</button>
        </div>

        <div id="solWorld" class="world">
            <canvas id="bgCanvasSol"></canvas>
            <canvas id="gameCanvasSol"></canvas>
            <div id="solHint" class="ui-text">DRAG SOL</div>
        </div>

        <div id="lunaWorld" class="world">
            <canvas id="bgCanvasLuna"></canvas>
            <canvas id="gameCanvasLuna"></canvas>
            <div id="lunaHint" class="ui-text">TOUCH TO ATTRACT LUNA</div>
        </div>

        <div id="levelIndicator">LEVEL 1<span class="level-stars"></span></div>
        <div id="timerDisplay">0:00.0</div>
        <div id="proximityIndicator">RESONANCE</div>

        <div id="tutorialOverlay">
            <div id="tutorialText"></div>
        </div>

        <div id="levelComplete">
            <h2>HARMONIZED</h2>
            <div class="stars-display" id="starsDisplay"></div>
            <p class="time-display" id="completeTimeDisplay"></p>
            <p class="best-time-display" id="bestTimeDisplay"></p>
            <p>Sol and Luna are reunited</p>
            <button id="continueButton">CONTINUE</button>
        </div>
    </div>

    <script>
        // Fix 7: Reduced motion preference check
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // ===== IMPROVEMENT 1: LEVEL DEFINITIONS =====
        // Positions use fractions of screen width/height so they scale to any device.
        // At runtime we multiply by actual CSS pixel dimensions.
        const levelDefs = [
            {
                name: 'Awakening',
                sol:  { startX: 0.12, startY: 0.35 },
                luna: { startX: 0.12, startY: 0.35 },
                chasm: { xFrac: 0.25, widthFrac: 0.45 },
                windmill: { xFrac: 0.12, yFrac: 0.30 },
                heatPlate: { xFrac: 0.85, yFrac: 0.50 },
                iceWall: { xFrac: 0.78, widthPx: 40 },
                exit: { xFrac: 0.92, yFrac: 0.12 },
                movingPlatform: null,
                starThresholds: [30, 50, 90]  // gold < 30s, silver < 50s, bronze < 90s
            },
            {
                name: 'Crossing',
                sol:  { startX: 0.08, startY: 0.70 },
                luna: { startX: 0.08, startY: 0.70 },
                chasm: { xFrac: 0.35, widthFrac: 0.30 },
                windmill: { xFrac: 0.22, yFrac: 0.20 },
                heatPlate: { xFrac: 0.80, yFrac: 0.30 },
                iceWall: { xFrac: 0.70, widthPx: 50 },
                exit: { xFrac: 0.90, yFrac: 0.85 },
                movingPlatform: null,
                starThresholds: [35, 60, 100]
            },
            {
                name: 'Drift',
                sol:  { startX: 0.50, startY: 0.85 },
                luna: { startX: 0.50, startY: 0.85 },
                chasm: { xFrac: 0.15, widthFrac: 0.55 },
                windmill: { xFrac: 0.06, yFrac: 0.50 },
                heatPlate: { xFrac: 0.88, yFrac: 0.65 },
                iceWall: { xFrac: 0.82, widthPx: 45 },
                exit: { xFrac: 0.93, yFrac: 0.15 },
                movingPlatform: { xFrac: 0.42, yFrac: 0.50, rangeFrac: 0.30, speed: 0.4 },
                starThresholds: [45, 75, 120]
            },
            {
                name: 'Convergence',
                sol:  { startX: 0.90, startY: 0.85 },
                luna: { startX: 0.90, startY: 0.85 },
                chasm: { xFrac: 0.20, widthFrac: 0.35 },
                windmill: { xFrac: 0.10, yFrac: 0.15 },
                heatPlate: { xFrac: 0.65, yFrac: 0.20 },
                iceWall: { xFrac: 0.60, widthPx: 35 },
                exit: { xFrac: 0.08, yFrac: 0.12 },
                movingPlatform: { xFrac: 0.30, yFrac: 0.45, rangeFrac: 0.25, speed: 0.55 },
                gravityWells: [
                    { xFrac: 0.45, yFrac: 0.60, strength: 120, radius: 80 }
                ],
                starThresholds: [50, 80, 130]
            },
            {
                name: 'Reunion',
                sol:  { startX: 0.06, startY: 0.90 },
                luna: { startX: 0.94, startY: 0.90 },
                chasm: { xFrac: 0.30, widthFrac: 0.40 },
                windmill: { xFrac: 0.18, yFrac: 0.25 },
                heatPlate: { xFrac: 0.78, yFrac: 0.45 },
                iceWall: { xFrac: 0.72, widthPx: 55 },
                exit: { xFrac: 0.50, yFrac: 0.10 },
                movingPlatform: { xFrac: 0.45, yFrac: 0.50, rangeFrac: 0.35, speed: 0.65 },
                gravityWells: [
                    { xFrac: 0.35, yFrac: 0.40, strength: 100, radius: 70 },
                    { xFrac: 0.65, yFrac: 0.70, strength: 130, radius: 90 }
                ],
                starThresholds: [60, 100, 150]
            }
        ];

        // Resolved pixel positions for the current level (set by loadLevel)
        let lvl = {};

        // ===== IMPROVEMENT 5: PERSISTENT BEST TIMES =====
        function loadBestTimes() {
            try {
                return JSON.parse(localStorage.getItem('symbiosis_bestTimes') || '{}');
            } catch(e) { return {}; }
        }
        function saveBestTime(levelIndex, time, stars) {
            const data = loadBestTimes();
            const key = 'level_' + levelIndex;
            if (!data[key] || time < data[key].time) {
                data[key] = { time: time, stars: stars };
            }
            localStorage.setItem('symbiosis_bestTimes', JSON.stringify(data));
        }
        function getBestForLevel(levelIndex) {
            const data = loadBestTimes();
            return data['level_' + levelIndex] || null;
        }
        function getStarsForTime(levelIndex, time) {
            const t = levelDefs[levelIndex].starThresholds;
            if (time <= t[0]) return 3;
            if (time <= t[1]) return 2;
            if (time <= t[2]) return 1;
            return 1; // always at least 1 star for completing
        }
        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return m + ':' + (s < 10 ? '0' : '') + s.toFixed(1);
        }
        function starsString(count) {
            let s = '';
            for (let i = 0; i < 3; i++) {
                s += i < count ? '\u2605' : '\u2606';  // filled star : empty star
            }
            return s;
        }

        // ===== IMPROVEMENT 3: TUTORIAL SYSTEM =====
        const tutorialSteps = [
            {
                text: 'DRAG SOL TO MOVE HER',
                sub: 'Touch and drag in the top world',
                check: function() { return Math.hypot(game.sol.x - game.sol.startX, game.sol.y - game.sol.startY) > 50; }
            },
            {
                text: 'TOUCH LUNA\'S WORLD TO ATTRACT HER',
                sub: 'Tap or drag in the bottom world',
                check: function() { return Math.hypot(game.luna.x - game.luna.startX, game.luna.y - game.luna.startY) > 50; }
            },
            {
                text: 'LUNA\'S MOVEMENT CREATES WIND',
                sub: 'Move Luna quickly to spin the windmill and extend the bridge',
                check: function() { return game.windPower > 3; }
            },
            {
                text: 'MOVE SOL ONTO THE HEAT PLATE',
                sub: 'The heat melts Luna\'s ice wall',
                check: function() { return game.heatActive; }
            }
        ];
        let tutorialActive = false;
        let tutorialStep = 0;
        function isTutorialDone() {
            try { return localStorage.getItem('symbiosis_tutorial_done') === '1'; } catch(e) { return false; }
        }
        function markTutorialDone() {
            try { localStorage.setItem('symbiosis_tutorial_done', '1'); } catch(e) {}
        }
        function showTutorial() {
            if (isTutorialDone()) { tutorialActive = false; return; }
            tutorialActive = true;
            tutorialStep = 0;
            const overlay = document.getElementById('tutorialOverlay');
            overlay.classList.add('active');
            renderTutorialStep();
        }
        function renderTutorialStep() {
            const el = document.getElementById('tutorialText');
            if (tutorialStep >= tutorialSteps.length) {
                hideTutorial();
                return;
            }
            const step = tutorialSteps[tutorialStep];
            el.innerHTML = step.text + '<span class="tutorial-sub">' + step.sub + '</span>';
            el.style.opacity = '1';
        }
        function hideTutorial() {
            tutorialActive = false;
            markTutorialDone();
            const overlay = document.getElementById('tutorialOverlay');
            overlay.classList.remove('active');
        }
        function updateTutorial() {
            if (!tutorialActive) return;
            if (tutorialStep >= tutorialSteps.length) { hideTutorial(); return; }
            if (tutorialSteps[tutorialStep].check()) {
                tutorialStep++;
                if (tutorialStep >= tutorialSteps.length) {
                    hideTutorial();
                } else {
                    // brief fade transition
                    const el = document.getElementById('tutorialText');
                    el.style.opacity = '0';
                    setTimeout(renderTutorialStep, 400);
                }
            }
        }

        // ===== IMPROVEMENT 2: AUDIO SYSTEM =====
        let audioCtx = null;
        let masterGain = null;
        let audioMuted = false;
        let solDrone = null;
        let lunaDrone = null;
        let solDroneGain = null;
        let lunaDroneGain = null;

        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioCtx.destination);

                // Sol drone: warm A2 (110 Hz) sine
                solDrone = audioCtx.createOscillator();
                solDrone.type = 'sine';
                solDrone.frequency.value = 110;
                solDroneGain = audioCtx.createGain();
                solDroneGain.gain.value = 0.08;
                solDrone.connect(solDroneGain);
                solDroneGain.connect(masterGain);
                solDrone.start();

                // Luna drone: cool E3 (164.81 Hz) sine
                lunaDrone = audioCtx.createOscillator();
                lunaDrone.type = 'sine';
                lunaDrone.frequency.value = 164.81;
                lunaDroneGain = audioCtx.createGain();
                lunaDroneGain.gain.value = 0.06;
                lunaDrone.connect(lunaDroneGain);
                lunaDroneGain.connect(masterGain);
                lunaDrone.start();
            } catch(e) {
                // Audio not available - game still works without it
                audioCtx = null;
            }
        }

        function updateAudioProximity() {
            if (!audioCtx || !solDroneGain || !lunaDroneGain) return;
            // As characters approach on X-axis, harmonize volumes
            const xDist = Math.abs(game.sol.x - game.luna.x);
            const maxDist = solCssWidth;
            const proximity = 1 - Math.min(1, xDist / maxDist);
            // Both drones swell when characters are close on X
            const baseS = 0.05;
            const baseL = 0.04;
            const harmonyBoost = proximity * proximity * 0.12;
            solDroneGain.gain.setTargetAtTime(baseS + harmonyBoost, audioCtx.currentTime, 0.1);
            lunaDroneGain.gain.setTargetAtTime(baseL + harmonyBoost, audioCtx.currentTime, 0.1);
        }

        // Event sounds
        function playIceCrackle() {
            if (!audioCtx) return;
            // Crackling: short burst of filtered noise
            const dur = 0.15;
            const bufSize = audioCtx.sampleRate * dur;
            const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.3));
            }
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            const filt = audioCtx.createBiquadFilter();
            filt.type = 'highpass';
            filt.frequency.value = 2000;
            const g = audioCtx.createGain();
            g.gain.value = 0.15;
            src.connect(filt);
            filt.connect(g);
            g.connect(masterGain);
            src.start();
            src.stop(audioCtx.currentTime + dur);
        }

        function playWindWhoosh() {
            if (!audioCtx) return;
            const dur = 0.3;
            const bufSize = audioCtx.sampleRate * dur;
            const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                const env = Math.sin(Math.PI * i / bufSize);
                data[i] = (Math.random() * 2 - 1) * env;
            }
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            const filt = audioCtx.createBiquadFilter();
            filt.type = 'bandpass';
            filt.frequency.value = 800;
            filt.Q.value = 2;
            const g = audioCtx.createGain();
            g.gain.value = 0.08;
            src.connect(filt);
            filt.connect(g);
            g.connect(masterGain);
            src.start();
            src.stop(audioCtx.currentTime + dur);
        }

        function playResonanceChime() {
            if (!audioCtx) return;
            // Bell-like tone: two sine oscillators with exponential decay
            const osc1 = audioCtx.createOscillator();
            osc1.type = 'sine';
            osc1.frequency.value = 523.25; // C5
            const osc2 = audioCtx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 659.25; // E5
            const g = audioCtx.createGain();
            g.gain.value = 0.15;
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.0);
            osc1.connect(g);
            osc2.connect(g);
            g.connect(masterGain);
            osc1.start();
            osc2.start();
            osc1.stop(audioCtx.currentTime + 1.0);
            osc2.stop(audioCtx.currentTime + 1.0);
        }

        function playVictoryStinger() {
            if (!audioCtx) return;
            // Ascending arpeggio: C5 E5 G5 C6
            const notes = [523.25, 659.25, 783.99, 1046.50];
            notes.forEach(function(freq, i) {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;
                const g = audioCtx.createGain();
                g.gain.value = 0;
                g.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.15);
                g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + i * 0.15 + 0.05);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.15 + 0.6);
                osc.connect(g);
                g.connect(masterGain);
                osc.start(audioCtx.currentTime + i * 0.15);
                osc.stop(audioCtx.currentTime + i * 0.15 + 0.7);
            });
        }

        function playCollisionBuzz() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = 80;
            const g = audioCtx.createGain();
            g.gain.value = 0.08;
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
            osc.connect(g);
            g.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.12);
        }

        function toggleMute() {
            audioMuted = !audioMuted;
            if (masterGain) {
                masterGain.gain.setTargetAtTime(audioMuted ? 0 : 0.3, audioCtx.currentTime, 0.05);
            }
            document.getElementById('muteButton').innerHTML = audioMuted ? '&#x1F507;' : '&#x1F50A;';
        }

        // Audio event tracking to avoid repeat-triggering
        let lastIceCrackleAlpha = 1;
        let lastResonanceTrigger = 0;
        let windWhooshCooldown = 0;

        // Game state
        const game = {
            sol: {
                x: 100,
                y: 100,
                vx: 0,
                vy: 0,
                radius: 16,
                targetX: 100,
                targetY: 100,
                scaleX: 1,
                scaleY: 1,
                trail: [],
                startX: 100,
                startY: 100,
                collisionFlash: 0
            },
            luna: {
                x: 100,
                y: 100,
                vx: 0,
                vy: 0,
                radius: 16,
                targetX: 100,
                targetY: 100,
                scaleX: 1,
                scaleY: 1,
                trail: [],
                frostPatterns: [],
                startX: 100,
                startY: 100,
                collisionFlash: 0
            },
            currentLevel: 0,
            windPower: 0,
            windAngle: 0,
            windParticles: [],
            heatActive: false,
            heatPower: 0,
            iceAlpha: 1,
            bridgeExtension: 0,
            windmillRotation: 0,
            gameStarted: false,
            levelCompleted: false,
            animTime: 0,
            proximityPower: 0,
            screenShake: { x: 0, y: 0, power: 0 },
            particles: [],
            dimensionalTears: [],
            parallaxLayers: {
                sol: [],
                luna: []
            },
            frameCount: 0,
            frameCountLuna: 0,
            iceCracks: [],
            // Timer (Improvement 5)
            levelStartTime: 0,
            levelElapsed: 0,
            timerRunning: false,
            // Moving platform state
            movingPlatformOffset: 0,
            // Idle animation tracking
            solLastMoveTime: 0,
            lunaLastMoveTime: 0,
            solIdleParticles: [],
            lunaIdleParticles: [],
            // Ambient background particles
            ambientSolParticles: [],
            ambientLunaParticles: [],
            // Gravity wells vortex rotation
            gravityWellRotation: 0
        };

        // Canvas references
        const canvases = {
            solGame: null,
            solBg: null,
            lunaGame: null,
            lunaBg: null,
            solCtx: null,
            solBgCtx: null,
            lunaCtx: null,
            lunaBgCtx: null
        };

        // CSS pixel dimensions (game logic uses these, NOT canvas.width/height which are scaled by DPR)
        let solCssWidth = 0;
        let solCssHeight = 0;
        let lunaCssWidth = 0;
        let lunaCssHeight = 0;

        // Input state
        const input = {
            solDragging: false,
            lunaTouch: { x: -1, y: -1, active: false }
        };

        // ===== LEVEL LOADING =====
        function loadLevel(index) {
            if (index >= levelDefs.length) {
                // All levels complete - loop back to start or show final screen
                index = 0;
            }
            game.currentLevel = index;
            const def = levelDefs[index];
            const w = solCssWidth || window.innerWidth;
            const h = solCssHeight || (window.innerHeight / 2);

            lvl = {
                chasm: { x: def.chasm.xFrac * w, width: def.chasm.widthFrac * w },
                windmill: { x: def.windmill.xFrac * w, y: def.windmill.yFrac * h },
                heatPlate: { x: def.heatPlate.xFrac * w, y: def.heatPlate.yFrac * h },
                iceWall: { x: def.iceWall.xFrac * w, width: def.iceWall.widthPx },
                exit: { x: def.exit.xFrac * w, y: def.exit.yFrac * h },
                movingPlatform: null
            };
            if (def.movingPlatform) {
                lvl.movingPlatform = {
                    x: def.movingPlatform.xFrac * w,
                    y: def.movingPlatform.yFrac * h,
                    range: def.movingPlatform.rangeFrac * h,
                    speed: def.movingPlatform.speed
                };
            }

            // Gravity wells
            lvl.gravityWells = [];
            if (def.gravityWells) {
                def.gravityWells.forEach(function(gw) {
                    lvl.gravityWells.push({
                        x: gw.xFrac * w,
                        y: gw.yFrac * h,
                        strength: gw.strength,
                        radius: gw.radius
                    });
                });
            }

            // Reset positions
            game.sol.x = def.sol.startX * w;
            game.sol.y = def.sol.startY * h;
            game.sol.targetX = game.sol.x;
            game.sol.targetY = game.sol.y;
            game.sol.vx = 0;
            game.sol.vy = 0;
            game.sol.trail = [];
            game.sol.startX = game.sol.x;
            game.sol.startY = game.sol.y;
            game.sol.collisionFlash = 0;

            game.luna.x = def.luna.startX * w;
            game.luna.y = def.luna.startY * h;
            game.luna.targetX = game.luna.x;
            game.luna.targetY = game.luna.y;
            game.luna.vx = 0;
            game.luna.vy = 0;
            game.luna.trail = [];
            game.luna.frostPatterns = [];
            game.luna.startX = game.luna.x;
            game.luna.startY = game.luna.y;
            game.luna.collisionFlash = 0;

            game.windPower = 0;
            game.windParticles = [];
            game.heatPower = 0;
            game.heatActive = false;
            game.iceAlpha = 1;
            game.iceCracks = [];
            game.bridgeExtension = 0;
            game.windmillRotation = 0;
            game.dimensionalTears = [];
            game.levelCompleted = false;
            game.movingPlatformOffset = 0;
            game.solLastMoveTime = 0;
            game.lunaLastMoveTime = 0;
            game.solIdleParticles = [];
            game.lunaIdleParticles = [];
            game.ambientSolParticles = [];
            game.ambientLunaParticles = [];
            game.gravityWellRotation = 0;

            // Timer
            game.levelStartTime = performance.now();
            game.levelElapsed = 0;
            game.timerRunning = true;

            // Audio tracking reset
            lastIceCrackleAlpha = 1;
            lastResonanceTrigger = 0;
            windWhooshCooldown = 0;

            // UI
            const best = getBestForLevel(index);
            const starStr = best ? starsString(best.stars) : '';
            document.getElementById('levelIndicator').innerHTML =
                'LEVEL ' + (index + 1) + ' - ' + def.name.toUpperCase() +
                '<span class="level-stars">' + starStr + '</span>';
            document.getElementById('timerDisplay').textContent = '0:00.0';
            document.getElementById('levelComplete').classList.remove('show');
        }

        // Fix 8: Canvas error handling
        function initCanvases() {
            canvases.solGame = document.getElementById('gameCanvasSol');
            canvases.solBg = document.getElementById('bgCanvasSol');
            canvases.lunaGame = document.getElementById('gameCanvasLuna');
            canvases.lunaBg = document.getElementById('bgCanvasLuna');

            canvases.solCtx = canvases.solGame.getContext('2d');
            if (!canvases.solCtx) {
                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff;background:#0a0f1c;font-family:sans-serif;text-align:center;padding:2rem"><div><h2>Canvas Not Supported</h2><p>Your browser does not support the canvas element required for this game.</p></div></div>';
                return;
            }
            canvases.solBgCtx = canvases.solBg.getContext('2d');
            if (!canvases.solBgCtx) {
                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff;background:#0a0f1c;font-family:sans-serif;text-align:center;padding:2rem"><div><h2>Canvas Not Supported</h2><p>Your browser does not support the canvas element required for this game.</p></div></div>';
                return;
            }
            canvases.lunaCtx = canvases.lunaGame.getContext('2d');
            if (!canvases.lunaCtx) {
                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff;background:#0a0f1c;font-family:sans-serif;text-align:center;padding:2rem"><div><h2>Canvas Not Supported</h2><p>Your browser does not support the canvas element required for this game.</p></div></div>';
                return;
            }
            canvases.lunaBgCtx = canvases.lunaBg.getContext('2d');
            if (!canvases.lunaBgCtx) {
                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff;background:#0a0f1c;font-family:sans-serif;text-align:center;padding:2rem"><div><h2>Canvas Not Supported</h2><p>Your browser does not support the canvas element required for this game.</p></div></div>';
                return;
            }

            resizeCanvases();
        }

        // Fix 1: DPI scaling in resizeCanvases
        function resizeCanvases() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight / 2;

            // Store CSS pixel dimensions for all game logic
            solCssWidth = w;
            solCssHeight = h;
            lunaCssWidth = w;
            lunaCssHeight = h;

            [canvases.solBg, canvases.solGame].forEach(c => {
                if (c) {
                    c.width = w * dpr;
                    c.height = h * dpr;
                    c.style.width = w + 'px';
                    c.style.height = h + 'px';
                    c.getContext('2d').scale(dpr, dpr);
                }
            });
            [canvases.lunaBg, canvases.lunaGame].forEach(c => {
                if (c) {
                    c.width = w * dpr;
                    c.height = h * dpr;
                    c.style.width = w + 'px';
                    c.style.height = h + 'px';
                    c.getContext('2d').scale(dpr, dpr);
                }
            });
        }

        function startGame() {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 500);

            initCanvases();
            initParallaxLayers();
            setupControls();
            initAudio();
            game.gameStarted = true;
            document.getElementById('resetButton').style.display = 'flex';
            loadLevel(0);

            // Tutorial for first level on first playthrough
            if (!isTutorialDone()) {
                showTutorial();
            }

            requestAnimationFrame(gameLoop);
        }

        // Show level select button on start screen if any level has been completed
        (function() {
            if (hasAnyCompletedLevel()) {
                document.getElementById('levelSelectButton').style.display = 'inline-block';
            }
        })();

        function initParallaxLayers() {
            // Reset layers before (re-)initializing
            game.parallaxLayers.sol = [];
            game.parallaxLayers.luna = [];
            // Create parallax layers for depth
            for (let i = 0; i < 3; i++) {
                game.parallaxLayers.sol.push({
                    shapes: [],
                    speed: 0.2 + i * 0.1,
                    opacity: 0.05 + i * 0.02
                });

                game.parallaxLayers.luna.push({
                    shapes: [],
                    speed: 0.2 + i * 0.1,
                    opacity: 0.05 + i * 0.02
                });

                // Generate random shapes for each layer
                for (let j = 0; j < 10; j++) {
                    game.parallaxLayers.sol[i].shapes.push({
                        x: Math.random() * solCssWidth,
                        y: Math.random() * solCssHeight,
                        size: 20 + Math.random() * 40,
                        rotation: Math.random() * Math.PI * 2
                    });

                    game.parallaxLayers.luna[i].shapes.push({
                        x: Math.random() * lunaCssWidth,
                        y: Math.random() * lunaCssHeight,
                        size: 20 + Math.random() * 40,
                        rotation: Math.random() * Math.PI * 2
                    });
                }
            }
        }

        function setupControls() {
            // Sol controls - drag to move
            canvases.solGame.addEventListener('mousedown', handleSolStart);
            canvases.solGame.addEventListener('mousemove', handleSolMove);
            canvases.solGame.addEventListener('mouseup', handleSolEnd);
            // Fix 5: passive: false for touch events
            canvases.solGame.addEventListener('touchstart', handleSolStart, { passive: false });
            canvases.solGame.addEventListener('touchmove', handleSolMove, { passive: false });
            canvases.solGame.addEventListener('touchend', handleSolEnd, { passive: false });

            // Luna controls - touch to attract
            canvases.lunaGame.addEventListener('mousedown', handleLunaStart);
            canvases.lunaGame.addEventListener('mousemove', handleLunaMove);
            canvases.lunaGame.addEventListener('mouseup', handleLunaEnd);
            // Fix 5: passive: false for touch events
            canvases.lunaGame.addEventListener('touchstart', handleLunaStart, { passive: false });
            canvases.lunaGame.addEventListener('touchmove', handleLunaMove, { passive: false });
            canvases.lunaGame.addEventListener('touchend', handleLunaEnd, { passive: false });

            // Fix 4: Debounced resize listener
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resizeCanvases();
                    initParallaxLayers();
                    // Re-resolve level pixel positions on resize
                    if (game.gameStarted) {
                        const def = levelDefs[game.currentLevel];
                        const w = solCssWidth;
                        const h = solCssHeight;
                        lvl.chasm = { x: def.chasm.xFrac * w, width: def.chasm.widthFrac * w };
                        lvl.windmill = { x: def.windmill.xFrac * w, y: def.windmill.yFrac * h };
                        lvl.heatPlate = { x: def.heatPlate.xFrac * w, y: def.heatPlate.yFrac * h };
                        lvl.iceWall = { x: def.iceWall.xFrac * w, width: def.iceWall.widthPx };
                        lvl.exit = { x: def.exit.xFrac * w, y: def.exit.yFrac * h };
                        if (def.movingPlatform) {
                            lvl.movingPlatform = {
                                x: def.movingPlatform.xFrac * w,
                                y: def.movingPlatform.yFrac * h,
                                range: def.movingPlatform.rangeFrac * h,
                                speed: def.movingPlatform.speed
                            };
                        }
                        lvl.gravityWells = [];
                        if (def.gravityWells) {
                            def.gravityWells.forEach(function(gw) {
                                lvl.gravityWells.push({
                                    x: gw.xFrac * w,
                                    y: gw.yFrac * h,
                                    strength: gw.strength,
                                    radius: gw.radius
                                });
                            });
                        }
                    }
                }, 200);
            });
        }

        function handleSolStart(e) {
            e.preventDefault();
            const rect = canvases.solGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Check if clicking on Sol
            const dist = Math.hypot(x - game.sol.x, y - game.sol.y);
            if (dist < game.sol.radius * 2) {
                input.solDragging = true;
            }
        }

        function handleSolMove(e) {
            if (!input.solDragging) return;
            e.preventDefault();

            const rect = canvases.solGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            game.sol.targetX = touch.clientX - rect.left;
            game.sol.targetY = touch.clientY - rect.top;
        }

        function handleSolEnd(e) {
            e.preventDefault();
            input.solDragging = false;
        }

        function handleLunaStart(e) {
            e.preventDefault();
            input.lunaTouch.active = true;
            const rect = canvases.lunaGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            input.lunaTouch.x = touch.clientX - rect.left;
            input.lunaTouch.y = touch.clientY - rect.top;
        }

        function handleLunaMove(e) {
            if (!input.lunaTouch.active) return;
            e.preventDefault();

            const rect = canvases.lunaGame.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            input.lunaTouch.x = touch.clientX - rect.left;
            input.lunaTouch.y = touch.clientY - rect.top;
        }

        function handleLunaEnd(e) {
            e.preventDefault();
            input.lunaTouch.active = false;
        }

        // ===== IMPROVEMENT 4: COLLISION DETECTION =====
        function checkSolCollisions(deltaTime) {
            const r = game.sol.radius;
            const chasmLeft = lvl.chasm.x;
            const chasmRight = lvl.chasm.x + lvl.chasm.width;
            const bridgeTop = solCssHeight / 2 - 20;
            const bridgeBottom = solCssHeight / 2 + 20;
            const bridgeRight = chasmLeft + lvl.chasm.width * game.bridgeExtension;

            // Sol is inside the chasm horizontal range
            if (game.sol.x + r > chasmLeft && game.sol.x - r < chasmRight) {
                // Check if on the bridge
                const onBridge = (game.sol.x - r < bridgeRight) &&
                                 (game.sol.y + r > bridgeTop) &&
                                 (game.sol.y - r < bridgeBottom);

                // Check if on moving platform
                let onPlatform = false;
                if (lvl.movingPlatform) {
                    const platY = lvl.movingPlatform.y + Math.sin(game.movingPlatformOffset) * lvl.movingPlatform.range;
                    const platLeft = lvl.movingPlatform.x - 30;
                    const platRight = lvl.movingPlatform.x + 30;
                    const platTop = platY - 12;
                    const platBottom = platY + 12;
                    if (game.sol.x + r > platLeft && game.sol.x - r < platRight &&
                        game.sol.y + r > platTop && game.sol.y - r < platBottom) {
                        onPlatform = true;
                    }
                }

                if (!onBridge && !onPlatform) {
                    // Block: push Sol out of chasm
                    const fromLeft = game.sol.x - chasmLeft;
                    const fromRight = chasmRight - game.sol.x;
                    if (fromLeft < fromRight) {
                        game.sol.x = chasmLeft - r;
                        game.sol.targetX = Math.min(game.sol.targetX, chasmLeft - r);
                    } else {
                        game.sol.x = chasmRight + r;
                        game.sol.targetX = Math.max(game.sol.targetX, chasmRight + r);
                    }
                    if (Math.abs(game.sol.vx) > 0.5) {
                        game.sol.collisionFlash = 0.3;
                        playCollisionBuzz();
                        hapticPulse(20);
                    }
                    game.sol.vx = 0;
                }
            }
        }

        function checkLunaCollisions(deltaTime) {
            const r = game.luna.radius;
            // Ice wall collision: Luna cannot pass if iceAlpha > 0.15
            if (game.iceAlpha > 0.15) {
                const wallLeft = lvl.iceWall.x;
                const wallRight = lvl.iceWall.x + lvl.iceWall.width;

                if (game.luna.x + r > wallLeft && game.luna.x - r < wallRight) {
                    const fromLeft = game.luna.x - wallLeft;
                    const fromRight = wallRight - game.luna.x;
                    if (fromLeft < fromRight) {
                        game.luna.x = wallLeft - r;
                    } else {
                        game.luna.x = wallRight + r;
                    }
                    if (Math.abs(game.luna.vx) > 0.5) {
                        game.luna.collisionFlash = 0.3;
                        playCollisionBuzz();
                        hapticPulse(20);
                    }
                    game.luna.vx *= -0.3;
                }
            }
        }

        // ===== FEATURE: LEVEL SELECT =====
        function hasAnyCompletedLevel() {
            const data = loadBestTimes();
            for (let i = 0; i < levelDefs.length; i++) {
                if (data['level_' + i]) return true;
            }
            return false;
        }

        function buildLevelSelectGrid() {
            const grid = document.getElementById('levelSelectGrid');
            grid.innerHTML = '';
            const data = loadBestTimes();
            // Level 0 is always unlocked; others require prior level beaten
            for (let i = 0; i < levelDefs.length; i++) {
                const btn = document.createElement('button');
                btn.className = 'level-select-btn';
                const best = data['level_' + i] || null;
                const prevBest = i === 0 ? true : !!data['level_' + (i - 1)];
                const unlocked = (i === 0) || prevBest;

                if (unlocked) {
                    btn.classList.add('unlocked');
                } else {
                    btn.classList.add('locked');
                }

                let inner = '<span class="ls-num">' + (i + 1) + '</span>';
                inner += '<span class="ls-name">' + levelDefs[i].name.toUpperCase() + '</span>';
                if (best) {
                    inner += '<span class="ls-stars">' + starsString(best.stars) + '</span>';
                    inner += '<span class="ls-time">' + formatTime(best.time) + '</span>';
                }
                btn.innerHTML = inner;

                if (unlocked) {
                    (function(levelIdx) {
                        btn.addEventListener('click', function() {
                            closeLevelSelect();
                            startGameFromLevel(levelIdx);
                        });
                    })(i);
                }
                grid.appendChild(btn);
            }
        }

        function showLevelSelect() {
            buildLevelSelectGrid();
            document.getElementById('levelSelectOverlay').classList.add('show');
        }

        function closeLevelSelect() {
            document.getElementById('levelSelectOverlay').classList.remove('show');
        }

        function startGameFromLevel(levelIdx) {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.opacity = '0';
            setTimeout(function() {
                startScreen.style.display = 'none';
            }, 500);

            if (!game.gameStarted) {
                initCanvases();
                initParallaxLayers();
                setupControls();
                initAudio();
                game.gameStarted = true;
                requestAnimationFrame(gameLoop);
            }
            document.getElementById('resetButton').style.display = 'flex';
            loadLevel(levelIdx);
        }

        // ===== FEATURE: RESET LEVEL =====
        function resetCurrentLevel() {
            if (!game.gameStarted) return;
            document.getElementById('levelComplete').classList.remove('show');
            loadLevel(game.currentLevel);
        }

        // ===== FEATURE: HAPTIC FEEDBACK =====
        function hapticPulse(duration) {
            try {
                if (navigator.vibrate) navigator.vibrate(duration);
            } catch(e) {}
        }
        function hapticPattern(pattern) {
            try {
                if (navigator.vibrate) navigator.vibrate(pattern);
            } catch(e) {}
        }

        // ===== FEATURE: IDLE ANIMATION UPDATE =====
        function updateIdleAnimations(deltaTime) {
            var solSpeed = Math.hypot(game.sol.vx, game.sol.vy);
            var lunaSpeed = Math.hypot(game.luna.vx, game.luna.vy);

            // Track last move times
            if (solSpeed > 0.5) game.solLastMoveTime = game.animTime;
            if (lunaSpeed > 0.5) game.lunaLastMoveTime = game.animTime;

            // Sol idle breathing + embers
            var solIdleDur = game.animTime - game.solLastMoveTime;
            if (solIdleDur > 2.0) {
                // Breathing pulse
                var breathPhase = Math.sin(game.animTime * 2.5);
                game.sol.scaleX = 1 + breathPhase * 0.05;
                game.sol.scaleY = 1 - breathPhase * 0.05;

                // Emit passive ember particles
                if (Math.random() < 0.08) {
                    game.solIdleParticles.push({
                        x: game.sol.x + (Math.random() - 0.5) * 20,
                        y: game.sol.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: -Math.random() * 0.8 - 0.3,
                        life: 1,
                        size: 1.5 + Math.random() * 2,
                        color: Math.random() > 0.5 ? '#ff9944' : '#ffcc66'
                    });
                }
            }

            // Luna idle breathing + snowflakes
            var lunaIdleDur = game.animTime - game.lunaLastMoveTime;
            if (lunaIdleDur > 2.0) {
                var breathPhaseLuna = Math.sin(game.animTime * 2.5 + Math.PI * 0.5);
                game.luna.scaleX = 1 + breathPhaseLuna * 0.05;
                game.luna.scaleY = 1 - breathPhaseLuna * 0.05;

                if (Math.random() < 0.08) {
                    game.lunaIdleParticles.push({
                        x: game.luna.x + (Math.random() - 0.5) * 20,
                        y: game.luna.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 0.4,
                        vy: (Math.random() - 0.5) * 0.4,
                        life: 1,
                        size: 2 + Math.random() * 2,
                        rotation: Math.random() * Math.PI * 2
                    });
                }
            }

            // Update idle particles
            game.solIdleParticles = game.solIdleParticles.filter(function(p) {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime * 0.8;
                return p.life > 0;
            });
            game.lunaIdleParticles = game.lunaIdleParticles.filter(function(p) {
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += deltaTime * 1.5;
                p.life -= deltaTime * 0.8;
                return p.life > 0;
            });
        }

        // ===== FEATURE: AMBIENT BACKGROUND PARTICLES =====
        function updateAmbientParticles(deltaTime) {
            // Sol's world: falling embers (warm oranges drifting downward)
            if (game.ambientSolParticles.length < 25 && Math.random() < 0.06) {
                game.ambientSolParticles.push({
                    x: Math.random() * solCssWidth,
                    y: -5,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: 0.3 + Math.random() * 0.5,
                    life: 1,
                    size: 1 + Math.random() * 2.5,
                    hue: 20 + Math.random() * 30,  // orange range
                    flicker: Math.random() * Math.PI * 2
                });
            }

            game.ambientSolParticles = game.ambientSolParticles.filter(function(p) {
                p.x += p.vx + Math.sin(game.animTime * 0.5 + p.flicker) * 0.15;
                p.y += p.vy;
                p.flicker += deltaTime;
                if (p.y > solCssHeight + 5) return false;
                p.life -= deltaTime * 0.15;
                return p.life > 0;
            });

            // Luna's world: rising ice crystals (cool blues drifting upward)
            if (game.ambientLunaParticles.length < 25 && Math.random() < 0.06) {
                game.ambientLunaParticles.push({
                    x: Math.random() * lunaCssWidth,
                    y: lunaCssHeight + 5,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: -(0.3 + Math.random() * 0.5),
                    life: 1,
                    size: 1 + Math.random() * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 1.5
                });
            }

            game.ambientLunaParticles = game.ambientLunaParticles.filter(function(p) {
                p.x += p.vx + Math.sin(game.animTime * 0.4 + p.rotation) * 0.1;
                p.y += p.vy;
                p.rotation += p.rotSpeed * deltaTime;
                if (p.y < -5) return false;
                p.life -= deltaTime * 0.15;
                return p.life > 0;
            });
        }

        // ===== FEATURE: GRAVITY WELLS PHYSICS =====
        function applyGravityWells(character, deltaTime) {
            if (!lvl.gravityWells || lvl.gravityWells.length === 0) return;
            lvl.gravityWells.forEach(function(gw) {
                var dx = gw.x - character.x;
                var dy = gw.y - character.y;
                var dist = Math.hypot(dx, dy);
                if (dist < gw.radius && dist > 5) {
                    var force = (gw.strength / (dist * dist)) * deltaTime * 60;
                    force = Math.min(force, 3); // cap force
                    character.vx += (dx / dist) * force;
                    character.vy += (dy / dist) * force;
                }
            });
        }

        function update(deltaTime) {
            if (!game.gameStarted || game.levelCompleted) return;

            game.animTime += deltaTime;

            // Update timer
            if (game.timerRunning) {
                game.levelElapsed = (performance.now() - game.levelStartTime) / 1000;
                document.getElementById('timerDisplay').textContent = formatTime(game.levelElapsed);
            }

            // Update tutorial
            updateTutorial();

            // Update Sol with momentum physics
            const solAccel = 0.5;
            const solFriction = 0.85;

            const dx = game.sol.targetX - game.sol.x;
            const dy = game.sol.targetY - game.sol.y;

            game.sol.vx += dx * solAccel * deltaTime;
            game.sol.vy += dy * solAccel * deltaTime;
            const solFrictionDt = Math.pow(solFriction, deltaTime * 60);
            game.sol.vx *= solFrictionDt;
            game.sol.vy *= solFrictionDt;

            game.sol.x += game.sol.vx;
            game.sol.y += game.sol.vy;

            // Keep Sol in bounds
            game.sol.x = Math.max(game.sol.radius, Math.min(solCssWidth - game.sol.radius, game.sol.x));
            game.sol.y = Math.max(game.sol.radius, Math.min(solCssHeight - game.sol.radius, game.sol.y));

            // IMPROVEMENT 4: Sol collision with chasm
            checkSolCollisions(deltaTime);

            // Update Luna with magnetic attraction
            if (input.lunaTouch.active) {
                const lunaAccel = 0.3;
                const ldx = input.lunaTouch.x - game.luna.x;
                const ldy = input.lunaTouch.y - game.luna.y;
                const dist = Math.hypot(ldx, ldy);

                if (dist > 5) {
                    // Stronger attraction when farther away
                    const force = Math.min(1, dist / 200) * lunaAccel;
                    game.luna.vx += (ldx / dist) * force * deltaTime * 60;
                    game.luna.vy += (ldy / dist) * force * deltaTime * 60;
                }
            }

            // Luna physics with ice sliding
            const lunaFriction = 0.94; // Less friction = more sliding
            const lunaFrictionDt = Math.pow(lunaFriction, deltaTime * 60);
            game.luna.vx *= lunaFrictionDt;
            game.luna.vy *= lunaFrictionDt;

            game.luna.x += game.luna.vx;
            game.luna.y += game.luna.vy;

            // Keep Luna in bounds with bounce
            if (game.luna.x < game.luna.radius || game.luna.x > lunaCssWidth - game.luna.radius) {
                game.luna.vx *= -0.5;
                game.luna.x = Math.max(game.luna.radius, Math.min(lunaCssWidth - game.luna.radius, game.luna.x));
            }
            if (game.luna.y < game.luna.radius || game.luna.y > lunaCssHeight - game.luna.radius) {
                game.luna.vy *= -0.5;
                game.luna.y = Math.max(game.luna.radius, Math.min(lunaCssHeight - game.luna.radius, game.luna.y));
            }

            // IMPROVEMENT 4: Luna collision with ice wall
            checkLunaCollisions(deltaTime);

            // FEATURE: Gravity wells pull on both characters
            applyGravityWells(game.sol, deltaTime);
            applyGravityWells(game.luna, deltaTime);
            game.gravityWellRotation += deltaTime * 3;

            // Collision flash decay
            if (game.sol.collisionFlash > 0) game.sol.collisionFlash -= deltaTime * 2;
            if (game.luna.collisionFlash > 0) game.luna.collisionFlash -= deltaTime * 2;

            // Update trails
            updateTrail(game.sol, deltaTime);
            updateTrail(game.luna, deltaTime);

            // Calculate proximity magnetism
            const proximityDist = Math.hypot(game.sol.x - game.luna.x, game.sol.y - game.luna.y);
            game.proximityPower = Math.max(0, 1 - proximityDist / 200);

            if (game.proximityPower > 0.5) {
                // Time dilation effect
                const slowFactor = 0.5 + (1 - game.proximityPower) * 0.5;
                const slowFactorDt = Math.pow(slowFactor, deltaTime * 60);
                game.sol.vx *= slowFactorDt;
                game.sol.vy *= slowFactorDt;
                game.luna.vx *= slowFactorDt;
                game.luna.vy *= slowFactorDt;

                // Screen shake
                game.screenShake.power = game.proximityPower * 2;

                // Show proximity indicator
                document.getElementById('proximityIndicator').style.opacity = game.proximityPower;

                // AUDIO: Resonance chime
                if (game.proximityPower > 0.7 && game.animTime - lastResonanceTrigger > 2.0) {
                    playResonanceChime();
                    lastResonanceTrigger = game.animTime;
                }

                // Create dimensional tear
                if (Math.random() < game.proximityPower * 0.1) {
                    game.dimensionalTears.push({
                        x: (game.sol.x + game.luna.x) / 2,
                        y: (game.sol.y + game.luna.y) / 2,
                        life: 1,
                        size: 20 + Math.random() * 30
                    });
                }
            } else {
                document.getElementById('proximityIndicator').style.opacity = 0;
            }

            // Update dimensional tears
            game.dimensionalTears = game.dimensionalTears.filter(tear => {
                tear.life -= deltaTime * 0.5;
                return tear.life > 0;
            });

            // Generate wind from Luna's movement
            const lunaSpeed = Math.hypot(game.luna.vx, game.luna.vy);
            game.windPower = lunaSpeed * 2;
            game.windAngle = Math.atan2(game.luna.vy, game.luna.vx);

            // AUDIO: Wind whoosh
            if (game.windPower > 4 && windWhooshCooldown <= 0) {
                playWindWhoosh();
                windWhooshCooldown = 0.5;
            }
            if (windWhooshCooldown > 0) windWhooshCooldown -= deltaTime;

            // Create wind particles
            if (game.windPower > 1 && Math.random() < 0.3) {
                for (let i = 0; i < 3; i++) {
                    game.windParticles.push({
                        x: game.luna.x + (Math.random() - 0.5) * 40,
                        y: game.luna.y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(game.windAngle) * game.windPower * 3 + (Math.random() - 0.5) * 2,
                        vy: Math.sin(game.windAngle) * game.windPower * 3 + (Math.random() - 0.5) * 2,
                        life: 1,
                        size: 2 + Math.random() * 3
                    });
                }
            }

            // Update wind particles
            game.windParticles = game.windParticles.filter(p => {
                p.x += p.vx * deltaTime * 60;
                p.y += p.vy * deltaTime * 60;
                const windFrictionDt = Math.pow(0.98, deltaTime * 60);
                p.vx *= windFrictionDt;
                p.vy *= windFrictionDt;
                p.life -= deltaTime;
                return p.life > 0;
            });

            // Update windmill
            game.windmillRotation += game.windPower * deltaTime * 2;

            // Extend bridge based on windmill
            if (game.windPower > 2) {
                game.bridgeExtension = Math.min(1, game.bridgeExtension + deltaTime);
            } else {
                game.bridgeExtension = Math.max(0, game.bridgeExtension - deltaTime * 0.5);
            }

            // Update moving platform
            if (lvl.movingPlatform) {
                game.movingPlatformOffset += lvl.movingPlatform.speed * deltaTime * 2;
            }

            // Check heat plate collision
            const heatPlateX = lvl.heatPlate.x;
            const heatPlateY = lvl.heatPlate.y;
            const heatDist = Math.hypot(game.sol.x - heatPlateX, game.sol.y - heatPlateY);
            game.heatActive = heatDist < 60;

            if (game.heatActive) {
                game.heatPower = Math.min(1, game.heatPower + deltaTime * 2);
            } else {
                game.heatPower = Math.max(0, game.heatPower - deltaTime);
            }

            // Melt ice based on heat
            const prevIceAlpha = game.iceAlpha;
            if (game.heatPower > 0) {
                game.iceAlpha = Math.max(0, game.iceAlpha - game.heatPower * deltaTime);
            } else {
                game.iceAlpha = Math.min(1, game.iceAlpha + deltaTime * 0.3);
            }

            // AUDIO: Ice crackling when melting
            if (game.iceAlpha < prevIceAlpha && prevIceAlpha - game.iceAlpha > 0.005) {
                if (prevIceAlpha - lastIceCrackleAlpha > 0.08) {
                    playIceCrackle();
                    lastIceCrackleAlpha = game.iceAlpha;
                }
            }

            // HAPTIC: Ice wall shatter
            if (prevIceAlpha >= 0.1 && game.iceAlpha < 0.1) {
                hapticPulse(50);
            }

            // Add frost patterns where Luna touches
            if (lunaSpeed < 1 && Math.random() < 0.05) {
                game.luna.frostPatterns.push({
                    x: game.luna.x + (Math.random() - 0.5) * 30,
                    y: game.luna.y + (Math.random() - 0.5) * 30,
                    size: 10 + Math.random() * 20,
                    life: 1,
                    growth: 0
                });
            }

            // Update frost patterns
            game.luna.frostPatterns = game.luna.frostPatterns.filter(frost => {
                frost.growth = Math.min(1, frost.growth + deltaTime * 0.5);
                frost.life -= deltaTime * 0.1;
                return frost.life > 0;
            });

            // Character squash and stretch (lerp factor 0.2 per frame at 60fps)
            const lerpFactor = 1 - Math.pow(1 - 0.2, deltaTime * 60);
            const solSpeed = Math.hypot(game.sol.vx, game.sol.vy);
            const targetScaleX = 1 + solSpeed * 0.02;
            const targetScaleY = 1 - solSpeed * 0.02;
            game.sol.scaleX += (targetScaleX - game.sol.scaleX) * lerpFactor;
            game.sol.scaleY += (targetScaleY - game.sol.scaleY) * lerpFactor;

            const targetScaleXLuna = 1 + lunaSpeed * 0.03;
            const targetScaleYLuna = 1 - lunaSpeed * 0.03;
            game.luna.scaleX += (targetScaleXLuna - game.luna.scaleX) * lerpFactor;
            game.luna.scaleY += (targetScaleYLuna - game.luna.scaleY) * lerpFactor;

            // Update screen shake
            // Fix 7: Skip shake for reduced motion preference
            if (game.screenShake.power > 0) {
                if (prefersReducedMotion) {
                    game.screenShake.x = 0;
                    game.screenShake.y = 0;
                    game.screenShake.power = 0;
                } else {
                    game.screenShake.x = (Math.random() - 0.5) * game.screenShake.power;
                    game.screenShake.y = (Math.random() - 0.5) * game.screenShake.power;
                    game.screenShake.power *= Math.pow(0.9, deltaTime * 60);
                }
            }

            // Audio proximity update
            updateAudioProximity();

            // FEATURE: Idle animations
            updateIdleAnimations(deltaTime);

            // FEATURE: Ambient background particles
            updateAmbientParticles(deltaTime);

            // Check win condition
            const exitX = lvl.exit.x;
            const exitY = lvl.exit.y;
            const solAtExit = Math.hypot(game.sol.x - exitX, game.sol.y - exitY) < 30;
            const lunaAtExit = Math.hypot(game.luna.x - exitX, game.luna.y - exitY) < 30;

            // Fix 9: Feedback when at exit but ice not melted
            if (solAtExit && lunaAtExit && game.iceAlpha < 0.1) {
                completeLevel();
            } else if (solAtExit && lunaAtExit && game.iceAlpha >= 0.1) {
                // Show hint about ice
                document.getElementById('proximityIndicator').textContent = 'MELT THE ICE BARRIER';
                document.getElementById('proximityIndicator').style.opacity = '1';
            } else {
                // Reset text when condition is no longer met
                document.getElementById('proximityIndicator').textContent = 'RESONANCE';
            }
        }

        function completeLevel() {
            game.levelCompleted = true;
            game.timerRunning = false;
            const elapsed = game.levelElapsed;
            const stars = getStarsForTime(game.currentLevel, elapsed);

            // Save best time
            saveBestTime(game.currentLevel, elapsed, stars);

            // Audio + Haptic
            playVictoryStinger();
            hapticPattern([30, 60, 30, 60, 80]);

            // Update level complete screen
            document.getElementById('starsDisplay').textContent = starsString(stars);
            document.getElementById('completeTimeDisplay').textContent = 'TIME: ' + formatTime(elapsed);
            const best = getBestForLevel(game.currentLevel);
            document.getElementById('bestTimeDisplay').textContent =
                best ? 'BEST: ' + formatTime(best.time) : '';

            // Update button text
            const btn = document.getElementById('continueButton');
            if (game.currentLevel >= levelDefs.length - 1) {
                btn.textContent = 'PLAY AGAIN';
            } else {
                btn.textContent = 'CONTINUE';
            }

            document.getElementById('levelComplete').classList.add('show');
        }

        function updateTrail(character, deltaTime) {
            // Add current position to trail
            character.trail.push({
                x: character.x,
                y: character.y,
                life: 1
            });

            // Update and clean trail (0.02 per frame at 60fps = 1.2 per second)
            character.trail = character.trail.filter(point => {
                point.life -= 1.2 * deltaTime;
                return point.life > 0;
            });

            // Limit trail length
            if (character.trail.length > 30) {
                character.trail.shift();
            }
        }

        function renderSolWorld() {
            const ctx = canvases.solCtx;
            const bgCtx = canvases.solBgCtx;
            const width = solCssWidth;
            const height = solCssHeight;

            // Fix 2: Periodic full clear to prevent ghosting
            game.frameCount += 1;
            if (game.frameCount % 60 === 0) {
                ctx.clearRect(0, 0, solCssWidth, solCssHeight);
            }
            // Clear with subtle fade for motion blur
            ctx.fillStyle = 'rgba(15, 15, 35, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Apply screen shake
            ctx.save();
            ctx.translate(game.screenShake.x, game.screenShake.y);

            // Render parallax background
            bgCtx.clearRect(0, 0, width, height);
            game.parallaxLayers.sol.forEach(layer => {
                bgCtx.fillStyle = `rgba(255, 107, 53, ${layer.opacity})`;
                layer.shapes.forEach(shape => {
                    bgCtx.save();
                    bgCtx.translate(shape.x - game.sol.x * layer.speed, shape.y - game.sol.y * layer.speed);
                    bgCtx.rotate(shape.rotation + game.animTime * 0.1);
                    bgCtx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);
                    bgCtx.restore();
                });
            });

            // Draw chasm (using level-defined positions)
            const chasmX = lvl.chasm.x;
            const chasmW = lvl.chasm.width;
            const gradient = ctx.createLinearGradient(chasmX, 0, chasmX + chasmW, 0);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(chasmX, 0, chasmW, height);

            // Draw bridge with glow + stability visual feedback
            if (game.bridgeExtension > 0) {
                const bridgeWidth = chasmW * game.bridgeExtension;
                const isUnstable = game.bridgeExtension < 1 && game.windPower <= 2;

                // Wobble offset: vertical oscillation when unstable
                var wobbleY = 0;
                var bridgeOpacity = 1;
                if (isUnstable) {
                    wobbleY = Math.sin(game.animTime * 12) * 3 * (1 - game.bridgeExtension);
                    bridgeOpacity = 0.5 + Math.sin(game.animTime * 8) * 0.25 + Math.sin(game.animTime * 13) * 0.15;
                }

                ctx.save();
                ctx.globalAlpha = Math.max(0.3, bridgeOpacity);

                // Bridge glow
                const glow = ctx.createRadialGradient(
                    chasmX + bridgeWidth/2, height/2 + wobbleY, 0,
                    chasmX + bridgeWidth/2, height/2 + wobbleY, bridgeWidth/2 + 40
                );
                glow.addColorStop(0, 'rgba(255, 150, 50, 0.4)');
                glow.addColorStop(1, 'rgba(255, 107, 53, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(chasmX - 20, height/2 - 40 + wobbleY, bridgeWidth + 40, 80);

                // Bridge body
                ctx.fillStyle = 'rgba(255, 140, 60, ' + (0.6 + Math.sin(game.animTime * 5) * 0.1) + ')';
                ctx.fillRect(chasmX, height/2 - 20 + wobbleY, bridgeWidth, 40);

                // Energy lines
                ctx.strokeStyle = '#ffaa55';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(chasmX, height/2 + wobbleY);
                ctx.lineTo(chasmX + bridgeWidth, height/2 + wobbleY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Instability warning sparks
                if (isUnstable && Math.random() < 0.3) {
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                    var sparkX = chasmX + Math.random() * bridgeWidth;
                    var sparkY = height/2 + wobbleY + (Math.random() - 0.5) * 30;
                    ctx.fillRect(sparkX - 1, sparkY - 1, 2, 2);
                }

                ctx.restore();
            }

            // Draw moving platform
            if (lvl.movingPlatform) {
                const mp = lvl.movingPlatform;
                const platY = mp.y + Math.sin(game.movingPlatformOffset) * mp.range;

                // Platform glow
                const platGlow = ctx.createRadialGradient(mp.x, platY, 0, mp.x, platY, 50);
                platGlow.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
                platGlow.addColorStop(1, 'rgba(255, 150, 50, 0)');
                ctx.fillStyle = platGlow;
                ctx.fillRect(mp.x - 50, platY - 50, 100, 100);

                // Platform body
                ctx.fillStyle = `rgba(255, 170, 80, ${0.7 + Math.sin(game.animTime * 4) * 0.15})`;
                ctx.fillRect(mp.x - 30, platY - 10, 60, 20);

                // Platform edge lines
                ctx.strokeStyle = 'rgba(255, 220, 150, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(mp.x - 30, platY - 10, 60, 20);
            }

            // Draw windmill with dynamic rotation (using level-defined position)
            ctx.save();
            ctx.translate(lvl.windmill.x, lvl.windmill.y);

            // Windmill glow
            if (game.windPower > 0) {
                const glowRadius = 30 + game.windPower * 10;
                const windGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                windGlow.addColorStop(0, `rgba(255, 180, 100, ${game.windPower * 0.3})`);
                windGlow.addColorStop(1, 'rgba(255, 107, 53, 0)');
                ctx.fillStyle = windGlow;
                ctx.fillRect(-glowRadius, -glowRadius, glowRadius * 2, glowRadius * 2);
            }

            ctx.rotate(game.windmillRotation);
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.fillStyle = `rgba(255, 140, 80, ${0.8 + Math.sin(game.animTime * 3) * 0.2})`;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -40);
                ctx.lineTo(10, -40);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();

            // Draw heat plate (using level-defined position)
            const heatX = lvl.heatPlate.x;
            const heatY = lvl.heatPlate.y;

            if (game.heatPower > 0) {
                // Heat waves
                for (let i = 0; i < 3; i++) {
                    const waveRadius = 30 + i * 20 + (game.animTime * 30) % 30;
                    ctx.strokeStyle = `rgba(255, 100, 0, ${game.heatPower * (1 - i / 3) * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(heatX, heatY, waveRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            ctx.fillStyle = game.heatActive ?
                `rgba(255, 100, 0, ${0.6 + Math.sin(game.animTime * 10) * 0.2})` :
                'rgba(150, 50, 0, 0.3)';
            ctx.fillRect(heatX - 40, heatY - 30, 80, 60);

            // Heat plate label
            ctx.fillStyle = 'rgba(255, 150, 80, 0.4)';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('HEAT', heatX, heatY + 45);

            // Draw exit portal with pulsing beacon (using level-defined position)
            const exitX = lvl.exit.x;
            const exitY = lvl.exit.y;

            // Vertical light beam (beacon)
            var beamAlpha = 0.12 + Math.sin(game.animTime * 2) * 0.06;
            var beamGrad = ctx.createLinearGradient(exitX, exitY - 8, exitX, Math.max(0, exitY - 120));
            beamGrad.addColorStop(0, 'rgba(255, 150, 80, ' + beamAlpha + ')');
            beamGrad.addColorStop(0.5, 'rgba(255, 107, 53, ' + (beamAlpha * 0.5) + ')');
            beamGrad.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = beamGrad;
            var beamWidth = 8 + Math.sin(game.animTime * 3) * 2;
            ctx.fillRect(exitX - beamWidth / 2, Math.max(0, exitY - 120), beamWidth, exitY - Math.max(0, exitY - 120));

            // Wider subtle glow beam
            var beamGrad2 = ctx.createLinearGradient(exitX, exitY - 5, exitX, Math.max(0, exitY - 80));
            beamGrad2.addColorStop(0, 'rgba(255, 140, 70, ' + (beamAlpha * 0.4) + ')');
            beamGrad2.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = beamGrad2;
            ctx.fillRect(exitX - 15, Math.max(0, exitY - 80), 30, exitY - Math.max(0, exitY - 80));

            // Portal ring
            ctx.strokeStyle = `rgba(255, 107, 53, ${0.5 + Math.sin(game.animTime * 3) * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(exitX, exitY, 25, game.animTime, game.animTime + Math.PI * 1.8);
            ctx.stroke();

            // Pulsing outer ring
            var pulseRadius = 25 + Math.sin(game.animTime * 2) * 5;
            ctx.strokeStyle = 'rgba(255, 107, 53, ' + (0.15 + Math.sin(game.animTime * 2.5) * 0.1) + ')';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(exitX, exitY, pulseRadius + 5, 0, Math.PI * 2);
            ctx.stroke();

            // Sol collision flash overlay
            if (game.sol.collisionFlash > 0) {
                ctx.fillStyle = `rgba(255, 50, 50, ${game.sol.collisionFlash * 0.3})`;
                ctx.fillRect(0, 0, width, height);
            }

            // Draw Sol's burning trail (speed-based color gradient)
            ctx.lineCap = 'round';
            var solSpeedNow = Math.hypot(game.sol.vx, game.sol.vy);
            var solSpeedNorm = Math.min(1, solSpeedNow / 8); // 0=slow, 1=fast
            game.sol.trail.forEach((point, index) => {
                if (index === 0) return;
                const prev = game.sol.trail[index - 1];

                // Slow: dim orange. Fast: bright orange->white gradient shift
                var r1 = 255, g1 = Math.floor(100 + solSpeedNorm * 155), b1 = Math.floor(0 + solSpeedNorm * 200);
                var r2 = 255, g2 = Math.floor(80 + solSpeedNorm * 120), b2 = Math.floor(0 + solSpeedNorm * 50);
                var alphaBoost = 0.3 + solSpeedNorm * 0.5;

                const trailGrad = ctx.createLinearGradient(prev.x, prev.y, point.x, point.y);
                trailGrad.addColorStop(0, 'rgba(' + r1 + ',' + g1 + ',' + b1 + ',' + (prev.life * alphaBoost) + ')');
                trailGrad.addColorStop(1, 'rgba(' + r2 + ',' + g2 + ',' + b2 + ',' + (point.life * (alphaBoost * 0.7)) + ')');

                ctx.strokeStyle = trailGrad;
                ctx.lineWidth = point.life * (6 + solSpeedNorm * 6);
                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            });

            // Draw Sol with squash/stretch
            ctx.save();
            ctx.translate(game.sol.x, game.sol.y);
            ctx.scale(game.sol.scaleX, game.sol.scaleY);

            // Sol glow
            const solGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, game.sol.radius * 2);
            solGlow.addColorStop(0, '#ffdd00');
            solGlow.addColorStop(0.5, '#ff9900');
            solGlow.addColorStop(1, 'rgba(255, 107, 53, 0.3)');

            ctx.fillStyle = solGlow;
            ctx.beginPath();
            ctx.arc(0, 0, game.sol.radius, 0, Math.PI * 2);
            ctx.fill();

            // Sol core
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, game.sol.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Draw gravity wells as spinning vortices (Sol's world)
            if (lvl.gravityWells) {
                lvl.gravityWells.forEach(function(gw) {
                    ctx.save();
                    ctx.translate(gw.x, gw.y);

                    // Dark radial gradient background
                    var vortexGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, gw.radius);
                    vortexGrad.addColorStop(0, 'rgba(20, 0, 40, 0.7)');
                    vortexGrad.addColorStop(0.4, 'rgba(40, 0, 60, 0.3)');
                    vortexGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = vortexGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, gw.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Spinning spiral arms
                    ctx.strokeStyle = 'rgba(100, 50, 150, 0.4)';
                    ctx.lineWidth = 2;
                    for (var arm = 0; arm < 3; arm++) {
                        ctx.beginPath();
                        var baseAngle = game.gravityWellRotation + (arm * Math.PI * 2 / 3);
                        for (var t = 0; t < 1; t += 0.05) {
                            var angle = baseAngle + t * Math.PI * 2;
                            var r = t * gw.radius * 0.8;
                            var px = Math.cos(angle) * r;
                            var py = Math.sin(angle) * r;
                            if (t === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }

                    // Center dark point
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            // Draw Sol's idle particles (embers)
            game.solIdleParticles.forEach(function(p) {
                ctx.save();
                ctx.globalAlpha = p.life * 0.7;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Draw ambient Sol particles (falling embers)
            game.ambientSolParticles.forEach(function(p) {
                ctx.save();
                ctx.globalAlpha = p.life * 0.35;
                var hsl = 'hsl(' + p.hue + ', 90%, ' + (50 + Math.sin(p.flicker * 3) * 15) + '%)';
                ctx.fillStyle = hsl;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Draw dimensional tears in Sol's world
            game.dimensionalTears.forEach(tear => {
                ctx.save();
                ctx.globalAlpha = tear.life;

                const tearGradient = ctx.createRadialGradient(
                    tear.x, tear.y / 2, 0,
                    tear.x, tear.y / 2, tear.size
                );
                tearGradient.addColorStop(0, '#ff00ff');
                tearGradient.addColorStop(0.5, '#9966ff');
                tearGradient.addColorStop(1, 'rgba(153, 102, 255, 0)');

                ctx.fillStyle = tearGradient;
                ctx.fillRect(tear.x - tear.size, tear.y / 2 - tear.size, tear.size * 2, tear.size * 2);
                ctx.restore();
            });

            ctx.restore();
        }

        function renderLunaWorld() {
            const ctx = canvases.lunaCtx;
            const bgCtx = canvases.lunaBgCtx;
            const width = lunaCssWidth;
            const height = lunaCssHeight;

            // Fix 2: Periodic full clear to prevent ghosting
            game.frameCountLuna += 1;
            if (game.frameCountLuna % 60 === 0) {
                ctx.clearRect(0, 0, lunaCssWidth, lunaCssHeight);
            }
            // Clear with fade
            ctx.fillStyle = 'rgba(15, 30, 50, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Apply screen shake
            ctx.save();
            ctx.translate(game.screenShake.x, game.screenShake.y);

            // Render parallax background
            bgCtx.clearRect(0, 0, width, height);
            game.parallaxLayers.luna.forEach(layer => {
                bgCtx.fillStyle = `rgba(74, 158, 218, ${layer.opacity})`;
                layer.shapes.forEach(shape => {
                    bgCtx.save();
                    bgCtx.translate(shape.x - game.luna.x * layer.speed, shape.y - game.luna.y * layer.speed);
                    bgCtx.rotate(-shape.rotation - game.animTime * 0.05);
                    bgCtx.beginPath();
                    bgCtx.arc(0, 0, shape.size, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.restore();
                });
            });

            // Draw frost patterns
            game.luna.frostPatterns.forEach(frost => {
                ctx.save();
                ctx.globalAlpha = frost.life * 0.3;

                const frostGradient = ctx.createRadialGradient(
                    frost.x, frost.y, 0,
                    frost.x, frost.y, frost.size * frost.growth
                );
                frostGradient.addColorStop(0, 'rgba(200, 230, 255, 0.5)');
                frostGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.3)');
                frostGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');

                ctx.fillStyle = frostGradient;
                ctx.beginPath();
                ctx.arc(frost.x, frost.y, frost.size * frost.growth, 0, Math.PI * 2);
                ctx.fill();

                // Draw crystalline structure
                ctx.strokeStyle = `rgba(200, 230, 255, ${frost.life * 0.5})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i;
                    ctx.beginPath();
                    ctx.moveTo(frost.x, frost.y);
                    ctx.lineTo(
                        frost.x + Math.cos(angle) * frost.size * frost.growth,
                        frost.y + Math.sin(angle) * frost.size * frost.growth
                    );
                    ctx.stroke();
                }

                ctx.restore();
            });

            // Draw ice wall (using level-defined position)
            if (game.iceAlpha > 0) {
                const iceX = lvl.iceWall.x;
                const iceW = lvl.iceWall.width;

                ctx.save();
                ctx.globalAlpha = game.iceAlpha;

                // Ice gradient
                const iceGradient = ctx.createLinearGradient(iceX, 0, iceX + iceW, 0);
                iceGradient.addColorStop(0, 'rgba(150, 200, 255, 0.6)');
                iceGradient.addColorStop(0.5, 'rgba(180, 220, 255, 0.8)');
                iceGradient.addColorStop(1, 'rgba(150, 200, 255, 0.6)');
                ctx.fillStyle = iceGradient;
                ctx.fillRect(iceX, 0, iceW, height);

                // Ice cracks when melting
                if (game.iceAlpha < 0.8) {
                    // Generate crack positions once and store them
                    if (game.iceCracks.length === 0) {
                        for (let i = 0; i < 5; i++) {
                            game.iceCracks.push({
                                x1: Math.random() * iceW,
                                y1: Math.random() * height,
                                x2: Math.random() * iceW,
                                y2: Math.random() * height
                            });
                        }
                    }
                    ctx.strokeStyle = `rgba(50, 100, 150, ${1 - game.iceAlpha})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < game.iceCracks.length; i++) {
                        const crack = game.iceCracks[i];
                        ctx.beginPath();
                        ctx.moveTo(iceX + crack.x1, crack.y1);
                        ctx.lineTo(iceX + crack.x2, crack.y2);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            // Draw visible wind particles
            game.windParticles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life * 0.6;

                // Wind streak
                const windGradient = ctx.createLinearGradient(
                    p.x - p.vx * 5, p.y - p.vy * 5,
                    p.x, p.y
                );
                windGradient.addColorStop(0, 'rgba(100, 200, 255, 0)');
                windGradient.addColorStop(1, 'rgba(150, 220, 255, 0.8)');

                ctx.strokeStyle = windGradient;
                ctx.lineWidth = p.size;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p.x - p.vx * 10, p.y - p.vy * 10);
                ctx.lineTo(p.x, p.y);
                ctx.stroke();

                ctx.restore();
            });

            // Draw exit portal with pulsing beacon (Luna world)
            const exitX = lvl.exit.x;
            const exitY = lvl.exit.y;

            // Vertical light beam (beacon) - upward from portal
            var lunaBeamAlpha = 0.12 + Math.sin(game.animTime * 2 + Math.PI) * 0.06;
            var lunaBeamGrad = ctx.createLinearGradient(exitX, exitY - 8, exitX, Math.max(0, exitY - 120));
            lunaBeamGrad.addColorStop(0, 'rgba(100, 180, 255, ' + lunaBeamAlpha + ')');
            lunaBeamGrad.addColorStop(0.5, 'rgba(74, 158, 218, ' + (lunaBeamAlpha * 0.5) + ')');
            lunaBeamGrad.addColorStop(1, 'rgba(74, 158, 218, 0)');
            ctx.fillStyle = lunaBeamGrad;
            var lunaBeamW = 8 + Math.sin(game.animTime * 3 + Math.PI) * 2;
            ctx.fillRect(exitX - lunaBeamW / 2, Math.max(0, exitY - 120), lunaBeamW, exitY - Math.max(0, exitY - 120));

            // Wider subtle glow beam
            var lunaBeamGrad2 = ctx.createLinearGradient(exitX, exitY - 5, exitX, Math.max(0, exitY - 80));
            lunaBeamGrad2.addColorStop(0, 'rgba(100, 180, 255, ' + (lunaBeamAlpha * 0.4) + ')');
            lunaBeamGrad2.addColorStop(1, 'rgba(74, 158, 218, 0)');
            ctx.fillStyle = lunaBeamGrad2;
            ctx.fillRect(exitX - 15, Math.max(0, exitY - 80), 30, exitY - Math.max(0, exitY - 80));

            // Portal ring
            ctx.strokeStyle = `rgba(74, 158, 218, ${0.5 + Math.sin(game.animTime * 3 + Math.PI) * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(exitX, exitY, 25, -game.animTime, -game.animTime + Math.PI * 1.8);
            ctx.stroke();

            // Pulsing outer ring
            var lunaPulseR = 25 + Math.sin(game.animTime * 2 + Math.PI) * 5;
            ctx.strokeStyle = 'rgba(74, 158, 218, ' + (0.15 + Math.sin(game.animTime * 2.5 + Math.PI) * 0.1) + ')';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(exitX, exitY, lunaPulseR + 5, 0, Math.PI * 2);
            ctx.stroke();

            // Luna collision flash overlay
            if (game.luna.collisionFlash > 0) {
                ctx.fillStyle = `rgba(100, 150, 255, ${game.luna.collisionFlash * 0.3})`;
                ctx.fillRect(0, 0, width, height);
            }

            // Draw Luna's frost trail (speed-based color gradient)
            ctx.lineCap = 'round';
            var lunaSpeedNow = Math.hypot(game.luna.vx, game.luna.vy);
            var lunaSpeedNorm = Math.min(1, lunaSpeedNow / 8);
            game.luna.trail.forEach((point, index) => {
                if (index === 0) return;
                const prev = game.luna.trail[index - 1];

                // Slow: dim blue. Fast: bright blue->cyan shift
                var r1 = Math.floor(100 + lunaSpeedNorm * 50), g1 = Math.floor(180 + lunaSpeedNorm * 75), b1 = 255;
                var r2 = Math.floor(0 + lunaSpeedNorm * 100), g2 = Math.floor(200 + lunaSpeedNorm * 55), b2 = 255;
                var alphaBoost = 0.2 + lunaSpeedNorm * 0.5;

                const trailGrad = ctx.createLinearGradient(prev.x, prev.y, point.x, point.y);
                trailGrad.addColorStop(0, 'rgba(' + r1 + ',' + g1 + ',' + b1 + ',' + (prev.life * alphaBoost) + ')');
                trailGrad.addColorStop(1, 'rgba(' + r2 + ',' + g2 + ',' + b2 + ',' + (point.life * (alphaBoost * 0.7)) + ')');

                ctx.strokeStyle = trailGrad;
                ctx.lineWidth = point.life * (5 + lunaSpeedNorm * 5);
                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            });

            // Draw Luna with squash/stretch
            ctx.save();
            ctx.translate(game.luna.x, game.luna.y);
            ctx.scale(game.luna.scaleX, game.luna.scaleY);

            // Luna glow (changes when attracted)
            const lunaGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, game.luna.radius * 2);
            if (input.lunaTouch.active) {
                lunaGlow.addColorStop(0, '#ffffff');
                lunaGlow.addColorStop(0.3, '#00ffff');
                lunaGlow.addColorStop(0.6, '#0099ff');
                lunaGlow.addColorStop(1, 'rgba(0, 150, 255, 0.3)');
            } else {
                lunaGlow.addColorStop(0, '#aaddff');
                lunaGlow.addColorStop(0.5, '#66aaff');
                lunaGlow.addColorStop(1, 'rgba(74, 158, 218, 0.3)');
            }

            ctx.fillStyle = lunaGlow;
            ctx.beginPath();
            ctx.arc(0, 0, game.luna.radius, 0, Math.PI * 2);
            ctx.fill();

            // Luna core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, 0, game.luna.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Draw touch indicator
            if (input.lunaTouch.active) {
                ctx.save();
                ctx.globalAlpha = 0.5;

                const touchGradient = ctx.createRadialGradient(
                    input.lunaTouch.x, input.lunaTouch.y, 0,
                    input.lunaTouch.x, input.lunaTouch.y, 40
                );
                touchGradient.addColorStop(0, 'rgba(0, 200, 255, 0.5)');
                touchGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');

                ctx.fillStyle = touchGradient;
                ctx.beginPath();
                ctx.arc(input.lunaTouch.x, input.lunaTouch.y, 40, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // Draw gravity wells as spinning vortices (Luna's world)
            if (lvl.gravityWells) {
                lvl.gravityWells.forEach(function(gw) {
                    ctx.save();
                    ctx.translate(gw.x, gw.y);

                    // Dark radial gradient background
                    var vortexGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, gw.radius);
                    vortexGrad.addColorStop(0, 'rgba(0, 10, 40, 0.7)');
                    vortexGrad.addColorStop(0.4, 'rgba(0, 20, 60, 0.3)');
                    vortexGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = vortexGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, gw.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Spinning spiral arms (blue tint for Luna's world)
                    ctx.strokeStyle = 'rgba(50, 80, 180, 0.4)';
                    ctx.lineWidth = 2;
                    for (var arm = 0; arm < 3; arm++) {
                        ctx.beginPath();
                        var baseAngle = -game.gravityWellRotation + (arm * Math.PI * 2 / 3);
                        for (var t = 0; t < 1; t += 0.05) {
                            var angle = baseAngle + t * Math.PI * 2;
                            var r = t * gw.radius * 0.8;
                            var px = Math.cos(angle) * r;
                            var py = Math.sin(angle) * r;
                            if (t === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }

                    // Center dark point
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            // Draw Luna's idle particles (snowflakes)
            game.lunaIdleParticles.forEach(function(p) {
                ctx.save();
                ctx.globalAlpha = p.life * 0.6;
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.strokeStyle = '#aaddff';
                ctx.lineWidth = 1;
                // Simple snowflake: 6 lines from center
                for (var i = 0; i < 6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    var sx = Math.cos(i * Math.PI / 3) * p.size;
                    var sy = Math.sin(i * Math.PI / 3) * p.size;
                    ctx.lineTo(sx, sy);
                    ctx.stroke();
                }
                ctx.restore();
            });

            // Draw ambient Luna particles (rising ice crystals)
            game.ambientLunaParticles.forEach(function(p) {
                ctx.save();
                ctx.globalAlpha = p.life * 0.3;
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                // Small diamond shape
                ctx.fillStyle = 'rgba(150, 200, 255, 0.6)';
                ctx.beginPath();
                ctx.moveTo(0, -p.size);
                ctx.lineTo(p.size * 0.5, 0);
                ctx.lineTo(0, p.size);
                ctx.lineTo(-p.size * 0.5, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });

            // Draw dimensional tears in Luna's world
            game.dimensionalTears.forEach(tear => {
                ctx.save();
                ctx.globalAlpha = tear.life;

                const tearGradient = ctx.createRadialGradient(
                    tear.x, height - tear.y / 2, 0,
                    tear.x, height - tear.y / 2, tear.size
                );
                tearGradient.addColorStop(0, '#ff00ff');
                tearGradient.addColorStop(0.5, '#9966ff');
                tearGradient.addColorStop(1, 'rgba(153, 102, 255, 0)');

                ctx.fillStyle = tearGradient;
                ctx.fillRect(tear.x - tear.size, height - tear.y / 2 - tear.size, tear.size * 2, tear.size * 2);
                ctx.restore();
            });

            ctx.restore();
        }

        function nextLevel() {
            document.getElementById('levelComplete').classList.remove('show');
            const nextIdx = game.currentLevel + 1;
            if (nextIdx >= levelDefs.length) {
                loadLevel(0); // Loop back
            } else {
                loadLevel(nextIdx);
            }
            // Tutorial only on first level, first playthrough
        }

        // Fix 6: addEventListener for buttons (in addition to existing onclick)
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('continueButton').addEventListener('click', nextLevel);
        document.getElementById('muteButton').addEventListener('click', toggleMute);
        document.getElementById('resetButton').addEventListener('click', resetCurrentLevel);
        document.getElementById('levelSelectButton').addEventListener('click', showLevelSelect);
        document.getElementById('levelSelectBack').addEventListener('click', closeLevelSelect);

        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.033); // Cap at 30fps minimum
            lastTime = currentTime;

            update(deltaTime);
            renderSolWorld();
            renderLunaWorld();

            requestAnimationFrame(gameLoop);
        }

        // Prevent scrolling
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        // Fix 3: Removed duplicate resize listener (kept the one in setupControls)
    </script>
</body>
</html>
