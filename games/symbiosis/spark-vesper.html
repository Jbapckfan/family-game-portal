<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Spark & Vesper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            overscroll-behavior: none;
        }
        
        body {
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100vw;
            height: 100vh;
        }
        
        #game {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .world {
            position: relative;
            width: 100%;
            height: 50%;
            overflow: hidden;
        }
        
        #sparkWorld {
            background: linear-gradient(180deg, #1a0820 0%, #2d1b3d 100%);
            border-bottom: 2px solid rgba(255, 215, 0, 0.2);
        }
        
        #vesperWorld {
            background: linear-gradient(180deg, #0f0f3a 0%, #1a1a4a 100%);
            border-top: 2px solid rgba(147, 112, 219, 0.2);
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .meter {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .meter-fill {
            height: 100%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        #sparkMeter .meter-fill {
            background: linear-gradient(90deg, #FFD700, #FFA500);
            box-shadow: 0 0 10px #FFD700;
        }
        
        #vesperMeter .meter-fill {
            background: linear-gradient(90deg, #9370DB, #6B46C1);
            box-shadow: 0 0 10px #9370DB;
        }
        
        .meter-label {
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a0820 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        h1 {
            font-size: 56px;
            font-weight: 200;
            letter-spacing: 10px;
            margin-bottom: 20px;
        }
        
        .spark-title {
            background: linear-gradient(135deg, #FFD700, #FF6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .vesper-title {
            background: linear-gradient(135deg, #9370DB, #4B0082);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #startBtn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #FFD700, #9370DB);
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 16px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        #startBtn:active {
            transform: scale(0.95);
        }
        
        #divider {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,215,0,0.5) 30%, 
                rgba(147,112,219,0.5) 70%, 
                transparent);
            transform: translateY(-1px);
            z-index: 100;
            transition: all 0.3s;
        }
        
        #divider.resonating {
            height: 4px;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            background: linear-gradient(90deg, 
                transparent, 
                #FFD700 30%, 
                #9370DB 70%, 
                transparent);
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>
            <span class="spark-title">SPARK</span>
            &
            <span class="vesper-title">VESPER</span>
        </h1>
        <p style="color: rgba(255,255,255,0.5); margin-bottom: 30px;">Two souls • Two dimensions • One destiny</p>
        <button id="startBtn">BEGIN JOURNEY</button>
    </div>
    
    <div id="game">
        <div id="sparkWorld" class="world">
            <canvas id="sparkCanvas"></canvas>
            <div class="meter" id="sparkMeter">
                <div class="meter-label">Surge</div>
                <div class="meter-fill" style="width: 0%"></div>
            </div>
        </div>
        
        <div id="divider"></div>
        
        <div id="vesperWorld" class="world">
            <canvas id="vesperCanvas"></canvas>
            <div class="meter" id="vesperMeter">
                <div class="meter-label">Flow</div>
                <div class="meter-fill" style="width: 0%"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Game State
        const game = {
            spark: {
                x: 100, y: 100,
                vx: 0, vy: 0,
                radius: 18,
                charge: 0,
                surgeActive: false,
                trail: []
            },
            vesper: {
                x: 100, y: 100,
                vx: 0, vy: 0,
                radius: 18,
                flow: 0,
                inFlow: false,
                trail: [],
                targetX: 100,
                targetY: 100
            },
            particles: [],
            proximityPower: 0,
            started: false,
            time: 0
        };
        
        // Canvas setup
        let sparkCanvas, vesperCanvas, sparkCtx, vesperCtx;
        let width, height;
        
        // Particle System
        class Particle {
            constructor(x, y, type, config = {}) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.vx = config.vx || (Math.random() - 0.5) * 2;
                this.vy = config.vy || (Math.random() - 0.5) * 2;
                this.life = config.life || 1;
                this.maxLife = this.life;
                this.size = config.size || 3;
                this.color = config.color || '#FFFFFF';
            }
            
            update(dt) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= dt * 2;
                
                if (this.type === 'electric') {
                    // Jittery electric movement
                    this.vx += (Math.random() - 0.5) * 0.5;
                    this.vy -= 0.5; // Rise
                } else if (this.type === 'mist') {
                    // Swirling mist
                    const swirl = this.life * 3;
                    this.vx += Math.cos(swirl) * 0.1;
                    this.vy += Math.sin(swirl) * 0.1;
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                }
                
                return this.life > 0;
            }
            
            render(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                
                if (this.type === 'electric') {
                    // Electric spark
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size
                    );
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.5, this.color);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                    
                    // Random lightning line
                    if (Math.random() < 0.1) {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x + Math.random() * 20 - 10, this.y + Math.random() * 20 - 10);
                        ctx.stroke();
                    }
                } else if (this.type === 'mist') {
                    // Flowing mist
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size * 2
                    );
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        function init() {
            sparkCanvas = document.getElementById('sparkCanvas');
            vesperCanvas = document.getElementById('vesperCanvas');
            sparkCtx = sparkCanvas.getContext('2d');
            vesperCtx = vesperCanvas.getContext('2d');
            
            resize();
            window.addEventListener('resize', resize);
            
            // Controls
            sparkCanvas.addEventListener('touchstart', handleSparkTouch, {passive: false});
            sparkCanvas.addEventListener('touchmove', handleSparkTouch, {passive: false});
            sparkCanvas.addEventListener('mousedown', handleSparkTouch);
            sparkCanvas.addEventListener('mousemove', handleSparkMove);
            
            vesperCanvas.addEventListener('touchstart', handleVesperTouch, {passive: false});
            vesperCanvas.addEventListener('touchmove', handleVesperTouch, {passive: false});
            vesperCanvas.addEventListener('mousedown', handleVesperTouch);
            vesperCanvas.addEventListener('mousemove', handleVesperMove);
            
            document.getElementById('startBtn').addEventListener('click', startGame);
        }
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight / 2;
            sparkCanvas.width = width;
            sparkCanvas.height = height;
            vesperCanvas.width = width;
            vesperCanvas.height = height;
        }
        
        let sparkDragging = false;
        function handleSparkTouch(e) {
            e.preventDefault();
            sparkDragging = true;
            const rect = sparkCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = (touch.clientX - rect.left) * (width / rect.width);
            const y = (touch.clientY - rect.top) * (height / rect.height);
            
            // Direct control for Spark
            game.spark.x = x;
            game.spark.y = y;
        }
        
        function handleSparkMove(e) {
            if (!sparkDragging && e.type === 'mousemove') return;
            handleSparkTouch(e);
        }
        
        function handleVesperTouch(e) {
            e.preventDefault();
            const rect = vesperCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            game.vesper.targetX = (touch.clientX - rect.left) * (width / rect.width);
            game.vesper.targetY = (touch.clientY - rect.top) * (height / rect.height);
        }
        
        function handleVesperMove(e) {
            if (e.buttons === 0 && e.type === 'mousemove') return;
            handleVesperTouch(e);
        }
        
        window.addEventListener('mouseup', () => sparkDragging = false);
        window.addEventListener('touchend', () => sparkDragging = false);
        
        function startGame() {
            document.getElementById('startScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('startScreen').style.display = 'none';
            }, 500);
            game.started = true;
            requestAnimationFrame(gameLoop);
        }
        
        function update(dt) {
            if (!game.started) return;
            
            game.time += dt;
            
            // Update Spark physics
            const prevSparkX = game.spark.x;
            const prevSparkY = game.spark.y;
            
            // Calculate velocity from position change
            game.spark.vx = game.spark.x - prevSparkX;
            game.spark.vy = game.spark.y - prevSparkY;
            
            // Build charge through movement
            const sparkSpeed = Math.sqrt(game.spark.vx * game.spark.vx + game.spark.vy * game.spark.vy);
            game.spark.charge = Math.min(100, game.spark.charge + sparkSpeed * 0.5);
            game.spark.charge *= 0.98; // Decay
            
            // Update Vesper with magnetic attraction
            const dx = game.vesper.targetX - game.vesper.x;
            const dy = game.vesper.targetY - game.vesper.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 5) {
                const force = Math.min(1, dist / 100) * 0.4;
                game.vesper.vx += (dx / dist) * force;
                game.vesper.vy += (dy / dist) * force;
            }
            
            game.vesper.vx *= 0.92; // Friction
            game.vesper.vy *= 0.92;
            
            game.vesper.x += game.vesper.vx;
            game.vesper.y += game.vesper.vy;
            
            // Build flow through smooth movement
            const vesperSpeed = Math.sqrt(game.vesper.vx * game.vesper.vx + game.vesper.vy * game.vesper.vy);
            if (vesperSpeed > 2) {
                game.vesper.flow = Math.min(100, game.vesper.flow + 1);
            } else {
                game.vesper.flow *= 0.95;
            }
            
            // Keep in bounds
            game.spark.x = Math.max(game.spark.radius, Math.min(width - game.spark.radius, game.spark.x));
            game.spark.y = Math.max(game.spark.radius, Math.min(height - game.spark.radius, game.spark.y));
            game.vesper.x = Math.max(game.vesper.radius, Math.min(width - game.vesper.radius, game.vesper.x));
            game.vesper.y = Math.max(game.vesper.radius, Math.min(height - game.vesper.radius, game.vesper.y));
            
            // Update trails
            updateTrail(game.spark, sparkSpeed);
            updateTrail(game.vesper, vesperSpeed);
            
            // Calculate proximity
            const proxDist = Math.abs(game.spark.x - game.vesper.x) + Math.abs(game.spark.y - game.vesper.y);
            game.proximityPower = Math.max(0, 1 - proxDist / 200);
            
            // Update divider glow based on proximity
            const divider = document.getElementById('divider');
            if (game.proximityPower > 0.5) {
                divider.classList.add('resonating');
            } else {
                divider.classList.remove('resonating');
            }
            
            // Spawn particles
            if (game.spark.charge > 20 && Math.random() < 0.3) {
                game.particles.push(new Particle(
                    game.spark.x + (Math.random() - 0.5) * 20,
                    game.spark.y + (Math.random() - 0.5) * 20,
                    'electric',
                    { color: '#FFD700', size: 2 + Math.random() * 2 }
                ));
            }
            
            if (game.vesper.flow > 20 && Math.random() < 0.3) {
                game.particles.push(new Particle(
                    game.vesper.x + (Math.random() - 0.5) * 20,
                    game.vesper.y + (Math.random() - 0.5) * 20,
                    'mist',
                    { color: '#9370DB', size: 3 + Math.random() * 3 }
                ));
            }
            
            // Update particles
            game.particles = game.particles.filter(p => p.update(dt));
            
            // Limit particles for performance
            if (game.particles.length > 200) {
                game.particles = game.particles.slice(-200);
            }
            
            // Update meters
            document.querySelector('#sparkMeter .meter-fill').style.width = game.spark.charge + '%';
            document.querySelector('#vesperMeter .meter-fill').style.width = game.vesper.flow + '%';
        }
        
        function updateTrail(character, speed) {
            if (speed > 0.5) {
                character.trail.push({
                    x: character.x,
                    y: character.y,
                    life: 1
                });
            }
            
            character.trail = character.trail.filter(point => {
                point.life -= 0.05;
                return point.life > 0;
            });
            
            if (character.trail.length > 20) {
                character.trail.shift();
            }
        }
        
        function renderSparkWorld() {
            // Subtle fade for motion blur
            sparkCtx.fillStyle = 'rgba(26, 8, 32, 0.1)';
            sparkCtx.fillRect(0, 0, width, height);
            
            // Render Spark's trail
            sparkCtx.lineCap = 'round';
            game.spark.trail.forEach((point, i) => {
                if (i === 0) return;
                const prev = game.spark.trail[i - 1];
                
                sparkCtx.strokeStyle = `rgba(255, 215, 0, ${point.life * 0.5})`;
                sparkCtx.lineWidth = point.life * 6;
                sparkCtx.beginPath();
                sparkCtx.moveTo(prev.x, prev.y);
                sparkCtx.lineTo(point.x, point.y);
                sparkCtx.stroke();
            });
            
            // Render electric particles
            game.particles.forEach(p => {
                if (p.type === 'electric') {
                    p.render(sparkCtx);
                }
            });
            
            // Render Spark with surge effect
            const surgeScale = 1 + (game.spark.charge / 100) * 0.3;
            
            // Outer glow
            const outerGlow = sparkCtx.createRadialGradient(
                game.spark.x, game.spark.y, 0,
                game.spark.x, game.spark.y, game.spark.radius * 2 * surgeScale
            );
            outerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            outerGlow.addColorStop(0.3, 'rgba(255, 215, 0, 0.6)');
            outerGlow.addColorStop(0.6, 'rgba(255, 140, 0, 0.3)');
            outerGlow.addColorStop(1, 'transparent');
            
            sparkCtx.fillStyle = outerGlow;
            sparkCtx.beginPath();
            sparkCtx.arc(game.spark.x, game.spark.y, game.spark.radius * 2 * surgeScale, 0, Math.PI * 2);
            sparkCtx.fill();
            
            // Core
            sparkCtx.fillStyle = '#FFFFFF';
            sparkCtx.beginPath();
            sparkCtx.arc(game.spark.x, game.spark.y, game.spark.radius * 0.5, 0, Math.PI * 2);
            sparkCtx.fill();
            
            // Electric arcs when charged
            if (game.spark.charge > 50) {
                sparkCtx.strokeStyle = `rgba(255, 215, 0, ${game.spark.charge / 200})`;
                sparkCtx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const angle = (game.time * 2 + i * 2) % (Math.PI * 2);
                    const reach = game.spark.radius * 3;
                    sparkCtx.beginPath();
                    sparkCtx.moveTo(game.spark.x, game.spark.y);
                    const endX = game.spark.x + Math.cos(angle) * reach;
                    const endY = game.spark.y + Math.sin(angle) * reach;
                    
                    // Lightning path
                    const steps = 5;
                    for (let j = 0; j < steps; j++) {
                        const t = (j + 1) / steps;
                        const x = game.spark.x + (endX - game.spark.x) * t + (Math.random() - 0.5) * 10;
                        const y = game.spark.y + (endY - game.spark.y) * t + (Math.random() - 0.5) * 10;
                        sparkCtx.lineTo(x, y);
                    }
                    sparkCtx.stroke();
                }
            }
        }
        
        function renderVesperWorld() {
            // Subtle fade
            vesperCtx.fillStyle = 'rgba(15, 15, 58, 0.1)';
            vesperCtx.fillRect(0, 0, width, height);
            
            // Render Vesper's trail
            vesperCtx.lineCap = 'round';
            game.vesper.trail.forEach((point, i) => {
                if (i === 0) return;
                const prev = game.vesper.trail[i - 1];
                
                vesperCtx.strokeStyle = `rgba(147, 112, 219, ${point.life * 0.3})`;
                vesperCtx.lineWidth = point.life * 8;
                vesperCtx.beginPath();
                vesperCtx.moveTo(prev.x, prev.y);
                vesperCtx.lineTo(point.x, point.y);
                vesperCtx.stroke();
            });
            
            // Render mist particles
            game.particles.forEach(p => {
                if (p.type === 'mist') {
                    p.render(vesperCtx);
                }
            });
            
            // Render touch target if active
            if (Math.abs(game.vesper.targetX - game.vesper.x) > 5) {
                const targetGlow = vesperCtx.createRadialGradient(
                    game.vesper.targetX, game.vesper.targetY, 0,
                    game.vesper.targetX, game.vesper.targetY, 30
                );
                targetGlow.addColorStop(0, 'rgba(147, 112, 219, 0.3)');
                targetGlow.addColorStop(1, 'transparent');
                vesperCtx.fillStyle = targetGlow;
                vesperCtx.beginPath();
                vesperCtx.arc(game.vesper.targetX, game.vesper.targetY, 30, 0, Math.PI * 2);
                vesperCtx.fill();
            }
            
            // Render Vesper with flow effect
            const flowAlpha = game.vesper.flow > 50 ? 0.7 : 1;
            
            // Outer mist
            if (game.vesper.flow > 30) {
                const mistGlow = vesperCtx.createRadialGradient(
                    game.vesper.x, game.vesper.y, game.vesper.radius,
                    game.vesper.x, game.vesper.y, game.vesper.radius * 3
                );
                mistGlow.addColorStop(0, 'transparent');
                mistGlow.addColorStop(0.5, `rgba(147, 112, 219, ${game.vesper.flow / 200})`);
                mistGlow.addColorStop(1, 'transparent');
                
                vesperCtx.fillStyle = mistGlow;
                vesperCtx.beginPath();
                vesperCtx.arc(game.vesper.x, game.vesper.y, game.vesper.radius * 3, 0, Math.PI * 2);
                vesperCtx.fill();
            }
            
            // Main body
            vesperCtx.globalAlpha = flowAlpha;
            const vesperGlow = vesperCtx.createRadialGradient(
                game.vesper.x, game.vesper.y, 0,
                game.vesper.x, game.vesper.y, game.vesper.radius * 2
            );
            vesperGlow.addColorStop(0, '#FFFFFF');
            vesperGlow.addColorStop(0.3, '#9370DB');
            vesperGlow.addColorStop(0.7, '#6B46C1');
            vesperGlow.addColorStop(1, 'transparent');
            
            vesperCtx.fillStyle = vesperGlow;
            vesperCtx.beginPath();
            vesperCtx.arc(game.vesper.x, game.vesper.y, game.vesper.radius * 1.5, 0, Math.PI * 2);
            vesperCtx.fill();
            vesperCtx.globalAlpha = 1;
            
            // Core
            vesperCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            vesperCtx.beginPath();
            vesperCtx.arc(game.vesper.x, game.vesper.y, game.vesper.radius * 0.3, 0, Math.PI * 2);
            vesperCtx.fill();
        }
        
        let lastTime = 0;
        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.033);
            lastTime = currentTime;
            
            update(dt);
            renderSparkWorld();
            renderVesperWorld();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Prevent scrolling
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        
        // Initialize
        init();
    </script>
</body>
</html>