<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>Ultra Premium Tower Defense - v2</title>

    <!-- ENHANCEMENT SYSTEMS -->
    <script src="flawless_placement_system.js"></script>
    <script src="critical_gameplay_fix.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: white;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            margin: 0;
            padding: 0;
            /* iOS specific */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            /* Handle safe areas on iOS */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #0a0a2e 0%, #000511 50%, #1a0033 100%);
            /* Prevent bounce scrolling on iOS */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }
        
        #ui {
            background: linear-gradient(135deg, rgba(20,20,60,0.95) 0%, rgba(40,20,80,0.95) 50%, rgba(60,10,90,0.95) 100%);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8), inset 0 -2px 10px rgba(255,20,147,0.3);
            border-bottom: 2px solid;
            border-image: linear-gradient(90deg, #8a2be2, #ff1493, #00ffff) 1;
            flex-wrap: wrap;
            gap: 15px;
            min-height: 70px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        #ui::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: uiShine 8s linear infinite;
        }
        
        @keyframes uiShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        #gameCanvas {
            flex: 1;
            background: #000;
            cursor: crosshair;
            image-rendering: crisp-edges;
            /* iOS specific */
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, rgba(0,0,0,0.6) 0%, rgba(50,0,100,0.4) 100%);
            padding: 10px 20px;
            border-radius: 30px;
            border: 2px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .stat::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .stat:hover::after {
            opacity: 1;
        }
        
        .stat:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 20, 147, 0.6);
        }
        
        .icon {
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, #ff1493 0%, #8a2be2 50%, #00ffff 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8), inset 0 -2px 5px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
            position: relative;
        }
        
        .icon::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, #ff1493, #8a2be2, #00ffff);
            border-radius: 50%;
            opacity: 0.5;
            filter: blur(5px);
            animation: iconGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes iconGlow {
            0% { opacity: 0.3; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(1.1); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(138, 43, 226, 0.8); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(255, 20, 147, 1); }
        }
        
        button {
            background: linear-gradient(135deg, #8a2be2 0%, #ff1493 100%);
            color: white;
            border: 2px solid transparent;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6), inset 0 -2px 10px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            /* iOS specific */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        
        button:hover::before {
            animation: shine 0.5s ease-in-out;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }
        
        button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(255, 20, 147, 0.8), inset 0 -2px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.3);
        }

        /* Responsive button styles for iPad */
        @media screen and (max-width: 1024px) {
            button {
                padding: 10px 18px;
                font-size: 14px;
                letter-spacing: 1px;
                min-width: auto;
                white-space: nowrap;
            }

            #ui {
                padding: 8px 15px;
                min-height: auto;
            }

            .stat {
                padding: 8px 15px;
                font-size: 14px;
            }
        }

        @media screen and (max-width: 768px) {
            button {
                padding: 8px 12px;
                font-size: 12px;
                letter-spacing: 0.5px;
            }

            #levelSelect {
                min-width: 100px !important;
                font-size: 12px !important;
            }
        }
        
        button:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            filter: grayscale(50%);
        }
        
        #pauseBtn {
            min-width: 80px;
        }
        
        #autoStartCheck {
            margin-right: 5px;
        }
        
        #addTowerBtn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 50%, #00ff44 100%);
            border: 2px solid #00ff44;
            color: #001122;
            font-weight: 900;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 20px rgba(0, 255, 136, 0.6), inset 0 -2px 10px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 4px 30px rgba(0, 255, 136, 1), inset 0 -2px 10px rgba(0,0,0,0.3); }
        }
        
        #towerModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(138,43,226,0.1) 0%, rgba(0,0,0,0.95) 100%);
            backdrop-filter: blur(10px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #towerGrid {
            background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 50%, rgba(60,10,90,0.98) 100%);
            padding: 40px;
            border-radius: 30px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            border: 3px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493, #00ffff) 1;
            box-shadow: 0 20px 60px rgba(138, 43, 226, 0.8), inset 0 2px 20px rgba(255,255,255,0.1);
            animation: slideIn 0.4s ease-out;
            position: relative;
        }
        
        #towerGrid::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #8a2be2, #ff1493, #00ffff, #8a2be2);
            border-radius: 30px;
            opacity: 0.5;
            z-index: -1;
            filter: blur(10px);
            /* Removed spinning animation */
        }
        
        @keyframes slideIn {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .towerOption {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2) 0%, rgba(255, 20, 147, 0.1) 50%, rgba(0, 255, 255, 0.1) 100%);
            padding: 25px;
            border-radius: 20px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
            text-align: center;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .towerOption::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #8a2be2, #ff1493, #00ffff, #8a2be2);
            border-radius: 20px;
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            filter: blur(5px);
        }
        
        .towerOption:hover::before {
            opacity: 1;
            /* Removed spinning animation */
        }
        
        .towerOption:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 20px 40px rgba(255, 20, 147, 0.6);
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.4) 0%, rgba(255, 20, 147, 0.3) 50%, rgba(0, 255, 255, 0.2) 100%);
        }
        
        .towerOption.selected {
            border-color: #00ff00;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(0, 255, 0, 0.3);
            transform: scale(1.05);
        }
        
        .towerOption.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        
        .towerOption.disabled:hover {
            transform: none;
        }
        
        .towerStats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        
        #levelInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.95) 0%, rgba(255, 20, 147, 0.95) 100%);
            padding: 30px 60px;
            border-radius: 30px;
            font-size: 36px;
            font-weight: 900;
            display: none;
            box-shadow: 0 20px 60px rgba(138, 43, 226, 1), inset 0 2px 20px rgba(255,255,255,0.3);
            text-align: center;
            z-index: 1000;
            border: 3px solid rgba(255,255,255,0.3);
            animation: levelPop 0.6s ease-out;
        }
        
        @keyframes levelPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(180deg); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(90deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(0); opacity: 1; }
            to { transform: translateX(-50%) translateY(-50px); opacity: 0; }
        }
        
        @keyframes fadeUp {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        
        @keyframes pathPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(180deg); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(90deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100px); opacity: 0; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        /* Game mode selection */
        .game-mode-option {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2) 0%, rgba(255, 20, 147, 0.1) 100%);
            padding: 40px;
            border-radius: 30px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
            min-width: 250px;
        }
        
        .game-mode-option:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 20px 40px rgba(255, 20, 147, 0.6);
            border-color: #ff1493;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.4) 0%, rgba(255, 20, 147, 0.3) 100%);
        }
        
        .game-mode-option h2 {
            color: #fff;
            margin: 10px 0;
            font-size: 28px;
        }
        
        .game-mode-option p {
            color: #ccc;
            margin: 0;
            font-size: 16px;
        }
        
        /* Co-op mode indicators */
        .player-cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            transition: all 0.1s;
        }
        
        #player2Cursor {
            background: radial-gradient(circle, rgba(255, 20, 147, 0.8) 0%, rgba(255, 20, 147, 0.4) 50%, transparent 70%);
            border: 2px solid #ff1493;
        }
        
        .player-indicator {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 8px;
            border-radius: 10px;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 100%);
            padding: 60px;
            border-radius: 40px;
            text-align: center;
            display: none;
            box-shadow: 0 30px 80px rgba(138, 43, 226, 1), inset 0 2px 30px rgba(255,255,255,0.2);
            border: 4px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            z-index: 1000;
        }
        
        #towerInfo {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(20,20,60,0.95) 0%, rgba(40,20,80,0.95) 50%, rgba(60,10,90,0.95) 100%);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6), inset 0 2px 10px rgba(255,255,255,0.1);
            display: none;
            min-width: 250px;
            backdrop-filter: blur(10px);
            animation: slideInRight 0.3s ease-out;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        #towerInfo h3 {
            color: #fff;
            margin: 0 0 15px 0;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(255,20,147,0.8);
        }
        
        .tower-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            color: #ccc;
            font-size: 14px;
        }
        
        .tower-stat-label {
            color: #888;
        }
        
        .tower-stat-value {
            color: #fff;
            font-weight: bold;
        }
        
        #upgradeBtn {
            width: 100%;
            margin-top: 15px;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            border-color: #00ff88;
            color: #001122;
        }
        
        #upgradeBtn:disabled {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            border-color: #555;
            color: #999;
        }
        
        .closeBtn {
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            color: rgba(255, 255, 255, 0.6) !important;
            font-size: 16px !important;
            cursor: pointer !important;
            padding: 0 !important;
            width: 28px !important;
            height: 28px !important;
            border-radius: 14px !important;
            box-shadow: none !important;
            transition: all 0.3s !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            line-height: 1 !important;
        }
        
        .closeBtn:hover {
            background: rgba(255, 100, 100, 0.3) !important;
            border-color: rgba(255, 100, 100, 0.5) !important;
            color: #fff !important;
            transform: scale(1.1) !important;
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.5) !important;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(138, 43, 226, 0.1);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #8a2be2, #ff1493);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #ff1493, #8a2be2);
        }
        
        /* Clean floating damage numbers */
        .damage-number {
            position: fixed;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 1000;
            -webkit-font-smoothing: antialiased;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(0.5);
                opacity: 0;
            }
        }
        
        /* Screen shake */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2px, 2px); }
            20% { transform: translate(2px, -2px); }
            30% { transform: translate(-3px, 0); }
            40% { transform: translate(3px, 2px); }
            50% { transform: translate(0, -2px); }
            60% { transform: translate(-2px, 3px); }
            70% { transform: translate(2px, 0); }
            80% { transform: translate(-1px, -2px); }
            90% { transform: translate(1px, 2px); }
        }
        
        .shake {
            animation: shake 0.3s ease-in-out;
        }
        
        /* Wave Preview */
        #wavePreview {
            position: fixed;
            top: 120px;
            left: 20px;
            background: linear-gradient(135deg, rgba(20,20,60,0.95) 0%, rgba(40,20,80,0.95) 100%);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6);
            display: none;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #wavePreview h4 {
            color: #00ffff;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        
        .wave-enemy {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .wave-enemy-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .wave-enemy-info {
            flex: 1;
            font-size: 12px;
        }
        
        .wave-enemy-name {
            color: #fff;
            font-weight: bold;
        }
        
        .wave-enemy-count {
            color: #888;
        }
        
        /* Achievements */
        #achievementPopup {
            position: fixed;
            top: 100px;
            right: -400px;
            background: linear-gradient(135deg, rgba(255,215,0,0.95) 0%, rgba(255,165,0,0.95) 100%);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(255,215,0,0.8);
            transition: right 0.5s ease-out;
            max-width: 350px;
            z-index: 1000;
        }
        
        #achievementPopup.show {
            right: 20px;
        }
        
        #achievementPopup h3 {
            color: #000;
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        #achievementPopup p {
            color: #333;
            margin: 0;
            font-size: 14px;
        }
        
        /* Target priority selector */
        .target-priority {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .target-option {
            cursor: pointer;
            padding: 3px 8px;
            border-radius: 10px;
            transition: all 0.3s;
        }
        
        .target-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .target-option.active {
            background: rgba(0,255,255,0.3);
            color: #00ffff;
        }
        
        /* Specialization buttons */
        .spec-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .spec-btn {
            flex: 1;
            padding: 10px;
            font-size: 12px;
            background: linear-gradient(135deg, #4a4a6a 0%, #3a3a5a 100%);
        }
        
        .spec-btn:hover {
            background: linear-gradient(135deg, #5a5a7a 0%, #4a4a6a 100%);
        }
        
        .spec-btn.selected {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
        }
        /* Power-up effect */
        .powerup {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            box-shadow: 0 0 20px #ffd700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            animation: powerupFloat 2s ease-in-out infinite;
            cursor: pointer;
            z-index: 100;
        }
        
        @keyframes powerupFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <!-- Game Mode Selection -->
    <div id="gameModeSelect" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0a2e 0%, #000511 50%, #1a0033 100%); display: flex; justify-content: center; align-items: center; z-index: 3000;">
        <div style="background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 100%); padding: 60px; border-radius: 40px; text-align: center; box-shadow: 0 30px 80px rgba(138, 43, 226, 1); border: 4px solid; border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;">
            <h1 style="color: #fff; margin-bottom: 40px; font-size: 48px; text-shadow: 0 0 20px rgba(255,20,147,0.8);">Ultra Premium Tower Defense</h1>
            <div style="display: flex; gap: 40px; justify-content: center; flex-wrap: wrap;">
                <div class="game-mode-option" onclick="startSinglePlayer()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üéÆ</div>
                    <h2>Single Player</h2>
                    <p>Classic tower defense experience</p>
                </div>
                <div class="game-mode-option" onclick="startCoOp()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üë•</div>
                    <h2>Local Co-Op</h2>
                    <p>Team up with a friend!</p>
                    <div style="margin-top: 15px; font-size: 14px; color: #aaa;">
                        P1: Mouse | P2: WASD + Space
                    </div>
                </div>
                <div class="game-mode-option" onclick="viewLeaderboard()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üèÜ</div>
                    <h2>Leaderboard</h2>
                    <p>View high scores</p>
                </div>
                <div class="game-mode-option" onclick="startChallenge()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üî•</div>
                    <h2>Challenge Mode</h2>
                    <p>Endless waves, limited lives</p>
                    <div style="margin-top: 15px; font-size: 14px; color: #ffa500;">
                        No selling ‚Ä¢ 3 lives ‚Ä¢ Increasing difficulty
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Player 2 Cursor for Co-op -->
    <div id="player2Cursor" class="player-cursor" style="display: none;">
        <div class="player-indicator">P2</div>
    </div>

    <div id="gameContainer" style="display: none;">
        <div id="ui">
            <div style="display: flex; gap: 15px; align-items: center;">
                <div class="stat">
                    <div class="icon">üí∞</div>
                    <span id="money">500</span>
                </div>
                <div class="stat">
                    <div class="icon">‚ù§Ô∏è</div>
                    <span id="health">100</span>
                </div>
                <div class="stat">
                    <div class="icon">‚öîÔ∏è</div>
                    <span><span id="level">1</span>/50</span>
                </div>
                <div class="stat">
                    <div class="icon">‚≠ê</div>
                    <span id="score">0</span>
                </div>
                <div class="stat" id="fpsDisplay" style="font-size: 12px; opacity: 0.7;">
                    <span id="fps">60 FPS</span>
                </div>
                <div class="stat" id="themeDisplay" style="min-width: 150px;">
                    <div class="icon">üåç</div>
                    <span id="themeName">Grassland</span>
                </div>
                <div class="stat" id="waveStatus" style="display: none;">
                    <div class="icon">üëæ</div>
                    <span><span id="currentWave">1</span>/<span id="totalWaves">1</span> ‚Ä¢ <span id="enemyCount">0</span></span>
                </div>
                <div class="stat" id="coopIndicator" style="display: none;">
                    <div class="icon">üë•</div>
                    <span>CO-OP MODE</span>
                </div>
            </div>
            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; max-width: 100%; overflow: hidden;">
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <button id="addTowerBtn">üèóÔ∏è Add Tower</button>
                    <button id="startLevel">‚ñ∂Ô∏è Start Level 1</button>
                    <select id="levelSelect" onchange="selectLevel(this.value)" style="background: linear-gradient(135deg, #8a2be2 0%, #ff1493 100%); color: white; border: 2px solid #ff1493; padding: 8px; border-radius: 20px; font-weight: bold; min-width: 120px;">
                        <option value="">Jump to Level...</option>
                    </select>
                </div>
                <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                    <button id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
                    <button id="speedBtn" onclick="cycleGameSpeed()">‚ö° 1x Speed</button>
                    <button id="perfBtn" onclick="togglePerformanceMode()" title="Toggle Performance Mode">üöÄ Perf</button>
                </div>
                <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                    <button id="bombBtn" onclick="useSpecialAbility('bomb')" title="Bomb (B) - Unlocks at level 10" style="background: linear-gradient(135deg, #ff6600 0%, #ff3300 100%); position: relative; display: none;">üí£ <span id="bombCooldown" style="position: absolute; top: -5px; right: -5px; font-size: 10px; background: black; padding: 2px; border-radius: 10px;"></span></button>
                    <button id="freezeBtn" onclick="useSpecialAbility('freeze')" title="Freeze (F) - Unlocks at level 15" style="background: linear-gradient(135deg, #00ccff 0%, #0088ff 100%); position: relative; display: none;">‚ùÑÔ∏è <span id="freezeCooldown" style="position: absolute; top: -5px; right: -5px; font-size: 10px; background: black; padding: 2px; border-radius: 10px;"></span></button>
                    <button id="doubleBtn" onclick="useSpecialAbility('double')" title="Double Damage (D) - Unlocks at level 20" style="background: linear-gradient(135deg, #ffcc00 0%, #ff8800 100%); position: relative; display: none;">‚öîÔ∏è <span id="doubleCooldown" style="position: absolute; top: -5px; right: -5px; font-size: 10px; background: black; padding: 2px; border-radius: 10px;"></span></button>
                    <button id="wavePreviewBtn" onclick="toggleWavePreview()">üëÅÔ∏è Preview</button>
                    <button id="leaderboardBtn" onclick="showInGameLeaderboard()">üèÜ</button>
                </div>
                <label style="font-size: 12px; white-space: nowrap;">
                    <input type="checkbox" id="autoStartCheck" checked onchange="toggleAutoStart()">
                    Auto-start
                </label>
            </div>
        </div>

        <canvas id="gameCanvas" style="display: block; background: #222; min-height: 400px; width: 100%;"></canvas>
        
        
        <!-- Wave Preview Panel -->
        <div id="wavePreview">
            <h4>üåä Incoming Waves</h4>
            <div id="waveContent"></div>
        </div>
        
        <!-- Achievement Popup -->
        <div id="achievementPopup">
            <h3>üèÜ Achievement Unlocked!</h3>
            <p id="achievementText"></p>
        </div>
        
        <!-- Tower Info Panel - Updated to remove ability button -->
        <div id="towerInfo">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 id="towerName">Tower Name</h3>
                <button class="closeBtn" onclick="selectedTower = null; updateUI();">‚úï</button>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Level:</span>
                <span class="tower-stat-value" id="towerLevel">1</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Damage:</span>
                <span class="tower-stat-value" id="towerDamage">10</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Range:</span>
                <span class="tower-stat-value" id="towerRange">150</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Fire Rate:</span>
                <span class="tower-stat-value" id="towerFireRate">Fast</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Kills:</span>
                <span class="tower-stat-value" id="towerKills">0</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Specialization:</span>
                <span class="tower-stat-value" id="towerSpec">None</span>
            </div>
            <div class="target-priority">
                <div class="target-option" data-priority="first" onclick="setTowerTargeting('first')">First</div>
                <div class="target-option" data-priority="last" onclick="setTowerTargeting('last')">Last</div>
                <div class="target-option active" data-priority="closest" onclick="setTowerTargeting('closest')">Closest</div>
                <div class="target-option" data-priority="strongest" onclick="setTowerTargeting('strongest')">Strong</div>
                <div class="target-option" data-priority="weakest" onclick="setTowerTargeting('weakest')">Weak</div>
            </div>
            <button id="upgradeBtn" onclick="upgradeTower()">‚¨ÜÔ∏è UPGRADE (üí∞100)</button>
            <div class="spec-buttons" id="specButtons" style="display: none;">
                <h4 style="color: #aaa; font-size: 12px; margin: 0 0 10px 0; text-align: center;">Choose Specialization:</h4>
                <button class="spec-btn" onclick="specializeTower('power')">üí• Power</button>
                <button class="spec-btn" onclick="specializeTower('speed')">‚ö° Speed</button>
                <button class="spec-btn" onclick="specializeTower('effect')">‚ú® Effect</button>
            </div>
            <button id="sellBtn" onclick="sellTower()" style="background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%); margin-top: 10px; width: 100%;">üí∞ SELL</button>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2); text-align: center;">
                <div style="font-size: 11px; color: #888;">Hotkeys: U = Upgrade ‚Ä¢ S = Sell</div>
            </div>
        </div>
        
        <!-- Tower Selection Modal -->
        <div id="towerModal">
            <div id="towerGrid">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 style="color: #fff; font-size: 36px; margin: 0; text-shadow: 0 0 20px rgba(255,20,147,0.8);">üèóÔ∏è Choose Your Tower</h2>
                    <button id="closeTowerModal" style="background: linear-gradient(135deg, #ff4444, #cc0000); width: 50px; height: 50px; border-radius: 50%; font-size: 24px;">‚úñ</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <div class="towerOption" data-type="pulse">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #00ff88);">üî´</div>
                        <h3 style="color: #00ff88; font-size: 24px; margin: 10px 0;">Pulse Cannon</h3>
                        <p style="color: #aaa; margin: 10px 0;">Rapid-fire energy weapon with consistent damage output</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">10</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">140</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Fast</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 120</p>
                    </div>
                    <div class="towerOption" data-type="laser">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #00ffff);">‚ö°</div>
                        <h3 style="color: #00ffff; font-size: 24px; margin: 10px 0;">Laser Tower</h3>
                        <p style="color: #aaa; margin: 10px 0;">Continuous beam weapon that melts through enemies</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">5/tick</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">180</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Beam</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 250</p>
                    </div>
                    <div class="towerOption" data-type="missile">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #ff8844);">üöÄ</div>
                        <h3 style="color: #ff8844; font-size: 24px; margin: 10px 0;">Missile Launcher</h3>
                        <p style="color: #aaa; margin: 10px 0;">Homing missiles with explosive area damage</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">50</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">220</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Slow</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 400</p>
                    </div>
                    <div class="towerOption" data-type="tesla">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #ffff00);">‚ö°</div>
                        <h3 style="color: #ffff00; font-size: 24px; margin: 10px 0;">Tesla Coil</h3>
                        <p style="color: #aaa; margin: 10px 0;">Chain lightning jumps between multiple enemies</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">25</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">160</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Medium</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 600</p>
                    </div>
                    <div class="towerOption" data-type="plasma">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #ff00ff);">üí•</div>
                        <h3 style="color: #ff00ff; font-size: 24px; margin: 10px 0;">Plasma Cannon</h3>
                        <p style="color: #aaa; margin: 10px 0;">Superheated plasma orbs with splash damage</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">70</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">200</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Medium</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 850</p>
                    </div>
                    <div class="towerOption" data-type="quantum">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #8a2be2);">üåÄ</div>
                        <h3 style="color: #8a2be2; font-size: 24px; margin: 10px 0;">Quantum Disruptor</h3>
                        <p style="color: #aaa; margin: 10px 0;">Reality-warping weapon that pierces through enemies</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">90</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">280</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Medium</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 1200</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="levelInfo">Level Complete!</div>
        
        <div id="gameOver">
            <h2 style="font-size: 48px; color: #ff1493; margin-bottom: 20px;">GAME OVER</h2>
            <p style="font-size: 24px; margin: 20px 0;">Final Score: <span id="finalScore" style="color: #00ff88;">0</span></p>
            <p style="font-size: 18px; margin: 10px 0;">Best Wave: <span id="bestWave" style="color: #00ffff;">0</span></p>
            <p style="font-size: 18px; margin: 10px 0;">Total Kills: <span id="totalKills" style="color: #ffaa00;">0</span></p>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px;">
                <button onclick="restartGame()" style="font-size: 20px; padding: 15px 40px;">Play Again</button>
                <button onclick="showLeaderboard()" style="font-size: 20px; padding: 15px 40px;">üèÜ Leaderboard</button>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" onclick="if(event.target === this) closeLeaderboard()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 100%); padding: 40px; border-radius: 30px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(138, 43, 226, 1); border: 3px solid; border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1; position: relative;">
            <button class="closeBtn" onclick="closeLeaderboard()" style="position: absolute; top: 15px; right: 15px;">‚úï</button>
            <h2 style="color: #fff; text-align: center; margin-bottom: 30px; font-size: 36px;">üèÜ Leaderboard</h2>
            <div id="leaderboardContent">
                <!-- Leaderboard entries will be added here -->
            </div>
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="closeLeaderboard()" style="min-width: 150px; background: linear-gradient(135deg, #8a2be2 0%, #ff1493 100%);">Close</button>
            </div>
        </div>
    </div>

<script>
// Initialize canvas - these need to be global
let canvas, ctx;

// Game settings
let gameSpeed = 1;

// Set canvas size
function resizeCanvas() {
    if (!canvas) {
        console.error('Canvas not initialized in resizeCanvas');
        return;
    }
    
    const ui = document.getElementById('ui');
    const width = window.innerWidth || 800;
    const height = (window.innerHeight || 600) - (ui ? ui.offsetHeight : 70);
    
    canvas.width = Math.max(100, width);
    canvas.height = Math.max(100, height);
    
    console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
    
    // Update path scaling when canvas resizes
    if (originalPath) {
        path = scalePath();
        updateBasePosition();
    }
}


// Game state
let money = 400; // Reduced starting money
let health = 100;
let level = 1;
let score = 0;
let enemies = [];
let towers = [];
let projectiles = [];
let particles = [];
let beams = [];
let powerups = [];
let levelActive = false;
let selectedTowerType = null;

// Special abilities
let specialAbilities = {
    bomb: { cooldown: 0, maxCooldown: 1800, unlocked: false }, // 30 seconds
    freeze: { cooldown: 0, maxCooldown: 2700, unlocked: false }, // 45 seconds  
    double: { cooldown: 0, maxCooldown: 3600, active: 0, unlocked: false } // 60 seconds, lasts 10 seconds
};
let placingTower = false;
let sellMode = false;
let challengeMode = false;
let challengeWave = 0;
let challengeLives = 3;
let mousePos = { x: 0, y: 0 };
let camera = { x: 0, y: 0 };
let enemiesSpawning = false;
let enemiesRemaining = 0;
let hoveredTower = null;
let selectedTower = null;
let currentWave = 0;
let totalWaves = 1;
let totalKills = 0;
let wavePreviewShown = false;
let autoStartEnabled = true;
let waveCountdown = 0;
let isPaused = false;
let screenShake = 0;
let shakeX = 0;
let shakeY = 0;

// Co-op mode variables
let isCoOpMode = false;
let player2Cursor = { x: 400, y: 300 };
let player2Keys = {};

// Leaderboard data
let leaderboard = [];

// Grid size for tower placement
const gridSize = 50;

// Achievements system
const achievements = {
    firstKill: { unlocked: false, name: "First Blood", desc: "Defeat your first enemy" },
    wave10: { unlocked: false, name: "Wave Survivor", desc: "Complete wave 10" },
    money1000: { unlocked: false, name: "Rich Defender", desc: "Save 1000 gold" },
    perfectWave: { unlocked: false, name: "Perfect Defense", desc: "Complete a wave without taking damage" },
    towerMaster: { unlocked: false, name: "Tower Master", desc: "Have 10 towers at once" },
    upgradeMax: { unlocked: false, name: "Max Power", desc: "Fully upgrade a tower" },
    specialization: { unlocked: false, name: "Specialist", desc: "Specialize a tower" }
};

// Stub function to prevent errors from any remaining references

// Level data - Increased difficulty
const levelData = [
    { level: 1, theme: 'Grassland', enemies: [{ type: 'slime', count: 15 }], waves: 1, hpRange: [80, 100], features: 'Intro to tower placement' },
    { level: 2, theme: 'Grassland', enemies: [{ type: 'slime', count: 25 }], waves: 2, hpRange: [100, 120], features: 'Multiple waves' },
    { level: 3, theme: 'Grassland', enemies: [{ type: 'slime', count: 35 }, { type: 'golem', count: 3 }], waves: 2, hpRange: [120, 150], features: 'Tougher enemies appear' },
    { level: 4, theme: 'Grassland', enemies: [{ type: 'slime', count: 45 }, { type: 'golem', count: 5 }], waves: 3, hpRange: [150, 200], features: 'Increased enemy variety' },
    { level: 5, theme: 'Grassland', enemies: [{ type: 'slime', count: 60 }, { type: 'golem', count: 8 }, { type: 'brute', count: 2 }, { type: 'boss', count: 1 }], waves: 3, hpRange: [200, 300], features: 'First boss battle!' },
    { level: 6, theme: 'Desert', enemies: [{ type: 'speeder', count: 20 }, { type: 'slime', count: 40 }, { type: 'golem', count: 10 }], waves: 3, hpRange: [250, 350], features: 'Speeders rush your defenses' },
    { level: 7, theme: 'Desert', enemies: [{ type: 'tank', count: 3 }, { type: 'speeder', count: 25 }, { type: 'golem', count: 15 }], waves: 4, hpRange: [300, 400], features: 'Heavily armored tanks appear' },
    { level: 8, theme: 'Haunted', enemies: [{ type: 'ghost', count: 15 }, { type: 'slime', count: 50 }, { type: 'speeder', count: 20 }], waves: 4, hpRange: [350, 450], features: 'Ghosts phase through attacks' },
    { level: 9, theme: 'Haunted', enemies: [{ type: 'healer', count: 8 }, { type: 'ghost', count: 20 }, { type: 'golem', count: 20 }], waves: 4, hpRange: [400, 500], features: 'Healers support enemy waves' },
    { level: 10, theme: 'Volcanic', enemies: [{ type: 'splitter', count: 12 }, { type: 'tank', count: 4 }, { type: 'healer', count: 10 }, { type: 'boss', count: 1 }], waves: 5, hpRange: [450, 600], features: 'First boss battle!' },
    { level: 11, theme: 'Volcanic', enemies: [{ type: 'bomber', count: 20 }, { type: 'shielder', count: 15 }, { type: 'speeder', count: 30 }], waves: 5, hpRange: [500, 700], features: 'Explosive enemies and shields' },
    { level: 12, theme: 'Arctic', enemies: [{ type: 'regenerator', count: 12 }, { type: 'shielder', count: 18 }, { type: 'tank', count: 6 }], waves: 5, hpRange: [600, 800], features: 'Regenerating enemies' },
    { level: 13, theme: 'Arctic', enemies: [{ type: 'absorber', count: 10 }, { type: 'regenerator', count: 15 }, { type: 'bomber', count: 25 }], waves: 6, hpRange: [700, 900], features: 'Damage absorbing enemies' },
    { level: 14, theme: 'Chaos', enemies: [{ type: 'teleporter', count: 20 }, { type: 'swarm', count: 100 }, { type: 'absorber', count: 8 }], waves: 6, hpRange: [800, 1000], features: 'Teleporting chaos' },
    { level: 15, theme: 'Chaos', enemies: [{ type: 'boss', count: 2 }, { type: 'teleporter', count: 25 }, { type: 'healer', count: 15 }, { type: 'tank', count: 8 }], waves: 7, hpRange: [1000, 1500], features: 'Ultimate challenge!' },
    // Extended levels 16-50
    { level: 16, theme: 'Void', enemies: [{ type: 'voidwalker', count: 10 }, { type: 'ghost', count: 30 }, { type: 'absorber', count: 12 }], waves: 6, hpRange: [1200, 1800], features: 'Void walkers phase in and out' },
    { level: 17, theme: 'Crystal', enemies: [{ type: 'crystalGuard', count: 8 }, { type: 'shielder', count: 20 }, { type: 'tank', count: 10 }], waves: 6, hpRange: [1400, 2000], features: 'Crystal guards reflect damage' },
    { level: 18, theme: 'Elemental', enemies: [{ type: 'fireElemental', count: 15 }, { type: 'iceElemental', count: 12 }, { type: 'lightningElemental', count: 18 }], waves: 7, hpRange: [1600, 2200], features: 'Elemental forces unite' },
    { level: 19, theme: 'Shadow', enemies: [{ type: 'shadowAssassin', count: 25 }, { type: 'voidwalker', count: 15 }, { type: 'ghost', count: 20 }], waves: 7, hpRange: [1800, 2500], features: 'Shadows strike from darkness' },
    { level: 20, theme: 'Necropolis', enemies: [{ type: 'necromancer', count: 5 }, { type: 'ghost', count: 40 }, { type: 'regenerator', count: 20 }, { type: 'megaBoss', count: 1 }], waves: 8, hpRange: [2000, 3000], features: 'Mega boss appears!' },
    { level: 21, theme: 'Time Rift', enemies: [{ type: 'timeBender', count: 12 }, { type: 'teleporter', count: 30 }, { type: 'speeder', count: 40 }], waves: 8, hpRange: [2200, 3200], features: 'Time manipulation chaos' },
    { level: 22, theme: 'Plasma Core', enemies: [{ type: 'plasmaBeast', count: 6 }, { type: 'fireElemental', count: 20 }, { type: 'bomber', count: 30 }], waves: 8, hpRange: [2400, 3500], features: 'Plasma shields protect enemies' },
    { level: 23, theme: 'Quantum', enemies: [{ type: 'quantumEntity', count: 15 }, { type: 'teleporter', count: 25 }, { type: 'timeBender', count: 10 }], waves: 9, hpRange: [2600, 3800], features: 'Quantum mechanics at play' },
    { level: 24, theme: 'Elite Forces', enemies: [{ type: 'eliteTank', count: 4 }, { type: 'crystalGuard', count: 10 }, { type: 'shielder', count: 25 }], waves: 9, hpRange: [2800, 4000], features: 'Elite armored units' },
    { level: 25, theme: 'Swarm Hell', enemies: [{ type: 'hyperSwarm', count: 200 }, { type: 'swarm', count: 150 }, { type: 'speeder', count: 50 }, { type: 'boss', count: 3 }], waves: 10, hpRange: [100, 300], features: 'Overwhelming numbers!' },
    { level: 26, theme: 'Corruption', enemies: [{ type: 'corruptor', count: 8 }, { type: 'necromancer', count: 6 }, { type: 'regenerator', count: 30 }], waves: 9, hpRange: [3000, 4500], features: 'Corruption spreads' },
    { level: 27, theme: 'Mixed Assault', enemies: [{ type: 'shadowAssassin', count: 30 }, { type: 'lightningElemental', count: 25 }, { type: 'plasmaBeast', count: 8 }], waves: 10, hpRange: [3200, 4800], features: 'Combined forces attack' },
    { level: 28, theme: 'Void Storm', enemies: [{ type: 'voidwalker', count: 25 }, { type: 'quantumEntity', count: 20 }, { type: 'timeBender', count: 15 }], waves: 10, hpRange: [3500, 5000], features: 'Reality bends' },
    { level: 29, theme: 'Elemental Chaos', enemies: [{ type: 'fireElemental', count: 30 }, { type: 'iceElemental', count: 30 }, { type: 'lightningElemental', count: 30 }], waves: 11, hpRange: [3800, 5500], features: 'Elemental mayhem' },
    { level: 30, theme: 'Boss Rush', enemies: [{ type: 'boss', count: 5 }, { type: 'megaBoss', count: 2 }, { type: 'eliteTank', count: 10 }], waves: 12, hpRange: [5000, 8000], features: 'Multiple bosses!' },
    { level: 31, theme: 'Crystal Fortress', enemies: [{ type: 'crystalGuard', count: 20 }, { type: 'eliteTank', count: 8 }, { type: 'corruptor', count: 10 }], waves: 11, hpRange: [4000, 6000], features: 'Fortified defenses' },
    { level: 32, theme: 'Shadow Realm', enemies: [{ type: 'shadowAssassin', count: 50 }, { type: 'voidwalker', count: 30 }, { type: 'necromancer', count: 10 }], waves: 12, hpRange: [4200, 6500], features: 'Darkness consumes' },
    { level: 33, theme: 'Quantum Flux', enemies: [{ type: 'quantumEntity', count: 30 }, { type: 'timeBender', count: 25 }, { type: 'teleporter', count: 40 }], waves: 12, hpRange: [4500, 7000], features: 'Space-time anomalies' },
    { level: 34, theme: 'Plasma Storm', enemies: [{ type: 'plasmaBeast', count: 15 }, { type: 'fireElemental', count: 40 }, { type: 'lightningElemental', count: 35 }], waves: 13, hpRange: [4800, 7500], features: 'Energy overload' },
    { level: 35, theme: 'Ultimate Swarm', enemies: [{ type: 'hyperSwarm', count: 500 }, { type: 'corruptor', count: 15 }, { type: 'necromancer', count: 8 }, { type: 'megaBoss', count: 1 }], waves: 14, hpRange: [200, 500], features: 'Mega boss with endless swarm!' },
    { level: 36, theme: 'Elite Command', enemies: [{ type: 'eliteTank', count: 12 }, { type: 'crystalGuard', count: 25 }, { type: 'megaBoss', count: 3 }], waves: 13, hpRange: [5000, 8000], features: 'Elite forces mobilize' },
    { level: 37, theme: 'Void Convergence', enemies: [{ type: 'voidwalker', count: 40 }, { type: 'shadowAssassin', count: 60 }, { type: 'quantumEntity', count: 35 }], waves: 14, hpRange: [5200, 8500], features: 'Void consumes all' },
    { level: 38, theme: 'Elemental Apex', enemies: [{ type: 'fireElemental', count: 50 }, { type: 'iceElemental', count: 50 }, { type: 'lightningElemental', count: 50 }], waves: 15, hpRange: [5500, 9000], features: 'Peak elemental power' },
    { level: 39, theme: 'Time Collapse', enemies: [{ type: 'timeBender', count: 40 }, { type: 'teleporter', count: 60 }, { type: 'quantumEntity', count: 40 }], waves: 15, hpRange: [5800, 9500], features: 'Time itself breaks' },
    { level: 40, theme: 'Apocalypse', enemies: [{ type: 'megaBoss', count: 5 }, { type: 'boss', count: 10 }, { type: 'eliteTank', count: 20 }], waves: 16, hpRange: [10000, 15000], features: 'The end approaches' },
    { level: 41, theme: 'Beyond', enemies: [{ type: 'corruptor', count: 25 }, { type: 'necromancer', count: 15 }, { type: 'plasmaBeast', count: 20 }], waves: 16, hpRange: [6000, 10000], features: 'Beyond mortal realm' },
    { level: 42, theme: 'Quantum Void', enemies: [{ type: 'quantumEntity', count: 50 }, { type: 'voidwalker', count: 50 }, { type: 'timeBender', count: 50 }], waves: 17, hpRange: [6500, 11000], features: 'Reality collapses' },
    { level: 43, theme: 'Crystal Apocalypse', enemies: [{ type: 'crystalGuard', count: 40 }, { type: 'eliteTank', count: 25 }, { type: 'corruptor', count: 30 }], waves: 17, hpRange: [7000, 12000], features: 'Crystal dominion' },
    { level: 44, theme: 'Shadow Eclipse', enemies: [{ type: 'shadowAssassin', count: 100 }, { type: 'voidwalker', count: 60 }, { type: 'necromancer', count: 20 }], waves: 18, hpRange: [7500, 13000], features: 'Total darkness' },
    { level: 45, theme: 'Elemental Ragnarok', enemies: [{ type: 'fireElemental', count: 80 }, { type: 'iceElemental', count: 80 }, { type: 'lightningElemental', count: 80 }, { type: 'megaBoss', count: 2 }], waves: 19, hpRange: [8000, 14000], features: 'Twin mega bosses with elemental chaos!' },
    { level: 46, theme: 'Mega Swarm', enemies: [{ type: 'hyperSwarm', count: 1000 }, { type: 'swarm', count: 500 }, { type: 'megaBoss', count: 5 }], waves: 20, hpRange: [500, 1000], features: 'Infinite army' },
    { level: 47, theme: 'Chaos Incarnate', enemies: [{ type: 'corruptor', count: 40 }, { type: 'plasmaBeast', count: 35 }, { type: 'quantumEntity', count: 60 }], waves: 20, hpRange: [8500, 15000], features: 'Pure chaos' },
    { level: 48, theme: 'Elite Finale', enemies: [{ type: 'eliteTank', count: 40 }, { type: 'crystalGuard', count: 50 }, { type: 'megaBoss', count: 8 }], waves: 21, hpRange: [9000, 16000], features: 'Elite last stand' },
    { level: 49, theme: 'Void Finale', enemies: [{ type: 'voidwalker', count: 100 }, { type: 'shadowAssassin', count: 150 }, { type: 'timeBender', count: 80 }], waves: 22, hpRange: [9500, 17000], features: 'Void consumes all' },
    { level: 50, theme: 'Final Stand', enemies: [{ type: 'finalBoss', count: 1 }, { type: 'megaBoss', count: 10 }, { type: 'boss', count: 20 }, { type: 'eliteTank', count: 50 }], waves: 25, hpRange: [50000, 100000], features: 'THE FINAL BOSS!' }
];

// Base
const base = {
    x: 20,
    y: 280,
    width: 100,
    height: 100,
    name: 'NEXUS CORE',
    energyAnimation: 0,
    shieldPulse: 0,
    coreRotation: 0,
    orbitalRings: []
};

// Function to update base position based on canvas size
function updateBasePosition() {
    const scale = getScaleFactor();
    base.x = 20 * (canvas.width / 800);
    base.y = 280 * (canvas.height / 600);
    base.width = 100 * scale;
    base.height = 100 * scale;
}

// Initialize orbital rings
for (let i = 0; i < 3; i++) {
    base.orbitalRings.push({
        radius: 50 + i * 15,
        rotation: 0,
        speed: 0.02 * (i + 1),
        color: ['#ff1493', '#00ffff', '#8a2be2'][i]
    });
}

// Multiple path layouts for variety every 5 levels
const pathLayouts = {
    // Path 1: Serpentine (Levels 1-5) - Clean path avoiding nexus core overlap
    serpentine: [
        { x: 750, y: 50, tunnel: false },   // Start far right, top
        { x: 650, y: 50, tunnel: false },
        { x: 550, y: 50, tunnel: false },
        { x: 450, y: 50, tunnel: false },
        { x: 350, y: 50, tunnel: false },
        { x: 250, y: 50, tunnel: false },
        { x: 150, y: 50, tunnel: false },
        { x: 150, y: 120, tunnel: false },   // Turn down, avoiding nexus area
        { x: 150, y: 190, tunnel: false },
        { x: 250, y: 190, tunnel: false },   // Go right
        { x: 350, y: 190, tunnel: false },
        { x: 450, y: 190, tunnel: false },
        { x: 550, y: 190, tunnel: false },
        { x: 650, y: 190, tunnel: false },
        { x: 750, y: 190, tunnel: false },
        { x: 750, y: 260, tunnel: false },   // Turn down again
        { x: 750, y: 330, tunnel: false },
        { x: 650, y: 330, tunnel: false },   // Go left
        { x: 550, y: 330, tunnel: false },
        { x: 450, y: 330, tunnel: false },
        { x: 350, y: 330, tunnel: false },
        { x: 250, y: 330, tunnel: false },
        { x: 150, y: 330, tunnel: false },
        { x: 150, y: 400, tunnel: false },   // Turn down final time
        { x: 150, y: 470, tunnel: false },
        { x: 120, y: 470, tunnel: false },   // Move toward nexus core area
        { x: 90, y: 450, tunnel: false },    // Approach from below
        { x: 70, y: 420, tunnel: false },
        { x: 50, y: 380, tunnel: false },
        { x: 35, y: 340, tunnel: false },
        { x: 25, y: 300, tunnel: false }     // End near nexus core center
    ],
    
    // Path 2: Figure-8 (Levels 6-10) - Uses full canvas
    figure8: [
        { x: 400, y: 50, tunnel: false },
        { x: 500, y: 75, tunnel: false },
        { x: 600, y: 125, tunnel: false },
        { x: 700, y: 200, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 700, y: 400, tunnel: false },
        { x: 600, y: 475, tunnel: false },
        { x: 500, y: 525, tunnel: false },
        { x: 400, y: 550, tunnel: false },
        { x: 300, y: 525, tunnel: false },
        { x: 200, y: 475, tunnel: false },
        { x: 100, y: 400, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 100, y: 200, tunnel: false },
        { x: 200, y: 125, tunnel: false },
        { x: 300, y: 75, tunnel: false },
        { x: 400, y: 50, tunnel: true }, // Tunnel crossing
        { x: 400, y: 150, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 400, y: 350, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ],
    
    // Path 3: Zigzag (Levels 11-15) - Diagonal paths using full space
    zigzag: [
        { x: 50, y: 50, tunnel: false },
        { x: 150, y: 150, tunnel: false },
        { x: 250, y: 50, tunnel: false },
        { x: 350, y: 150, tunnel: false },
        { x: 450, y: 50, tunnel: false },
        { x: 550, y: 150, tunnel: false },
        { x: 650, y: 50, tunnel: false },
        { x: 750, y: 150, tunnel: false },
        { x: 750, y: 250, tunnel: false },
        { x: 650, y: 350, tunnel: false },
        { x: 550, y: 250, tunnel: false },
        { x: 450, y: 350, tunnel: false },
        { x: 350, y: 250, tunnel: false },
        { x: 250, y: 350, tunnel: false },
        { x: 150, y: 250, tunnel: false },
        { x: 50, y: 350, tunnel: false },
        { x: 50, y: 450, tunnel: false },
        { x: 150, y: 550, tunnel: false },
        { x: 250, y: 450, tunnel: false },
        { x: 350, y: 550, tunnel: false },
        { x: 450, y: 450, tunnel: false },
        { x: 550, y: 550, tunnel: false },
        { x: 650, y: 450, tunnel: false },
        { x: 750, y: 550, tunnel: false }
    ],
    
    // Path 4: Diamond (Levels 16-20) - Uses corners and center
    diamond: [
        { x: 400, y: 50, tunnel: false },
        { x: 500, y: 100, tunnel: false },
        { x: 600, y: 150, tunnel: false },
        { x: 700, y: 200, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 700, y: 400, tunnel: false },
        { x: 600, y: 450, tunnel: false },
        { x: 500, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false },
        { x: 300, y: 500, tunnel: false },
        { x: 200, y: 450, tunnel: false },
        { x: 100, y: 400, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 100, y: 200, tunnel: false },
        { x: 200, y: 150, tunnel: false },
        { x: 300, y: 100, tunnel: false },
        { x: 400, y: 50, tunnel: true }, // Back to start with tunnel
        { x: 400, y: 300, tunnel: false } // To center base
    ],
    
    // Keep original spiral as path 5 (Levels 21-25)
    spiral: [
        { x: 750, y: 150, tunnel: false },
        { x: 700, y: 160, tunnel: false },
        { x: 650, y: 180, tunnel: false },
        { x: 600, y: 200, tunnel: false },
        { x: 550, y: 220, tunnel: false },
        { x: 500, y: 240, tunnel: false },
        { x: 450, y: 250, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 350, y: 240, tunnel: false },
        { x: 300, y: 220, tunnel: false },
        { x: 250, y: 200, tunnel: false },
        { x: 200, y: 190, tunnel: false },
        { x: 150, y: 200, tunnel: false },
        { x: 120, y: 230, tunnel: false },
        { x: 110, y: 270, tunnel: false },
        { x: 120, y: 310, tunnel: false },
        { x: 150, y: 340, tunnel: false },
        { x: 190, y: 360, tunnel: false },
        { x: 230, y: 370, tunnel: false },
        { x: 270, y: 380, tunnel: false },
        { x: 310, y: 390, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 390, y: 410, tunnel: false },
        { x: 430, y: 420, tunnel: false },
        { x: 470, y: 430, tunnel: false },
        { x: 510, y: 440, tunnel: false },
        { x: 550, y: 450, tunnel: false },
        { x: 590, y: 460, tunnel: false },
        { x: 630, y: 470, tunnel: false },
        { x: 670, y: 480, tunnel: false },
        { x: 710, y: 470, tunnel: false },
        { x: 740, y: 440, tunnel: false },
        { x: 750, y: 400, tunnel: false },
        { x: 740, y: 360, tunnel: false },
        { x: 720, y: 320, tunnel: false },
        { x: 690, y: 290, tunnel: false },
        { x: 650, y: 270, tunnel: false },
        { x: 610, y: 260, tunnel: false },
        { x: 570, y: 270, tunnel: false },
        { x: 530, y: 290, tunnel: false },
        { x: 490, y: 310, tunnel: false },
        { x: 450, y: 330, tunnel: false },
        { x: 410, y: 340, tunnel: false },
        { x: 370, y: 340, tunnel: false },
        { x: 330, y: 330, tunnel: false },
        { x: 290, y: 310, tunnel: false },
        { x: 250, y: 290, tunnel: false },
        { x: 210, y: 280, tunnel: false },
        { x: 170, y: 280, tunnel: false },
        { x: 130, y: 280, tunnel: false },
        { x: 90, y: 280, tunnel: false },
        { x: 50, y: 280, tunnel: false },
        { x: 20, y: 280, tunnel: false }
    ],
    zigzag: [
        // Zigzag pattern - Levels 6-10
        { x: 50, y: 100, tunnel: false },
        { x: 150, y: 100, tunnel: false },
        { x: 250, y: 100, tunnel: false },
        { x: 350, y: 100, tunnel: false },
        { x: 450, y: 100, tunnel: false },
        { x: 550, y: 100, tunnel: false },
        { x: 650, y: 100, tunnel: false },
        { x: 750, y: 100, tunnel: false },
        { x: 750, y: 200, tunnel: false },
        { x: 650, y: 200, tunnel: false },
        { x: 550, y: 200, tunnel: false },
        { x: 450, y: 200, tunnel: false },
        { x: 350, y: 200, tunnel: false },
        { x: 250, y: 200, tunnel: false },
        { x: 150, y: 200, tunnel: false },
        { x: 50, y: 200, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 150, y: 300, tunnel: false },
        { x: 250, y: 300, tunnel: false },
        { x: 350, y: 300, tunnel: false },
        { x: 450, y: 300, tunnel: false },
        { x: 550, y: 300, tunnel: false },
        { x: 650, y: 300, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 750, y: 400, tunnel: false },
        { x: 650, y: 400, tunnel: false },
        { x: 550, y: 400, tunnel: false },
        { x: 450, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 150, y: 400, tunnel: false },
        { x: 50, y: 400, tunnel: false },
        { x: 50, y: 500, tunnel: false },
        { x: 100, y: 500, tunnel: false },
        { x: 150, y: 500, tunnel: false },
        { x: 200, y: 500, tunnel: false },
        { x: 250, y: 500, tunnel: false },
        { x: 300, y: 500, tunnel: false },
        { x: 350, y: 500, tunnel: false },
        { x: 400, y: 500, tunnel: false }
    ],
    cross: [
        // Cross pattern with tunnels - Levels 11-15
        { x: 400, y: 50, tunnel: false },
        { x: 400, y: 100, tunnel: false },
        { x: 400, y: 150, tunnel: false },
        { x: 400, y: 200, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 350, y: 300, tunnel: false },
        { x: 300, y: 300, tunnel: false },
        { x: 250, y: 300, tunnel: false },
        { x: 200, y: 300, tunnel: false },
        { x: 150, y: 300, tunnel: false },
        { x: 100, y: 300, tunnel: false },
        { x: 100, y: 350, tunnel: true },
        { x: 100, y: 400, tunnel: true },
        { x: 150, y: 400, tunnel: false },
        { x: 200, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 300, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 450, y: 400, tunnel: false },
        { x: 500, y: 400, tunnel: false },
        { x: 550, y: 400, tunnel: false },
        { x: 600, y: 400, tunnel: false },
        { x: 650, y: 400, tunnel: false },
        { x: 700, y: 400, tunnel: false },
        { x: 700, y: 350, tunnel: true },
        { x: 700, y: 300, tunnel: true },
        { x: 650, y: 300, tunnel: false },
        { x: 600, y: 300, tunnel: false },
        { x: 550, y: 300, tunnel: false },
        { x: 500, y: 300, tunnel: false },
        { x: 450, y: 300, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 400, y: 350, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ],
    maze: [
        // Maze pattern - Levels 16-20
        { x: 50, y: 550, tunnel: false },
        { x: 100, y: 550, tunnel: false },
        { x: 150, y: 550, tunnel: false },
        { x: 200, y: 550, tunnel: false },
        { x: 200, y: 500, tunnel: false },
        { x: 200, y: 450, tunnel: false },
        { x: 200, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 300, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 400, y: 350, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 350, y: 250, tunnel: false },
        { x: 300, y: 250, tunnel: false },
        { x: 250, y: 250, tunnel: false },
        { x: 200, y: 250, tunnel: false },
        { x: 200, y: 200, tunnel: false },
        { x: 200, y: 150, tunnel: false },
        { x: 200, y: 100, tunnel: false },
        { x: 250, y: 100, tunnel: false },
        { x: 300, y: 100, tunnel: false },
        { x: 350, y: 100, tunnel: false },
        { x: 400, y: 100, tunnel: false },
        { x: 450, y: 100, tunnel: false },
        { x: 500, y: 100, tunnel: false },
        { x: 550, y: 100, tunnel: false },
        { x: 600, y: 100, tunnel: false },
        { x: 600, y: 150, tunnel: false },
        { x: 600, y: 200, tunnel: false },
        { x: 600, y: 250, tunnel: false },
        { x: 600, y: 300, tunnel: false },
        { x: 600, y: 350, tunnel: false },
        { x: 600, y: 400, tunnel: false },
        { x: 600, y: 450, tunnel: false },
        { x: 550, y: 450, tunnel: false },
        { x: 500, y: 450, tunnel: false },
        { x: 450, y: 450, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ],
    highway: [
        // Fast highway pattern - Levels 21-25
        { x: 50, y: 300, tunnel: false },
        { x: 100, y: 300, tunnel: false },
        { x: 150, y: 300, tunnel: false },
        { x: 200, y: 300, tunnel: false },
        { x: 250, y: 300, tunnel: false },
        { x: 300, y: 300, tunnel: false },
        { x: 350, y: 300, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 450, y: 300, tunnel: false },
        { x: 500, y: 300, tunnel: false },
        { x: 550, y: 300, tunnel: false },
        { x: 600, y: 300, tunnel: false },
        { x: 650, y: 300, tunnel: false },
        { x: 700, y: 300, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 750, y: 250, tunnel: false },
        { x: 750, y: 200, tunnel: false },
        { x: 700, y: 200, tunnel: false },
        { x: 650, y: 200, tunnel: false },
        { x: 600, y: 200, tunnel: false },
        { x: 550, y: 200, tunnel: false },
        { x: 500, y: 200, tunnel: false },
        { x: 450, y: 200, tunnel: false },
        { x: 400, y: 200, tunnel: false },
        { x: 350, y: 200, tunnel: false },
        { x: 300, y: 200, tunnel: false },
        { x: 250, y: 200, tunnel: false },
        { x: 200, y: 200, tunnel: false },
        { x: 150, y: 200, tunnel: false },
        { x: 100, y: 200, tunnel: false },
        { x: 50, y: 200, tunnel: false },
        { x: 50, y: 250, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 50, y: 350, tunnel: false },
        { x: 50, y: 400, tunnel: false },
        { x: 100, y: 400, tunnel: false },
        { x: 150, y: 400, tunnel: false },
        { x: 200, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 300, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ]
};

// Current path layout - Start with serpentine
let currentPathLayout = 'serpentine';
let originalPath = pathLayouts[currentPathLayout];

// Function to scale path based on canvas size
function scalePath() {
    const baseWidth = 800;
    const baseHeight = 600;
    const scaleX = (canvas.width || baseWidth) / baseWidth;
    const scaleY = (canvas.height || baseHeight) / baseHeight;
    
    return originalPath.map(point => ({
        x: point.x * scaleX,
        y: point.y * scaleY,
        tunnel: point.tunnel
    }));
}

// Dynamic path that scales with canvas
let path = [];

// Calculate scale factor for game elements
function getScaleFactor() {
    const baseSize = 800; // Base size for original design
    const scale = Math.min(canvas.width, canvas.height) / baseSize;
    // Ensure we have a valid scale factor
    return isNaN(scale) || scale <= 0 ? 1 : scale;
}

// Tower types - Rebalanced to be less powerful
const towerTypes = {
    pulse: {
        cost: 120,
        damage: 10,
        range: 140,
        fireRate: 600,
        color: '#00ff88',
        projectileSpeed: 12,
        name: 'Pulse Cannon',
        element: 'kinetic',
        description: 'Rapid-fire cannon with consistent damage',
        upgrades: {
            damage: { base: 10, perLevel: 2.5, max: 100 },
            range: { base: 140, perLevel: 5, max: 250 },
            fireRate: { base: 600, perLevel: -30, min: 150 }
        }
    },
    laser: {
        cost: 250,
        damage: 5,
        range: 180,
        fireRate: 50,
        color: '#00ffff',
        beam: true,
        name: 'Laser Tower',
        element: 'energy',
        description: 'Continuous beam weapon, melts armor',
        upgrades: {
            damage: { base: 5, perLevel: 1.5, max: 50 },
            range: { base: 180, perLevel: 8, max: 300 },
            beamWidth: { base: 1, perLevel: 0.5, max: 5 }
        }
    },
    missile: {
        cost: 400,
        damage: 50,
        range: 220,
        fireRate: 2500,
        color: '#ff8844',
        projectileSpeed: 6,
        explosive: true,
        homing: true,
        name: 'Missile Launcher',
        element: 'explosive',
        description: 'Homing missiles with area damage',
        upgrades: {
            damage: { base: 50, perLevel: 10, max: 300 },
            range: { base: 220, perLevel: 10, max: 400 },
            splashRadius: { base: 40, perLevel: 5, max: 100 },
            fireRate: { base: 2500, perLevel: -100, min: 1000 }
        }
    },
    tesla: {
        cost: 600,
        damage: 25,
        range: 160,
        fireRate: 1200,
        color: '#ffff00',
        chain: true,
        chainCount: 2,
        name: 'Tesla Coil',
        element: 'electric',
        description: 'Chain lightning hits multiple enemies',
        upgrades: {
            damage: { base: 25, perLevel: 5, max: 150 },
            range: { base: 160, perLevel: 6, max: 280 },
            chainCount: { base: 2, perLevel: 0.5, max: 8 },
            fireRate: { base: 1200, perLevel: -60, min: 300 }
        }
    },
    plasma: {
        cost: 850,
        damage: 70,
        range: 200,
        fireRate: 1800,
        color: '#ff00ff',
        projectileSpeed: 10,
        splash: true,
        splashRadius: 50,
        name: 'Plasma Cannon',
        element: 'plasma',
        description: 'High damage with splash effect',
        upgrades: {
            damage: { base: 70, perLevel: 15, max: 400 },
            range: { base: 200, perLevel: 7, max: 350 },
            splashRadius: { base: 50, perLevel: 8, max: 150 },
            fireRate: { base: 1800, perLevel: -80, min: 800 }
        }
    },
    railgun: {
        cost: 1200,
        damage: 90,
        range: 280,
        fireRate: 1500,
        color: '#8a2be2',
        projectileSpeed: 18,
        pierce: true,
        name: 'Railgun',
        element: 'magnetic',
        description: 'Pierces through multiple enemies',
        upgrades: {
            damage: { base: 90, perLevel: 20, max: 500 },
            range: { base: 280, perLevel: 12, max: 500 },
            pierceCount: { base: 3, perLevel: 1, max: 15 },
            fireRate: { base: 1500, perLevel: -70, min: 500 }
        }
    },
    // New tower types for advanced levels
    quantum: {
        cost: 1800,
        damage: 120,
        range: 250,
        fireRate: 2000,
        color: '#00ff99',
        projectileSpeed: 15,
        name: 'Quantum Disruptor',
        element: 'quantum',
        description: 'Phases through reality to hit multiple timelines',
        quantumPhase: true,
        upgrades: {
            damage: { base: 120, perLevel: 25, max: 600 },
            range: { base: 250, perLevel: 10, max: 450 },
            phaseCount: { base: 2, perLevel: 0.5, max: 6 },
            fireRate: { base: 2000, perLevel: -100, min: 600 }
        }
    },
    void: {
        cost: 2500,
        damage: 150,
        range: 300,
        fireRate: 2500,
        color: '#6600cc',
        name: 'Void Cannon',
        element: 'void',
        description: 'Creates black holes that pull enemies',
        voidPull: true,
        upgrades: {
            damage: { base: 150, perLevel: 30, max: 750 },
            range: { base: 300, perLevel: 12, max: 500 },
            pullRadius: { base: 80, perLevel: 10, max: 200 },
            fireRate: { base: 2500, perLevel: -120, min: 800 }
        }
    },
    crystal: {
        cost: 3000,
        damage: 200,
        range: 350,
        fireRate: 3000,
        color: '#00ffff',
        beam: true,
        name: 'Crystal Prism',
        element: 'crystal',
        description: 'Refracts beams to hit multiple targets',
        refract: true,
        upgrades: {
            damage: { base: 200, perLevel: 40, max: 1000 },
            range: { base: 350, perLevel: 15, max: 600 },
            refractCount: { base: 3, perLevel: 1, max: 10 },
            fireRate: { base: 3000, perLevel: -150, min: 1000 }
        }
    },
    omega: {
        cost: 5000,
        damage: 500,
        range: 400,
        fireRate: 4000,
        color: '#ff0066',
        projectileSpeed: 20,
        name: 'Omega Cannon',
        element: 'omega',
        description: 'Ultimate weapon with devastating power',
        omegaBlast: true,
        upgrades: {
            damage: { base: 500, perLevel: 100, max: 2500 },
            range: { base: 400, perLevel: 20, max: 800 },
            blastRadius: { base: 100, perLevel: 15, max: 300 },
            fireRate: { base: 4000, perLevel: -200, min: 1500 }
        }
    }
};

// Enemy types - Increased health and rewards
const enemyTypes = {
    slime: { health: 80, speed: 1, reward: 15, color: '#88ff88', size: 18, glow: '#00ff00' },
    golem: { health: 250, speed: 0.6, reward: 35, color: '#8b7355', size: 25, glow: '#a0522d' },
    brute: { health: 800, speed: 0.4, reward: 150, color: '#654321', size: 35, glow: '#8b4513' },
    speeder: { health: 120, speed: 2.5, reward: 40, color: '#00ddff', size: 16, glow: '#00ffff' },
    tank: { health: 2000, speed: 0.25, reward: 300, color: '#555555', size: 40, glow: '#888888' },
    ghost: { health: 400, speed: 1.2, reward: 80, color: '#cc99ff', size: 20, glow: '#ff99ff', phasing: true },
    healer: { health: 500, speed: 0.8, reward: 100, color: '#ffcc00', size: 22, glow: '#ffff00', healing: true },
    splitter: { health: 300, speed: 1.1, reward: 60, color: '#ff6600', size: 24, glow: '#ff9900', splits: 2 },
    shielder: { health: 600, speed: 0.7, reward: 120, color: '#0099ff', size: 26, glow: '#00ccff', shield: 300 },
    bomber: { health: 350, speed: 1.3, reward: 90, color: '#ff0066', size: 23, glow: '#ff3399', explodeOnDeath: true },
    regenerator: { health: 700, speed: 0.9, reward: 140, color: '#00ff66', size: 25, glow: '#66ff99', regen: 5 },
    absorber: { health: 900, speed: 0.5, reward: 180, color: '#9900ff', size: 30, glow: '#cc66ff', damageReduction: 0.5 },
    teleporter: { health: 450, speed: 1.5, reward: 110, color: '#ff00ff', size: 21, glow: '#ff66ff', teleports: true },
    swarm: { health: 50, speed: 1.8, reward: 8, color: '#ffff66', size: 12, glow: '#ffff99' },
    boss: { health: 5000, speed: 0.3, reward: 1000, color: '#ff0000', size: 50, glow: '#ff6666', boss: true },
    // New enemies for levels 16-50
    voidwalker: { health: 1200, speed: 1.0, reward: 200, color: '#000033', size: 28, glow: '#6600cc', voidWalk: true },
    crystalGuard: { health: 1800, speed: 0.4, reward: 250, color: '#00ffff', size: 32, glow: '#66ffff', reflect: 0.3 },
    fireElemental: { health: 1000, speed: 1.2, reward: 180, color: '#ff6600', size: 26, glow: '#ffaa00', burnDamage: 10 },
    iceElemental: { health: 1500, speed: 0.8, reward: 220, color: '#99ccff', size: 28, glow: '#ccddff', slow: true },
    lightningElemental: { health: 800, speed: 1.5, reward: 200, color: '#ffff00', size: 24, glow: '#ffffcc', chainStrike: true },
    shadowAssassin: { health: 600, speed: 2.0, reward: 300, color: '#330033', size: 20, glow: '#660066', stealth: true },
    necromancer: { health: 2000, speed: 0.6, reward: 400, color: '#660066', size: 30, glow: '#990099', summons: true },
    timeBender: { health: 1000, speed: 1.0, reward: 350, color: '#0066ff', size: 25, glow: '#3399ff', timeWarp: true },
    plasmaBeast: { health: 2500, speed: 0.5, reward: 500, color: '#ff00ff', size: 35, glow: '#ff66ff', plasmaShield: 500 },
    quantumEntity: { health: 1500, speed: 1.3, reward: 450, color: '#00ff99', size: 27, glow: '#66ffcc', quantum: true },
    megaBoss: { health: 15000, speed: 0.2, reward: 3000, color: '#ff0066', size: 60, glow: '#ff3399', megaBoss: true },
    eliteTank: { health: 5000, speed: 0.3, reward: 600, color: '#333333', size: 45, glow: '#666666', armor: 50 },
    hyperSwarm: { health: 100, speed: 2.5, reward: 15, color: '#ffff00', size: 10, glow: '#ffffcc', hyperSwarm: true },
    corruptor: { health: 2000, speed: 0.7, reward: 700, color: '#006600', size: 32, glow: '#009900', corrupt: true },
    finalBoss: { health: 50000, speed: 0.15, reward: 10000, color: '#ff0000', size: 80, glow: '#ff9999', finalBoss: true }
};

// Tower class
class Tower {
    constructor(type, x, y) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.id = 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        this.stats = {...towerTypes[type]};
        this.lastShot = 0;
        this.rotation = 0;
        this.targetRotation = 0;
        this.level = 1;
        this.kills = 0;
        this.chargeAnimation = 0;
        this.beamTarget = null;
        this.idleAnimation = 0;
        this.targetPriority = 'closest';
        this.specialization = null;
        this.synergyBonus = 0;
        this.abilityCooldown = 0;
        this.abilityActive = false;
        this.abilityDuration = 0;
        this.stunned = 0;
        this.upgradeAnimation = 0;
        this.specializationAnimation = 0;
        this.specialAbilityCooldown = 0;
        this.specialAbilityActive = false;
    }
    
    checkSynergies() {
        this.synergyBonus = 0;
        let nearbyTypes = new Set();
        
        // Check for nearby towers
        for (let tower of towers) {
            if (tower !== this) {
                const dist = Math.sqrt(
                    Math.pow(tower.x - this.x, 2) +
                    Math.pow(tower.y - this.y, 2)
                );
                if (dist < 150) {
                    nearbyTypes.add(tower.type);
                }
            }
        }
        
        // Synergy bonuses
        if (this.type === 'laser' && nearbyTypes.has('tesla')) {
            this.synergyBonus += 0.2; // 20% damage boost
        }
        if (this.type === 'missile' && nearbyTypes.has('railgun')) {
            this.synergyBonus += 0.25; // 25% damage boost
        }
        if (this.type === 'tesla' && nearbyTypes.has('plasma')) {
            this.synergyBonus += 0.15; // 15% damage boost
        }
        if (nearbyTypes.size >= 3) {
            this.synergyBonus += 0.1; // Diversity bonus
        }
    }
    
    getUpgradeCost() {
        if (this.level >= 10) return 0;
        return Math.floor(this.stats.cost * Math.pow(1.6, this.level - 1));
    }
    
    upgrade() {
        const cost = this.getUpgradeCost();
        if (cost > 0 && money >= cost) {
            money -= cost;
            this.level++;
            this.stats.damage *= 1.15;
            this.stats.range *= 1.03;
            this.stats.fireRate *= 0.92;
            this.upgradeAnimation = 60; // Start upgrade animation
            
            if (this.level === 10 && !achievements.upgradeMax.unlocked) {
                unlockAchievement('upgradeMax');
            }
            
            updateUI();
            
            // Upgrade effects
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 5 + Math.random() * 10;
                particles.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: this.stats.color,
                    life: 1,
                    size: 5
                });
            }
            
            return true;
        }
        return false;
    }
    
    specialize(type) {
        if (this.level >= 5 && !this.specialization) {
            this.specialization = type;
            
            // Enhanced tower-specific specialization bonuses
            const towerSpecs = {
                pulse: {
                    power: {
                        damage: 2.2,
                        fireRate: 0.8,
                        critChance: 0.25,
                        ability: 'rapidfire' // 3 seconds of 3x fire rate
                    },
                    speed: {
                        fireRate: 0.4,
                        projectileSpeed: 2.5,
                        multishot: 2,
                        ability: 'overdrive' // 5 seconds of no reload
                    },
                    effect: {
                        damage: 1.5,
                        slow: 0.4,
                        pierce: 3,
                        ability: 'freeze' // Freezes all enemies in range for 2 seconds
                    }
                },
                laser: {
                    power: {
                        damage: 2.5,
                        beamWidth: 3,
                        burnDps: 10,
                        ability: 'megabeam' // 3x damage beam for 4 seconds
                    },
                    speed: {
                        fireRate: 0.2,
                        range: 1.8,
                        chainBeams: 2,
                        ability: 'prism' // Splits into 5 beams
                    },
                    effect: {
                        penetrate: true,
                        weaken: 0.3,
                        chainCount: 3,
                        ability: 'disintegrate' // Instant kill enemies below 30% health
                    }
                },
                missile: {
                    power: {
                        damage: 3.0,
                        splashRadius: 2.5,
                        stunDuration: 1.0,
                        ability: 'nuke' // Massive explosion dealing 1000 damage
                    },
                    speed: {
                        fireRate: 0.3,
                        projectileSpeed: 4.0,
                        barrage: 3,
                        ability: 'cluster' // Fires 10 missiles at once
                    },
                    effect: {
                        splashRadius: 3.5,
                        burnDps: 15,
                        fragment: 8,
                        ability: 'napalm' // Leaves burning area for 10 seconds
                    }
                },
                tesla: {
                    power: {
                        damage: 2.0,
                        chainCount: 4,
                        stunChance: 0.5,
                        ability: 'thunderstorm' // Chain lightning hits all enemies
                    },
                    speed: {
                        fireRate: 0.3,
                        chainSpeed: 3.0,
                        instantChain: true,
                        ability: 'surge' // Double chain count for 5 seconds
                    },
                    effect: {
                        chainCount: 6,
                        range: 1.6,
                        emp: true,
                        ability: 'emp' // Disables all enemy abilities for 5 seconds
                    }
                },
                plasma: {
                    power: {
                        damage: 3.2,
                        splashRadius: 2.0,
                        meltArmor: true,
                        ability: 'meltdown' // Continuous damage aura
                    },
                    speed: {
                        fireRate: 0.2,
                        projectileSpeed: 3.5,
                        homing: 2.0,
                        ability: 'plasma_volley' // Rapid fire plasma bursts
                    },
                    effect: {
                        splashRadius: 3.0,
                        slow: 0.7,
                        dot: 20,
                        ability: 'plasma_field' // Creates damaging field
                    }
                },
                railgun: {
                    power: {
                        damage: 4.0,
                        pierce: 999,
                        critMultiplier: 3.0,
                        ability: 'piercing_shot' // One shot pierces all enemies
                    },
                    speed: {
                        fireRate: 0.2,
                        range: 2.0,
                        instantHit: true,
                        ability: 'rapid_rail' // Machine gun mode
                    },
                    effect: {
                        stunDuration: 1.5,
                        knockback: 100,
                        shred: 0.7,
                        ability: 'shockwave' // Knockback wave
                    }
                },
                quantum: {
                    power: {
                        damage: 2.8,
                        phaseShift: true,
                        voidDamage: 0.5,
                        ability: 'void_rift' // Creates damaging rift
                    },
                    speed: {
                        fireRate: 0.3,
                        teleportShots: true,
                        multiverse: 3,
                        ability: 'time_warp' // Slows time in area
                    },
                    effect: {
                        slow: 0.9,
                        confuse: true,
                        reality_tear: true,
                        ability: 'singularity' // Mini black hole
                    }
                },
                void: {
                    power: {
                        damage: 3.5,
                        pullForce: 200,
                        crushDamage: 50,
                        ability: 'black_hole' // Massive gravity well
                    },
                    speed: {
                        fireRate: 0.2,
                        range: 2.0,
                        vortexSpeed: 2.0,
                        ability: 'gravity_pulse' // Pulls then pushes
                    },
                    effect: {
                        pullForce: 300,
                        slow: 0.98,
                        implode: true,
                        ability: 'void_prison' // Traps enemies
                    }
                },
                prism: {
                    power: {
                        damage: 2.8,
                        splitCount: 5,
                        rainbow: true,
                        ability: 'spectrum' // All damage types
                    },
                    speed: {
                        fireRate: 0.3,
                        beamCount: 8,
                        instantSplit: true,
                        ability: 'disco' // Rotating laser show
                    },
                    effect: {
                        splitCount: 10,
                        refract: true,
                        blind: 0.5,
                        ability: 'kaleidoscope' // Confuses and damages
                    }
                },
                omega: {
                    power: {
                        damage: 5.0,
                        annihilate: true,
                        overkill: true,
                        ability: 'doomsday' // Screen clear
                    },
                    speed: {
                        fireRate: 0.1,
                        omnishot: true,
                        instantKill: 0.15,
                        ability: 'time_stop' // Freezes all enemies
                    },
                    effect: {
                        damage: 3.0,
                        apocalypse: true,
                        cascade: 15,
                        ability: 'omega_wave' // Expanding death wave
                    }
                }
            };
            
            const specs = towerSpecs[this.type]?.[type] || {
                power: { damage: 1.8, fireRate: 0.85 },
                speed: { fireRate: 0.5, projectileSpeed: 1.8 },
                effect: { range: 1.4, special: true }
            }[type];
            
            // Apply specialization bonuses
            Object.entries(specs).forEach(([key, value]) => {
                if (key === 'ability') {
                    this.specialAbility = value;
                } else if (key === 'damage' || key === 'range' || key === 'projectileSpeed') {
                    if (this.stats[key]) this.stats[key] *= value;
                } else if (key === 'fireRate') {
                    this.stats.fireRate *= value;
                } else if (key === 'splashRadius') {
                    if (!this.stats.splashRadius) this.stats.splashRadius = 60;
                    this.stats.splashRadius *= value;
                } else if (key === 'chainCount') {
                    if (!this.stats.chainCount) this.stats.chainCount = 0;
                    this.stats.chainCount += value;
                    this.stats.chain = true;
                } else {
                    this.stats[key] = value;
                }
            });
            
            // Visual effect for specialization
            this.specializationAnimation = 120;
            
            // Create epic specialization particles
            const colors = {
                power: '#ff4444',
                speed: '#44ff44',
                effect: '#4444ff'
            };
            
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2;
                const speed = 10 + Math.random() * 15;
                particles.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: colors[type],
                    life: 1,
                    size: 10,
                    type: 'spark'
                });
            }
            
            // Show notification
            const specNames = {
                power: 'üí• Power',
                speed: '‚ö° Speed', 
                effect: '‚ú® Effect'
            };
            showNotification(`${this.stats.name} specialized: ${specNames[type]}!`);
            
            // Play sound
            playSound('achievement');
            
            if (!achievements.specialization.unlocked) {
                unlockAchievement('specialization');
            }
        }
    }
    
    activateSpecialAbility() {
        if (this.specialAbility && this.specialAbilityCooldown <= 0) {
            this.specialAbilityActive = true;
            this.specialAbilityCooldown = 600; // 10 second cooldown
            
            // Execute ability based on type
            switch(this.specialAbility) {
                case 'freeze':
                    // Freeze all enemies in range
                    enemies.forEach(enemy => {
                        const dist = Math.sqrt(
                            Math.pow(enemy.position.x - this.x, 2) +
                            Math.pow(enemy.position.y - this.y, 2)
                        );
                        if (dist <= this.stats.range) {
                            enemy.frozen = 120; // 2 seconds
                        }
                    });
                    // Freeze effect
                    for (let i = 0; i < 30; i++) {
                        const angle = (i / 30) * Math.PI * 2;
                        particles.push({
                            x: this.x + Math.cos(angle) * this.stats.range,
                            y: this.y + Math.sin(angle) * this.stats.range,
                            vx: 0,
                            vy: -2,
                            color: '#00ffff',
                            life: 1,
                            size: 8,
                            type: 'snowflake'
                        });
                    }
                    playSound('freeze');
                    break;
                    
                case 'nuke':
                    // Find nearest enemy and nuke area
                    const target = this.findTarget();
                    if (target) {
                        // Deal massive damage in area
                        enemies.forEach(enemy => {
                            const dist = Math.sqrt(
                                Math.pow(enemy.position.x - target.position.x, 2) +
                                Math.pow(enemy.position.y - target.position.y, 2)
                            );
                            if (dist <= 150) {
                                enemy.takeDamage(1000 * (1 - dist / 150));
                            }
                        });
                        // Nuke explosion effect
                        for (let i = 0; i < 100; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 30;
                            particles.push({
                                x: target.position.x,
                                y: target.position.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                color: ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                life: 1,
                                size: 15,
                                type: 'explosion'
                            });
                        }
                        screenShake = 30;
                        playSound('explosion');
                    }
                    break;
                    
                case 'time_stop':
                    // Stop all enemies for 3 seconds
                    enemies.forEach(enemy => {
                        enemy.timeStop = 180;
                    });
                    // Time stop visual
                    ctx.save();
                    ctx.fillStyle = 'rgba(128, 128, 255, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                    playSound('powerup');
                    break;
                    
                case 'black_hole':
                    // Create a black hole that pulls enemies
                    this.blackHoleActive = 300; // 5 seconds
                    this.blackHoleX = this.x;
                    this.blackHoleY = this.y;
                    playSound('void');
                    break;
                    
                // Add more ability implementations as needed
                default:
                    // Generic powerful attack
                    this.stats.damage *= 3;
                    setTimeout(() => {
                        this.stats.damage /= 3;
                    }, 3000);
                    break;
            }
            
            showNotification(`üéÜ ${this.stats.name} used special ability!`);
        }
    }
    
    update() {
        this.idleAnimation += 0.05 * gameSpeed;
        
        // Update special ability cooldown
        if (this.specialAbilityCooldown > 0) {
            this.specialAbilityCooldown -= gameSpeed;
        }
        
        // Handle black hole special ability
        if (this.blackHoleActive > 0) {
            this.blackHoleActive -= gameSpeed;
            // Pull enemies toward black hole
            enemies.forEach(enemy => {
                const dx = this.blackHoleX - enemy.position.x;
                const dy = this.blackHoleY - enemy.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 10 && dist < 300) {
                    const pullForce = 200 / dist;
                    enemy.position.x += (dx / dist) * pullForce * gameSpeed;
                    enemy.position.y += (dy / dist) * pullForce * gameSpeed;
                    enemy.takeDamage(2 * gameSpeed);
                }
            });
        }
        
        // Update stun
        if (this.stunned > 0) {
            this.stunned -= gameSpeed;
            return; // Can't do anything while stunned
        }
        
        // Update upgrade animation
        if (this.upgradeAnimation > 0) {
            this.upgradeAnimation -= gameSpeed;
        }
        
        // Update ability cooldown
        if (this.abilityCooldown > 0) {
            this.abilityCooldown -= gameSpeed;
        }
        
        // Update ability duration
        if (this.abilityDuration > 0) {
            this.abilityDuration -= gameSpeed;
            if (this.abilityDuration <= 0) {
                this.abilityActive = false;
            }
        }
        
        // Smooth rotation
        const rotDiff = this.targetRotation - this.rotation;
        this.rotation += rotDiff * 0.2;
        
        const now = Date.now();
        let effectiveFireRate = this.stats.fireRate;
        
        // Pulse ability: double fire rate
        if (this.type === 'pulse' && this.abilityActive) {
            effectiveFireRate *= 0.5;
        }
        
        if (now - this.lastShot > effectiveFireRate / gameSpeed) {
            const target = this.findTarget();
            if (target) {
                this.targetRotation = Math.atan2(target.position.y - this.y, target.position.x - this.x);
                this.shoot(target);
                this.lastShot = now;
            } else {
                this.beamTarget = null;
            }
        }
        
        if (this.chargeAnimation > 0) {
            this.chargeAnimation -= gameSpeed;
        }
    }
    
    findTarget() {
        let targets = [];
        const effectiveRange = this.stats.range;
        
        // Get all enemies in range
        for (let enemy of enemies) {
            if (enemy.inTunnel) continue;
            
            const dist = Math.sqrt(
                Math.pow(enemy.position.x - this.x, 2) +
                Math.pow(enemy.position.y - this.y, 2)
            );
            
            if (dist < effectiveRange) {
                targets.push({ enemy, dist });
            }
        }
        
        if (targets.length === 0) return null;
        
        // Sort by priority
        switch(this.targetPriority) {
            case 'first':
                return targets.sort((a, b) => b.enemy.pathProgress - a.enemy.pathProgress)[0].enemy;
            case 'last':
                return targets.sort((a, b) => a.enemy.pathProgress - b.enemy.pathProgress)[0].enemy;
            case 'closest':
                return targets.sort((a, b) => a.dist - b.dist)[0].enemy;
            case 'strongest':
                return targets.sort((a, b) => b.enemy.health - a.enemy.health)[0].enemy;
            case 'weakest':
                return targets.sort((a, b) => a.enemy.health - b.enemy.health)[0].enemy;
            default:
                return targets[0].enemy;
        }
    }
    
    shoot(target) {
        this.chargeAnimation = 10;
        const damage = this.stats.damage * (1 + this.synergyBonus);
        
        if (this.stats.beam) {
            // Laser beam
            this.beamTarget = target;
            if (target.takeDamage(damage, target.position.x, target.position.y)) {
                enemies = enemies.filter(e => e !== target);
                this.kills++;
                totalKills++;
                this.beamTarget = null;
            }
        } else if (this.stats.chain) {
            // Tesla chain lightning
            const hitTargets = [target];
            let currentTarget = target;
            
            beams.push({
                type: 'lightning',
                from: { x: this.x, y: this.y },
                to: { x: target.position.x, y: target.position.y },
                color: this.stats.color,
                life: 10
            });
            
            if (currentTarget.takeDamage(damage, currentTarget.position.x, currentTarget.position.y)) {
                enemies = enemies.filter(e => e !== currentTarget);
                this.kills++;
                totalKills++;
            }
            
            // Chain to nearby enemies
            const chainCount = this.stats.chainCount;
            for (let i = 0; i < chainCount; i++) {
                let nearestEnemy = null;
                let nearestDist = 150;
                
                for (let enemy of enemies) {
                    if (hitTargets.includes(enemy) || enemy.inTunnel) continue;
                    
                    const dist = Math.sqrt(
                        Math.pow(enemy.position.x - currentTarget.position.x, 2) +
                        Math.pow(enemy.position.y - currentTarget.position.y, 2)
                    );
                    
                    if (dist < nearestDist) {
                        nearestEnemy = enemy;
                        nearestDist = dist;
                    }
                }
                
                if (nearestEnemy) {
                    beams.push({
                        type: 'lightning',
                        from: { x: currentTarget.position.x, y: currentTarget.position.y },
                        to: { x: nearestEnemy.position.x, y: nearestEnemy.position.y },
                        color: this.stats.color,
                        life: 10
                    });
                    
                    hitTargets.push(nearestEnemy);
                    if (nearestEnemy.takeDamage(damage * 0.7, nearestEnemy.position.x, nearestEnemy.position.y)) {
                        enemies = enemies.filter(e => e !== nearestEnemy);
                        this.kills++;
                        totalKills++;
                    }
                    currentTarget = nearestEnemy;
                } else {
                    break;
                }
            }
        } else {
            // Projectile weapon
            projectiles.push({
                x: this.x,
                y: this.y,
                target: target,
                damage: damage,
                color: this.stats.color,
                speed: this.stats.projectileSpeed || 10,
                type: this.type,
                trail: [],
                rotation: Math.atan2(target.position.y - this.y, target.position.x - this.x),
                towerRef: this,
                homing: this.stats.homing,
                pierce: this.stats.pierce,
                explosive: this.stats.explosive,
                splash: this.stats.splash,
                splashRadius: this.stats.splashRadius
            });
        }
    }
    
    activateAbility() {
        if (this.abilityCooldown > 0 || this.level < 5) return;
        
        this.abilityActive = true;
        this.abilityCooldown = 300; // 5 seconds at 60fps
        
        switch(this.type) {
            case 'pulse':
                // Overcharge: Double fire rate for 3 seconds
                this.abilityDuration = 180;
                break;
            case 'laser':
                // Beam Sweep: Hit all enemies in range
                this.beamSweep();
                break;
            case 'missile':
                // Missile Barrage: Launch 5 missiles at once
                this.missileBarrage();
                break;
            case 'tesla':
                // Lightning Storm: Chain to all enemies in range
                this.lightningStorm();
                break;
            case 'plasma':
                // Plasma Nova: Massive explosion
                this.plasmaNova();
                break;
            case 'railgun':
                // Penetrating Shot: Super pierce shot
                this.railgunBlast();
                break;
        }
    }
    
    beamSweep() {
        const inRange = enemies.filter(enemy => {
            if (enemy.inTunnel) return false;
            const dist = Math.sqrt(
                Math.pow(enemy.position.x - this.x, 2) +
                Math.pow(enemy.position.y - this.y, 2)
            );
            return dist < this.stats.range;
        });
        
        inRange.forEach(enemy => {
            const damage = this.stats.damage * (1 + this.synergyBonus) * 3;
            if (enemy.takeDamage(damage, enemy.position.x, enemy.position.y)) {
                enemies = enemies.filter(e => e !== enemy);
                this.kills++;
                totalKills++;
            }
        });
        
        // Visual effect
        addScreenShake(10);
    }
    
    missileBarrage() {
        const targets = enemies.filter(enemy => !enemy.inTunnel).slice(0, 5);
        targets.forEach(target => {
            projectiles.push({
                x: this.x,
                y: this.y,
                target: target,
                damage: this.stats.damage * (1 + this.synergyBonus) * 2,
                color: this.stats.color,
                speed: this.stats.projectileSpeed * 1.5,
                type: this.type,
                trail: [],
                rotation: Math.atan2(target.position.y - this.y, target.position.x - this.x),
                towerRef: this,
                homing: true,
                explosive: true
            });
        });
    }
    
    lightningStorm() {
        const allEnemies = enemies.filter(enemy => {
            if (enemy.inTunnel) return false;
            const dist = Math.sqrt(
                Math.pow(enemy.position.x - this.x, 2) +
                Math.pow(enemy.position.y - this.y, 2)
            );
            return dist < this.stats.range * 1.5;
        });
        
        allEnemies.forEach(enemy => {
            beams.push({
                type: 'lightning',
                from: { x: this.x, y: this.y },
                to: { x: enemy.position.x, y: enemy.position.y },
                color: this.stats.color,
                life: 20
            });
            
            const damage = this.stats.damage * (1 + this.synergyBonus) * 0.5;
            if (enemy.takeDamage(damage, enemy.position.x, enemy.position.y)) {
                enemies = enemies.filter(e => e !== enemy);
                this.kills++;
                totalKills++;
            }
        });
        
        addScreenShake(15);
    }
    
    plasmaNova() {
        // Create massive explosion
        const x = this.x;
        const y = this.y;
        const radius = 150;
        
        enemies.forEach(enemy => {
            if (enemy.inTunnel) return;
            const dist = Math.sqrt(
                Math.pow(enemy.position.x - x, 2) +
                Math.pow(enemy.position.y - y, 2)
            );
            if (dist < radius) {
                const damage = this.stats.damage * (1 + this.synergyBonus) * 4 * (1 - dist / radius);
                if (enemy.takeDamage(damage, enemy.position.x, enemy.position.y)) {
                    enemies = enemies.filter(e => e !== enemy);
                    this.kills++;
                    totalKills++;
                }
            }
        });
        
        // Visual explosion
        for (let i = 0; i < 50; i++) {
            const angle = (i / 50) * Math.PI * 2;
            const speed = 10 + Math.random() * 20;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                color: this.stats.color,
                life: 1,
                size: 10
            });
        }
        
        addScreenShake(20);
    }
    
    railgunBlast() {
        // Fire a super powerful piercing shot
        const target = this.findTarget();
        if (target) {
            projectiles.push({
                x: this.x,
                y: this.y,
                target: target,
                damage: this.stats.damage * (1 + this.synergyBonus) * 5,
                color: '#ffffff',
                speed: this.stats.projectileSpeed * 2,
                type: 'super_railgun',
                trail: [],
                rotation: Math.atan2(target.position.y - this.y, target.position.x - this.x),
                towerRef: this,
                pierce: true,
                pierceCount: 999
            });
            
            addScreenShake(8);
        }
    }
    
    draw() {
        const x = this.x - camera.x;
        const y = this.y - camera.y;
        const scale = getScaleFactor();
        
        // Idle animation
        this.idleAnimation += 0.02;
        
        // Upgrade animation effect
        if (this.upgradeAnimation > 0) {
            const upgradeScale = 1 + (this.upgradeAnimation / 60) * 0.3;
            ctx.save();
            ctx.globalAlpha = this.upgradeAnimation / 60;
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.arc(x, y, 40 * scale * upgradeScale, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        
        // Stun effect
        if (this.stunned > 0) {
            ctx.save();
            ctx.globalAlpha = 0.5;
            // Draw electric sparks around stunned tower
            const sparkCount = 5;
            for (let i = 0; i < sparkCount; i++) {
                const angle = (Math.PI * 2 * i) / sparkCount + Date.now() * 0.002;
                const sparkX = x + Math.cos(angle) * 30 * scale;
                const sparkY = y + Math.sin(angle) * 30 * scale;
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(sparkX, sparkY);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        // Tower base with gradient and glow
        ctx.save();
        
        // Base glow effect (reduced when stunned)
        const glowIntensity = this.stunned > 0 ? '20' : '40';
        const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 50 * scale);
        glowGradient.addColorStop(0, this.stats.color + glowIntensity);
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(x - 50 * scale, y - 50 * scale, 100 * scale, 100 * scale);
        
        // Base platform
        const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, 35 * scale);
        baseGradient.addColorStop(0, 'rgba(80,80,120,0.9)');
        baseGradient.addColorStop(0.7, 'rgba(50,50,80,0.9)');
        baseGradient.addColorStop(1, 'rgba(30,30,60,0.9)');
        ctx.fillStyle = baseGradient;
        ctx.beginPath();
        ctx.arc(x, y, 35 * scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Base ring
        ctx.strokeStyle = this.stats.color;
        ctx.lineWidth = 3 * scale;
        ctx.stroke();
        
        // Inner ring
        ctx.beginPath();
        ctx.arc(x, y, 28 * scale, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1 * scale;
        ctx.stroke();
        
        ctx.restore();
        
        // Tower body
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        
        // Draw based on tower type
        if (this.type === 'laser') {
            this.drawLaserTower(scale);
        } else if (this.type === 'missile') {
            this.drawMissileTower(scale);
        } else if (this.type === 'tesla') {
            this.drawTeslaTower(scale);
        } else if (this.type === 'pulse') {
            this.drawPulseTower(scale);
        } else if (this.type === 'plasma') {
            this.drawPlasmaTower(scale);
        } else if (this.type === 'railgun') {
            this.drawRailgunTower(scale);
        } else if (this.type === 'quantum') {
            this.drawQuantumTower(scale);
        } else if (this.type === 'void') {
            this.drawVoidTower(scale);
        } else if (this.type === 'crystal') {
            this.drawCrystalTower(scale);
        } else if (this.type === 'omega') {
            this.drawOmegaTower(scale);
        }
        
        ctx.restore();
        
        // Level indicator
        if (this.level > 1) {
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${12 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText(`Lv${this.level}`, x, y - 40 * scale);
        }
        
        // Specialization indicator
        if (this.specialization) {
            const specIcon = this.specialization === 'power' ? 'üí•' :
                           this.specialization === 'speed' ? '‚ö°' :
                           this.specialization === 'effect' ? '‚ú®' :
                           this.specialization === 'special' ? '‚ú®' : '';
            ctx.fillText(specIcon, x + 25 * scale, y - 25 * scale);
        }
        
        // Range indicator when selected or hovered
        if (selectedTower === this || hoveredTower === this) {
            ctx.strokeStyle = this.stats.color + '44';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(x, y, this.stats.range * getScaleFactor(), 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Show range number
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${14 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText(`Range: ${Math.round(this.stats.range)}`, x, y + 55 * scale);
        } else if (this.showFaintRange) {
            // Faint range indicator when mouse is near
            ctx.strokeStyle = this.stats.color + '22';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 10]);
            ctx.beginPath();
            ctx.arc(x, y, this.stats.range * getScaleFactor(), 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Selection indicator
        if (selectedTower === this) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 40 * scale, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Draw beam if active
        if (this.stats.beam && this.beamTarget && enemies.includes(this.beamTarget) && !this.beamTarget.inTunnel) {
            const gradient = ctx.createLinearGradient(x, y,
                this.beamTarget.position.x - camera.x,
                this.beamTarget.position.y - camera.y);
            gradient.addColorStop(0, this.stats.color);
            gradient.addColorStop(0.5, '#ffffff');
            gradient.addColorStop(1, this.stats.color);
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4 * scale;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(this.beamTarget.position.x - camera.x, this.beamTarget.position.y - camera.y);
            ctx.stroke();
        }
        
        // Draw synergy indicators (skip in performance mode)
        if (!performanceMode && this.synergyBonus > 0) {
            // Synergy aura effect
            const synergyPulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
            ctx.save();
            
            // Outer synergy ring
            const synergyGrad = ctx.createRadialGradient(x, y, 35 * scale, x, y, 45 * scale);
            synergyGrad.addColorStop(0, `rgba(255, 215, 0, ${0.2 * synergyPulse})`);
            synergyGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = synergyGrad;
            ctx.beginPath();
            ctx.arc(x, y, 45 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Synergy particles
            const particleCount = Math.floor(this.synergyBonus * 10);
            for (let i = 0; i < particleCount; i++) {
                const angle = (Date.now() * 0.001 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
                const radius = 40 * scale + Math.sin(Date.now() * 0.002 + i) * 5 * scale;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                
                ctx.fillStyle = `rgba(255, 215, 0, ${0.6 * synergyPulse})`;
                ctx.beginPath();
                ctx.arc(px, py, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Synergy bonus text
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${10 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText(`+${Math.floor(this.synergyBonus * 100)}%`, x, y + 50 * scale);
            
            ctx.restore();
        }
        
        // Draw ability indicators
        if (this.level >= 5) {
            const abilityX = x + 30 * scale;
            const abilityY = y - 30 * scale;
            
            // Ability button background
            const abilityGrad = ctx.createRadialGradient(abilityX, abilityY, 0, abilityX, abilityY, 15 * scale);
            if (this.abilityCooldown > 0) {
                // On cooldown
                const cooldownPercent = this.abilityCooldown / 300;
                abilityGrad.addColorStop(0, `rgba(100, 100, 100, 0.8)`);
                abilityGrad.addColorStop(1, `rgba(50, 50, 50, 0.8)`);
                
                // Draw cooldown arc
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 3 * scale;
                ctx.beginPath();
                ctx.arc(abilityX, abilityY, 12 * scale, -Math.PI/2, -Math.PI/2 + (1 - cooldownPercent) * Math.PI * 2);
                ctx.stroke();
            } else {
                // Ready to use
                const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
                abilityGrad.addColorStop(0, `rgba(255, 215, 0, ${pulse})`);
                abilityGrad.addColorStop(1, `rgba(255, 140, 0, ${pulse})`);
            }
            
            ctx.fillStyle = abilityGrad;
            ctx.beginPath();
            ctx.arc(abilityX, abilityY, 12 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Ability icon
            ctx.fillStyle = this.abilityCooldown > 0 ? '#666' : '#fff';
            ctx.font = `bold ${14 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('!', abilityX, abilityY);
            
            // Active ability effect
            if (this.abilityActive) {
                const activeGlow = ctx.createRadialGradient(x, y, 0, x, y, 60 * scale);
                activeGlow.addColorStop(0, `rgba(255, 215, 0, 0.3)`);
                activeGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = activeGlow;
                ctx.beginPath();
                ctx.arc(x, y, 60 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    drawPulseTower(scale) {
        // Optimized Premium Pulse Cannon - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.15 + 0.85;

        ctx.save();

        // Simple base - solid color
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(-15 * scale, -12 * scale, 30 * scale, 24 * scale);

        // Barrel
        ctx.fillStyle = '#00cc66';
        ctx.fillRect(15 * scale, -8 * scale, 20 * scale, 16 * scale);

        // Glowing core - single gradient
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 12 * scale);
        coreGrad.addColorStop(0, '#ffffff');
        coreGrad.addColorStop(0.5, '#00ff88');
        coreGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = coreGrad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawLaserTower(scale) {
        // Optimized Premium Laser Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base circle
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Glowing core
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 12 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#ff0000');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawMissileTower(scale) {
        // Optimized Premium Missile Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base platform
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(-15 * scale, -12 * scale, 30 * scale, 24 * scale);

        // Missile launcher
        ctx.fillStyle = '#cc5500';
        ctx.fillRect(15 * scale, -8 * scale, 25 * scale, 16 * scale);

        // Glowing tip
        const grad = ctx.createRadialGradient(40 * scale, 0, 0, 40 * scale, 0, 8 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#ff6600');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(40 * scale, 0, 8 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawTeslaTower(scale) {
        // Optimized Premium Tesla Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base coil
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(-10 * scale, -15 * scale, 20 * scale, 30 * scale);

        // Glowing orb
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#ffff00');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawPlasmaTower(scale) {
        // Optimized Premium Plasma Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base circle
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(0, 0, 16 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Glowing core
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#ff00ff');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 14 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawRailgunTower(scale) {
        // Optimized Premium Railgun Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base core
        ctx.fillStyle = '#00ffff';
        ctx.beginPath();
        ctx.arc(0, 0, 14 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Rail barrel
        ctx.fillStyle = '#00cccc';
        ctx.fillRect(10 * scale, -6 * scale, 40 * scale, 12 * scale);

        // Glowing energy
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 12 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#00ffff');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawQuantumTower(scale) {
        // Optimized Premium Quantum Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base hexagon
        ctx.fillStyle = '#9400d3';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const x = Math.cos(angle) * 15 * scale;
            const y = Math.sin(angle) * 15 * scale;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        // Glowing quantum core
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 12 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#9400d3');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawVoidTower(scale) {
        // Optimized Premium Void Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base dark circle
        ctx.fillStyle = '#4b0082';
        ctx.beginPath();
        ctx.arc(0, 0, 17 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Dark void core
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14 * scale);
        grad.addColorStop(0, '#000000');
        grad.addColorStop(0.5, '#4b0082');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 14 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawCrystalTower(scale) {
        // Optimized Premium Crystal Tower - smooth & fast
        const pulse = Math.sin(this.idleAnimation * 2) * 0.2 + 0.8;
        ctx.save();

        // Base diamond
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(0, -16 * scale);
        ctx.lineTo(16 * scale, 0);
        ctx.lineTo(0, 16 * scale);
        ctx.lineTo(-16 * scale, 0);
        ctx.closePath();
        ctx.fill();

        // Glowing prism
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 13 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#e0e0ff');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 13 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
    
    drawOmegaTower(scale) {
        // Optimized Premium Omega Tower - smooth & fast, THE ULTIMATE WEAPON
        const pulse = Math.sin(this.idleAnimation * 2) * 0.3 + 0.7;
        ctx.save();

        // Base star
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI / 4) * i;
            const radius = i % 2 === 0 ? 18 * scale : 10 * scale;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        // Glowing ultimate core
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15 * scale);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#ffd700');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = pulse;
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
    }
}

// Enemy class
class Enemy {
    constructor(type) {
        this.type = type;
        this.pathIndex = 0;
        this.pathProgress = 0;
        this.position = { x: path[0].x, y: path[0].y };
        this.health = enemyTypes[type].health;
        this.maxHealth = this.health;
        this.speed = enemyTypes[type].speed;
        this.reward = enemyTypes[type].reward;
        this.color = enemyTypes[type].color;
        this.size = enemyTypes[type].size;
        this.rotation = 0;
        this.hitFlash = 0;
        this.inTunnel = false;
        
        // Special properties
        this.shield = enemyTypes[type].shield || 0;
        this.maxShield = this.shield;
        this.phasing = enemyTypes[type].phasing || false;
        this.phaseTimer = 0;
        this.teleportCooldown = 0;
        this.regenRate = enemyTypes[type].regen || 0;
        this.lastRegen = Date.now();
        this.damageReduction = enemyTypes[type].damageReduction || 0;
        this.splits = enemyTypes[type].splits || 0;
        this.explodeOnDeath = enemyTypes[type].explodeOnDeath || false;
        this.healing = enemyTypes[type].healing || false;
        this.healCooldown = 0;
        this.teleports = enemyTypes[type].teleports || false;
        this.boss = enemyTypes[type].boss || false;
        
        // Health bar display
        this.healthBarVisible = 0;
        this.lastHitTime = 0;
        
        // Boss abilities
        this.megaBoss = enemyTypes[type].megaBoss || false;
        this.finalBoss = enemyTypes[type].finalBoss || false;
        this.bossAbilityCooldown = 0;
        this.summonCooldown = 0;
        this.stunWaveCooldown = 0;
    }
    
    update() {
        // Update health bar visibility
        if (this.healthBarVisible > 0) {
            this.healthBarVisible -= gameSpeed;
        }
        
        // Boss abilities
        if (this.megaBoss && this.summonCooldown <= 0) {
            // Summon minions
            if (Math.random() < 0.005) {
                for (let i = 0; i < 3; i++) {
                    const minion = new Enemy('slime');
                    minion.pathIndex = this.pathIndex;
                    minion.pathProgress = Math.max(0, this.pathProgress - 0.1 * i);
                    minion.position.x = this.position.x + (Math.random() - 0.5) * 60;
                    minion.position.y = this.position.y + (Math.random() - 0.5) * 60;
                    enemies.push(minion);
                }
                this.summonCooldown = 300;
                
                // Visual effect
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: this.position.x,
                        y: this.position.y,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        color: '#ff0066',
                        life: 1,
                        size: 8
                    });
                }
            }
        }
        if (this.summonCooldown > 0) this.summonCooldown--;
        
        if (this.finalBoss && this.stunWaveCooldown <= 0) {
            // Stun wave ability
            if (Math.random() < 0.003) {
                towers.forEach(tower => {
                    const dist = Math.sqrt(
                        Math.pow(tower.x - this.position.x, 2) +
                        Math.pow(tower.y - this.position.y, 2)
                    );
                    if (dist < 200) {
                        tower.stunned = 120; // Stun for 2 seconds
                    }
                });
                this.stunWaveCooldown = 600;
                
                // Visual shockwave
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 * i) / 30;
                    particles.push({
                        x: this.position.x,
                        y: this.position.y,
                        vx: Math.cos(angle) * 20,
                        vy: Math.sin(angle) * 20,
                        color: '#ff00ff',
                        life: 1,
                        size: 10
                    });
                }
            }
        }
        if (this.stunWaveCooldown > 0) this.stunWaveCooldown--;
        
        // Handle special abilities
        if (this.phasing) {
            this.phaseTimer++;
            this.inTunnel = Math.sin(this.phaseTimer * 0.1) > 0;
        }
        
        if (this.regenRate > 0 && Date.now() - this.lastRegen > 1000) {
            this.health = Math.min(this.maxHealth, this.health + this.regenRate);
            this.lastRegen = Date.now();
        }
        
        if (this.healing && this.healCooldown <= 0) {
            // Heal nearby enemies
            enemies.forEach(enemy => {
                if (enemy !== this && !enemy.inTunnel) {
                    const dist = Math.sqrt(
                        Math.pow(enemy.position.x - this.position.x, 2) +
                        Math.pow(enemy.position.y - this.position.y, 2)
                    );
                    if (dist < 100) {
                        enemy.health = Math.min(enemy.maxHealth, enemy.health + 20);
                        this.healCooldown = 60;
                    }
                }
            });
        }
        if (this.healCooldown > 0) this.healCooldown--;
        
        if (this.teleports && this.teleportCooldown <= 0 && Math.random() < 0.01) {
            // Teleport forward
            this.pathIndex = Math.min(path.length - 2, this.pathIndex + 3);
            this.pathProgress = 0;
            this.teleportCooldown = 120;
            
            // Teleport effect
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: this.position.x,
                    y: this.position.y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: '#ff00ff',
                    life: 1,
                    size: 5
                });
            }
        }
        if (this.teleportCooldown > 0) this.teleportCooldown--;
        
        if (this.pathIndex < path.length - 1) {
            const current = path[this.pathIndex];
            const next = path[this.pathIndex + 1];
            const dx = next.x - current.x;
            const dy = next.y - current.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            this.pathProgress += (this.speed * gameSpeed) / distance;
            
            if (this.pathProgress >= 1) {
                this.pathIndex++;
                this.pathProgress = 0;
                if (this.pathIndex >= path.length - 1) {
                    return false;
                }
                if (!this.phasing) {
                    this.inTunnel = path[this.pathIndex].tunnel || false;
                }
            }
            
            this.position.x = current.x + dx * this.pathProgress;
            this.position.y = current.y + dy * this.pathProgress;
            this.rotation = Math.atan2(dy, dx);
            
            if (!this.phasing && (current.tunnel || next.tunnel)) {
                this.inTunnel = true;
            }
        } else {
            // Move towards base
            const dx = base.x + base.width/2 - this.position.x;
            const dy = base.y + base.height/2 - this.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 30) {
                health -= this.boss ? 50 : 10;
                updateUI();
                return true;
            }
            
            this.position.x += (dx / distance) * this.speed * gameSpeed;
            this.position.y += (dy / distance) * this.speed * gameSpeed;
            this.rotation = Math.atan2(dy, dx);
            if (!this.phasing) {
                this.inTunnel = false;
            }
        }
        
        if (this.hitFlash > 0) this.hitFlash -= gameSpeed;
        
        return false;
    }
    
    draw() {
        const x = this.position.x - camera.x;
        const y = this.position.y - camera.y;

        ctx.save();

        // Make enemy semi-transparent in tunnel
        if (this.inTunnel) {
            ctx.globalAlpha = 0.4;
        }

        // Enemy body
        const scale = getScaleFactor();

        // Shield effect - simple ring, no blur
        if (this.shield > 0) {
            const shieldAlpha = this.shield / this.maxShield;
            ctx.strokeStyle = `rgba(0, 200, 255, ${shieldAlpha * 0.8})`;
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.arc(x, y, (this.size/2 + 4) * scale, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Boss aura - simple glow, single gradient
        if (this.boss) {
            const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, this.size * scale * 0.8);
            auraGrad.addColorStop(0, 'rgba(255, 50, 50, 0.4)');
            auraGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = auraGrad;
            ctx.beginPath();
            ctx.arc(x, y, this.size * scale * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Enemy body - NO SHADOW BLUR (expensive!)
        ctx.fillStyle = this.hitFlash > 0 ? '#ffffff' : this.color;
        ctx.beginPath();
        ctx.arc(x, y, (this.size/2) * scale, 0, Math.PI * 2);
        ctx.fill();

        // Simple outline
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        // Special indicators - simplified
        if (this.healing) {
            ctx.fillStyle = '#ffff00';
            ctx.font = `${10 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('+', x, y - (this.size/2 + 8) * scale);
        }

        if (this.teleports) {
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.arc(x, y, (this.size/2 + 2) * scale, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.restore();
        
        // Health bar (shows on hit and fades)
        if (this.healthBarVisible > 0 && this.health < this.maxHealth && !this.inTunnel) {
            const alpha = Math.min(1, this.healthBarVisible / 180);
            const barWidth = this.size * 1.5 * scale;
            const barHeight = 5 * scale;
            const barY = y - (this.size * scale) - (12 * scale);
            
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(x - barWidth/2 - 1, barY - 1, barWidth + 2, barHeight + 2);
            
            // Health bar
            const healthPercent = this.health / this.maxHealth;
            const gradient = ctx.createLinearGradient(x - barWidth/2, barY, x + barWidth/2, barY);
            if (healthPercent > 0.5) {
                gradient.addColorStop(0, '#00ff00');
                gradient.addColorStop(1, '#00cc00');
            } else if (healthPercent > 0.25) {
                gradient.addColorStop(0, '#ffaa00');
                gradient.addColorStop(1, '#ff8800');
            } else {
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(1, '#cc0000');
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(x - barWidth/2, barY, barWidth * healthPercent, barHeight);
            
            // White border
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - barWidth/2, barY, barWidth, barHeight);
            
            ctx.restore();
        }
    }
    
    takeDamage(damage, x, y) {
        if (this.inTunnel) return false;
        
        // Apply damage reduction
        if (this.damageReduction > 0) {
            damage *= (1 - this.damageReduction);
        }
        
        // Apply shield first
        if (this.shield > 0) {
            const shieldDamage = Math.min(this.shield, damage);
            this.shield -= shieldDamage;
            damage -= shieldDamage;
        }
        
        this.health -= damage;
        this.hitFlash = 5;
        this.healthBarVisible = 180; // Show health bar for 3 seconds
        
        // Damage numbers disabled for performance
        // showDamageNumber(x, y, Math.round(damage), '#ffff00');
        
        // Hit particles - REDUCED from 5 to 2 for performance
        if (performanceMode) {
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: this.color,
                    life: 1,
                    size: 2
                });
            }
        }
        
        if (this.health <= 0) {
            money += this.reward;
            score += this.reward * level;
            updateUI();
            
            // Reward numbers disabled for performance
            // showDamageNumber(this.position.x - camera.x, this.position.y - camera.y, `+${this.reward}`, '#00ff00');
            
            // Splitter effect
            if (this.splits > 0) {
                for (let i = 0; i < this.splits; i++) {
                    const splitEnemy = new Enemy('slime');
                    splitEnemy.pathIndex = this.pathIndex;
                    splitEnemy.pathProgress = this.pathProgress;
                    splitEnemy.position.x = this.position.x + (Math.random() - 0.5) * 20;
                    splitEnemy.position.y = this.position.y + (Math.random() - 0.5) * 20;
                    enemies.push(splitEnemy);
                }
            }
            
            // Bomber explosion
            if (this.explodeOnDeath) {
                enemies.forEach(enemy => {
                    if (enemy !== this && !enemy.inTunnel) {
                        const dist = Math.sqrt(
                            Math.pow(enemy.position.x - this.position.x, 2) +
                            Math.pow(enemy.position.y - this.position.y, 2)
                        );
                        if (dist < 100) {
                            enemy.takeDamage(150, enemy.position.x, enemy.position.y);
                        }
                    }
                });
                
                // Big explosion effect - REDUCED from 30 to 8 particles
                for (let i = 0; i < 8; i++) {
                    particles.push({
                        x: this.position.x,
                        y: this.position.y,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        color: '#ff0066',
                        life: 1,
                        size: 6
                    });
                }
                
                // Screen shake for explosion
                addScreenShake(15);
            }
            
            // Boss death shake
            if (this.boss) {
                addScreenShake(25);
            }
            
            // Death effects - REDUCED from 10 to 4 particles
            for (let i = 0; i < 4; i++) {
                particles.push({
                    x: this.position.x,
                    y: this.position.y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    color: this.color,
                    life: 1,
                    size: 4
                });
            }
            
            // Random power-up chance
            if (Math.random() < 0.05) { // Reduced from 0.1
                powerups.push({
                    x: this.position.x,
                    y: this.position.y,
                    type: Math.random() < 0.5 ? 'money' : 'health',
                    value: this.type === 'brute' ? 100 : 30
                });
            }
            
            if (totalKills === 1 && !achievements.firstKill.unlocked) {
                unlockAchievement('firstKill');
            }
            
            return true;
        }
        return false;
    }
}

// Show damage/reward number (disabled for performance)
function showDamageNumber(x, y, text, color) {
    // Disabled to improve performance
    return;
    /*
    const dmgNum = document.createElement('div');
    dmgNum.className = 'damage-number';
    dmgNum.textContent = typeof text === 'number' ? `-${text}` : text;
    dmgNum.style.color = color;
    dmgNum.style.left = `${x}px`;
    dmgNum.style.top = `${y}px`;
    document.body.appendChild(dmgNum);
    setTimeout(() => dmgNum.remove(), 1000);
    */
}

// Update projectiles
function updateProjectiles() {
    projectiles = projectiles.filter(proj => {
        proj.trail.push({ x: proj.x, y: proj.y });
        if (proj.trail.length > 10) proj.trail.shift();
        
        if (proj.pierce) {
            // Piercing projectiles
            proj.x += Math.cos(proj.rotation) * proj.speed * gameSpeed;
            proj.y += Math.sin(proj.rotation) * proj.speed * gameSpeed;
            
            enemies = enemies.filter(enemy => {
                if (enemy.inTunnel) return true;
                
                const dist = Math.sqrt(
                    Math.pow(enemy.position.x - proj.x, 2) +
                    Math.pow(enemy.position.y - proj.y, 2)
                );
                
                if (dist < 30) {
                    if (enemy.takeDamage(proj.damage, enemy.position.x, enemy.position.y)) {
                        if (proj.towerRef) {
                            proj.towerRef.kills++;
                            totalKills++;
                        }
                        return false;
                    }
                }
                return true;
            });
            
            return proj.x > -100 && proj.x < canvas.width + 100 &&
                   proj.y > -100 && proj.y < canvas.height + 100;
        } else if (enemies.includes(proj.target)) {
            if (proj.target.inTunnel) {
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: proj.x,
                        y: proj.y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: proj.color,
                        life: 1,
                        size: 3
                    });
                }
                return false;
            }
            
            const dx = proj.target.position.x - proj.x;
            const dy = proj.target.position.y - proj.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 20) {
                // Hit target
                if (proj.target.takeDamage(proj.damage, proj.target.position.x, proj.target.position.y)) {
                    enemies = enemies.filter(e => e !== proj.target);
                    if (proj.towerRef) {
                        proj.towerRef.kills++;
                        totalKills++;
                    }
                }
                
                // Explosion effect
                if (proj.explosive) {
                    enemies = enemies.filter(enemy => {
                        if (enemy === proj.target || enemy.inTunnel) return true;
                        
                        const explodeDist = Math.sqrt(
                            Math.pow(enemy.position.x - proj.x, 2) +
                            Math.pow(enemy.position.y - proj.y, 2)
                        );
                        
                        if (explodeDist < 80) {
                            if (enemy.takeDamage(proj.damage * 0.5, enemy.position.x, enemy.position.y)) {
                                if (proj.towerRef) {
                                    proj.towerRef.kills++;
                                    totalKills++;
                                }
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: proj.x,
                            y: proj.y,
                            vx: (Math.random() - 0.5) * 20,
                            vy: (Math.random() - 0.5) * 20,
                            color: proj.color,
                            life: 1,
                            size: 8
                        });
                    }
                } else if (proj.splash) {
                    enemies = enemies.filter(enemy => {
                        if (enemy === proj.target || enemy.inTunnel) return true;
                        
                        const splashDist = Math.sqrt(
                            Math.pow(enemy.position.x - proj.x, 2) +
                            Math.pow(enemy.position.y - proj.y, 2)
                        );
                        
                        if (splashDist < proj.splashRadius) {
                            if (enemy.takeDamage(proj.damage * 0.3, enemy.position.x, enemy.position.y)) {
                                if (proj.towerRef) {
                                    proj.towerRef.kills++;
                                    totalKills++;
                                }
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: proj.x,
                            y: proj.y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            color: proj.color,
                            life: 1,
                            size: 6
                        });
                    }
                }
                
                return false;
            }
            
            // Move towards target
            if (proj.homing || dist < 200) {
                proj.x += (dx / dist) * proj.speed * gameSpeed;
                proj.y += (dy / dist) * proj.speed * gameSpeed;
                proj.rotation = Math.atan2(dy, dx);
            } else {
                proj.x += Math.cos(proj.rotation) * proj.speed * gameSpeed;
                proj.y += Math.sin(proj.rotation) * proj.speed * gameSpeed;
            }
            
            return true;
        }
        
        return false;
    });
}

// Update particles
function updateParticles() {
    particles = particles.filter(particle => {
        particle.x += particle.vx * gameSpeed;
        particle.y += particle.vy * gameSpeed;
        particle.vy += 0.3 * gameSpeed;
        particle.life -= 0.02 * gameSpeed;
        particle.size *= 0.97;
        return particle.life > 0;
    });
}

// Update beams
function updateBeams() {
    beams = beams.filter(beam => {
        beam.life -= gameSpeed;
        return beam.life > 0;
    });
}

// Update power-ups
function updatePowerups() {
    powerups = powerups.filter(powerup => {
        // Check if player collected it (click)
        const dist = Math.sqrt(
            Math.pow(mousePos.x - (powerup.x - camera.x), 2) +
            Math.pow(mousePos.y - (powerup.y - camera.y), 2)
        );
        
        if (dist < 30) {
            if (powerup.type === 'money') {
                money += powerup.value;
            } else if (powerup.type === 'health') {
                health = Math.min(100, health + powerup.value);
            }
            updateUI();
            
            // Collection effect
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: powerup.x,
                    y: powerup.y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10 - 5,
                    color: powerup.type === 'money' ? '#ffd700' : '#ff0000',
                    life: 1,
                    size: 5
                });
            }
            
            return false;
        }
        
        return true;
    });
}

// Cached background
let cachedBackground = null;
let cachedBackgroundCanvas = null;

// Draw background
function drawBackground() {
    if (performanceMode) {
        // Simple solid background in performance mode
        ctx.fillStyle = '#0a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else {
        // Cache the background for better performance
        if (!cachedBackgroundCanvas || cachedBackgroundCanvas.width !== canvas.width) {
            cachedBackgroundCanvas = document.createElement('canvas');
            cachedBackgroundCanvas.width = canvas.width;
            cachedBackgroundCanvas.height = canvas.height;
            const cacheCtx = cachedBackgroundCanvas.getContext('2d');
            
            const gradient = cacheCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a2e');
            gradient.addColorStop(0.5, '#000511');
            gradient.addColorStop(1, '#1a0033');
            cacheCtx.fillStyle = gradient;
            cacheCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars
            cacheCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137) % canvas.width;
                const y = (i * 91) % canvas.height;
                const size = (i % 3) * 0.5 + 0.5;
                cacheCtx.beginPath();
                cacheCtx.arc(x, y, size, 0, Math.PI * 2);
                cacheCtx.fill();
            }
        }
        
        // Draw cached background
        ctx.drawImage(cachedBackgroundCanvas, 0, 0);
    }
}

// Draw grid
function drawGrid() {
    if (performanceMode) {
        // Skip grid in performance mode
        return;
    }
    
    ctx.strokeStyle = 'rgba(100, 100, 150, 0.1)';
    ctx.lineWidth = 1;
    
    const gridSize = 50;
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
    }
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
    }
    ctx.stroke();
}

// Draw path with directional indicators
function drawPath() {
    const scale = getScaleFactor();
    
    // Glowing path outline
    ctx.save();
    ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
    ctx.shadowBlur = 20 * scale;
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 45 * scale;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.stroke();
    ctx.restore();
    
    // Path border
    ctx.strokeStyle = '#2a5570';
    ctx.lineWidth = 36 * scale;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // Main path surface with brighter gradient
    const pathGradient = ctx.createLinearGradient(
        path[0].x - camera.x, path[0].y - camera.y,
        base.x - camera.x, base.y - camera.y
    );
    pathGradient.addColorStop(0, '#506080');
    pathGradient.addColorStop(0.5, '#405070');
    pathGradient.addColorStop(1, '#354560');
    ctx.strokeStyle = pathGradient;
    ctx.lineWidth = 32 * scale;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // Path center line for extra definition
    ctx.strokeStyle = 'rgba(150, 200, 255, 0.2)';
    ctx.lineWidth = 2 * scale;
    ctx.stroke();
    
    // Directional texture - subtle arrows in the center of the path
    ctx.save();
    const arrowSpacing = 60;
    const animOffset = (Date.now() * 0.03) % arrowSpacing;
    
    // Create clipping path for arrows
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.lineWidth = 25 * scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    ctx.clip();
    
    // Draw directional arrows along the path
    for (let i = 0; i < path.length - 1; i++) {
        const current = path[i];
        const next = path[i + 1];
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        const numArrows = Math.floor(distance / arrowSpacing);
        
        for (let j = 0; j <= numArrows; j++) {
            const progress = j / Math.max(1, numArrows);
            const arrowX = current.x + dx * progress - camera.x;
            const arrowY = current.y + dy * progress - camera.y;
            
            // Calculate opacity based on animation
            const localOffset = (j * arrowSpacing - animOffset + arrowSpacing) % arrowSpacing;
            const opacity = 0.3 + (1 - localOffset / arrowSpacing) * 0.4;
            
            ctx.save();
            ctx.translate(arrowX, arrowY);
            ctx.rotate(angle);
            
            // Draw glowing arrow
            ctx.strokeStyle = `rgba(150, 220, 255, ${opacity})`;
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(0, 0);
            ctx.lineTo(-10, 5);
            ctx.stroke();
            
            ctx.restore();
        }
    }
    
    // Draw arrows for final segment to base
    const lastPath = path[path.length - 1];
    const baseX = base.x + base.width/2;
    const baseY = base.y + base.height/2;
    const dx = baseX - lastPath.x;
    const dy = baseY - lastPath.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    
    const numArrows = Math.floor(distance / arrowSpacing);
    for (let j = 0; j <= numArrows; j++) {
        const progress = j / Math.max(1, numArrows);
        const arrowX = lastPath.x + dx * progress - camera.x;
        const arrowY = lastPath.y + dy * progress - camera.y;
        
        const localOffset = (j * arrowSpacing - animOffset + arrowSpacing) % arrowSpacing;
        const opacity = 0.1 + (1 - localOffset / arrowSpacing) * 0.15;
        
        ctx.save();
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        
        ctx.beginPath();
        ctx.moveTo(-8, -4);
        ctx.lineTo(0, 0);
        ctx.lineTo(-8, 4);
        ctx.stroke();
        
        ctx.restore();
    }
    
    ctx.restore();
    
    // Path surface texture - subtle dots
    ctx.save();
    ctx.globalAlpha = 0.08;
    
    // Create clipping path
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.lineWidth = 28 * scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    ctx.clip();
    
    // Draw dot pattern
    ctx.fillStyle = '#ffffff';
    for (let x = 0; x < canvas.width; x += 8) {
        for (let y = 0; y < canvas.height; y += 8) {
            if ((x + y) % 16 === 0) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    ctx.restore();
    
    // Path highlights on edges
    ctx.save();
    ctx.globalAlpha = 0.1;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.setLineDash([20, 20]);
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
}

// Draw base with enhanced animation
function drawBase() {
    const x = base.x - camera.x;
    const y = base.y - camera.y;
    
    base.energyAnimation += 0.03 * gameSpeed;
    base.shieldPulse += 0.025 * gameSpeed;
    base.coreRotation += 0.015 * gameSpeed;
    
    // Update orbital rings
    base.orbitalRings.forEach(ring => {
        ring.rotation += ring.speed * gameSpeed;
    });
    
    // Outer energy field with pulsing effect
    const pulseSize = 120 + Math.sin(base.energyAnimation) * 15;
    const fieldGradient = ctx.createRadialGradient(
        x + base.width/2, y + base.height/2, 0,
        x + base.width/2, y + base.height/2, pulseSize
    );
    fieldGradient.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
    fieldGradient.addColorStop(0.3, 'rgba(138, 43, 226, 0.08)');
    fieldGradient.addColorStop(0.6, 'rgba(255, 20, 147, 0.05)');
    fieldGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = fieldGradient;
    ctx.fillRect(x - 100, y - 100, base.width + 200, base.height + 200);
    
    // Draw orbital rings
    ctx.save();
    ctx.translate(x + base.width/2, y + base.height/2);
    
    base.orbitalRings.forEach((ring, i) => {
        ctx.save();
        ctx.rotate(ring.rotation);
        
        // Ring gradient
        const ringGradient = ctx.createLinearGradient(-ring.radius, 0, ring.radius, 0);
        ringGradient.addColorStop(0, 'transparent');
        ringGradient.addColorStop(0.4, ring.color);
        ringGradient.addColorStop(0.6, ring.color);
        ringGradient.addColorStop(1, 'transparent');
        
        ctx.strokeStyle = ringGradient;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7 + Math.sin(base.energyAnimation + i) * 0.3;
        
        // Draw ring with perspective
        ctx.beginPath();
        ctx.ellipse(0, 0, ring.radius, ring.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Energy nodes on rings
        for (let j = 0; j < 4; j++) {
            const angle = (j / 4) * Math.PI * 2;
            const nodeX = Math.cos(angle) * ring.radius;
            const nodeY = Math.sin(angle) * ring.radius * 0.4;
            
            const nodeGradient = ctx.createRadialGradient(nodeX, nodeY, 0, nodeX, nodeY, 6);
            nodeGradient.addColorStop(0, '#ffffff');
            nodeGradient.addColorStop(0.5, ring.color);
            nodeGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = nodeGradient;
            ctx.beginPath();
            ctx.arc(nodeX, nodeY, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    });
    
    ctx.restore();
    
    // Base platform with hexagonal design
    ctx.save();
    ctx.translate(x + base.width/2, y + base.height/2);
    
    // Hexagonal platform
    ctx.fillStyle = 'rgba(10, 10, 30, 0.9)';
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const hx = Math.cos(angle) * 50;
        const hy = Math.sin(angle) * 50;
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
    }
    ctx.closePath();
    ctx.fill();
    
    // Platform edges with gradient
    const edgeGradient = ctx.createLinearGradient(-50, -50, 50, 50);
    edgeGradient.addColorStop(0, '#8a2be2');
    edgeGradient.addColorStop(0.5, '#ff1493');
    edgeGradient.addColorStop(1, '#00ffff');
    ctx.strokeStyle = edgeGradient;
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Inner hexagon
    ctx.fillStyle = 'rgba(20, 20, 50, 0.8)';
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const hx = Math.cos(angle) * 35;
        const hy = Math.sin(angle) * 35;
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
    }
    ctx.closePath();
    ctx.fill();
    
    // Central core with multiple layers
    const coreSize = 25 + Math.sin(base.energyAnimation * 2) * 3;
    
    // Outer core glow
    const outerCoreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize + 10);
    outerCoreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    outerCoreGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
    outerCoreGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
    ctx.fillStyle = outerCoreGradient;
    ctx.beginPath();
    ctx.arc(0, 0, coreSize + 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Main core
    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);
    coreGradient.addColorStop(0, '#ffffff');
    coreGradient.addColorStop(0.3, '#00ffff');
    coreGradient.addColorStop(0.6, '#ff1493');
    coreGradient.addColorStop(1, '#8a2be2');
    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner core pulse
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.7 + Math.sin(base.energyAnimation * 3) * 0.3;
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Energy beams from core to hexagon vertices
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
        if (Math.sin(base.energyAnimation * 2 + i) > 0.5) {
            const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
            const hx = Math.cos(angle) * 50;
            const hy = Math.sin(angle) * 50;
            
            const beamGradient = ctx.createLinearGradient(0, 0, hx, hy);
            beamGradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            beamGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.3)');
            beamGradient.addColorStop(1, 'rgba(0, 255, 255, 0.1)');
            ctx.strokeStyle = beamGradient;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(hx, hy);
            ctx.stroke();
        }
    }
    
    ctx.restore();
    
    // Shield effect
    const shieldSize = 70 + Math.sin(base.shieldPulse) * 5;
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 10]);
    ctx.beginPath();
    ctx.arc(x + base.width/2, y + base.height/2, shieldSize, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Base name with enhanced glow
    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 18px Orbitron';
    ctx.textAlign = 'center';
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#00ffff';
    ctx.fillText(base.name, x + base.width/2, y - 20);
    
    // Subtitle
    ctx.font = '12px Orbitron';
    ctx.fillStyle = '#ff1493';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ff1493';
    ctx.fillText('QUANTUM DEFENSE MATRIX', x + base.width/2, y - 5);
    ctx.shadowBlur = 0;
    
    // Health bar
    const healthPercent = health / 100;
    const barWidth = base.width + 20;
    const barHeight = 8;
    const barY = y - 10;
    const barX = x - 10;
    
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' :
                     healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
    
    ctx.strokeStyle = '#8a2be2';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barWidth, barHeight);
    
    // Floating energy particles around base
    for (let i = 0; i < 8; i++) {
        const angle = (base.energyAnimation * 0.5 + i * Math.PI / 4) % (Math.PI * 2);
        const radius = 80 + Math.sin(base.energyAnimation + i) * 10;
        const px = x + base.width/2 + Math.cos(angle) * radius;
        const py = y + base.height/2 + Math.sin(angle) * radius;
        
        const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, 5);
        particleGradient.addColorStop(0, '#ffffff');
        particleGradient.addColorStop(0.5, '#00ffff');
        particleGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = particleGradient;
        ctx.globalAlpha = 0.6 + Math.sin(base.energyAnimation * 2 + i) * 0.4;
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// Draw projectiles
function drawProjectiles() {
    projectiles.forEach(proj => {
        // Trail
        if (proj.trail.length > 1) {
            ctx.strokeStyle = proj.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.moveTo(proj.trail[0].x - camera.x, proj.trail[0].y - camera.y);
            for (let i = 1; i < proj.trail.length; i++) {
                ctx.lineTo(proj.trail[i].x - camera.x, proj.trail[i].y - camera.y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        // Projectile
        ctx.fillStyle = proj.color;
        ctx.beginPath();
        ctx.arc(proj.x - camera.x, proj.y - camera.y, 5, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Draw particles (optimized)
function drawParticles() {
    if (performanceMode && particles.length > maxParticles / 2) {
        // Skip every other particle in performance mode
        for (let i = 0; i < particles.length; i += 2) {
            const particle = particles[i];
            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            ctx.fillRect(
                particle.x - camera.x - particle.size/2, 
                particle.y - camera.y - particle.size/2, 
                particle.size, 
                particle.size
            );
        }
    } else {
        // Batch particles by color to reduce state changes
        const particlesByColor = {};
        particles.forEach(particle => {
            if (!particlesByColor[particle.color]) {
                particlesByColor[particle.color] = [];
            }
            particlesByColor[particle.color].push(particle);
        });
        
        for (const color in particlesByColor) {
            ctx.fillStyle = color;
            particlesByColor[color].forEach(particle => {
                ctx.globalAlpha = particle.life;
                if (performanceMode) {
                    // Use rectangles instead of circles for better performance
                    ctx.fillRect(
                        particle.x - camera.x - particle.size/2, 
                        particle.y - camera.y - particle.size/2, 
                        particle.size, 
                        particle.size
                    );
                } else {
                    ctx.beginPath();
                    ctx.arc(particle.x - camera.x, particle.y - camera.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    ctx.globalAlpha = 1;
}

// Draw beams
function drawBeams() {
    beams.forEach(beam => {
        ctx.globalAlpha = beam.life / 10;
        
        if (beam.type === 'lightning') {
            ctx.strokeStyle = beam.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(beam.from.x - camera.x, beam.from.y - camera.y);
            
            // Jagged lightning
            const segments = 5;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const x = beam.from.x + (beam.to.x - beam.from.x) * t + (Math.random() - 0.5) * 20;
                const y = beam.from.y + (beam.to.y - beam.from.y) * t + (Math.random() - 0.5) * 20;
                ctx.lineTo(x - camera.x, y - camera.y);
            }
            
            ctx.lineTo(beam.to.x - camera.x, beam.to.y - camera.y);
            ctx.stroke();
        } else if (beam.type === 'laser') {
            const gradient = ctx.createLinearGradient(
                beam.from.x - camera.x, beam.from.y - camera.y,
                beam.to.x - camera.x, beam.to.y - camera.y
            );
            gradient.addColorStop(0, beam.color);
            gradient.addColorStop(0.5, '#ffffff');
            gradient.addColorStop(1, beam.color);
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(beam.from.x - camera.x, beam.from.y - camera.y);
            ctx.lineTo(beam.to.x - camera.x, beam.to.y - camera.y);
            ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
    });
}

// Draw boss health bars at top of screen
function drawBossHealthBars() {
    // Find all boss enemies
    const bosses = enemies.filter(enemy => 
        enemy.type === 'boss' || 
        enemy.type === 'megaBoss' || 
        enemy.type === 'finalBoss'
    );
    
    if (bosses.length === 0) return;
    
    // Draw each boss health bar
    bosses.forEach((boss, index) => {
        const barWidth = canvas.width * 0.6;
        const barHeight = 30;
        const barX = (canvas.width - barWidth) / 2;
        const barY = 10 + (index * 40); // Stack multiple boss bars
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
        
        // Health bar background
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health bar
        const healthPercent = boss.health / boss.maxHealth;
        const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth * healthPercent, barY);
        
        if (boss.type === 'finalBoss') {
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(0.5, '#ff00ff');
            gradient.addColorStop(1, '#ffaa00');
        } else if (boss.type === 'megaBoss') {
            gradient.addColorStop(0, '#ff0066');
            gradient.addColorStop(1, '#ff3399');
        } else {
            gradient.addColorStop(0, '#cc0000');
            gradient.addColorStop(1, '#ff0000');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Animated shine effect
        const shineX = barX + (Date.now() % 2000) / 2000 * barWidth;
        const shineGrad = ctx.createLinearGradient(shineX - 20, barY, shineX + 20, barY);
        shineGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
        shineGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
        shineGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = shineGrad;
        ctx.fillRect(shineX - 20, barY, 40, barHeight);
        
        // Border
        ctx.strokeStyle = boss.type === 'finalBoss' ? '#ff00ff' : '#ff0000';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Boss name and health text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let bossName = 'BOSS';
        if (boss.type === 'finalBoss') bossName = '‚ò†Ô∏è FINAL BOSS ‚ò†Ô∏è';
        else if (boss.type === 'megaBoss') bossName = 'üíÄ MEGA BOSS üíÄ';
        
        ctx.fillText(bossName, canvas.width / 2, barY + barHeight / 2);
        
        // Health numbers
        ctx.font = '12px Orbitron';
        ctx.fillText(`${Math.floor(boss.health)} / ${boss.maxHealth}`, canvas.width / 2, barY + barHeight + 12);
    });
}

// Draw power-ups
function drawPowerups() {
    powerups.forEach(powerup => {
        const x = powerup.x - camera.x;
        const y = powerup.y - camera.y;
        
        ctx.save();
        ctx.translate(x, y);
        
        // Glow effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
        gradient.addColorStop(0, powerup.type === 'money' ? 'rgba(255,215,0,0.3)' : 'rgba(255,0,0,0.3)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(-30, -30, 60, 60);
        
        // Power-up body
        ctx.fillStyle = powerup.type === 'money' ? '#ffd700' : '#ff0000';
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Icon
        ctx.fillStyle = '#000';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(powerup.type === 'money' ? 'üí∞' : '‚ù§Ô∏è', 0, 0);
        
        ctx.restore();
    });
}

// Update UI
function updateUI() {
    // Check if DOM is ready
    if (!document.getElementById('money')) {
        console.log('UI not ready yet');
        return;
    }
    
    document.getElementById('money').textContent = money;
    document.getElementById('health').textContent = health;
    document.getElementById('level').textContent = level;
    document.getElementById('score').textContent = score;
    document.getElementById('themeName').textContent = 'Grassland';
    
    if (enemiesSpawning || enemies.length > 0) {
        document.getElementById('waveStatus').style.display = 'flex';
        document.getElementById('currentWave').textContent = currentWave;
        document.getElementById('totalWaves').textContent = totalWaves;
        document.getElementById('enemyCount').textContent = enemies.length;
    } else {
        document.getElementById('waveStatus').style.display = 'none';
    }
    
    // Check achievements
    if (money >= 1000 && !achievements.money1000.unlocked) {
        unlockAchievement('money1000');
    }
    
    if (towers.length >= 10 && !achievements.towerMaster.unlocked) {
        unlockAchievement('towerMaster');
    }
    
    // Update tower info
    if (selectedTower) {
        document.getElementById('towerInfo').style.display = 'block';
        document.getElementById('towerName').innerHTML = `${selectedTower.stats.name} <span style="color: ${selectedTower.stats.color};">‚óè</span>`;
        document.getElementById('towerLevel').textContent = selectedTower.level + (selectedTower.level >= 10 ? ' (MAX)' : '');
        document.getElementById('towerDamage').textContent = Math.floor(selectedTower.stats.damage);
        document.getElementById('towerRange').textContent = Math.floor(selectedTower.stats.range);
        
        const fireRate = selectedTower.stats.fireRate;
        let fireRateText = 'Slow';
        if (fireRate < 300) fireRateText = 'Very Fast';
        else if (fireRate < 600) fireRateText = 'Fast';
        else if (fireRate < 1000) fireRateText = 'Medium';
        document.getElementById('towerFireRate').textContent = fireRateText;
        
        document.getElementById('towerKills').textContent = selectedTower.kills;
        document.getElementById('towerSpec').textContent = selectedTower.specialization ?
            (selectedTower.specialization === 'power' ? 'Power' :
             selectedTower.specialization === 'speed' ? 'Speed' :
             selectedTower.specialization === 'effect' ? 'Effect' :
             selectedTower.specialization === 'special' ? 'Effect' : 'None') : 'None';
        
        // Update target priority buttons
        document.querySelectorAll('.target-option').forEach(option => {
            if (option.dataset.priority === selectedTower.targetPriority) {
                option.classList.add('active');
            } else {
                option.classList.remove('active');
            }
        });
        
        // Update upgrade button with range increase info
        const upgradeCost = selectedTower.getUpgradeCost();
        const upgradeBtn = document.getElementById('upgradeBtn');
        if (upgradeCost > 0) {
            const currentRange = Math.floor(selectedTower.stats.range);
            const nextRange = Math.floor(selectedTower.stats.range * 1.03);
            const rangeIncrease = nextRange > currentRange ? ` (+${nextRange - currentRange} range)` : '';
            upgradeBtn.innerHTML = `‚¨ÜÔ∏è UPGRADE (üí∞${upgradeCost})${rangeIncrease}`;
            upgradeBtn.disabled = money < upgradeCost;
        } else {
            upgradeBtn.textContent = '‚ú® MAX LEVEL';
            upgradeBtn.disabled = true;
        }
        
        // Show specialization buttons at level 5
        if (selectedTower.level >= 5 && !selectedTower.specialization) {
            document.getElementById('specButtons').style.display = 'flex';
        } else {
            document.getElementById('specButtons').style.display = 'none';
        }
        
        // Update sell button
        const sellValue = Math.floor(selectedTower.stats.cost * 0.7 * selectedTower.level);
        document.getElementById('sellBtn').textContent = `üí∞ SELL FOR ${sellValue}`;
    } else {
        document.getElementById('towerInfo').style.display = 'none';
    }
    
    // Update tower availability
    const towerOptions = document.querySelectorAll('.towerOption');
    if (towerOptions.length > 0) {
        towerOptions.forEach(option => {
            const type = option.dataset.type;
            if (type && towerTypes[type]) {
                if (money < towerTypes[type].cost) {
                    option.classList.add('disabled');
                } else {
                    option.classList.remove('disabled');
                }
            }
        });
    }
    
    if (health <= 0) {
        gameOver();
    }
}

// Unlock achievement
function unlockAchievement(id) {
    achievements[id].unlocked = true;
    const popup = document.getElementById('achievementPopup');
    document.getElementById('achievementText').textContent = achievements[id].desc;
    popup.classList.add('show');
    setTimeout(() => popup.classList.remove('show'), 3000);
}

// Set tower targeting
function setTowerTargeting(priority) {
    if (selectedTower) {
        selectedTower.targetPriority = priority;
        updateUI();
    }
}

// Specialize tower
function specializeTower(type) {
    if (selectedTower) {
        selectedTower.specialize(type);
        updateUI();
    }
}

// Toggle wave preview
function toggleWavePreview() {
    wavePreviewShown = !wavePreviewShown;
    const preview = document.getElementById('wavePreview');
    
    if (wavePreviewShown) {
        preview.style.display = 'block';
        updateWavePreview();
    } else {
        preview.style.display = 'none';
    }
}

// Update wave preview
function updateWavePreview() {
    const content = document.getElementById('waveContent');
    content.innerHTML = '';
    
    const levelInfo = levelData[Math.min(level - 1, levelData.length - 1)];
    
    levelInfo.enemies.forEach(group => {
        const enemyDiv = document.createElement('div');
        enemyDiv.className = 'wave-enemy';
        
        const iconDiv = document.createElement('div');
        iconDiv.className = 'wave-enemy-icon';
        iconDiv.style.backgroundColor = enemyTypes[group.type].color;
        iconDiv.textContent = group.type[0].toUpperCase();
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'wave-enemy-info';
        infoDiv.innerHTML = `
            <div class="wave-enemy-name">${group.type.charAt(0).toUpperCase() + group.type.slice(1)}</div>
            <div class="wave-enemy-count">x${group.count} ‚Ä¢ HP: ${enemyTypes[group.type].health}</div>
        `;
        
        enemyDiv.appendChild(iconDiv);
        enemyDiv.appendChild(infoDiv);
        content.appendChild(enemyDiv);
    });
}

// Upgrade tower
function upgradeTower() {
    if (selectedTower && selectedTower.upgrade()) {
        updateUI();
    }
}

// Select tower type for placement
function selectTowerType(type) {
    if (money >= towerTypes[type].cost) {
        selectedTowerType = type;
        placingTower = true;
        document.getElementById('towerModal').style.display = 'none';
        canvas.style.cursor = 'crosshair';
    }
}

// Sell tower
function sellTower() {
    if (challengeMode) {
        showNotification('‚ùå Cannot sell towers in Challenge Mode!');
        return;
    }
    
    if (selectedTower) {
        const refund = Math.floor(selectedTower.stats.cost * 0.7 * selectedTower.level);
        money += refund;
        towers = towers.filter(t => t !== selectedTower);
        
        // Recalculate synergies for remaining towers
        towers.forEach(tower => tower.checkSynergies());
        
        // Sell effect
        for (let i = 0; i < 20; i++) {
            particles.push({
                x: selectedTower.x,
                y: selectedTower.y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10 - 5,
                color: '#ffd700',
                life: 1,
                size: 5
            });
        }
        
        selectedTower = null;
        updateUI();
    }
}

// Pause/Resume game
function togglePause() {
    isPaused = !isPaused;
    const pauseBtn = document.getElementById('pauseBtn');
    pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    if (!isPaused) {
        requestAnimationFrame(gameLoop); // Resume game loop
    }
}

// Set game speed
function cycleGameSpeed() {
    if (gameSpeed === 1) {
        gameSpeed = 2;
    } else if (gameSpeed === 2) {
        gameSpeed = 3;
    } else if (gameSpeed === 3) {
        gameSpeed = 4;
    } else if (gameSpeed === 4) {
        gameSpeed = 5;
    } else {
        gameSpeed = 1;
    }
    document.getElementById('speedBtn').textContent = `‚ö° ${gameSpeed}x Speed`;
    
    // Change button color based on speed
    const btn = document.getElementById('speedBtn');
    if (gameSpeed === 1) {
        btn.style.background = 'linear-gradient(135deg, #8a2be2 0%, #ff1493 100%)';
    } else if (gameSpeed === 2) {
        btn.style.background = 'linear-gradient(135deg, #00ff00 0%, #00aa00 100%)';
    } else if (gameSpeed === 3) {
        btn.style.background = 'linear-gradient(135deg, #ffaa00 0%, #ff6600 100%)';
    } else if (gameSpeed === 4) {
        btn.style.background = 'linear-gradient(135deg, #ff4444 0%, #cc0000 100%)';
    } else {
        btn.style.background = 'linear-gradient(135deg, #ff00ff 0%, #ff0066 100%)';
    }
}

// Level selection for testing
function selectLevel(selectedLevel) {
    if (!selectedLevel) return;
    
    const levelNum = parseInt(selectedLevel);
    if (levelNum > 0 && levelNum <= levelData.length) {
        level = levelNum;
        money = 400 + (levelNum - 1) * 100; // Give more money for higher levels
        score = levelNum * 1000;
        
        // Change path layout based on selected level
        const newLayout = getPathLayoutForLevel(level);
        if (newLayout !== currentPathLayout) {
            changePathLayout(newLayout);
        }
        
        document.getElementById('startLevel').textContent = `‚ñ∂Ô∏è Start Level ${level}`;
        updateUI();
        showNotification(`üìç Jumped to Level ${level}`);
    }
    
    // Reset dropdown
    document.getElementById('levelSelect').value = '';
}

function resetGameState() {
    console.log('Resetting game state...');

    // Reset core game variables
    money = 200;
    lives = 10;
    level = 1;
    score = 0;
    currentWave = 0;
    totalWaves = 1;
    waveStarted = false;
    levelActive = false;
    gameSpeed = 1;
    paused = false;
    enemies = [];
    towers = [];
    projectiles = [];
    particles = [];
    explosions = [];

    // Reset repositioning system
    if (recentlyPlacedTowers) {
        recentlyPlacedTowers.clear();
    }

    // Reset selected elements
    selectedTower = null;
    selectedTowerType = null;
    placingTower = false;

    console.log('Game state reset complete');
}

// Game mode selection functions
function startSinglePlayer() {
    console.log('Starting Single Player mode...');
    isCoOpMode = false;

    // Hide game mode selection and show game
    document.getElementById('gameModeSelect').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('coopIndicator').style.display = 'none';
    document.getElementById('player2Cursor').style.display = 'none';

    console.log('Single Player mode started');
}

function startCoOp() {
    isCoOpMode = true;
    document.getElementById('gameModeSelect').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('coopIndicator').style.display = 'block';
    document.getElementById('player2Cursor').style.display = 'block';
    initGame();
    
    // Initialize player 2 controls
    setupPlayer2Controls();
}

function startChallenge() {
    challengeMode = true;
    challengeWave = 0;
    challengeLives = 3;
    health = 3; // Only 3 lives in challenge mode
    money = 600; // Start with more money but can't sell
    document.getElementById('gameModeSelect').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('coopIndicator').style.display = 'none';
    document.getElementById('player2Cursor').style.display = 'none';
    
    // Show challenge mode indicator
    showNotification('üî• CHALLENGE MODE: No selling ‚Ä¢ 3 lives ‚Ä¢ Endless waves');
    
    initGame();
    
    // Auto-start first wave after delay
    setTimeout(() => {
        if (challengeMode) {
            startChallengeWave();
        }
    }, 3000);
}

function startChallengeWave() {
    if (!challengeMode) return;
    
    challengeWave++;
    currentWave = challengeWave;
    totalWaves = '‚àû'; // Infinite waves
    enemiesSpawning = true;
    
    showNotification(`üî• Challenge Wave ${challengeWave}`);
    
    // Calculate enemies for this wave
    const baseEnemies = 5 + challengeWave * 2;
    const enemyPool = [];
    
    // Add basic enemies
    for (let i = 0; i < Math.min(baseEnemies, 10); i++) {
        enemyPool.push('slime');
    }
    
    // Add harder enemies as waves progress
    if (challengeWave >= 3) {
        for (let i = 0; i < Math.floor(challengeWave / 3); i++) {
            enemyPool.push('drone');
        }
    }
    
    if (challengeWave >= 5) {
        for (let i = 0; i < Math.floor(challengeWave / 5); i++) {
            enemyPool.push('tank');
        }
    }
    
    if (challengeWave >= 10) {
        for (let i = 0; i < Math.floor(challengeWave / 10); i++) {
            enemyPool.push('destroyer');
        }
    }
    
    // Boss every 5 waves
    if (challengeWave % 5 === 0) {
        enemyPool.push(challengeWave % 10 === 0 ? 'megaBoss' : 'eliteTank');
    }
    
    // Final boss every 20 waves
    if (challengeWave % 20 === 0) {
        enemyPool.push('finalBoss');
    }
    
    enemiesRemaining = enemyPool.length;
    
    // Spawn enemies with delay
    let spawnIndex = 0;
    const spawnInterval = setInterval(() => {
        if (spawnIndex < enemyPool.length) {
            const enemy = new Enemy(enemyPool[spawnIndex]);
            // Scale health and reward based on wave
            enemy.health *= 1 + (challengeWave * 0.1);
            enemy.maxHealth = enemy.health;
            enemy.reward = Math.floor(enemy.reward * (1 + challengeWave * 0.05));
            enemies.push(enemy);
            spawnIndex++;
        } else {
            clearInterval(spawnInterval);
            enemiesSpawning = false;
        }
    }, Math.max(1200 - Math.min(challengeWave * 20, 800), 400)); // Increased spacing, minimum 400ms between enemies
}

function viewLeaderboard() {
    showLeaderboard();
}

function showInGameLeaderboard() {
    showLeaderboard();
}

function showLeaderboard() {
    loadLeaderboard();
    document.getElementById('leaderboardModal').style.display = 'flex';
    
    const content = document.getElementById('leaderboardContent');
    content.innerHTML = '';
    
    if (leaderboard.length === 0) {
        content.innerHTML = '<p style="color: #aaa; text-align: center;">No high scores yet!</p>';
        return;
    }
    
    // Sort leaderboard by score
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Display top 10 scores
    const topScores = leaderboard.slice(0, 10);
    topScores.forEach((entry, index) => {
        const div = document.createElement('div');
        div.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.1); border-radius: 10px; font-size: 18px;';
        
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
        
        div.innerHTML = `
            <div style="display: flex; align-items: center; gap: 15px;">
                <span style="font-size: 24px;">${medal}</span>
                <span style="color: #fff;">${entry.name}</span>
            </div>
            <div style="text-align: right;">
                <div style="color: #ffd700; font-size: 20px; font-weight: bold;">${entry.score.toLocaleString()}</div>
                <div style="color: #aaa; font-size: 14px;">Level ${entry.level} ‚Ä¢ ${entry.mode}</div>
            </div>
        `;
        
        content.appendChild(div);
    });
}

function closeLeaderboard() {
    document.getElementById('leaderboardModal').style.display = 'none';
}

function loadLeaderboard() {
    const saved = localStorage.getItem('ultrapremium_leaderboard');
    if (saved) {
        leaderboard = JSON.parse(saved);
    }
}

function saveLeaderboard() {
    localStorage.setItem('ultrapremium_leaderboard', JSON.stringify(leaderboard));
}

function addToLeaderboard(name, score, level) {
    const entry = {
        name: name,
        score: score,
        level: level,
        mode: isCoOpMode ? 'Co-Op' : 'Single',
        date: new Date().toISOString()
    };
    
    leaderboard.push(entry);
    saveLeaderboard();
}

// Player 2 controls for co-op mode
function setupPlayer2Controls() {
    document.addEventListener('keydown', (e) => {
        if (!isCoOpMode) return;
        player2Keys[e.key.toLowerCase()] = true;
        
        // Space to place tower
        if (e.key === ' ' && placingTower) {
            e.preventDefault();
            const gridX = Math.floor(player2Cursor.x / gridSize) * gridSize + gridSize/2;
            const gridY = Math.floor(player2Cursor.y / gridSize) * gridSize + gridSize/2;
            
            if (canPlaceTower(gridX, gridY)) {
                placeTowerAt(gridX, gridY, selectedTowerType);
            }
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (!isCoOpMode) return;
        player2Keys[e.key.toLowerCase()] = false;
    });
}

function updatePlayer2Cursor() {
    if (!isCoOpMode) return;
    
    const speed = 8;
    if (player2Keys['w']) player2Cursor.y -= speed;
    if (player2Keys['s']) player2Cursor.y += speed;
    if (player2Keys['a']) player2Cursor.x -= speed;
    if (player2Keys['d']) player2Cursor.x += speed;
    
    // Keep cursor on screen
    player2Cursor.x = Math.max(0, Math.min(canvas.width, player2Cursor.x));
    player2Cursor.y = Math.max(0, Math.min(canvas.height, player2Cursor.y));
    
    // Update cursor position on screen
    const cursorElement = document.getElementById('player2Cursor');
    if (cursorElement) {
        cursorElement.style.left = player2Cursor.x + 'px';
        cursorElement.style.top = (player2Cursor.y + document.getElementById('ui').offsetHeight) + 'px';
    }
}

// Helper function to calculate distance from a point to a line segment
function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq != 0) {
        param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;

    return Math.sqrt(dx * dx + dy * dy);
}

function canPlaceTower(x, y) {
    const gridX = Math.floor(x / gridSize) * gridSize + gridSize/2;
    const gridY = Math.floor(y / gridSize) * gridSize + gridSize/2;
    
    // Check if position is on path
    for (let i = 0; i < path.length - 1; i++) {
        const dist = pointToLineDistance(
            gridX, gridY,
            path[i].x, path[i].y,
            path[i+1].x, path[i+1].y
        );
        if (dist < gridSize) return false;
    }
    
    // Check if position overlaps with existing towers
    for (let tower of towers) {
        const dist = Math.sqrt(
            Math.pow(tower.x - gridX, 2) + 
            Math.pow(tower.y - gridY, 2)
        );
        if (dist < gridSize) return false;
    }
    
    // Check enemy spawn and base
    const spawnDist = Math.sqrt(
        Math.pow(gridX - path[0].x, 2) + 
        Math.pow(gridY - path[0].y, 2)
    );
    const baseDist = Math.sqrt(
        Math.pow(gridX - path[path.length-1].x, 2) + 
        Math.pow(gridY - path[path.length-1].y, 2)
    );
    if (spawnDist < 100 || baseDist < 100) return false;
    
    return true;
}

function placeTowerAt(x, y, towerType) {
    if (!towerType || !towerTypes[towerType]) return;

    const cost = towerTypes[towerType].cost;
    if (money >= cost && canPlaceTower(x, y)) {
        money -= cost;
        const newTower = new Tower(towerType, x, y);
        towers.push(newTower);

        // Mark tower as repositionable for 5 seconds
        markTowerAsRepositionable(newTower);

        // Check synergies for all towers
        towers.forEach(tower => tower.checkSynergies());

        updateUI();
        
        // Placement effect
        for (let i = 0; i < 10; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                color: towerTypes[towerType].color,
                life: 1,
                size: 5
            });
        }
        
        // Placement sound effect placeholder
        // playSound('towerPlace');
    }
}

// Tower Repositioning System - Integrated directly into game
let recentlyPlacedTowers = new Map();
let repositionTimeLimit = 3000; // 3 seconds
let dragState = {
    isDragging: false,
    tower: null,
    startX: 0,
    startY: 0,
    originalX: 0,
    originalY: 0
};

function markTowerAsRepositionable(tower) {
    if (!tower || !tower.id) return;

    recentlyPlacedTowers.set(tower.id, {
        tower: tower,
        placedTime: Date.now(),
        canReposition: true
    });

    // Show hint
    showRepositioningHint(tower);

    // Auto-remove after time limit
    setTimeout(() => {
        recentlyPlacedTowers.delete(tower.id);
        hideRepositioningHint(tower);
        console.log(`‚è∞ Tower ${tower.id} no longer repositionable`);
    }, repositionTimeLimit);

    console.log(`üéØ Tower ${tower.id} marked as repositionable for 3 seconds`);
}

function canRepositionTower(tower) {
    if (!tower || !tower.id) return false;
    const towerData = recentlyPlacedTowers.get(tower.id);
    if (!towerData) return false;
    const timeElapsed = Date.now() - towerData.placedTime;
    return timeElapsed < repositionTimeLimit && towerData.canReposition;
}

function getTowerAt(x, y) {
    if (!towers) return null;
    for (let tower of towers) {
        const dist = Math.sqrt(Math.pow(x - tower.x, 2) + Math.pow(y - tower.y, 2));
        if (dist < 30) return tower;
    }
    return null;
}

function showRepositioningHint(tower) {
    const hint = document.createElement('div');
    hint.className = 'reposition-hint';
    hint.id = `hint-${tower.id}`;
    hint.textContent = 'üéØ Drag to reposition (3s)';
    hint.style.cssText = `
        position: absolute;
        background: rgba(0, 255, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: bold;
        pointer-events: none;
        z-index: 1000;
        left: ${tower.x + 40}px;
        top: ${tower.y - 30}px;
        animation: repositionPulse 2s infinite;
    `;
    document.body.appendChild(hint);

    // Add CSS animation if not exists
    if (!document.getElementById('repositionCSS')) {
        const style = document.createElement('style');
        style.id = 'repositionCSS';
        style.innerHTML = `
            @keyframes repositionPulse {
                0%, 100% { opacity: 0.8; transform: scale(1); }
                50% { opacity: 1; transform: scale(1.05); }
            }
        `;
        document.head.appendChild(style);
    }
}

function hideRepositioningHint(tower) {
    const hint = document.getElementById(`hint-${tower.id}`);
    if (hint) hint.remove();
}

function startRepositioning(tower, startX, startY) {
    console.log('üéØ Starting tower repositioning for tower:', tower.id);

    dragState = {
        isDragging: true,
        tower: tower,
        startX: startX,
        startY: startY,
        originalX: tower.x,
        originalY: tower.y
    };

    // Visual feedback
    if (tower.element) {
        tower.element.style.opacity = '0.7';
        tower.element.style.transform = 'scale(1.1)';
    }
}

function handleRepositioningDrag(e) {
    if (!dragState.isDragging) return;

    e.preventDefault();

    // Get current position
    let clientX, clientY;
    if (e.type.includes('touch')) {
        if (e.touches.length === 0) return;
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }

    // Convert to world coordinates
    const rect = e.target.getBoundingClientRect();
    const canvasX = clientX - rect.left;
    const canvasY = clientY - rect.top;
    const worldX = canvasX + camera.x;
    const worldY = canvasY + camera.y;

    // Update tower position if valid
    if (isValidRepositionPosition(worldX, worldY, dragState.tower)) {
        dragState.tower.x = worldX;
        dragState.tower.y = worldY;
    }
}

function stopRepositioning(e) {
    if (!dragState.isDragging) return;

    console.log('üéØ Stopping tower repositioning');

    const tower = dragState.tower;

    // Check if final position is valid
    if (!isValidRepositionPosition(tower.x, tower.y, tower)) {
        // Revert to original position if invalid
        tower.x = dragState.originalX;
        tower.y = dragState.originalY;
        console.log('‚ùå Invalid position, reverted to original');
    } else {
        console.log('‚úÖ Tower repositioned successfully');
    }

    // Reset visual feedback
    if (tower.element) {
        tower.element.style.opacity = '1';
        tower.element.style.transform = 'scale(1)';
    }

    // Reset drag state
    dragState = {
        isDragging: false,
        tower: null,
        startX: 0,
        startY: 0,
        originalX: 0,
        originalY: 0
    };
}

function isValidRepositionPosition(x, y, currentTower) {
    // Check if position is valid for tower placement
    if (!canPlaceTower(x, y)) return false;

    // Additional check for tower overlap (excluding current tower)
    for (let tower of towers) {
        if (tower === currentTower) continue;
        const dx = x - tower.x;
        const dy = y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 40) return false;
    }

    return true;
}

// Note: Drag operations are handled by the main game's mouse/touch event system

// Toggle auto-start
function toggleAutoStart() {
    autoStartEnabled = document.getElementById('autoStartCheck').checked;
}

// Start next level
function startNextLevel() {
    if (level < levelData.length) {
        level++;
        
        // Change path layout every 5 levels
        const newLayout = getPathLayoutForLevel(level);
        if (newLayout !== currentPathLayout) {
            changePathLayout(newLayout);
        }
        
        levelActive = true;
        spawnLevel();
        updateUI();
    }
}

// Determine which path layout to use based on level
function getPathLayoutForLevel(level) {
    if (level <= 5) return 'serpentine';
    else if (level <= 10) return 'figure8';
    else if (level <= 15) return 'zigzag';
    else if (level <= 20) return 'diamond';
    else if (level <= 25) return 'spiral';
    // Loop back through paths for higher levels
    else {
        const pathCycle = ['serpentine', 'figure8', 'zigzag', 'diamond', 'spiral'];
        const index = Math.floor((level - 1) / 5) % pathCycle.length;
        return pathCycle[index];
    }
}

// Change path layout while preserving towers
function changePathLayout(newLayout) {
    // Store current towers
    const savedTowers = towers.map(tower => ({
        type: tower.type,
        x: tower.x,
        y: tower.y,
        level: tower.level,
        kills: tower.kills,
        specialization: tower.specialization
    }));
    
    // Change layout
    currentPathLayout = newLayout;
    originalPath = pathLayouts[currentPathLayout];
    path = scalePath();
    
    // Update base position for new path
    updateBasePosition();
    
    // Show transition effect
    showPathTransition(newLayout);
    
    // Validate tower positions and adjust if needed
    towers = [];
    savedTowers.forEach(savedTower => {
        // Check if tower position is still valid (not on new path)
        let validPosition = true;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i + 1];
            const dist = distanceToLineSegment(savedTower.x, savedTower.y, p1, p2);
            if (dist < 45) {
                validPosition = false;
                break;
            }
        }
        
        // Check distance from new base position
        const baseDist = Math.sqrt(
            Math.pow(savedTower.x - (base.x + base.width/2), 2) +
            Math.pow(savedTower.y - (base.y + base.height/2), 2)
        );
        if (baseDist < 100) validPosition = false;
        
        if (validPosition) {
            // Recreate tower at same position
            const tower = new Tower(savedTower.type, savedTower.x, savedTower.y);
            tower.level = savedTower.level;
            tower.kills = savedTower.kills;
            tower.specialization = savedTower.specialization;
            
            // Recalculate stats based on level
            for (let i = 1; i < tower.level; i++) {
                const upgradeType = towerTypes[tower.type];
                if (upgradeType.upgrades.damage) {
                    tower.stats.damage = Math.min(
                        upgradeType.upgrades.damage.base + upgradeType.upgrades.damage.perLevel * i,
                        upgradeType.upgrades.damage.max || Infinity
                    );
                }
                if (upgradeType.upgrades.range) {
                    tower.stats.range = Math.min(
                        upgradeType.upgrades.range.base + upgradeType.upgrades.range.perLevel * i,
                        upgradeType.upgrades.range.max || Infinity
                    );
                }
                if (upgradeType.upgrades.fireRate) {
                    tower.stats.fireRate = Math.max(
                        upgradeType.upgrades.fireRate.base + upgradeType.upgrades.fireRate.perLevel * i,
                        upgradeType.upgrades.fireRate.min || 0
                    );
                }
            }
            
            towers.push(tower);
        } else {
            // Tower is on new path, refund it
            money += Math.floor(towerTypes[savedTower.type].cost * 0.8 * savedTower.level);
            showNotification(`Tower refunded due to path change: +üí∞ ${Math.floor(towerTypes[savedTower.type].cost * 0.8 * savedTower.level)}`);
        }
    });
}

// Show path transition animation
function showPathTransition(newLayout) {
    const notification = document.createElement('div');
    notification.id = 'pathTransition';
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.95) 0%, rgba(255, 20, 147, 0.95) 100%);
        padding: 30px 60px;
        border-radius: 30px;
        font-size: 36px;
        font-weight: 900;
        color: white;
        box-shadow: 0 20px 60px rgba(138, 43, 226, 1), inset 0 2px 20px rgba(255,255,255,0.3);
        text-align: center;
        z-index: 2000;
        border: 3px solid rgba(255,255,255,0.3);
        animation: pathPop 0.6s ease-out;
    `;
    
    const layoutNames = {
        spiral: 'Spiral Path',
        zigzag: 'Zigzag Highway',
        cross: 'Cross Roads',
        maze: 'The Maze',
        highway: 'Speed Highway'
    };
    
    notification.innerHTML = `
        <div style="font-size: 20px; margin-bottom: 10px;">PATH CHANGE!</div>
        <div>${layoutNames[newLayout]}</div>
        <div style="font-size: 16px; margin-top: 10px;">Towers preserved!</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'fadeOut 0.5s ease-out';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 500);
    }, 2000);
}

// Show notification for events
function showNotification(message) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        font-size: 16px;
        z-index: 1500;
        animation: slideInRight 0.3s ease-out;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// Add screen shake effect
function addScreenShake(intensity) {
    screenShake = Math.max(screenShake, intensity);
}

// Restart game
function restartGame() {
    // Reset game state
    money = 400;
    health = 100;
    level = 1;
    score = 0;
    enemies = [];
    towers = [];
    projectiles = [];
    particles = [];
    beams = [];
    powerups = [];
    levelActive = false;
    selectedTowerType = null;
    placingTower = false;
    selectedTower = null;
    currentWave = 0;
    totalWaves = 1;
    totalKills = 0;
    enemiesSpawning = false;
    enemiesRemaining = 0;
    waveCountdown = 0;
    
    // Hide game over screen
    document.getElementById('gameOver').style.display = 'none';
    
    // Reset UI
    document.getElementById('startLevel').textContent = '‚ñ∂Ô∏è Start Level 1';
    document.getElementById('startLevel').disabled = false;
    updateUI();
}

// Game over
function gameOver() {
    document.getElementById('gameOver').style.display = 'block';
    document.getElementById('finalScore').textContent = score;
    document.getElementById('bestWave').textContent = challengeMode ? challengeWave : level;
    document.getElementById('totalKills').textContent = totalKills;
    levelActive = false;
    enemiesSpawning = false;
    
    if (challengeMode) {
        showNotification(`üî• Challenge Mode: Reached Wave ${challengeWave}!`);
    }
    
    // Check if score qualifies for leaderboard
    loadLeaderboard();
    const qualifies = leaderboard.length < 10 || score > Math.min(...leaderboard.map(e => e.score));
    
    if (qualifies) {
        setTimeout(() => {
            const name = prompt('New High Score! Enter your name for the leaderboard:') || 'Anonymous';
            addToLeaderboard(name, score, level);
            showLeaderboard();
        }, 1000);
    }
}

// Spawn level
function spawnLevel() {
    const levelInfo = levelData[Math.min(level - 1, levelData.length - 1)];
    currentWave = 0;
    totalWaves = levelInfo.waves;
    
    const healthBeforeWave = health;
    
    spawnWave(levelInfo);
}

// Spawn wave
function spawnWave(levelInfo) {
    currentWave++;
    enemiesSpawning = true;
    
    let totalEnemies = 0;
    let spawnDelay = 0;
    
    const enemySpawns = [];
    levelInfo.enemies.forEach(enemyGroup => {
        for (let i = 0; i < enemyGroup.count; i++) {
            enemySpawns.push({
                type: enemyGroup.type,
                delay: spawnDelay
            });
            spawnDelay += 600; // Faster spawn rate for longer path
        }
        totalEnemies += enemyGroup.count;
    });
    
    enemiesRemaining = totalEnemies;
    
    enemySpawns.forEach(spawn => {
        setTimeout(() => {
            if (levelActive && health > 0) {
                const enemy = new Enemy(spawn.type);
                enemies.push(enemy);
                enemiesRemaining--;
                
                if (enemiesRemaining === 0) {
                    enemiesSpawning = false;
                    
                    if (currentWave < totalWaves) {
                        // Wait for current wave to be cleared before spawning next
                        const checkForNextWave = setInterval(() => {
                            if (enemies.length === 0 && levelActive && health > 0) {
                                clearInterval(checkForNextWave);
                                setTimeout(() => {
                                    if (levelActive && health > 0) {
                                        spawnWave(levelInfo);
                                    }
                                }, 2000);
                            }
                        }, 100);
                    }
                }
            } else {
                enemiesRemaining--;
                if (enemiesRemaining === 0) {
                    enemiesSpawning = false;
                }
            }
        }, spawn.delay);
    });
}

// Check level complete
function checkLevelComplete() {
    // Challenge mode wave complete
    if (challengeMode && !enemiesSpawning && enemies.length === 0) {
        const waveBonus = 50 * challengeWave;
        money += waveBonus;
        score += waveBonus * 2;
        updateUI();
        
        showNotification(`Wave ${challengeWave} Complete! +üí∞${waveBonus}`);
        
        // Auto-start next wave after delay
        setTimeout(() => {
            if (challengeMode && health > 0) {
                startChallengeWave();
            }
        }, 3000);
        return;
    }
    
    if (levelActive && !enemiesSpawning && enemies.length === 0 && currentWave >= totalWaves) {
        levelActive = false;
        const reward = 100 + level * 50;
        money += reward;
        score += reward;
        updateUI();
        
        if (level === 10 && !achievements.wave10.unlocked) {
            unlockAchievement('wave10');
        }
        
        // Level complete notification
        const levelInfo = document.getElementById('levelInfo');
        levelInfo.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 10px;">LEVEL ${level} COMPLETE!</div>
            <div style="font-size: 24px; color: #ffd700;">+${reward} üí∞</div>
        `;
        levelInfo.style.display = 'block';
        
        setTimeout(() => {
            levelInfo.style.display = 'none';
            level++;
            updateUI();
            
            const maxLevel = levelData.length;
            
            if (level > maxLevel) {
                // Game complete!
                document.getElementById('startLevel').textContent = 'üèÜ Game Complete!';
                document.getElementById('startLevel').disabled = true;
            } else {
                document.getElementById('startLevel').textContent = `‚ñ∂Ô∏è Start Level ${level}`;
                document.getElementById('startLevel').disabled = false;
                
                // Start countdown if auto-start is enabled
                if (autoStartEnabled) {
                    waveCountdown = 300; // 5 seconds at 60 FPS
                }
            }
        }, 3000);
    }
}

// Performance settings - OPTIMIZED FOR iPAD
let performanceMode = true; // Enabled by default
let targetFPS = 30; // Lower FPS for smoother performance
let lastFrameTime = 0;
let frameCount = 0;
let fps = 30;
let lastFPSUpdate = 0;
let maxParticles = 100; // Reduced from 500
let particleQuality = 0.5; // Skip half the particles

// Optimized particle creation
function addParticle(x, y, vx, vy, color, life, size) {
    // Limit total particles
    if (particles.length >= maxParticles) {
        // Remove oldest particle
        particles.shift();
    }
    
    // Skip some particles in performance mode
    if (performanceMode && Math.random() > particleQuality) {
        return;
    }
    
    particles.push({
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        color: color,
        life: life,
        size: size
    });
}

// Toggle performance mode
function togglePerformanceMode() {
    performanceMode = !performanceMode;
    const perfBtn = document.getElementById('perfBtn');
    
    if (performanceMode) {
        targetFPS = 30; // Lower FPS for better performance
        maxParticles = 200; // Fewer particles
        particleQuality = 0.5; // Skip half the particles
        perfBtn.textContent = 'üîã Eco';
        perfBtn.style.background = 'linear-gradient(135deg, #00ff00, #00aa00)';
        showNotification('üîã Performance Mode ON - Better performance, reduced effects');
    } else {
        targetFPS = 60; // Full FPS
        maxParticles = 500; // Normal particles
        particleQuality = 1.0; // All particles
        perfBtn.textContent = 'üöÄ Perf';
        perfBtn.style.background = '';
        showNotification('üöÄ Performance Mode OFF - Full visual quality');
    }
}

// Main game loop
function gameLoop(currentTime) {
    // Check if canvas and ctx are initialized
    if (!canvas || !ctx) {
        console.error('Canvas or context not initialized in gameLoop');
        return;
    }
    
    // Frame rate limiting
    if (!currentTime) currentTime = performance.now();
    const deltaTime = currentTime - lastFrameTime;
    const targetFrameTime = 1000 / targetFPS;
    
    if (deltaTime < targetFrameTime) {
        requestAnimationFrame(gameLoop);
        return;
    }
    
    lastFrameTime = currentTime - (deltaTime % targetFrameTime);
    
    // FPS counter
    frameCount++;
    if (currentTime - lastFPSUpdate >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFPSUpdate = currentTime;
        
        // Update FPS display
        const fpsElement = document.getElementById('fps');
        if (fpsElement) {
            fpsElement.textContent = `${fps} FPS`;
            // Color code based on performance
            if (fps >= 55) {
                fpsElement.style.color = '#00ff00';
            } else if (fps >= 30) {
                fpsElement.style.color = '#ffff00';
            } else {
                fpsElement.style.color = '#ff0000';
            }
        }
    }
    
    // Handle pause
    if (isPaused) {
        // Draw pause overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 48px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
        requestAnimationFrame(gameLoop);
        return; // Don't continue game loop
    }
    
    try {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Check if game is initialized
        if (!path || path.length === 0) {
            // Try to initialize path
            if (originalPath && originalPath.length > 0) {
                path = scalePath();
                updateBasePosition();
            } else {
                // Still not ready, show loading
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Initializing game...', canvas.width/2, canvas.height/2);
            }
            
            requestAnimationFrame(gameLoop);
            return;
        }
        
        // Handle screen shake
        if (screenShake > 0) {
            shakeX = (Math.random() - 0.5) * screenShake;
            shakeY = (Math.random() - 0.5) * screenShake;
            ctx.save();
            ctx.translate(shakeX, shakeY);
            screenShake *= 0.9; // Decay shake
            if (screenShake < 0.1) screenShake = 0;
        }
        
        // Draw background
        drawBackground();
        drawGrid();
        drawPath();
        drawBase();
        
        // Update and draw towers
        towers.forEach(tower => {
            tower.update();
            tower.draw();
        });
        
        // Update and draw enemies
        enemies = enemies.filter(enemy => {
            const reachedBase = enemy.update();
            if (!reachedBase) {
                enemy.draw();
                return true;
            }
            return false;
        });
        
        // Update and draw projectiles
        updateProjectiles();
        drawProjectiles();
        
        // Update and draw other elements
        updateParticles();
        drawParticles();
        updateBeams();
        drawBeams();
        updatePowerups();
        drawPowerups();
        
        // Draw boss health bars
        drawBossHealthBars();
        
        // Update player 2 cursor in co-op mode
        updatePlayer2Cursor();
        
        // Tower placement preview
        if (placingTower && selectedTowerType) {
            const worldX = mousePos.x + camera.x;
            const worldY = mousePos.y + camera.y;
            
            // Check if position is valid
            let validPosition = true;
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                const dist = distanceToLineSegment(worldX, worldY, p1, p2);
                if (dist < 45) { // Adjusted for narrower path
                    validPosition = false;
                    break;
                }
            }
            
            // Check distance from base
            const baseDist = Math.sqrt(
                Math.pow(worldX - (base.x + base.width/2), 2) +
                Math.pow(worldY - (base.y + base.height/2), 2)
            );
            if (baseDist < 100) validPosition = false;
            
            // Check distance from other towers
            for (let tower of towers) {
                const towerDist = Math.sqrt(
                    Math.pow(worldX - tower.x, 2) +
                    Math.pow(worldY - tower.y, 2)
                );
                if (towerDist < 60) {
                    validPosition = false;
                    break;
                }
            }
            
            // Draw range preview
            ctx.save();
            ctx.strokeStyle = validPosition ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(mousePos.x, mousePos.y, towerTypes[selectedTowerType].range * getScaleFactor(), 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
            
            // Draw tower preview
            ctx.globalAlpha = validPosition ? 0.7 : 0.3;
            const ghost = new Tower(selectedTowerType, worldX, worldY);
            ghost.draw();
            ctx.globalAlpha = 1;
            
            // Show cost
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            
            if (!validPosition) {
                ctx.fillStyle = '#ff0000';
                ctx.fillText('INVALID POSITION', mousePos.x, mousePos.y - 60);
            } else {
                ctx.fillStyle = money >= towerTypes[selectedTowerType].cost ? '#00ff00' : '#ff0000';
                ctx.fillText(`üí∞ ${towerTypes[selectedTowerType].cost}`, mousePos.x, mousePos.y - 60);
            }
        }
        
        // Check level complete
        checkLevelComplete();
        
        // Draw countdown if auto-starting
        if (waveCountdown > 0 && !levelActive) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
            
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 36px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`Next wave in: ${Math.ceil(waveCountdown / 60)}`, canvas.width/2, canvas.height/2);
            ctx.restore();
            
            waveCountdown -= gameSpeed;
            if (waveCountdown <= 0) {
                document.getElementById('startLevel').click();
            }
        }
        
        // Update UI
        updateUI();
        
        // Restore context if shake was applied
        if (screenShake > 0) {
            ctx.restore();
        }
        
    } catch (error) {
        console.error('Game loop error:', error);
        console.error('Error stack:', error.stack);
        
        // Try to draw something simple to show canvas is working
        ctx.fillStyle = 'yellow';
        ctx.font = '20px Arial';
        ctx.fillText('Error in game loop! Check console.', 50, 50);
    }
    
    requestAnimationFrame(gameLoop);
}

// Helper function for distance to line segment
function distanceToLineSegment(px, py, p1, p2) {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / (dx * dx + dy * dy)));
    const nearestX = p1.x + t * dx;
    const nearestY = p1.y + t * dy;
    return Math.sqrt(Math.pow(px - nearestX, 2) + Math.pow(py - nearestY, 2));
}

// Event listeners
// Function to handle pointer position updates
function updatePointerPosition(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    mousePos.x = clientX - rect.left;
    mousePos.y = clientY - rect.top;
}

// Setup event listeners
function setupEventListeners() {
    if (!canvas) {
        console.error('Canvas not initialized for event listeners');
        return;
    }
    
    // Mouse events
    canvas.addEventListener('mousemove', (e) => {
    updatePointerPosition(e.clientX, e.clientY);
    
    const worldX = mousePos.x + camera.x;
    const worldY = mousePos.y + camera.y;
    
    hoveredTower = null;
    if (!placingTower) {
        for (let tower of towers) {
            const dist = Math.sqrt(
                Math.pow(worldX - tower.x, 2) +
                Math.pow(worldY - tower.y, 2)
            );
            if (dist < 40) {
                hoveredTower = tower;
                canvas.style.cursor = 'pointer';
                break;
            }
        }
        
        if (!hoveredTower) {
            // Check for power-ups
            let hoveringPowerup = false;
            for (let powerup of powerups) {
                const dist = Math.sqrt(
                    Math.pow(worldX - powerup.x, 2) +
                    Math.pow(worldY - powerup.y, 2)
                );
                if (dist < 30) {
                    canvas.style.cursor = 'pointer';
                    hoveringPowerup = true;
                    break;
                }
            }
            
            if (!hoveringPowerup) {
                canvas.style.cursor = 'crosshair';
            }
        }
    }

    // Handle repositioning drag
    handleRepositioningDrag(e);

    // Update faint range indicators for nearby towers
    for (let tower of towers) {
        const screenX = tower.x - camera.x;
        const screenY = tower.y - camera.y;
        const mouseDist = Math.sqrt(
            Math.pow(screenX - mousePos.x, 2) +
            Math.pow(screenY - mousePos.y, 2)
        );
        tower.showFaintRange = mouseDist < 100 && tower !== selectedTower && tower !== hoveredTower;
    }
});

// Touch events for iOS
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        const touch = e.touches[0];
        updatePointerPosition(touch.clientX, touch.clientY);
        handleCanvasClick();
    }
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        const touch = e.touches[0];
        updatePointerPosition(touch.clientX, touch.clientY);

        // Handle repositioning drag
        handleRepositioningDrag(e);
    }
});

// Mouse up event
canvas.addEventListener('mouseup', (e) => {
    stopRepositioning(e);
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    stopRepositioning(e);
});

// Function to handle canvas clicks/taps
function handleCanvasClick() {
    const worldX = mousePos.x + camera.x;
    const worldY = mousePos.y + camera.y;

    // Check for tower repositioning first
    const clickedTower = getTowerAt(worldX, worldY);
    if (clickedTower && canRepositionTower(clickedTower)) {
        startRepositioning(clickedTower, worldX, worldY);
        return; // Don't execute other click handlers
    }

    // Quick sell mode with shift
    if (shiftPressed) {
        for (let tower of towers) {
            const dist = Math.sqrt(
                Math.pow(tower.x - worldX, 2) +
                Math.pow(tower.y - worldY, 2)
            );
            if (dist < 40) {
                selectedTower = tower;
                sellTower();
                return;
            }
        }
    }
    
    // Check for power-up collection
    for (let i = powerups.length - 1; i >= 0; i--) {
        const powerup = powerups[i];
        const dist = Math.sqrt(
            Math.pow(worldX - powerup.x, 2) +
            Math.pow(worldY - powerup.y, 2)
        );
        if (dist < 30) {
            if (powerup.type === 'money') {
                money += powerup.value;
            } else if (powerup.type === 'health') {
                health = Math.min(100, health + powerup.value);
            }
            updateUI();
            
            // Collection effect
            for (let j = 0; j < 10; j++) {
                particles.push({
                    x: powerup.x,
                    y: powerup.y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10 - 5,
                    color: powerup.type === 'money' ? '#ffd700' : '#ff0000',
                    life: 1,
                    size: 5
                });
            }
            
            powerups.splice(i, 1);
            return;
        }
    }
    
    if (placingTower && selectedTowerType) {
        // Check if position is valid
        let validPosition = true;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i + 1];
            const dist = distanceToLineSegment(worldX, worldY, p1, p2);
            if (dist < 45) { // Adjusted for narrower path
                validPosition = false;
                break;
            }
        }
        
        // Check distance from base
        const baseDist = Math.sqrt(
            Math.pow(worldX - (base.x + base.width/2), 2) +
            Math.pow(worldY - (base.y + base.height/2), 2)
        );
        if (baseDist < 100) validPosition = false;
        
        // Check distance from other towers
        for (let tower of towers) {
            const towerDist = Math.sqrt(
                Math.pow(worldX - tower.x, 2) +
                Math.pow(worldY - tower.y, 2)
            );
            if (towerDist < 60) {
                validPosition = false;
                break;
            }
        }
        
        const cost = towerTypes[selectedTowerType].cost;
        if (validPosition && money >= cost) {
            money -= cost;
            const newTower = new Tower(selectedTowerType, worldX, worldY);
            towers.push(newTower);
            
            // Check synergies for all towers
            towers.forEach(tower => tower.checkSynergies());
            
            updateUI();
            
            // Placement effect
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: worldX,
                    y: worldY,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: towerTypes[selectedTowerType].color,
                    life: 1,
                    size: 5
                });
            }
            
            placingTower = false;
            selectedTowerType = null;
            canvas.style.cursor = 'crosshair';
        }
    } else if (sellMode) {
        // Sell mode - click tower to sell
        let clickedTower = null;
        for (let tower of towers) {
            const dist = Math.sqrt(
                Math.pow(worldX - tower.x, 2) +
                Math.pow(worldY - tower.y, 2)
            );
            if (dist < 40) {
                clickedTower = tower;
                break;
            }
        }
        
        if (clickedTower) {
            const sellPrice = Math.floor(clickedTower.stats.cost * 0.7);
            money += sellPrice;
            towers = towers.filter(t => t !== clickedTower);
            if (selectedTower === clickedTower) {
                selectedTower = null;
            }
            showNotification(`Tower sold for üí∞${sellPrice}`);
            updateUI();
        }
        sellMode = false;
        canvas.style.cursor = 'default';
    } else if (!placingTower) {
        // Check if clicking on a tower
        let clickedTower = null;
        for (let tower of towers) {
            const dist = Math.sqrt(
                Math.pow(worldX - tower.x, 2) +
                Math.pow(worldY - tower.y, 2)
            );
            if (dist < 40) {
                clickedTower = tower;
                break;
            }
        }
        
        if (clickedTower) {
            // Check if clicking on ability button
            const scale = getScaleFactor();
            const abilityX = clickedTower.x + 30 * scale;
            const abilityY = clickedTower.y - 30 * scale;
            const abilityDist = Math.sqrt(
                Math.pow(worldX - abilityX, 2) +
                Math.pow(worldY - abilityY, 2)
            );
            
            if (abilityDist < 15 * scale && clickedTower.level >= 5) {
                // Clicked on ability button
                clickedTower.activateAbility();
            } else {
                // Normal tower selection
                selectedTower = clickedTower;
            }
        } else {
            selectedTower = null;
        }
        updateUI();
    }
}

// Mouse click event
canvas.addEventListener('click', (e) => {
    handleCanvasClick();
});

// UI Event listeners
document.getElementById('startLevel').addEventListener('click', function() {
    if (!levelActive) {
        levelActive = true;
        this.disabled = true;
        spawnLevel();
    }
});

document.getElementById('addTowerBtn').addEventListener('click', function() {
    document.getElementById('towerModal').style.display = 'flex';
    selectedTower = null;
    placingTower = false;
    selectedTowerType = null;
    updateUI();
});

document.getElementById('closeTowerModal').addEventListener('click', function() {
    document.getElementById('towerModal').style.display = 'none';
    placingTower = false;
    selectedTowerType = null;
    canvas.style.cursor = 'crosshair';
});

// Speed button click is handled by cycleGameSpeed() in the onclick attribute

document.querySelectorAll('.towerOption').forEach(option => {
    option.addEventListener('click', function() {
        const type = this.dataset.type;
        if (money >= towerTypes[type].cost && !this.classList.contains('disabled')) {
            selectedTowerType = type;
            placingTower = true;
            selectedTower = null;
            document.getElementById('towerModal').style.display = 'none';
            
            document.querySelectorAll('.towerOption').forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
        }
    });
});

// Cancel placement on right click or escape
canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    placingTower = false;
    selectedTowerType = null;
    canvas.style.cursor = 'crosshair';
});

// Shift for sell mode
let shiftPressed = false;

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        placingTower = false;
        selectedTowerType = null;
        selectedTower = null;
        sellMode = false;
        canvas.style.cursor = 'default';
        document.getElementById('towerModal').style.display = 'none';
        updateUI();
    } else if (e.key === 'u' || e.key === 'U') {
        if (selectedTower) {
            upgradeTower();
        }
    } else if (e.key === 's' || e.key === 'S') {
        if (challengeMode) {
            showNotification('‚ùå Cannot sell towers in Challenge Mode!');
        } else if (!placingTower && !selectedTower) {
            // Enter sell mode
            sellMode = true;
            canvas.style.cursor = 'not-allowed';
            showNotification('Sell Mode: Click a tower to sell (ESC to cancel)');
        } else if (selectedTower) {
            sellTower();
        }
    } else if (e.key === 'p' || e.key === 'P') {
        togglePause();
    } else if (e.key === 'a' || e.key === 'A') {
        // Activate tower ability
        if (selectedTower && selectedTower.level >= 5) {
            selectedTower.activateAbility();
        }
    } else if (e.key >= '1' && e.key <= '9') {
        // Tower hotkeys (extended to 9)
        const towerTypeMap = ['pulse', 'laser', 'missile', 'tesla', 'plasma', 'railgun', 'quantum', 'void', 'crystal'];
        const typeIndex = parseInt(e.key) - 1;
        if (typeIndex < towerTypeMap.length) {
            const towerType = towerTypeMap[typeIndex];
            if (money >= towerTypes[towerType].cost) {
                selectedTowerType = towerType;
                placingTower = true;
                canvas.style.cursor = 'crosshair';
                document.getElementById('towerModal').style.display = 'none';
                showNotification(`Placing ${towerTypes[towerType].name} (${e.key})`);
            } else {
                showNotification(`Not enough money for ${towerTypes[towerType].name}`);
            }
        }
    } else if (e.key === 'Shift' && !shiftPressed) {
        shiftPressed = true;
        canvas.style.cursor = 'pointer';
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key === 'Shift') {
        shiftPressed = false;
        canvas.style.cursor = placingTower ? 'crosshair' : 'default';
    }
});
} // End of setupEventListeners

// Initialize everything when DOM is ready
function initGame() {
    console.log('Initializing game...');
    
    // Load leaderboard data
    loadLeaderboard();
    
    // Initialize canvas
    canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error('Canvas not found!');
        return;
    }
    
    ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('Could not get 2D context!');
        return;
    }
    
    console.log('Canvas and context initialized');
    
    // Set up event listeners
    setupEventListeners();
    
    // Set initial canvas size
    resizeCanvas();
    
    // Add resize listener
    window.addEventListener('resize', resizeCanvas);

    // Initialize scaled elements after canvas is ready
    if (originalPath) {
        path = scalePath();
        updateBasePosition();
    }

    // Make functions globally accessible for onclick handlers
    window.upgradeTower = upgradeTower;
    window.sellTower = sellTower;
    window.selectTowerType = selectTowerType;
    window.specializeTower = specializeTower;
    window.startNextLevel = startNextLevel;
    window.toggleWavePreview = toggleWavePreview;
    window.togglePause = togglePause;
    window.cycleGameSpeed = cycleGameSpeed;
    window.toggleAutoStart = toggleAutoStart;
    window.restartGame = restartGame;
    window.closeLeaderboard = closeLeaderboard;
    window.showInGameLeaderboard = showInGameLeaderboard;
    window.selectLevel = selectLevel;
    
    // Also make canvas and ctx globally accessible
    window.canvas = canvas;
    window.ctx = ctx;

    // Initialize UI
    updateUI();
    
    // Populate level selector for testing
    const levelSelect = document.getElementById('levelSelect');
    if (levelSelect && levelSelect.options.length <= 1) {
        // Add boss levels with special markers
        const bossLevels = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
        for (let i = 1; i <= 50; i++) {
            const option = document.createElement('option');
            option.value = i;
            if (bossLevels.includes(i)) {
                option.textContent = `Level ${i} ‚öîÔ∏è BOSS`;
                option.style.color = '#ff0000';
            } else {
                option.textContent = `Level ${i}`;
            }
            levelSelect.appendChild(option);
        }
    }
    
    // Initialize tower repositioning system
    if (window.TowerRepositioningSystem) {
        console.log('Initializing Tower Repositioning System...');
        window.TowerRepositioningSystem.init();
    }

    // Start game loop
    console.log('Starting game loop...');
    requestAnimationFrame(gameLoop);
}

function setupBasicElements() {
    console.log('Setting up basic elements...');
    // Just make functions globally accessible for onclick handlers
    window.startSinglePlayer = startSinglePlayer;
    window.startCoOp = startCoOp;
    window.startChallenge = startChallenge;
    window.showLeaderboard = showLeaderboard;

    // Expose tower placement and repositioning functions
    window.placeTowerAt = placeTowerAt;
    window.canRepositionTower = canRepositionTower;
    window.markTowerAsRepositionable = markTowerAsRepositionable;
    window.startRepositioning = startRepositioning;
    window.handleRepositioningDrag = handleRepositioningDrag;
    window.stopRepositioning = stopRepositioning;

    // Expose game data for debugging
    window.towers = towers;
    window.towerTypes = towerTypes;
    window.recentlyPlacedTowers = recentlyPlacedTowers;
    window.pointToLineDistance = pointToLineDistance;
    window.repositionTimeLimit = repositionTimeLimit;
}

// Don't auto-initialize game - wait for user to select mode
window.addEventListener('load', function() {
    console.log('Window loaded, initializing game...');
    setupBasicElements();
    initGame();
});

// Also try DOMContentLoaded as backup
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded');
    if (!canvas) {
        console.log('Canvas not initialized yet, waiting for window load...');
    }
});
</script>
