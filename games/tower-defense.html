<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>Ultra Premium Tower Defense - v2</title>

<script src="app_store_features.js"></script>
<script src="game_assets.js"></script>
<script src="visual_excellence.js"></script>

<script>
// Initialize App Store Features
let gameSystems = null;
let playerData = {
    level: 1,
    xp: 0,
    gems: 50,
    tickets: 5,
    vipActive: false,
    battlePassLevel: 1
};

// Initialize on game start
document.addEventListener('DOMContentLoaded', function() {
    gameSystems = initializeAppStoreFeatures();
    
    // Initialize Visual Excellence Systems
    if (typeof initializeVisualExcellence !== 'undefined') {
        initializeVisualExcellence();
        console.log('Visual Excellence systems initialized');
    }
    
    // Update UI with player data
    updateCurrencyDisplay();
    checkDailyRewards();
    initializeSocialFeatures();
});
</script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: white;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            margin: 0;
            padding: 0;
            /* iOS specific */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            /* Handle safe areas on iOS */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #0a0a2e 0%, #000511 50%, #1a0033 100%);
            /* Prevent bounce scrolling on iOS */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }
        
        #ui {
            background: linear-gradient(135deg, rgba(20,20,60,0.95) 0%, rgba(40,20,80,0.95) 50%, rgba(60,10,90,0.95) 100%);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8), inset 0 -2px 10px rgba(255,20,147,0.3);
            border-bottom: 2px solid;
            border-image: linear-gradient(90deg, #8a2be2, #ff1493, #00ffff) 1;
            flex-wrap: wrap;
            gap: 15px;
            min-height: 70px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        #ui::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: uiShine 8s linear infinite;
        }
        
        @keyframes uiShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        #gameCanvas {
            flex: 1;
            background: #000;
            cursor: crosshair;
            image-rendering: crisp-edges;
            /* iOS specific */
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, rgba(0,0,0,0.6) 0%, rgba(50,0,100,0.4) 100%);
            padding: 10px 20px;
            border-radius: 30px;
            border: 2px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .stat::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .stat:hover::after {
            opacity: 1;
        }
        
        .stat:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 20, 147, 0.6);
        }
        
        .icon {
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, #ff1493 0%, #8a2be2 50%, #00ffff 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8), inset 0 -2px 5px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
            position: relative;
        }
        
        .icon::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, #ff1493, #8a2be2, #00ffff);
            border-radius: 50%;
            opacity: 0.5;
            filter: blur(5px);
            animation: iconGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes iconGlow {
            0% { opacity: 0.3; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(1.1); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(138, 43, 226, 0.8); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(255, 20, 147, 1); }
        }
        
        button {
            background: linear-gradient(135deg, #8a2be2 0%, #ff1493 100%);
            color: white;
            border: 2px solid transparent;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6), inset 0 -2px 10px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            /* iOS specific */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        
        button:hover::before {
            animation: shine 0.5s ease-in-out;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }
        
        button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(255, 20, 147, 0.8), inset 0 -2px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        button:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            filter: grayscale(50%);
        }
        
        #pauseBtn {
            min-width: 80px;
        }
        
        #autoStartCheck {
            margin-right: 5px;
        }
        
        #addTowerBtn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 50%, #00ff44 100%);
            border: 2px solid #00ff44;
            color: #001122;
            font-weight: 900;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 20px rgba(0, 255, 136, 0.6), inset 0 -2px 10px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 4px 30px rgba(0, 255, 136, 1), inset 0 -2px 10px rgba(0,0,0,0.3); }
        }
        
        #towerModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(138,43,226,0.1) 0%, rgba(0,0,0,0.95) 100%);
            backdrop-filter: blur(10px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #towerGrid {
            background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 50%, rgba(60,10,90,0.98) 100%);
            padding: 40px;
            border-radius: 30px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            border: 3px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493, #00ffff) 1;
            box-shadow: 0 20px 60px rgba(138, 43, 226, 0.8), inset 0 2px 20px rgba(255,255,255,0.1);
            animation: slideIn 0.4s ease-out;
            position: relative;
        }
        
        #towerGrid::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #8a2be2, #ff1493, #00ffff, #8a2be2);
            border-radius: 30px;
            opacity: 0.5;
            z-index: -1;
            filter: blur(10px);
            /* Removed spinning animation */
        }
        
        @keyframes slideIn {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .towerOption {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2) 0%, rgba(255, 20, 147, 0.1) 50%, rgba(0, 255, 255, 0.1) 100%);
            padding: 25px;
            border-radius: 20px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
            text-align: center;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .towerOption::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #8a2be2, #ff1493, #00ffff, #8a2be2);
            border-radius: 20px;
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            filter: blur(5px);
        }
        
        .towerOption:hover::before {
            opacity: 1;
            /* Removed spinning animation */
        }
        
        .towerOption:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 20px 40px rgba(255, 20, 147, 0.6);
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.4) 0%, rgba(255, 20, 147, 0.3) 50%, rgba(0, 255, 255, 0.2) 100%);
        }
        
        .towerOption.selected {
            border-color: #00ff00;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(0, 255, 0, 0.3);
            transform: scale(1.05);
        }
        
        .towerOption.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        
        .towerOption.disabled:hover {
            transform: none;
        }
        
        .towerStats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        
        #levelInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.95) 0%, rgba(255, 20, 147, 0.95) 100%);
            padding: 30px 60px;
            border-radius: 30px;
            font-size: 36px;
            font-weight: 900;
            display: none;
            box-shadow: 0 20px 60px rgba(138, 43, 226, 1), inset 0 2px 20px rgba(255,255,255,0.3);
            text-align: center;
            z-index: 1000;
            border: 3px solid rgba(255,255,255,0.3);
            animation: levelPop 0.6s ease-out;
        }
        
        @keyframes levelPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(180deg); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(90deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(0); opacity: 1; }
            to { transform: translateX(-50%) translateY(-50px); opacity: 0; }
        }
        
        @keyframes fadeUp {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        
        @keyframes pathPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(180deg); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(90deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100px); opacity: 0; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        /* Game mode selection */
        .game-mode-option {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2) 0%, rgba(255, 20, 147, 0.1) 100%);
            padding: 40px;
            border-radius: 30px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
            min-width: 250px;
        }
        
        .game-mode-option:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 20px 40px rgba(255, 20, 147, 0.6);
            border-color: #ff1493;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.4) 0%, rgba(255, 20, 147, 0.3) 100%);
        }
        
        .game-mode-option h2 {
            color: #fff;
            margin: 10px 0;
            font-size: 28px;
        }
        
        .game-mode-option p {
            color: #ccc;
            margin: 0;
            font-size: 16px;
        }
        
        /* Co-op mode indicators */
        .player-cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            transition: all 0.1s;
        }
        
        #player2Cursor {
            background: radial-gradient(circle, rgba(255, 20, 147, 0.8) 0%, rgba(255, 20, 147, 0.4) 50%, transparent 70%);
            border: 2px solid #ff1493;
        }
        
        .player-indicator {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 8px;
            border-radius: 10px;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 100%);
            padding: 60px;
            border-radius: 40px;
            text-align: center;
            display: none;
            box-shadow: 0 30px 80px rgba(138, 43, 226, 1), inset 0 2px 30px rgba(255,255,255,0.2);
            border: 4px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            z-index: 1000;
        }
        
        #towerInfo {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(20,20,60,0.95) 0%, rgba(40,20,80,0.95) 50%, rgba(60,10,90,0.95) 100%);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6), inset 0 2px 10px rgba(255,255,255,0.1);
            display: none;
            min-width: 250px;
            backdrop-filter: blur(10px);
            animation: slideInRight 0.3s ease-out;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        #towerInfo h3 {
            color: #fff;
            margin: 0 0 15px 0;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(255,20,147,0.8);
        }
        
        .tower-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            color: #ccc;
            font-size: 14px;
        }
        
        .tower-stat-label {
            color: #888;
        }
        
        .tower-stat-value {
            color: #fff;
            font-weight: bold;
        }
        
        #upgradeBtn {
            width: 100%;
            margin-top: 15px;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            border-color: #00ff88;
            color: #001122;
        }
        
        #upgradeBtn:disabled {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            border-color: #555;
            color: #999;
        }
        
        .closeBtn {
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            color: rgba(255, 255, 255, 0.6) !important;
            font-size: 16px !important;
            cursor: pointer !important;
            padding: 0 !important;
            width: 28px !important;
            height: 28px !important;
            border-radius: 14px !important;
            box-shadow: none !important;
            transition: all 0.3s !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            line-height: 1 !important;
        }
        
        .closeBtn:hover {
            background: rgba(255, 100, 100, 0.3) !important;
            border-color: rgba(255, 100, 100, 0.5) !important;
            color: #fff !important;
            transform: scale(1.1) !important;
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.5) !important;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(138, 43, 226, 0.1);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #8a2be2, #ff1493);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #ff1493, #8a2be2);
        }
        
        /* Clean floating damage numbers */
        .damage-number {
            position: fixed;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 1000;
            -webkit-font-smoothing: antialiased;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(0.5);
                opacity: 0;
            }
        }
        
        /* Screen shake */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2px, 2px); }
            20% { transform: translate(2px, -2px); }
            30% { transform: translate(-3px, 0); }
            40% { transform: translate(3px, 2px); }
            50% { transform: translate(0, -2px); }
            60% { transform: translate(-2px, 3px); }
            70% { transform: translate(2px, 0); }
            80% { transform: translate(-1px, -2px); }
            90% { transform: translate(1px, 2px); }
        }
        
        .shake {
            animation: shake 0.3s ease-in-out;
        }
        
        /* Wave Preview */
        #wavePreview {
            position: fixed;
            top: 120px;
            left: 20px;
            background: linear-gradient(135deg, rgba(20,20,60,0.95) 0%, rgba(40,20,80,0.95) 100%);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid;
            border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6);
            display: none;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #wavePreview h4 {
            color: #00ffff;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        
        .wave-enemy {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .wave-enemy-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .wave-enemy-info {
            flex: 1;
            font-size: 12px;
        }
        
        .wave-enemy-name {
            color: #fff;
            font-weight: bold;
        }
        
        .wave-enemy-count {
            color: #888;
        }
        
        /* Achievements */
        #achievementPopup {
            position: fixed;
            top: 100px;
            right: -400px;
            background: linear-gradient(135deg, rgba(255,215,0,0.95) 0%, rgba(255,165,0,0.95) 100%);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(255,215,0,0.8);
            transition: right 0.5s ease-out;
            max-width: 350px;
            z-index: 1000;
        }
        
        #achievementPopup.show {
            right: 20px;
        }
        
        #achievementPopup h3 {
            color: #000;
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        #achievementPopup p {
            color: #333;
            margin: 0;
            font-size: 14px;
        }
        
        /* Target priority selector */
        .target-priority {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .target-option {
            cursor: pointer;
            padding: 3px 8px;
            border-radius: 10px;
            transition: all 0.3s;
        }
        
        .target-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .target-option.active {
            background: rgba(0,255,255,0.3);
            color: #00ffff;
        }
        
        /* Specialization buttons */
        .spec-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .spec-btn {
            flex: 1;
            padding: 10px;
            font-size: 12px;
            background: linear-gradient(135deg, #4a4a6a 0%, #3a3a5a 100%);
        }
        
        .spec-btn:hover {
            background: linear-gradient(135deg, #5a5a7a 0%, #4a4a6a 100%);
        }
        
        .spec-btn.selected {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
        }
        /* Power-up effect */
        .powerup {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            box-shadow: 0 0 20px #ffd700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            animation: powerupFloat 2s ease-in-out infinite;
            cursor: pointer;
            z-index: 100;
        }
        
        @keyframes powerupFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
    
    /* App Store Feature Styles */
    .currency-bar {
        position: fixed;
        top: 10px;
        left: 10px;
        display: flex;
        gap: 15px;
        z-index: 1000;
    }
    
    .currency-item {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.8);
        padding: 8px 15px;
        border-radius: 20px;
        border: 2px solid;
    }
    
    .currency-gold { border-color: #FFD700; }
    .currency-gems { border-color: #FF1493; }
    .currency-tickets { border-color: #00CED1; }
    
    .currency-plus {
        width: 20px;
        height: 20px;
        background: #00ff00;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 14px;
        color: white;
    }
    
    .battle-pass-indicator {
        position: fixed;
        top: 10px;
        right: 10px;
        background: linear-gradient(135deg, #FFD700, #FFA500);
        padding: 8px 20px;
        border-radius: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .bp-progress {
        width: 100px;
        height: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow: hidden;
    }
    
    .bp-fill {
        height: 100%;
        background: #00ff00;
        transition: width 0.3s;
    }
    
    .daily-reward-btn {
        position: fixed;
        top: 60px;
        right: 10px;
        background: linear-gradient(135deg, #8B008B, #FF1493);
        padding: 10px 20px;
        border-radius: 20px;
        cursor: pointer;
        color: white;
        font-weight: bold;
    }
    
    .notification-dot {
        position: absolute;
        top: -5px;
        right: -5px;
        width: 12px;
        height: 12px;
        background: red;
        border-radius: 50%;
        display: none;
    }
    
    .notification-dot.active {
        display: block;
        animation: pulse 1s infinite;
    }
    
    /* Loot box styles */
    .lootbox-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #2d1b69, #1a0033);
        border: 3px solid #FFD700;
        border-radius: 20px;
        padding: 30px;
        z-index: 10000;
        display: none;
    }
    
    .lootbox-opening {
        animation: shake 0.5s, explode 1s 0.5s forwards;
    }
    
    @keyframes shake {
        0%, 100% { transform: translate(-50%, -50%) rotate(-5deg); }
        50% { transform: translate(-50%, -50%) rotate(5deg); }
    }
    
    @keyframes explode {
        to { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
    }
    
    /* Achievement notification */
    .achievement-notification {
        position: fixed;
        top: 100px;
        right: -400px;
        width: 350px;
        background: linear-gradient(135deg, #FFD700, #FFA500);
        border-radius: 15px;
        padding: 15px;
        transition: right 0.5s;
        z-index: 10001;
    }
    
    .achievement-notification.show {
        right: 20px;
    }

</style>
</head>
<body>

    <!-- App Store UI Elements -->
    <div class="currency-bar">
        <div class="currency-item currency-gold">
            <div class="currency-icon">üí∞</div>
            <div class="currency-amount" id="goldAmount">1,000</div>
        </div>
        <div class="currency-item currency-gems">
            <div class="currency-icon">üíé</div>
            <div class="currency-amount" id="gemAmount">50</div>
            <div class="currency-plus" onclick="openGemShop()">+</div>
        </div>
        <div class="currency-item currency-tickets">
            <div class="currency-icon">üéüÔ∏è</div>
            <div class="currency-amount" id="ticketAmount">5</div>
        </div>
    </div>
    
    <div class="battle-pass-indicator" onclick="openBattlePass()">
        <span class="bp-level">BP LV <span id="bpLevel">1</span></span>
        <div class="bp-progress">
            <div class="bp-fill" id="bpFill" style="width: 0%"></div>
        </div>
    </div>
    
    <div class="daily-reward-btn" onclick="showDailyRewards()">
        <span>üìÖ Daily</span>
        <span class="notification-dot" id="dailyDot"></span>
    </div>

    <!-- Game Mode Selection -->
    <div id="gameModeSelect" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0a2e 0%, #000511 50%, #1a0033 100%); display: flex; justify-content: center; align-items: center; z-index: 3000;">
        <div style="background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 100%); padding: 60px; border-radius: 40px; text-align: center; box-shadow: 0 30px 80px rgba(138, 43, 226, 1); border: 4px solid; border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1;">
            <h1 style="color: #fff; margin-bottom: 40px; font-size: 48px; text-shadow: 0 0 20px rgba(255,20,147,0.8);">Ultra Premium Tower Defense</h1>
            <div style="display: flex; gap: 40px; justify-content: center; flex-wrap: wrap;">
                <div class="game-mode-option" onclick="startSinglePlayer()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üéÆ</div>
                    <h2>Single Player</h2>
                    <p>Classic tower defense experience</p>
                </div>
                <div class="game-mode-option" onclick="startCoOp()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üë•</div>
                    <h2>Local Co-Op</h2>
                    <p>Team up with a friend!</p>
                    <div style="margin-top: 15px; font-size: 14px; color: #aaa;">
                        P1: Mouse | P2: WASD + Space
                    </div>
                </div>
                <div class="game-mode-option" onclick="viewLeaderboard()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üèÜ</div>
                    <h2>Leaderboard</h2>
                    <p>View high scores</p>
                </div>
                <div class="game-mode-option" onclick="startChallenge()">
                    <div style="font-size: 60px; margin-bottom: 20px;">üî•</div>
                    <h2>Challenge Mode</h2>
                    <p>Endless waves, limited lives</p>
                    <div style="margin-top: 15px; font-size: 14px; color: #ffa500;">
                        No selling ‚Ä¢ 3 lives ‚Ä¢ Increasing difficulty
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Player 2 Cursor for Co-op -->
    <div id="player2Cursor" class="player-cursor" style="display: none;">
        <div class="player-indicator">P2</div>
    </div>

    <div id="gameContainer" style="display: none;">
        <div id="ui">
            <div style="display: flex; gap: 15px; align-items: center;">
                <div class="stat">
                    <div class="icon">üí∞</div>
                    <span id="money">500</span>
                </div>
                <div class="stat">
                    <div class="icon">‚ù§Ô∏è</div>
                    <span id="health">100</span>
                </div>
                <div class="stat">
                    <div class="icon">‚öîÔ∏è</div>
                    <span><span id="level">1</span>/50</span>
                </div>
                <div class="stat">
                    <div class="icon">‚≠ê</div>
                    <span id="score">0</span>
                </div>
                <div class="stat" id="fpsDisplay" style="font-size: 12px; opacity: 0.7;">
                    <span id="fps">60 FPS</span>
                </div>
                <div class="stat" id="themeDisplay" style="min-width: 150px;">
                    <div class="icon">üåç</div>
                    <span id="themeName">Grassland</span>
                </div>
                <div class="stat" id="waveStatus" style="display: none;">
                    <div class="icon">üëæ</div>
                    <span><span id="currentWave">1</span>/<span id="totalWaves">1</span> ‚Ä¢ <span id="enemyCount">0</span></span>
                </div>
                <div class="stat" id="coopIndicator" style="display: none;">
                    <div class="icon">üë•</div>
                    <span>CO-OP MODE</span>
                </div>
            </div>
            <div style="display: flex; gap: 15px; align-items: center;">
                <button id="addTowerBtn">üèóÔ∏è Add Tower</button>
                <button id="startLevel">‚ñ∂Ô∏è Start Level 1</button>
                <select id="levelSelect" onchange="selectLevel(this.value)" style="background: linear-gradient(135deg, #8a2be2 0%, #ff1493 100%); color: white; border: 2px solid #ff1493; padding: 8px; border-radius: 20px; font-weight: bold; margin-left: 10px;">
                    <option value="">Jump to Level...</option>
                </select>
                <button id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
                <button id="speedBtn" onclick="cycleGameSpeed()">‚ö° 1x Speed</button>
                <button id="perfBtn" onclick="togglePerformanceMode()" title="Toggle Performance Mode">üöÄ Perf</button>
                <button id="bombBtn" onclick="useSpecialAbility('bomb')" title="Bomb (B) - Unlocks at level 10" style="background: linear-gradient(135deg, #ff6600 0%, #ff3300 100%); position: relative; display: none;">üí£ <span id="bombCooldown" style="position: absolute; top: -5px; right: -5px; font-size: 10px; background: black; padding: 2px; border-radius: 10px;"></span></button>
                <button id="freezeBtn" onclick="useSpecialAbility('freeze')" title="Freeze (F) - Unlocks at level 15" style="background: linear-gradient(135deg, #00ccff 0%, #0088ff 100%); position: relative; display: none;">‚ùÑÔ∏è <span id="freezeCooldown" style="position: absolute; top: -5px; right: -5px; font-size: 10px; background: black; padding: 2px; border-radius: 10px;"></span></button>
                <button id="doubleBtn" onclick="useSpecialAbility('double')" title="Double Damage (D) - Unlocks at level 20" style="background: linear-gradient(135deg, #ffcc00 0%, #ff8800 100%); position: relative; display: none;">‚öîÔ∏è <span id="doubleCooldown" style="position: absolute; top: -5px; right: -5px; font-size: 10px; background: black; padding: 2px; border-radius: 10px;"></span></button>
                <button id="wavePreviewBtn" onclick="toggleWavePreview()">üëÅÔ∏è Preview</button>
                <button id="leaderboardBtn" onclick="showInGameLeaderboard()">üèÜ</button>
                <label style="margin-left: 10px; font-size: 12px;">
                    <input type="checkbox" id="autoStartCheck" checked onchange="toggleAutoStart()">
                    Auto-start
                </label>
            </div>
        </div>

        <canvas id="gameCanvas" style="display: block; background: #222; min-height: 400px; width: 100%;"></canvas>
        
        
        <!-- Wave Preview Panel -->
        <div id="wavePreview">
            <h4>üåä Incoming Waves</h4>
            <div id="waveContent"></div>
        </div>
        
        <!-- Achievement Popup -->
        <div id="achievementPopup">
            <h3>üèÜ Achievement Unlocked!</h3>
            <p id="achievementText"></p>
        </div>
        
        <!-- Tower Info Panel - Updated to remove ability button -->
        <div id="towerInfo">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 id="towerName">Tower Name</h3>
                <button class="closeBtn" onclick="selectedTower = null; updateUI();">‚úï</button>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Level:</span>
                <span class="tower-stat-value" id="towerLevel">1</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Damage:</span>
                <span class="tower-stat-value" id="towerDamage">10</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Range:</span>
                <span class="tower-stat-value" id="towerRange">150</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Fire Rate:</span>
                <span class="tower-stat-value" id="towerFireRate">Fast</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Kills:</span>
                <span class="tower-stat-value" id="towerKills">0</span>
            </div>
            <div class="tower-stat">
                <span class="tower-stat-label">Specialization:</span>
                <span class="tower-stat-value" id="towerSpec">None</span>
            </div>
            <div class="target-priority">
                <div class="target-option" data-priority="first" onclick="setTowerTargeting('first')">First</div>
                <div class="target-option" data-priority="last" onclick="setTowerTargeting('last')">Last</div>
                <div class="target-option active" data-priority="closest" onclick="setTowerTargeting('closest')">Closest</div>
                <div class="target-option" data-priority="strongest" onclick="setTowerTargeting('strongest')">Strong</div>
                <div class="target-option" data-priority="weakest" onclick="setTowerTargeting('weakest')">Weak</div>
            </div>
            <button id="upgradeBtn" onclick="upgradeTower()">‚¨ÜÔ∏è UPGRADE (üí∞100)</button>
            <div class="spec-buttons" id="specButtons" style="display: none;">
                <h4 style="color: #aaa; font-size: 12px; margin: 0 0 10px 0; text-align: center;">Choose Specialization:</h4>
                <button class="spec-btn" onclick="specializeTower('power')">üí• Power</button>
                <button class="spec-btn" onclick="specializeTower('speed')">‚ö° Speed</button>
                <button class="spec-btn" onclick="specializeTower('effect')">‚ú® Effect</button>
            </div>
            <button id="sellBtn" onclick="sellTower()" style="background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%); margin-top: 10px; width: 100%;">üí∞ SELL</button>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2); text-align: center;">
                <div style="font-size: 11px; color: #888;">Hotkeys: U = Upgrade ‚Ä¢ S = Sell</div>
            </div>
        </div>
        
        <!-- Tower Selection Modal -->
        <div id="towerModal">
            <div id="towerGrid">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 style="color: #fff; font-size: 36px; margin: 0; text-shadow: 0 0 20px rgba(255,20,147,0.8);">üèóÔ∏è Choose Your Tower</h2>
                    <button id="closeTowerModal" style="background: linear-gradient(135deg, #ff4444, #cc0000); width: 50px; height: 50px; border-radius: 50%; font-size: 24px;">‚úñ</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <div class="towerOption" data-type="pulse">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #00ff88);">üî´</div>
                        <h3 style="color: #00ff88; font-size: 24px; margin: 10px 0;">Pulse Cannon</h3>
                        <p style="color: #aaa; margin: 10px 0;">Rapid-fire energy weapon with consistent damage output</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">10</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">140</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Fast</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 120</p>
                    </div>
                    <div class="towerOption" data-type="laser">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #00ffff);">‚ö°</div>
                        <h3 style="color: #00ffff; font-size: 24px; margin: 10px 0;">Laser Tower</h3>
                        <p style="color: #aaa; margin: 10px 0;">Continuous beam weapon that melts through enemies</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">5/tick</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">180</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Beam</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 250</p>
                    </div>
                    <div class="towerOption" data-type="missile">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #ff8844);">üöÄ</div>
                        <h3 style="color: #ff8844; font-size: 24px; margin: 10px 0;">Missile Launcher</h3>
                        <p style="color: #aaa; margin: 10px 0;">Homing missiles with explosive area damage</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">50</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">220</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Slow</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 400</p>
                    </div>
                    <div class="towerOption" data-type="tesla">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #ffff00);">‚ö°</div>
                        <h3 style="color: #ffff00; font-size: 24px; margin: 10px 0;">Tesla Coil</h3>
                        <p style="color: #aaa; margin: 10px 0;">Chain lightning jumps between multiple enemies</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">25</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">160</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Medium</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 600</p>
                    </div>
                    <div class="towerOption" data-type="plasma">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #ff00ff);">üí•</div>
                        <h3 style="color: #ff00ff; font-size: 24px; margin: 10px 0;">Plasma Cannon</h3>
                        <p style="color: #aaa; margin: 10px 0;">Superheated plasma orbs with splash damage</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">70</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">200</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Medium</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 850</p>
                    </div>
                    <div class="towerOption" data-type="quantum">
                        <div style="font-size: 60px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #8a2be2);">üåÄ</div>
                        <h3 style="color: #8a2be2; font-size: 24px; margin: 10px 0;">Quantum Disruptor</h3>
                        <p style="color: #aaa; margin: 10px 0;">Reality-warping weapon that pierces through enemies</p>
                        <div class="towerStats">
                            <div class="stat-item">
                                <span class="stat-label">Damage</span>
                                <span class="stat-value">90</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range</span>
                                <span class="stat-value">280</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Speed</span>
                                <span class="stat-value">Medium</span>
                            </div>
                        </div>
                        <p style="color: #ffd700; font-weight: bold; font-size: 24px; margin-top: 15px;">üí∞ 1200</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="levelInfo">Level Complete!</div>
        
        <div id="gameOver">
            <h2 style="font-size: 48px; color: #ff1493; margin-bottom: 20px;">GAME OVER</h2>
            <p style="font-size: 24px; margin: 20px 0;">Final Score: <span id="finalScore" style="color: #00ff88;">0</span></p>
            <p style="font-size: 18px; margin: 10px 0;">Best Wave: <span id="bestWave" style="color: #00ffff;">0</span></p>
            <p style="font-size: 18px; margin: 10px 0;">Total Kills: <span id="totalKills" style="color: #ffaa00;">0</span></p>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px;">
                <button onclick="restartGame()" style="font-size: 20px; padding: 15px 40px;">Play Again</button>
                <button onclick="showLeaderboard()" style="font-size: 20px; padding: 15px 40px;">üèÜ Leaderboard</button>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" onclick="if(event.target === this) closeLeaderboard()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, rgba(20,20,60,0.98) 0%, rgba(40,20,80,0.98) 100%); padding: 40px; border-radius: 30px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(138, 43, 226, 1); border: 3px solid; border-image: linear-gradient(135deg, #8a2be2, #ff1493) 1; position: relative;">
            <button class="closeBtn" onclick="closeLeaderboard()" style="position: absolute; top: 15px; right: 15px;">‚úï</button>
            <h2 style="color: #fff; text-align: center; margin-bottom: 30px; font-size: 36px;">üèÜ Leaderboard</h2>
            <div id="leaderboardContent">
                <!-- Leaderboard entries will be added here -->
            </div>
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="closeLeaderboard()" style="min-width: 150px; background: linear-gradient(135deg, #8a2be2 0%, #ff1493 100%);">Close</button>
            </div>
        </div>
    </div>

<script>
// Initialize canvas - these need to be global
let canvas, ctx;

// Game settings
let gameSpeed = 1;

// ========== PERFORMANCE OPTIMIZATIONS ==========

// Helper function for squared distance (avoids expensive Math.sqrt)
function distanceSquared(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
}

// Spatial partitioning system for efficient collision detection
class SpatialGrid {
    constructor(cellSize = 100) {
        this.cellSize = cellSize;
        this.cells = new Map();
    }
    
    clear() {
        this.cells.clear();
    }
    
    getCellKey(x, y) {
        const cellX = Math.floor(x / this.cellSize);
        const cellY = Math.floor(y / this.cellSize);
        return `${cellX},${cellY}`;
    }
    
    add(entity, x, y) {
        const key = this.getCellKey(x, y);
        if (!this.cells.has(key)) {
            this.cells.set(key, []);
        }
        this.cells.get(key).push(entity);
    }
    
    getNearby(x, y, range) {
        const entities = [];
        const cellRange = Math.ceil(range / this.cellSize);
        const centerCellX = Math.floor(x / this.cellSize);
        const centerCellY = Math.floor(y / this.cellSize);
        
        for (let dx = -cellRange; dx <= cellRange; dx++) {
            for (let dy = -cellRange; dy <= cellRange; dy++) {
                const key = `${centerCellX + dx},${centerCellY + dy}`;
                if (this.cells.has(key)) {
                    entities.push(...this.cells.get(key));
                }
            }
        }
        return entities;
    }
}

// Particle object pool for reduced GC pressure
class ParticlePool {
    constructor(size = 1000) {
        this.pool = [];
        this.active = [];
        this.maxSize = size;
        
        // Pre-allocate particles
        for (let i = 0; i < size; i++) {
            this.pool.push({
                x: 0, y: 0, vx: 0, vy: 0,
                color: '', life: 0, size: 0,
                type: 'default', active: false
            });
        }
    }
    
    get(x, y, vx, vy, color, life = 1, size = 5, type = 'default') {
        let particle;
        if (this.pool.length > 0) {
            particle = this.pool.pop();
        } else if (this.active.length < this.maxSize) {
            particle = {
                x: 0, y: 0, vx: 0, vy: 0,
                color: '', life: 0, size: 0,
                type: 'default', active: false
            };
        } else {
            // Pool is full, reuse oldest active particle
            particle = this.active.shift();
        }
        
        particle.x = x;
        particle.y = y;
        particle.vx = vx;
        particle.vy = vy;
        particle.color = color;
        particle.life = life;
        particle.size = size;
        particle.type = type;
        particle.active = true;
        
        this.active.push(particle);
        return particle;
    }
    
    release(particle) {
        particle.active = false;
        const index = this.active.indexOf(particle);
        if (index !== -1) {
            this.active.splice(index, 1);
            if (this.pool.length < this.maxSize) {
                this.pool.push(particle);
            }
        }
    }
    
    update() {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const particle = this.active[i];
            particle.x += particle.vx * gameSpeed;
            particle.y += particle.vy * gameSpeed;
            particle.vy += 0.3 * gameSpeed;
            particle.life -= 0.02 * gameSpeed;
            
            if (particle.life <= 0) {
                this.release(particle);
            }
        }
    }
    
    getActiveParticles() {
        return this.active;
    }
}

// Initialize performance optimization systems
const enemySpatialGrid = new SpatialGrid(150);
const particlePool = new ParticlePool(1000);

// ========== PHASE 2 PERFORMANCE OPTIMIZATIONS ==========

// 1. GRADIENT CACHE
class GradientCache {
    constructor() {
        this.cache = new Map();
    }
    
    getLinearGradient(ctx, x0, y0, x1, y1, stops) {
        const key = `linear_${x0}_${y0}_${x1}_${y1}_${JSON.stringify(stops)}`;
        if (!this.cache.has(key)) {
            const gradient = gradientCache.getLinearGradient(ctx, x0, y0, x1, y1, [
            for (const [position, color] of stops) {
                gradient.addColorStop(position, color);
            }
            this.cache.set(key, gradient);
        }
        return this.cache.get(key);
    }
    
    getRadialGradient(ctx, x0, y0, r0, x1, y1, r1, stops) {
        const key = `radial_${x0}_${y0}_${r0}_${x1}_${y1}_${r1}_${JSON.stringify(stops)}`;
        if (!this.cache.has(key)) {
            const gradient = gradientCache.getRadialGradient(ctx, x0, y0, r0, x1, y1, r1, [
            for (const [position, color] of stops) {
                gradient.addColorStop(position, color);
            }
            this.cache.set(key, gradient);
        }
        return this.cache.get(key);
    }
}

const gradientCache = new GradientCache();

// 2. PROJECTILE POOL
class ProjectilePool {
    constructor(size = 500) {
        this.pool = [];
        this.active = [];
        this.maxSize = size;
        
        for (let i = 0; i < size; i++) {
            this.pool.push({
                x: 0, y: 0, target: null, damage: 0, speed: 0,
                color: '#ffffff', trail: [], pierce: false,
                explosive: false, splash: false, tracking: false,
                towerRef: null, active: false
            });
        }
    }
    
    get(x, y, target, damage, speed, color, properties = {}) {
        let projectile = this.pool.length > 0 ? this.pool.pop() : 
            (this.active.length < this.maxSize ? {
                x: 0, y: 0, target: null, damage: 0, speed: 0,
                color: '#ffffff', trail: [], pierce: false,
                explosive: false, splash: false, tracking: false,
                towerRef: null, active: false
            } : null);
        
        if (!projectile) return null;
        
        projectile.x = x;
        projectile.y = y;
        projectile.target = target;
        projectile.damage = damage;
        projectile.speed = speed;
        projectile.color = color;
        projectile.trail = [];
        Object.assign(projectile, properties);
        projectile.active = true;
        
        this.active.push(projectile);
        return projectile;
    }
    
    release(projectile) {
        projectile.active = false;
        projectile.target = null;
        projectile.trail = [];
        const index = this.active.indexOf(projectile);
        if (index !== -1) {
            this.active.splice(index, 1);
            if (this.pool.length < this.maxSize) {
                this.pool.push(projectile);
            }
        }
    }
}

const projectilePool = new ProjectilePool(500);

// 3. VISUAL QUALITY LEVELS
const QualityLevels = {
    ULTRA: { particles: 1000, particleQuality: 1.0, shadows: true, gradients: true, 
             trails: true, glowEffects: true, screenShake: true, floatingText: true, fps: 60 },
    HIGH: { particles: 500, particleQuality: 0.8, shadows: true, gradients: true,
            trails: true, glowEffects: false, screenShake: true, floatingText: true, fps: 60 },
    MEDIUM: { particles: 300, particleQuality: 0.5, shadows: false, gradients: true,
              trails: false, glowEffects: false, screenShake: true, floatingText: true, fps: 30 },
    LOW: { particles: 100, particleQuality: 0.3, shadows: false, gradients: false,
           trails: false, glowEffects: false, screenShake: false, floatingText: false, fps: 30 }
};

let currentQuality = 'HIGH';
let qualitySettings = QualityLevels.HIGH;

function setQualityLevel(level) {
    currentQuality = level;
    qualitySettings = QualityLevels[level];
    maxParticles = qualitySettings.particles;
    particleQuality = qualitySettings.particleQuality;
    targetFPS = qualitySettings.fps;
    return qualitySettings;
}

function autoDetectQuality() {
    if (fps < 20) return setQualityLevel('LOW');
    if (fps < 30) return setQualityLevel('MEDIUM');
    if (fps < 50) return setQualityLevel('HIGH');
    return setQualityLevel('ULTRA');
}

// 4. FLOATING TEXT POOL
class FloatingTextPool {
    constructor(size = 100) {
        this.pool = [];
        this.active = [];
        this.maxSize = size;
        
        for (let i = 0; i < size; i++) {
            this.pool.push({
                x: 0, y: 0, text: '', color: '#ffffff',
                life: 0, vx: 0, vy: 0, size: 16, active: false
            });
        }
    }
    
    get(x, y, text, color = '#ffffff', size = 16) {
        let floatingText = this.pool.length > 0 ? this.pool.pop() : 
            (this.active.length < this.maxSize ? {
                x: 0, y: 0, text: '', color: '#ffffff',
                life: 0, vx: 0, vy: 0, size: 16, active: false
            } : null);
        
        if (!floatingText) return null;
        
        floatingText.x = x;
        floatingText.y = y;
        floatingText.text = text;
        floatingText.color = color;
        floatingText.life = 1;
        floatingText.vx = (Math.random() - 0.5) * 2;
        floatingText.vy = -2;
        floatingText.size = size;
        floatingText.active = true;
        
        this.active.push(floatingText);
        return floatingText;
    }
    
    release(text) {
        text.active = false;
        const index = this.active.indexOf(text);
        if (index !== -1) {
            this.active.splice(index, 1);
            if (this.pool.length < this.maxSize) this.pool.push(text);
        }
    }
    
    update() {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const text = this.active[i];
            text.x += text.vx;
            text.y += text.vy;
            text.life -= 0.02;
            if (text.life <= 0) this.release(text);
        }
    }
}

const floatingTextPool = new FloatingTextPool(100);


// Frame throttling for low performance
let skipFrames = 0;
let frameSkipThreshold = 30;



// Set canvas size
function resizeCanvas() {
    if (!canvas) {
        console.error('Canvas not initialized in resizeCanvas');
        return;
    }
    
    const ui = document.getElementById('ui');
    const width = window.innerWidth || 800;
    const height = (window.innerHeight || 600) - (ui ? ui.offsetHeight : 70);
    
    canvas.width = Math.max(100, width);
    canvas.height = Math.max(100, height);
    
    console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
    
    // Update path scaling when canvas resizes
    if (originalPath) {
        path = scalePath();
        updateBasePosition();
    }
}


// Game state
let money = 400; // Reduced starting money
let health = 100;
let level = 1;
let score = 0;
let enemies = [];
let towers = [];
let projectiles = [];
let particles = [];
let beams = [];
let powerups = [];
let levelActive = false;
let selectedTowerType = null;

// Special abilities
let specialAbilities = {
    bomb: { cooldown: 0, maxCooldown: 1800, unlocked: false }, // 30 seconds
    freeze: { cooldown: 0, maxCooldown: 2700, unlocked: false }, // 45 seconds  
    double: { cooldown: 0, maxCooldown: 3600, active: 0, unlocked: false } // 60 seconds, lasts 10 seconds
};
let placingTower = false;
let sellMode = false;
let challengeMode = false;
let challengeWave = 0;
let challengeLives = 3;
let mousePos = { x: 0, y: 0 };
let camera = { x: 0, y: 0 };
let enemiesSpawning = false;
let enemiesRemaining = 0;
let hoveredTower = null;
let selectedTower = null;
let currentWave = 0;
let totalWaves = 1;
let totalKills = 0;
let wavePreviewShown = false;
let autoStartEnabled = true;
let waveCountdown = 0;
let isPaused = false;
let screenShake = 0;
let shakeX = 0;
let shakeY = 0;

// Co-op mode variables
let isCoOpMode = false;
let player2Cursor = { x: 400, y: 300 };
let player2Keys = {};

// Leaderboard data
let leaderboard = [];

// Grid size for tower placement
const gridSize = 50;

// Achievements system
const achievements = {
    firstKill: { unlocked: false, name: "First Blood", desc: "Defeat your first enemy" },
    wave10: { unlocked: false, name: "Wave Survivor", desc: "Complete wave 10" },
    money1000: { unlocked: false, name: "Rich Defender", desc: "Save 1000 gold" },
    perfectWave: { unlocked: false, name: "Perfect Defense", desc: "Complete a wave without taking damage" },
    towerMaster: { unlocked: false, name: "Tower Master", desc: "Have 10 towers at once" },
    upgradeMax: { unlocked: false, name: "Max Power", desc: "Fully upgrade a tower" },
    specialization: { unlocked: false, name: "Specialist", desc: "Specialize a tower" }
};

// Stub function to prevent errors from any remaining references

// Level data - Increased difficulty
const levelData = [
    { level: 1, theme: 'Grassland', enemies: [{ type: 'slime', count: 15 }], waves: 1, hpRange: [80, 100], features: 'Intro to tower placement' },
    { level: 2, theme: 'Grassland', enemies: [{ type: 'slime', count: 25 }], waves: 2, hpRange: [100, 120], features: 'Multiple waves' },
    { level: 3, theme: 'Grassland', enemies: [{ type: 'slime', count: 35 }, { type: 'golem', count: 3 }], waves: 2, hpRange: [120, 150], features: 'Tougher enemies appear' },
    { level: 4, theme: 'Grassland', enemies: [{ type: 'slime', count: 45 }, { type: 'golem', count: 5 }], waves: 3, hpRange: [150, 200], features: 'Increased enemy variety' },
    { level: 5, theme: 'Grassland', enemies: [{ type: 'slime', count: 60 }, { type: 'golem', count: 8 }, { type: 'brute', count: 2 }, { type: 'boss', count: 1 }], waves: 3, hpRange: [200, 300], features: 'First boss battle!' },
    { level: 6, theme: 'Desert', enemies: [{ type: 'speeder', count: 20 }, { type: 'slime', count: 40 }, { type: 'golem', count: 10 }], waves: 3, hpRange: [250, 350], features: 'Speeders rush your defenses' },
    { level: 7, theme: 'Desert', enemies: [{ type: 'tank', count: 3 }, { type: 'speeder', count: 25 }, { type: 'golem', count: 15 }], waves: 4, hpRange: [300, 400], features: 'Heavily armored tanks appear' },
    { level: 8, theme: 'Haunted', enemies: [{ type: 'ghost', count: 15 }, { type: 'slime', count: 50 }, { type: 'speeder', count: 20 }], waves: 4, hpRange: [350, 450], features: 'Ghosts phase through attacks' },
    { level: 9, theme: 'Haunted', enemies: [{ type: 'healer', count: 8 }, { type: 'ghost', count: 20 }, { type: 'golem', count: 20 }], waves: 4, hpRange: [400, 500], features: 'Healers support enemy waves' },
    { level: 10, theme: 'Volcanic', enemies: [{ type: 'splitter', count: 12 }, { type: 'tank', count: 4 }, { type: 'healer', count: 10 }, { type: 'boss', count: 1 }], waves: 5, hpRange: [450, 600], features: 'First boss battle!' },
    { level: 11, theme: 'Volcanic', enemies: [{ type: 'bomber', count: 20 }, { type: 'shielder', count: 15 }, { type: 'speeder', count: 30 }], waves: 5, hpRange: [500, 700], features: 'Explosive enemies and shields' },
    { level: 12, theme: 'Arctic', enemies: [{ type: 'regenerator', count: 12 }, { type: 'shielder', count: 18 }, { type: 'tank', count: 6 }], waves: 5, hpRange: [600, 800], features: 'Regenerating enemies' },
    { level: 13, theme: 'Arctic', enemies: [{ type: 'absorber', count: 10 }, { type: 'regenerator', count: 15 }, { type: 'bomber', count: 25 }], waves: 6, hpRange: [700, 900], features: 'Damage absorbing enemies' },
    { level: 14, theme: 'Chaos', enemies: [{ type: 'teleporter', count: 20 }, { type: 'swarm', count: 100 }, { type: 'absorber', count: 8 }], waves: 6, hpRange: [800, 1000], features: 'Teleporting chaos' },
    { level: 15, theme: 'Chaos', enemies: [{ type: 'boss', count: 2 }, { type: 'teleporter', count: 25 }, { type: 'healer', count: 15 }, { type: 'tank', count: 8 }], waves: 7, hpRange: [1000, 1500], features: 'Ultimate challenge!' },
    // Extended levels 16-50
    { level: 16, theme: 'Void', enemies: [{ type: 'voidwalker', count: 10 }, { type: 'ghost', count: 30 }, { type: 'absorber', count: 12 }], waves: 6, hpRange: [1200, 1800], features: 'Void walkers phase in and out' },
    { level: 17, theme: 'Crystal', enemies: [{ type: 'crystalGuard', count: 8 }, { type: 'shielder', count: 20 }, { type: 'tank', count: 10 }], waves: 6, hpRange: [1400, 2000], features: 'Crystal guards reflect damage' },
    { level: 18, theme: 'Elemental', enemies: [{ type: 'fireElemental', count: 15 }, { type: 'iceElemental', count: 12 }, { type: 'lightningElemental', count: 18 }], waves: 7, hpRange: [1600, 2200], features: 'Elemental forces unite' },
    { level: 19, theme: 'Shadow', enemies: [{ type: 'shadowAssassin', count: 25 }, { type: 'voidwalker', count: 15 }, { type: 'ghost', count: 20 }], waves: 7, hpRange: [1800, 2500], features: 'Shadows strike from darkness' },
    { level: 20, theme: 'Necropolis', enemies: [{ type: 'necromancer', count: 5 }, { type: 'ghost', count: 40 }, { type: 'regenerator', count: 20 }, { type: 'megaBoss', count: 1 }], waves: 8, hpRange: [2000, 3000], features: 'Mega boss appears!' },
    { level: 21, theme: 'Time Rift', enemies: [{ type: 'timeBender', count: 12 }, { type: 'teleporter', count: 30 }, { type: 'speeder', count: 40 }], waves: 8, hpRange: [2200, 3200], features: 'Time manipulation chaos' },
    { level: 22, theme: 'Plasma Core', enemies: [{ type: 'plasmaBeast', count: 6 }, { type: 'fireElemental', count: 20 }, { type: 'bomber', count: 30 }], waves: 8, hpRange: [2400, 3500], features: 'Plasma shields protect enemies' },
    { level: 23, theme: 'Quantum', enemies: [{ type: 'quantumEntity', count: 15 }, { type: 'teleporter', count: 25 }, { type: 'timeBender', count: 10 }], waves: 9, hpRange: [2600, 3800], features: 'Quantum mechanics at play' },
    { level: 24, theme: 'Elite Forces', enemies: [{ type: 'eliteTank', count: 4 }, { type: 'crystalGuard', count: 10 }, { type: 'shielder', count: 25 }], waves: 9, hpRange: [2800, 4000], features: 'Elite armored units' },
    { level: 25, theme: 'Swarm Hell', enemies: [{ type: 'hyperSwarm', count: 200 }, { type: 'swarm', count: 150 }, { type: 'speeder', count: 50 }, { type: 'boss', count: 3 }], waves: 10, hpRange: [100, 300], features: 'Overwhelming numbers!' },
    { level: 26, theme: 'Corruption', enemies: [{ type: 'corruptor', count: 8 }, { type: 'necromancer', count: 6 }, { type: 'regenerator', count: 30 }], waves: 9, hpRange: [3000, 4500], features: 'Corruption spreads' },
    { level: 27, theme: 'Mixed Assault', enemies: [{ type: 'shadowAssassin', count: 30 }, { type: 'lightningElemental', count: 25 }, { type: 'plasmaBeast', count: 8 }], waves: 10, hpRange: [3200, 4800], features: 'Combined forces attack' },
    { level: 28, theme: 'Void Storm', enemies: [{ type: 'voidwalker', count: 25 }, { type: 'quantumEntity', count: 20 }, { type: 'timeBender', count: 15 }], waves: 10, hpRange: [3500, 5000], features: 'Reality bends' },
    { level: 29, theme: 'Elemental Chaos', enemies: [{ type: 'fireElemental', count: 30 }, { type: 'iceElemental', count: 30 }, { type: 'lightningElemental', count: 30 }], waves: 11, hpRange: [3800, 5500], features: 'Elemental mayhem' },
    { level: 30, theme: 'Boss Rush', enemies: [{ type: 'boss', count: 5 }, { type: 'megaBoss', count: 2 }, { type: 'eliteTank', count: 10 }], waves: 12, hpRange: [5000, 8000], features: 'Multiple bosses!' },
    { level: 31, theme: 'Crystal Fortress', enemies: [{ type: 'crystalGuard', count: 20 }, { type: 'eliteTank', count: 8 }, { type: 'corruptor', count: 10 }], waves: 11, hpRange: [4000, 6000], features: 'Fortified defenses' },
    { level: 32, theme: 'Shadow Realm', enemies: [{ type: 'shadowAssassin', count: 50 }, { type: 'voidwalker', count: 30 }, { type: 'necromancer', count: 10 }], waves: 12, hpRange: [4200, 6500], features: 'Darkness consumes' },
    { level: 33, theme: 'Quantum Flux', enemies: [{ type: 'quantumEntity', count: 30 }, { type: 'timeBender', count: 25 }, { type: 'teleporter', count: 40 }], waves: 12, hpRange: [4500, 7000], features: 'Space-time anomalies' },
    { level: 34, theme: 'Plasma Storm', enemies: [{ type: 'plasmaBeast', count: 15 }, { type: 'fireElemental', count: 40 }, { type: 'lightningElemental', count: 35 }], waves: 13, hpRange: [4800, 7500], features: 'Energy overload' },
    { level: 35, theme: 'Ultimate Swarm', enemies: [{ type: 'hyperSwarm', count: 500 }, { type: 'corruptor', count: 15 }, { type: 'necromancer', count: 8 }, { type: 'megaBoss', count: 1 }], waves: 14, hpRange: [200, 500], features: 'Mega boss with endless swarm!' },
    { level: 36, theme: 'Elite Command', enemies: [{ type: 'eliteTank', count: 12 }, { type: 'crystalGuard', count: 25 }, { type: 'megaBoss', count: 3 }], waves: 13, hpRange: [5000, 8000], features: 'Elite forces mobilize' },
    { level: 37, theme: 'Void Convergence', enemies: [{ type: 'voidwalker', count: 40 }, { type: 'shadowAssassin', count: 60 }, { type: 'quantumEntity', count: 35 }], waves: 14, hpRange: [5200, 8500], features: 'Void consumes all' },
    { level: 38, theme: 'Elemental Apex', enemies: [{ type: 'fireElemental', count: 50 }, { type: 'iceElemental', count: 50 }, { type: 'lightningElemental', count: 50 }], waves: 15, hpRange: [5500, 9000], features: 'Peak elemental power' },
    { level: 39, theme: 'Time Collapse', enemies: [{ type: 'timeBender', count: 40 }, { type: 'teleporter', count: 60 }, { type: 'quantumEntity', count: 40 }], waves: 15, hpRange: [5800, 9500], features: 'Time itself breaks' },
    { level: 40, theme: 'Apocalypse', enemies: [{ type: 'megaBoss', count: 5 }, { type: 'boss', count: 10 }, { type: 'eliteTank', count: 20 }], waves: 16, hpRange: [10000, 15000], features: 'The end approaches' },
    { level: 41, theme: 'Beyond', enemies: [{ type: 'corruptor', count: 25 }, { type: 'necromancer', count: 15 }, { type: 'plasmaBeast', count: 20 }], waves: 16, hpRange: [6000, 10000], features: 'Beyond mortal realm' },
    { level: 42, theme: 'Quantum Void', enemies: [{ type: 'quantumEntity', count: 50 }, { type: 'voidwalker', count: 50 }, { type: 'timeBender', count: 50 }], waves: 17, hpRange: [6500, 11000], features: 'Reality collapses' },
    { level: 43, theme: 'Crystal Apocalypse', enemies: [{ type: 'crystalGuard', count: 40 }, { type: 'eliteTank', count: 25 }, { type: 'corruptor', count: 30 }], waves: 17, hpRange: [7000, 12000], features: 'Crystal dominion' },
    { level: 44, theme: 'Shadow Eclipse', enemies: [{ type: 'shadowAssassin', count: 100 }, { type: 'voidwalker', count: 60 }, { type: 'necromancer', count: 20 }], waves: 18, hpRange: [7500, 13000], features: 'Total darkness' },
    { level: 45, theme: 'Elemental Ragnarok', enemies: [{ type: 'fireElemental', count: 80 }, { type: 'iceElemental', count: 80 }, { type: 'lightningElemental', count: 80 }, { type: 'megaBoss', count: 2 }], waves: 19, hpRange: [8000, 14000], features: 'Twin mega bosses with elemental chaos!' },
    { level: 46, theme: 'Mega Swarm', enemies: [{ type: 'hyperSwarm', count: 1000 }, { type: 'swarm', count: 500 }, { type: 'megaBoss', count: 5 }], waves: 20, hpRange: [500, 1000], features: 'Infinite army' },
    { level: 47, theme: 'Chaos Incarnate', enemies: [{ type: 'corruptor', count: 40 }, { type: 'plasmaBeast', count: 35 }, { type: 'quantumEntity', count: 60 }], waves: 20, hpRange: [8500, 15000], features: 'Pure chaos' },
    { level: 48, theme: 'Elite Finale', enemies: [{ type: 'eliteTank', count: 40 }, { type: 'crystalGuard', count: 50 }, { type: 'megaBoss', count: 8 }], waves: 21, hpRange: [9000, 16000], features: 'Elite last stand' },
    { level: 49, theme: 'Void Finale', enemies: [{ type: 'voidwalker', count: 100 }, { type: 'shadowAssassin', count: 150 }, { type: 'timeBender', count: 80 }], waves: 22, hpRange: [9500, 17000], features: 'Void consumes all' },
    { level: 50, theme: 'Final Stand', enemies: [{ type: 'finalBoss', count: 1 }, { type: 'megaBoss', count: 10 }, { type: 'boss', count: 20 }, { type: 'eliteTank', count: 50 }], waves: 25, hpRange: [50000, 100000], features: 'THE FINAL BOSS!' }
];

// Base
const base = {
    x: 20,
    y: 280,
    width: 100,
    height: 100,
    name: 'NEXUS CORE',
    energyAnimation: 0,
    shieldPulse: 0,
    coreRotation: 0,
    orbitalRings: []
};

// Function to update base position based on canvas size
function updateBasePosition() {
    const scale = getScaleFactor();
    base.x = 20 * (canvas.width / 800);
    base.y = 280 * (canvas.height / 600);
    base.width = 100 * scale;
    base.height = 100 * scale;
}

// Initialize orbital rings
for (let i = 0; i < 3; i++) {
    base.orbitalRings.push({
        radius: 50 + i * 15,
        rotation: 0,
        speed: 0.02 * (i + 1),
        color: ['#ff1493', '#00ffff', '#8a2be2'][i]
    });
}

// Multiple path layouts for variety every 5 levels
const pathLayouts = {
    // Path 1: Serpentine (Levels 1-5) - Uses full vertical space
    serpentine: [
        { x: 50, y: 50, tunnel: false },
        { x: 150, y: 50, tunnel: false },
        { x: 250, y: 50, tunnel: false },
        { x: 350, y: 50, tunnel: false },
        { x: 450, y: 50, tunnel: false },
        { x: 550, y: 50, tunnel: false },
        { x: 650, y: 50, tunnel: false },
        { x: 750, y: 50, tunnel: false },
        { x: 750, y: 150, tunnel: false },
        { x: 750, y: 250, tunnel: false },
        { x: 650, y: 250, tunnel: false },
        { x: 550, y: 250, tunnel: false },
        { x: 450, y: 250, tunnel: false },
        { x: 350, y: 250, tunnel: false },
        { x: 250, y: 250, tunnel: false },
        { x: 150, y: 250, tunnel: false },
        { x: 50, y: 250, tunnel: false },
        { x: 50, y: 350, tunnel: false },
        { x: 50, y: 450, tunnel: false },
        { x: 150, y: 450, tunnel: false },
        { x: 250, y: 450, tunnel: false },
        { x: 350, y: 450, tunnel: false },
        { x: 450, y: 450, tunnel: false },
        { x: 550, y: 450, tunnel: false },
        { x: 650, y: 450, tunnel: false },
        { x: 750, y: 450, tunnel: false },
        { x: 750, y: 550, tunnel: false },
        { x: 650, y: 550, tunnel: false },
        { x: 550, y: 550, tunnel: false },
        { x: 450, y: 550, tunnel: false },
        { x: 350, y: 550, tunnel: false },
        { x: 250, y: 550, tunnel: false },
        { x: 150, y: 550, tunnel: false },
        { x: 50, y: 550, tunnel: false }
    ],
    
    // Path 2: Figure-8 (Levels 6-10) - Uses full canvas
    figure8: [
        { x: 400, y: 50, tunnel: false },
        { x: 500, y: 75, tunnel: false },
        { x: 600, y: 125, tunnel: false },
        { x: 700, y: 200, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 700, y: 400, tunnel: false },
        { x: 600, y: 475, tunnel: false },
        { x: 500, y: 525, tunnel: false },
        { x: 400, y: 550, tunnel: false },
        { x: 300, y: 525, tunnel: false },
        { x: 200, y: 475, tunnel: false },
        { x: 100, y: 400, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 100, y: 200, tunnel: false },
        { x: 200, y: 125, tunnel: false },
        { x: 300, y: 75, tunnel: false },
        { x: 400, y: 50, tunnel: true }, // Tunnel crossing
        { x: 400, y: 150, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 400, y: 350, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ],
    
    // Path 3: Zigzag (Levels 11-15) - Diagonal paths using full space
    zigzag: [
        { x: 50, y: 50, tunnel: false },
        { x: 150, y: 150, tunnel: false },
        { x: 250, y: 50, tunnel: false },
        { x: 350, y: 150, tunnel: false },
        { x: 450, y: 50, tunnel: false },
        { x: 550, y: 150, tunnel: false },
        { x: 650, y: 50, tunnel: false },
        { x: 750, y: 150, tunnel: false },
        { x: 750, y: 250, tunnel: false },
        { x: 650, y: 350, tunnel: false },
        { x: 550, y: 250, tunnel: false },
        { x: 450, y: 350, tunnel: false },
        { x: 350, y: 250, tunnel: false },
        { x: 250, y: 350, tunnel: false },
        { x: 150, y: 250, tunnel: false },
        { x: 50, y: 350, tunnel: false },
        { x: 50, y: 450, tunnel: false },
        { x: 150, y: 550, tunnel: false },
        { x: 250, y: 450, tunnel: false },
        { x: 350, y: 550, tunnel: false },
        { x: 450, y: 450, tunnel: false },
        { x: 550, y: 550, tunnel: false },
        { x: 650, y: 450, tunnel: false },
        { x: 750, y: 550, tunnel: false }
    ],
    
    // Path 4: Diamond (Levels 16-20) - Uses corners and center
    diamond: [
        { x: 400, y: 50, tunnel: false },
        { x: 500, y: 100, tunnel: false },
        { x: 600, y: 150, tunnel: false },
        { x: 700, y: 200, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 700, y: 400, tunnel: false },
        { x: 600, y: 450, tunnel: false },
        { x: 500, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false },
        { x: 300, y: 500, tunnel: false },
        { x: 200, y: 450, tunnel: false },
        { x: 100, y: 400, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 100, y: 200, tunnel: false },
        { x: 200, y: 150, tunnel: false },
        { x: 300, y: 100, tunnel: false },
        { x: 400, y: 50, tunnel: true }, // Back to start with tunnel
        { x: 400, y: 300, tunnel: false } // To center base
    ],
    
    // Keep original spiral as path 5 (Levels 21-25)
    spiral: [
        { x: 750, y: 150, tunnel: false },
        { x: 700, y: 160, tunnel: false },
        { x: 650, y: 180, tunnel: false },
        { x: 600, y: 200, tunnel: false },
        { x: 550, y: 220, tunnel: false },
        { x: 500, y: 240, tunnel: false },
        { x: 450, y: 250, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 350, y: 240, tunnel: false },
        { x: 300, y: 220, tunnel: false },
        { x: 250, y: 200, tunnel: false },
        { x: 200, y: 190, tunnel: false },
        { x: 150, y: 200, tunnel: false },
        { x: 120, y: 230, tunnel: false },
        { x: 110, y: 270, tunnel: false },
        { x: 120, y: 310, tunnel: false },
        { x: 150, y: 340, tunnel: false },
        { x: 190, y: 360, tunnel: false },
        { x: 230, y: 370, tunnel: false },
        { x: 270, y: 380, tunnel: false },
        { x: 310, y: 390, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 390, y: 410, tunnel: false },
        { x: 430, y: 420, tunnel: false },
        { x: 470, y: 430, tunnel: false },
        { x: 510, y: 440, tunnel: false },
        { x: 550, y: 450, tunnel: false },
        { x: 590, y: 460, tunnel: false },
        { x: 630, y: 470, tunnel: false },
        { x: 670, y: 480, tunnel: false },
        { x: 710, y: 470, tunnel: false },
        { x: 740, y: 440, tunnel: false },
        { x: 750, y: 400, tunnel: false },
        { x: 740, y: 360, tunnel: false },
        { x: 720, y: 320, tunnel: false },
        { x: 690, y: 290, tunnel: false },
        { x: 650, y: 270, tunnel: false },
        { x: 610, y: 260, tunnel: false },
        { x: 570, y: 270, tunnel: false },
        { x: 530, y: 290, tunnel: false },
        { x: 490, y: 310, tunnel: false },
        { x: 450, y: 330, tunnel: false },
        { x: 410, y: 340, tunnel: false },
        { x: 370, y: 340, tunnel: false },
        { x: 330, y: 330, tunnel: false },
        { x: 290, y: 310, tunnel: false },
        { x: 250, y: 290, tunnel: false },
        { x: 210, y: 280, tunnel: false },
        { x: 170, y: 280, tunnel: false },
        { x: 130, y: 280, tunnel: false },
        { x: 90, y: 280, tunnel: false },
        { x: 50, y: 280, tunnel: false },
        { x: 20, y: 280, tunnel: false }
    ],
    zigzag: [
        // Zigzag pattern - Levels 6-10
        { x: 50, y: 100, tunnel: false },
        { x: 150, y: 100, tunnel: false },
        { x: 250, y: 100, tunnel: false },
        { x: 350, y: 100, tunnel: false },
        { x: 450, y: 100, tunnel: false },
        { x: 550, y: 100, tunnel: false },
        { x: 650, y: 100, tunnel: false },
        { x: 750, y: 100, tunnel: false },
        { x: 750, y: 200, tunnel: false },
        { x: 650, y: 200, tunnel: false },
        { x: 550, y: 200, tunnel: false },
        { x: 450, y: 200, tunnel: false },
        { x: 350, y: 200, tunnel: false },
        { x: 250, y: 200, tunnel: false },
        { x: 150, y: 200, tunnel: false },
        { x: 50, y: 200, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 150, y: 300, tunnel: false },
        { x: 250, y: 300, tunnel: false },
        { x: 350, y: 300, tunnel: false },
        { x: 450, y: 300, tunnel: false },
        { x: 550, y: 300, tunnel: false },
        { x: 650, y: 300, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 750, y: 400, tunnel: false },
        { x: 650, y: 400, tunnel: false },
        { x: 550, y: 400, tunnel: false },
        { x: 450, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 150, y: 400, tunnel: false },
        { x: 50, y: 400, tunnel: false },
        { x: 50, y: 500, tunnel: false },
        { x: 100, y: 500, tunnel: false },
        { x: 150, y: 500, tunnel: false },
        { x: 200, y: 500, tunnel: false },
        { x: 250, y: 500, tunnel: false },
        { x: 300, y: 500, tunnel: false },
        { x: 350, y: 500, tunnel: false },
        { x: 400, y: 500, tunnel: false }
    ],
    cross: [
        // Cross pattern with tunnels - Levels 11-15
        { x: 400, y: 50, tunnel: false },
        { x: 400, y: 100, tunnel: false },
        { x: 400, y: 150, tunnel: false },
        { x: 400, y: 200, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 350, y: 300, tunnel: false },
        { x: 300, y: 300, tunnel: false },
        { x: 250, y: 300, tunnel: false },
        { x: 200, y: 300, tunnel: false },
        { x: 150, y: 300, tunnel: false },
        { x: 100, y: 300, tunnel: false },
        { x: 100, y: 350, tunnel: true },
        { x: 100, y: 400, tunnel: true },
        { x: 150, y: 400, tunnel: false },
        { x: 200, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 300, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 450, y: 400, tunnel: false },
        { x: 500, y: 400, tunnel: false },
        { x: 550, y: 400, tunnel: false },
        { x: 600, y: 400, tunnel: false },
        { x: 650, y: 400, tunnel: false },
        { x: 700, y: 400, tunnel: false },
        { x: 700, y: 350, tunnel: true },
        { x: 700, y: 300, tunnel: true },
        { x: 650, y: 300, tunnel: false },
        { x: 600, y: 300, tunnel: false },
        { x: 550, y: 300, tunnel: false },
        { x: 500, y: 300, tunnel: false },
        { x: 450, y: 300, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 400, y: 350, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ],
    maze: [
        // Maze pattern - Levels 16-20
        { x: 50, y: 550, tunnel: false },
        { x: 100, y: 550, tunnel: false },
        { x: 150, y: 550, tunnel: false },
        { x: 200, y: 550, tunnel: false },
        { x: 200, y: 500, tunnel: false },
        { x: 200, y: 450, tunnel: false },
        { x: 200, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 300, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 400, y: 350, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 400, y: 250, tunnel: false },
        { x: 350, y: 250, tunnel: false },
        { x: 300, y: 250, tunnel: false },
        { x: 250, y: 250, tunnel: false },
        { x: 200, y: 250, tunnel: false },
        { x: 200, y: 200, tunnel: false },
        { x: 200, y: 150, tunnel: false },
        { x: 200, y: 100, tunnel: false },
        { x: 250, y: 100, tunnel: false },
        { x: 300, y: 100, tunnel: false },
        { x: 350, y: 100, tunnel: false },
        { x: 400, y: 100, tunnel: false },
        { x: 450, y: 100, tunnel: false },
        { x: 500, y: 100, tunnel: false },
        { x: 550, y: 100, tunnel: false },
        { x: 600, y: 100, tunnel: false },
        { x: 600, y: 150, tunnel: false },
        { x: 600, y: 200, tunnel: false },
        { x: 600, y: 250, tunnel: false },
        { x: 600, y: 300, tunnel: false },
        { x: 600, y: 350, tunnel: false },
        { x: 600, y: 400, tunnel: false },
        { x: 600, y: 450, tunnel: false },
        { x: 550, y: 450, tunnel: false },
        { x: 500, y: 450, tunnel: false },
        { x: 450, y: 450, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ],
    highway: [
        // Fast highway pattern - Levels 21-25
        { x: 50, y: 300, tunnel: false },
        { x: 100, y: 300, tunnel: false },
        { x: 150, y: 300, tunnel: false },
        { x: 200, y: 300, tunnel: false },
        { x: 250, y: 300, tunnel: false },
        { x: 300, y: 300, tunnel: false },
        { x: 350, y: 300, tunnel: false },
        { x: 400, y: 300, tunnel: false },
        { x: 450, y: 300, tunnel: false },
        { x: 500, y: 300, tunnel: false },
        { x: 550, y: 300, tunnel: false },
        { x: 600, y: 300, tunnel: false },
        { x: 650, y: 300, tunnel: false },
        { x: 700, y: 300, tunnel: false },
        { x: 750, y: 300, tunnel: false },
        { x: 750, y: 250, tunnel: false },
        { x: 750, y: 200, tunnel: false },
        { x: 700, y: 200, tunnel: false },
        { x: 650, y: 200, tunnel: false },
        { x: 600, y: 200, tunnel: false },
        { x: 550, y: 200, tunnel: false },
        { x: 500, y: 200, tunnel: false },
        { x: 450, y: 200, tunnel: false },
        { x: 400, y: 200, tunnel: false },
        { x: 350, y: 200, tunnel: false },
        { x: 300, y: 200, tunnel: false },
        { x: 250, y: 200, tunnel: false },
        { x: 200, y: 200, tunnel: false },
        { x: 150, y: 200, tunnel: false },
        { x: 100, y: 200, tunnel: false },
        { x: 50, y: 200, tunnel: false },
        { x: 50, y: 250, tunnel: false },
        { x: 50, y: 300, tunnel: false },
        { x: 50, y: 350, tunnel: false },
        { x: 50, y: 400, tunnel: false },
        { x: 100, y: 400, tunnel: false },
        { x: 150, y: 400, tunnel: false },
        { x: 200, y: 400, tunnel: false },
        { x: 250, y: 400, tunnel: false },
        { x: 300, y: 400, tunnel: false },
        { x: 350, y: 400, tunnel: false },
        { x: 400, y: 400, tunnel: false },
        { x: 400, y: 450, tunnel: false },
        { x: 400, y: 500, tunnel: false },
        { x: 400, y: 550, tunnel: false }
    ]
};

// Current path layout - Start with serpentine
let currentPathLayout = 'serpentine';
let originalPath = pathLayouts[currentPathLayout];

// Function to scale path based on canvas size
function scalePath() {
    const baseWidth = 800;
    const baseHeight = 600;
    const scaleX = (canvas.width || baseWidth) / baseWidth;
    const scaleY = (canvas.height || baseHeight) / baseHeight;
    
    return originalPath.map(point => ({
        x: point.x * scaleX,
        y: point.y * scaleY,
        tunnel: point.tunnel
    }));
}

// Dynamic path that scales with canvas
let path = [];

// Calculate scale factor for game elements
function getScaleFactor() {
    const baseSize = 800; // Base size for original design
    const scale = Math.min(canvas.width, canvas.height) / baseSize;
    // Ensure we have a valid scale factor
    return isNaN(scale) || scale <= 0 ? 1 : scale;
}

// Tower types - Rebalanced to be less powerful
const towerTypes = {
    pulse: {
        cost: 120,
        damage: 10,
        range: 140,
        fireRate: 600,
        color: '#00ff88',
        projectileSpeed: 12,
        name: 'Pulse Cannon',
        element: 'kinetic',
        description: 'Rapid-fire cannon with consistent damage',
        upgrades: {
            damage: { base: 10, perLevel: 2.5, max: 100 },
            range: { base: 140, perLevel: 5, max: 250 },
            fireRate: { base: 600, perLevel: -30, min: 150 }
        }
    },
    laser: {
        cost: 250,
        damage: 5,
        range: 180,
        fireRate: 50,
        color: '#00ffff',
        beam: true,
        name: 'Laser Tower',
        element: 'energy',
        description: 'Continuous beam weapon, melts armor',
        upgrades: {
            damage: { base: 5, perLevel: 1.5, max: 50 },
            range: { base: 180, perLevel: 8, max: 300 },
            beamWidth: { base: 1, perLevel: 0.5, max: 5 }
        }
    },
    missile: {
        cost: 400,
        damage: 50,
        range: 220,
        fireRate: 2500,
        color: '#ff8844',
        projectileSpeed: 6,
        explosive: true,
        homing: true,
        name: 'Missile Launcher',
        element: 'explosive',
        description: 'Homing missiles with area damage',
        upgrades: {
            damage: { base: 50, perLevel: 10, max: 300 },
            range: { base: 220, perLevel: 10, max: 400 },
            splashRadius: { base: 40, perLevel: 5, max: 100 },
            fireRate: { base: 2500, perLevel: -100, min: 1000 }
        }
    },
    tesla: {
        cost: 600,
        damage: 25,
        range: 160,
        fireRate: 1200,
        color: '#ffff00',
        chain: true,
        chainCount: 2,
        name: 'Tesla Coil',
        element: 'electric',
        description: 'Chain lightning hits multiple enemies',
        upgrades: {
            damage: { base: 25, perLevel: 5, max: 150 },
            range: { base: 160, perLevel: 6, max: 280 },
            chainCount: { base: 2, perLevel: 0.5, max: 8 },
            fireRate: { base: 1200, perLevel: -60, min: 300 }
        }
    },
    plasma: {
        cost: 850,
        damage: 70,
        range: 200,
        fireRate: 1800,
        color: '#ff00ff',
        projectileSpeed: 10,
        splash: true,
        splashRadius: 50,
        name: 'Plasma Cannon',
        element: 'plasma',
        description: 'High damage with splash effect',
        upgrades: {
            damage: { base: 70, perLevel: 15, max: 400 },
            range: { base: 200, perLevel: 7, max: 350 },
            splashRadius: { base: 50, perLevel: 8, max: 150 },
            fireRate: { base: 1800, perLevel: -80, min: 800 }
        }
    },
    railgun: {
        cost: 1200,
        damage: 90,
        range: 280,
        fireRate: 1500,
        color: '#8a2be2',
        projectileSpeed: 18,
        pierce: true,
        name: 'Railgun',
        element: 'magnetic',
        description: 'Pierces through multiple enemies',
        upgrades: {
            damage: { base: 90, perLevel: 20, max: 500 },
            range: { base: 280, perLevel: 12, max: 500 },
            pierceCount: { base: 3, perLevel: 1, max: 15 },
            fireRate: { base: 1500, perLevel: -70, min: 500 }
        }
    },
    // New tower types for advanced levels
    quantum: {
        cost: 1800,
        damage: 120,
        range: 250,
        fireRate: 2000,
        color: '#00ff99',
        projectileSpeed: 15,
        name: 'Quantum Disruptor',
        element: 'quantum',
        description: 'Phases through reality to hit multiple timelines',
        quantumPhase: true,
        upgrades: {
            damage: { base: 120, perLevel: 25, max: 600 },
            range: { base: 250, perLevel: 10, max: 450 },
            phaseCount: { base: 2, perLevel: 0.5, max: 6 },
            fireRate: { base: 2000, perLevel: -100, min: 600 }
        }
    },
    void: {
        cost: 2500,
        damage: 150,
        range: 300,
        fireRate: 2500,
        color: '#6600cc',
        name: 'Void Cannon',
        element: 'void',
        description: 'Creates black holes that pull enemies',
        voidPull: true,
        upgrades: {
            damage: { base: 150, perLevel: 30, max: 750 },
            range: { base: 300, perLevel: 12, max: 500 },
            pullRadius: { base: 80, perLevel: 10, max: 200 },
            fireRate: { base: 2500, perLevel: -120, min: 800 }
        }
    },
    crystal: {
        cost: 3000,
        damage: 200,
        range: 350,
        fireRate: 3000,
        color: '#00ffff',
        beam: true,
        name: 'Crystal Prism',
        element: 'crystal',
        description: 'Refracts beams to hit multiple targets',
        refract: true,
        upgrades: {
            damage: { base: 200, perLevel: 40, max: 1000 },
            range: { base: 350, perLevel: 15, max: 600 },
            refractCount: { base: 3, perLevel: 1, max: 10 },
            fireRate: { base: 3000, perLevel: -150, min: 1000 }
        }
    },
    omega: {
        cost: 5000,
        damage: 500,
        range: 400,
        fireRate: 4000,
        color: '#ff0066',
        projectileSpeed: 20,
        name: 'Omega Cannon',
        element: 'omega',
        description: 'Ultimate weapon with devastating power',
        omegaBlast: true,
        upgrades: {
            damage: { base: 500, perLevel: 100, max: 2500 },
            range: { base: 400, perLevel: 20, max: 800 },
            blastRadius: { base: 100, perLevel: 15, max: 300 },
            fireRate: { base: 4000, perLevel: -200, min: 1500 }
        }
    }
};

// Enemy types - Increased health and rewards
const enemyTypes = {
    slime: { health: 80, speed: 1, reward: 15, color: '#88ff88', size: 18, glow: '#00ff00' },
    golem: { health: 250, speed: 0.6, reward: 35, color: '#8b7355', size: 25, glow: '#a0522d' },
    brute: { health: 800, speed: 0.4, reward: 150, color: '#654321', size: 35, glow: '#8b4513' },
    speeder: { health: 120, speed: 2.5, reward: 40, color: '#00ddff', size: 16, glow: '#00ffff' },
    tank: { health: 2000, speed: 0.25, reward: 300, color: '#555555', size: 40, glow: '#888888' },
    ghost: { health: 400, speed: 1.2, reward: 80, color: '#cc99ff', size: 20, glow: '#ff99ff', phasing: true },
    healer: { health: 500, speed: 0.8, reward: 100, color: '#ffcc00', size: 22, glow: '#ffff00', healing: true },
    splitter: { health: 300, speed: 1.1, reward: 60, color: '#ff6600', size: 24, glow: '#ff9900', splits: 2 },
    shielder: { health: 600, speed: 0.7, reward: 120, color: '#0099ff', size: 26, glow: '#00ccff', shield: 300 },
    bomber: { health: 350, speed: 1.3, reward: 90, color: '#ff0066', size: 23, glow: '#ff3399', explodeOnDeath: true },
    regenerator: { health: 700, speed: 0.9, reward: 140, color: '#00ff66', size: 25, glow: '#66ff99', regen: 5 },
    absorber: { health: 900, speed: 0.5, reward: 180, color: '#9900ff', size: 30, glow: '#cc66ff', damageReduction: 0.5 },
    teleporter: { health: 450, speed: 1.5, reward: 110, color: '#ff00ff', size: 21, glow: '#ff66ff', teleports: true },
    swarm: { health: 50, speed: 1.8, reward: 8, color: '#ffff66', size: 12, glow: '#ffff99' },
    boss: { health: 5000, speed: 0.3, reward: 1000, color: '#ff0000', size: 50, glow: '#ff6666', boss: true },
    // New enemies for levels 16-50
    voidwalker: { health: 1200, speed: 1.0, reward: 200, color: '#000033', size: 28, glow: '#6600cc', voidWalk: true },
    crystalGuard: { health: 1800, speed: 0.4, reward: 250, color: '#00ffff', size: 32, glow: '#66ffff', reflect: 0.3 },
    fireElemental: { health: 1000, speed: 1.2, reward: 180, color: '#ff6600', size: 26, glow: '#ffaa00', burnDamage: 10 },
    iceElemental: { health: 1500, speed: 0.8, reward: 220, color: '#99ccff', size: 28, glow: '#ccddff', slow: true },
    lightningElemental: { health: 800, speed: 1.5, reward: 200, color: '#ffff00', size: 24, glow: '#ffffcc', chainStrike: true },
    shadowAssassin: { health: 600, speed: 2.0, reward: 300, color: '#330033', size: 20, glow: '#660066', stealth: true },
    necromancer: { health: 2000, speed: 0.6, reward: 400, color: '#660066', size: 30, glow: '#990099', summons: true },
    timeBender: { health: 1000, speed: 1.0, reward: 350, color: '#0066ff', size: 25, glow: '#3399ff', timeWarp: true },
    plasmaBeast: { health: 2500, speed: 0.5, reward: 500, color: '#ff00ff', size: 35, glow: '#ff66ff', plasmaShield: 500 },
    quantumEntity: { health: 1500, speed: 1.3, reward: 450, color: '#00ff99', size: 27, glow: '#66ffcc', quantum: true },
    megaBoss: { health: 15000, speed: 0.2, reward: 3000, color: '#ff0066', size: 60, glow: '#ff3399', megaBoss: true },
    eliteTank: { health: 5000, speed: 0.3, reward: 600, color: '#333333', size: 45, glow: '#666666', armor: 50 },
    hyperSwarm: { health: 100, speed: 2.5, reward: 15, color: '#ffff00', size: 10, glow: '#ffffcc', hyperSwarm: true },
    corruptor: { health: 2000, speed: 0.7, reward: 700, color: '#006600', size: 32, glow: '#009900', corrupt: true },
    finalBoss: { health: 50000, speed: 0.15, reward: 10000, color: '#ff0000', size: 80, glow: '#ff9999', finalBoss: true }
};


// Expanded tower types with special abilities
const TOWER_ABILITIES = {
    // Support towers
    buffer: { 
        effect: 'buff', 
        radius: 150, 
        boost: { damage: 1.5, speed: 1.3 },
        description: 'Increases nearby tower damage and speed'
    },
    slower: {
        effect: 'slow',
        radius: 120,
        slowAmount: 0.5,
        description: 'Slows enemies in range'
    },
    generator: {
        effect: 'income',
        goldPerWave: 50,
        description: 'Generates gold each wave'
    },
    
    // Legendary towers
    phoenix: {
        effect: 'resurrect',
        cooldown: 300,
        description: 'Revives fallen allies'
    },
    dragon: {
        effect: 'firebreath',
        burnDamage: 10,
        burnDuration: 3,
        description: 'Burns enemies over time'
    },
    
    // Mythic towers
    infinity: {
        effect: 'timewarp',
        range: 300,
        damage: 300,
        description: 'Warps time to destroy enemies'
    }
};

// Tower class
class Tower {
    constructor(type, x, y) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.stats = {...towerTypes[type]};
        this.lastShot = 0;
        this.rotation = 0;
        this.targetRotation = 0;
        this.level = 1;
        this.kills = 0;
        this.chargeAnimation = 0;
        this.beamTarget = null;
        this.idleAnimation = 0;
        this.targetPriority = 'closest';
        this.specialization = null;
        this.synergyBonus = 0;
        this.abilityCooldown = 0;
        this.abilityActive = false;
        this.abilityDuration = 0;
        this.stunned = 0;
        this.upgradeAnimation = 0;
        this.specializationAnimation = 0;
        this.specialAbilityCooldown = 0;
        this.specialAbilityActive = false;
    }
    
    checkSynergies() {
        this.synergyBonus = 0;
        let nearbyTypes = new Set();
        
        // Check for nearby towers
        for (let tower of towers) {
            if (tower !== this) {
                const distSq = distanceSquared(tower.x, tower.y, this.x, this.y);
                if (distSq < 150 * 150) {
                    nearbyTypes.add(tower.type);
                }
            }
        }
        
        // Synergy bonuses
        if (this.type === 'laser' && nearbyTypes.has('tesla')) {
            this.synergyBonus += 0.2; // 20% damage boost
        }
        if (this.type === 'missile' && nearbyTypes.has('railgun')) {
            this.synergyBonus += 0.25; // 25% damage boost
        }
        if (this.type === 'tesla' && nearbyTypes.has('plasma')) {
            this.synergyBonus += 0.15; // 15% damage boost
        }
        if (nearbyTypes.size >= 3) {
            this.synergyBonus += 0.1; // Diversity bonus
        }
    }
    
    getUpgradeCost() {
        if (this.level >= 10) return 0;
        return Math.floor(this.stats.cost * Math.pow(1.6, this.level - 1));
    }
    
    upgrade() {
        const cost = this.getUpgradeCost();
        if (cost > 0 && money >= cost) {
            money -= cost;
            this.level++;
            this.stats.damage *= 1.15;
            this.stats.range *= 1.03;
            this.stats.fireRate *= 0.92;
            this.upgradeAnimation = 60; // Start upgrade animation
            
            if (this.level === 10 && !achievements.upgradeMax.unlocked) {
                unlockAchievement('upgradeMax');
            }
            
            updateUI();
            
            // Upgrade effects
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 5 + Math.random() * 10;
                particlePool.get(this.x, this.y, Math.cos(angle) * speed, Math.sin(angle) * speed, this.stats.color, 1, 5);
            }
            
            return true;
        }
        return false;
    }
    
    specialize(type) {
        if (this.level >= 5 && !this.specialization) {
            this.specialization = type;
            
            // Enhanced tower-specific specialization bonuses
            const towerSpecs = {
                pulse: {
                    power: {
                        damage: 2.2,
                        fireRate: 0.8,
                        critChance: 0.25,
                        ability: 'rapidfire' // 3 seconds of 3x fire rate
                    },
                    speed: {
                        fireRate: 0.4,
                        projectileSpeed: 2.5,
                        multishot: 2,
                        ability: 'overdrive' // 5 seconds of no reload
                    },
                    effect: {
                        damage: 1.5,
                        slow: 0.4,
                        pierce: 3,
                        ability: 'freeze' // Freezes all enemies in range for 2 seconds
                    }
                },
                laser: {
                    power: {
                        damage: 2.5,
                        beamWidth: 3,
                        burnDps: 10,
                        ability: 'megabeam' // 3x damage beam for 4 seconds
                    },
                    speed: {
                        fireRate: 0.2,
                        range: 1.8,
                        chainBeams: 2,
                        ability: 'prism' // Splits into 5 beams
                    },
                    effect: {
                        penetrate: true,
                        weaken: 0.3,
                        chainCount: 3,
                        ability: 'disintegrate' // Instant kill enemies below 30% health
                    }
                },
                missile: {
                    power: {
                        damage: 3.0,
                        splashRadius: 2.5,
                        stunDuration: 1.0,
                        ability: 'nuke' // Massive explosion dealing 1000 damage
                    },
                    speed: {
                        fireRate: 0.3,
                        projectileSpeed: 4.0,
                        barrage: 3,
                        ability: 'cluster' // Fires 10 missiles at once
                    },
                    effect: {
                        splashRadius: 3.5,
                        burnDps: 15,
                        fragment: 8,
                        ability: 'napalm' // Leaves burning area for 10 seconds
                    }
                },
                tesla: {
                    power: {
                        damage: 2.0,
                        chainCount: 4,
                        stunChance: 0.5,
                        ability: 'thunderstorm' // Chain lightning hits all enemies
                    },
                    speed: {
                        fireRate: 0.3,
                        chainSpeed: 3.0,
                        instantChain: true,
                        ability: 'surge' // Double chain count for 5 seconds
                    },
                    effect: {
                        chainCount: 6,
                        range: 1.6,
                        emp: true,
                        ability: 'emp' // Disables all enemy abilities for 5 seconds
                    }
                },
                plasma: {
                    power: {
                        damage: 3.2,
                        splashRadius: 2.0,
                        meltArmor: true,
                        ability: 'meltdown' // Continuous damage aura
                    },
                    speed: {
                        fireRate: 0.2,
                        projectileSpeed: 3.5,
                        homing: 2.0,
                        ability: 'plasma_volley' // Rapid fire plasma bursts
                    },
                    effect: {
                        splashRadius: 3.0,
                        slow: 0.7,
                        dot: 20,
                        ability: 'plasma_field' // Creates damaging field
                    }
                },
                railgun: {
                    power: {
                        damage: 4.0,
                        pierce: 999,
                        critMultiplier: 3.0,
                        ability: 'piercing_shot' // One shot pierces all enemies
                    },
                    speed: {
                        fireRate: 0.2,
                        range: 2.0,
                        instantHit: true,
                        ability: 'rapid_rail' // Machine gun mode
                    },
                    effect: {
                        stunDuration: 1.5,
                        knockback: 100,
                        shred: 0.7,
                        ability: 'shockwave' // Knockback wave
                    }
                },
                quantum: {
                    power: {
                        damage: 2.8,
                        phaseShift: true,
                        voidDamage: 0.5,
                        ability: 'void_rift' // Creates damaging rift
                    },
                    speed: {
                        fireRate: 0.3,
                        teleportShots: true,
                        multiverse: 3,
                        ability: 'time_warp' // Slows time in area
                    },
                    effect: {
                        slow: 0.9,
                        confuse: true,
                        reality_tear: true,
                        ability: 'singularity' // Mini black hole
                    }
                },
                void: {
                    power: {
                        damage: 3.5,
                        pullForce: 200,
                        crushDamage: 50,
                        ability: 'black_hole' // Massive gravity well
                    },
                    speed: {
                        fireRate: 0.2,
                        range: 2.0,
                        vortexSpeed: 2.0,
                        ability: 'gravity_pulse' // Pulls then pushes
                    },
                    effect: {
                        pullForce: 300,
                        slow: 0.98,
                        implode: true,
                        ability: 'void_prison' // Traps enemies
                    }
                },
                prism: {
                    power: {
                        damage: 2.8,
                        splitCount: 5,
                        rainbow: true,
                        ability: 'spectrum' // All damage types
                    },
                    speed: {
                        fireRate: 0.3,
                        beamCount: 8,
                        instantSplit: true,
                        ability: 'disco' // Rotating laser show
                    },
                    effect: {
                        splitCount: 10,
                        refract: true,
                        blind: 0.5,
                        ability: 'kaleidoscope' // Confuses and damages
                    }
                },
                omega: {
                    power: {
                        damage: 5.0,
                        annihilate: true,
                        overkill: true,
                        ability: 'doomsday' // Screen clear
                    },
                    speed: {
                        fireRate: 0.1,
                        omnishot: true,
                        instantKill: 0.15,
                        ability: 'time_stop' // Freezes all enemies
                    },
                    effect: {
                        damage: 3.0,
                        apocalypse: true,
                        cascade: 15,
                        ability: 'omega_wave' // Expanding death wave
                    }
                }
            };
            
            const specs = towerSpecs[this.type]?.[type] || {
                power: { damage: 1.8, fireRate: 0.85 },
                speed: { fireRate: 0.5, projectileSpeed: 1.8 },
                effect: { range: 1.4, special: true }
            }[type];
            
            // Apply specialization bonuses
            Object.entries(specs).forEach(([key, value]) => {
                if (key === 'ability') {
                    this.specialAbility = value;
                } else if (key === 'damage' || key === 'range' || key === 'projectileSpeed') {
                    if (this.stats[key]) this.stats[key] *= value;
                } else if (key === 'fireRate') {
                    this.stats.fireRate *= value;
                } else if (key === 'splashRadius') {
                    if (!this.stats.splashRadius) this.stats.splashRadius = 60;
                    this.stats.splashRadius *= value;
                } else if (key === 'chainCount') {
                    if (!this.stats.chainCount) this.stats.chainCount = 0;
                    this.stats.chainCount += value;
                    this.stats.chain = true;
                } else {
                    this.stats[key] = value;
                }
            });
            
            // Visual effect for specialization
            this.specializationAnimation = 120;
            
            // Create epic specialization particles
            const colors = {
                power: '#ff4444',
                speed: '#44ff44',
                effect: '#4444ff'
            };
            
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2;
                const speed = 10 + Math.random() * 15;
                particlePool.get(this.x, this.y, Math.cos(angle) * speed, Math.sin(angle) * speed, colors[type], 1, 10);
            }
            
            // Show notification
            const specNames = {
                power: 'üí• Power',
                speed: '‚ö° Speed', 
                effect: '‚ú® Effect'
            };
            showNotification(`${this.stats.name} specialized: ${specNames[type]}!`);
            
            // Play sound
            playSound('achievement');
            
            if (!achievements.specialization.unlocked) {
                unlockAchievement('specialization');
            }
        }
    }
    
    activateSpecialAbility() {
        if (this.specialAbility && this.specialAbilityCooldown <= 0) {
            this.specialAbilityActive = true;
            this.specialAbilityCooldown = 600; // 10 second cooldown
            
            // Execute ability based on type
            switch(this.specialAbility) {
                case 'freeze':
                    // Freeze all enemies in range
                    enemies.forEach(enemy => {
                        const distSq = distanceSquared(enemy.position.x, enemy.position.y, this.x, this.y);
                        if (distSq <= this.stats.range * this.stats.range) {
                            enemy.frozen = 120; // 2 seconds
                        }
                    });
                    // Freeze effect
                    for (let i = 0; i < 30; i++) {
                        const angle = (i / 30) * Math.PI * 2;
                        particlePool.get(this.x + Math.cos(angle) * this.stats.range, this.y + Math.sin(angle) * this.stats.range, 0, -2, '#00ffff', 1, 8);
                    }
                    playSound('freeze');
                    break;
                    
                case 'nuke':
                    // Find nearest enemy and nuke area
                    const target = this.findTarget();
                    if (target) {
                        // Deal massive damage in area
                        enemies.forEach(enemy => {
                            const distSq = distanceSquared(enemy.position.x, enemy.position.y, target.position.x, target.position.y);
                            if (distSq <= 150 * 150) {
                                enemy.takeDamage(1000 * (1 - dist / 150));
                            }
                        });
                        // Nuke explosion effect
                        for (let i = 0; i < 100; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 30;
                            particlePool.get(target.position.x, target.position.y, Math.cos(angle) * speed, Math.sin(angle) * speed, ['#ff0000', 1, 15);
                        }
                        screenShake = 30;
                        playSound('explosion');
                    }
                    break;
                    
                case 'time_stop':
                    // Stop all enemies for 3 seconds
                    for (let i = 0; i < enemies.length; i++) { const enemy = enemies[i];
                        enemy.timeStop = 180;
                    };
                    // Time stop visual
                    ctxSaveCount++; ctx.save();
                    ctx.fillStyle = 'rgba(128, 128, 255, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctxSaveCount--; ctx.restore();
                    playSound('powerup');
                    break;
                    
                case 'black_hole':
                    // Create a black hole that pulls enemies
                    this.blackHoleActive = 300; // 5 seconds
                    this.blackHoleX = this.x;
                    this.blackHoleY = this.y;
                    playSound('void');
                    break;
                    
                // Add more ability implementations as needed
                default:
                    // Generic powerful attack
                    this.stats.damage *= 3;
                    setTimeout(() => {
                        this.stats.damage /= 3;
                    }, 3000);
                    break;
            }
            
            showNotification(`üéÜ ${this.stats.name} used special ability!`);
        }
    }
    
    update() {
        this.idleAnimation += 0.05 * gameSpeed;
        
        // Update special ability cooldown
        if (this.specialAbilityCooldown > 0) {
            this.specialAbilityCooldown -= gameSpeed;
        }
        
        // Handle black hole special ability
        if (this.blackHoleActive > 0) {
            this.blackHoleActive -= gameSpeed;
            // Pull enemies toward black hole
            enemies.forEach(enemy => {
                const dx = this.blackHoleX - enemy.position.x;
                const dy = this.blackHoleY - enemy.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 10 && dist < 300) {
                    const pullForce = 200 / dist;
                    enemy.position.x += (dx / dist) * pullForce * gameSpeed;
                    enemy.position.y += (dy / dist) * pullForce * gameSpeed;
                    enemy.takeDamage(2 * gameSpeed);
                }
            });
        }
        
        // Update stun
        if (this.stunned > 0) {
            this.stunned -= gameSpeed;
            return; // Can't do anything while stunned
        }
        
        // Update upgrade animation
        if (this.upgradeAnimation > 0) {
            this.upgradeAnimation -= gameSpeed;
        }
        
        // Update ability cooldown
        if (this.abilityCooldown > 0) {
            this.abilityCooldown -= gameSpeed;
        }
        
        // Update ability duration
        if (this.abilityDuration > 0) {
            this.abilityDuration -= gameSpeed;
            if (this.abilityDuration <= 0) {
                this.abilityActive = false;
            }
        }
        
        // Smooth rotation
        const rotDiff = this.targetRotation - this.rotation;
        this.rotation += rotDiff * 0.2;
        
        const now = Date.now();
        let effectiveFireRate = this.stats.fireRate;
        
        // Pulse ability: double fire rate
        if (this.type === 'pulse' && this.abilityActive) {
            effectiveFireRate *= 0.5;
        }
        
        if (now - this.lastShot > effectiveFireRate / gameSpeed) {
            const target = this.findTarget();
            if (target) {
                this.targetRotation = Math.atan2(target.position.y - this.y, target.position.x - this.x);
                this.shoot(target);
                this.lastShot = now;
            } else {
                this.beamTarget = null;
            }
        }
        
        if (this.chargeAnimation > 0) {
            this.chargeAnimation -= gameSpeed;
        }
    }
    
    findTarget() {
        let targets = [];
        const effectiveRange = this.stats.range;
        
        // Get all enemies in range using spatial grid
        const nearbyEnemies = enemySpatialGrid.getNearby(this.x, this.y, this.stats.range);
        for (let enemy of nearbyEnemies) {
            if (enemy.inTunnel) continue;
            
            const distSq = distanceSquared(enemy.position.x, enemy.position.y, this.x, this.y);
            
            if (dist < effectiveRange) {
                targets.push({ enemy, dist });
            }
        }
        
        if (targets.length === 0) return null;
        
        // Sort by priority
        switch(this.targetPriority) {
            case 'first':
                return targets.sort((a, b) => b.enemy.pathProgress - a.enemy.pathProgress)[0].enemy;
            case 'last':
                return targets.sort((a, b) => a.enemy.pathProgress - b.enemy.pathProgress)[0].enemy;
            case 'closest':
                return targets.sort((a, b) => a.dist - b.dist)[0].enemy;
            case 'strongest':
                return targets.sort((a, b) => b.enemy.health - a.enemy.health)[0].enemy;
            case 'weakest':
                return targets.sort((a, b) => a.enemy.health - b.enemy.health)[0].enemy;
            default:
                return targets[0].enemy;
        }
    }
    
    shoot(target) {
        this.chargeAnimation = 10;
        const damage = this.stats.damage * (1 + this.synergyBonus);
        
        if (this.stats.beam) {
            // Laser beam
            this.beamTarget = target;
            if (target.takeDamage(damage, target.position.x, target.position.y)) {
                const index = enemies.indexOf(target);
                if (index !== -1) enemies.splice(index, 1);
                this.kills++;
                totalKills++;
                this.beamTarget = null;
            }
        } else if (this.stats.chain) {
            // Tesla chain lightning
            const hitTargets = [target];
            let currentTarget = target;
            
            beams.push({
                type: 'lightning',
                from: { x: this.x, y: this.y },
                to: { x: target.position.x, y: target.position.y },
                color: this.stats.color,
                life: 10
            });
            
            if (currentTarget.takeDamage(damage, currentTarget.position.x, currentTarget.position.y)) {
                const index = enemies.indexOf(currentTarget);
                if (index !== -1) enemies.splice(index, 1);
                this.kills++;
                totalKills++;
            }
            
            // Chain to nearby enemies
            const chainCount = this.stats.chainCount;
            for (let i = 0; i < chainCount; i++) {
                let nearestEnemy = null;
                let nearestDist = 150;
                
                for (let enemy of enemies) {
                    if (hitTargets.includes(enemy) || enemy.inTunnel) continue;
                    
                    const distSq = distanceSquared(enemy.position.x, enemy.position.y, currentTarget.position.x, currentTarget.position.y);
                    
                    if (dist < nearestDist) {
                        nearestEnemy = enemy;
                        nearestDist = dist;
                    }
                }
                
                if (nearestEnemy) {
                    beams.push({
                        type: 'lightning',
                        from: { x: currentTarget.position.x, y: currentTarget.position.y },
                        to: { x: nearestEnemy.position.x, y: nearestEnemy.position.y },
                        color: this.stats.color,
                        life: 10
                    });
                    
                    hitTargets.push(nearestEnemy);
                    if (nearestEnemy.takeDamage(damage * 0.7, nearestEnemy.position.x, nearestEnemy.position.y)) {
                        const index = enemies.indexOf(nearestEnemy);
                if (index !== -1) enemies.splice(index, 1);
                        this.kills++;
                        totalKills++;
                    }
                    currentTarget = nearestEnemy;
                } else {
                    break;
                }
            }
        } else {
            // Projectile weapon
            projectilePool.get(this.x, this.y, target, damage, this.stats.projectileSpeed || 10, this.stats.color, {pierce: this.stats.pierce, explosive: this.stats.explosive, splash: this.stats.splash, towerRef: this});
        }
    }
    
    activateAbility() {
        if (this.abilityCooldown > 0 || this.level < 5) return;
        
        this.abilityActive = true;
        this.abilityCooldown = 300; // 5 seconds at 60fps
        
        switch(this.type) {
            case 'pulse':
                // Overcharge: Double fire rate for 3 seconds
                this.abilityDuration = 180;
                break;
            case 'laser':
                // Beam Sweep: Hit all enemies in range
                this.beamSweep();
                break;
            case 'missile':
                // Missile Barrage: Launch 5 missiles at once
                this.missileBarrage();
                break;
            case 'tesla':
                // Lightning Storm: Chain to all enemies in range
                this.lightningStorm();
                break;
            case 'plasma':
                // Plasma Nova: Massive explosion
                this.plasmaNova();
                break;
            case 'railgun':
                // Penetrating Shot: Super pierce shot
                this.railgunBlast();
                break;
        }
    }
    
    beamSweep() {
        const inRange = enemies.filter(enemy => {
            if (enemy.inTunnel) return false;
            const distSq = distanceSquared(enemy.position.x, enemy.position.y, this.x, this.y);
            return dist < this.stats.range;
        });
        
        inRange.forEach(enemy => {
            const damage = this.stats.damage * (1 + this.synergyBonus) * 3;
            if (enemy.takeDamage(damage, enemy.position.x, enemy.position.y)) {
                const index = enemies.indexOf(enemy);
                if (index !== -1) enemies.splice(index, 1);
                this.kills++;
                totalKills++;
            }
        });
        
        // Visual effect
        addScreenShake(10);
    }
    
    missileBarrage() {
        const targets = enemies.filter(enemy => !enemy.inTunnel).slice(0, 5);
        targets.forEach(target => {
            projectilePool.get(this.x, this.y, target, this.stats.damage * (1 + this.synergyBonus) * 2, this.stats.projectileSpeed * 1.5, this.stats.color, {explosive: true, towerRef: this});
        });
    }
    
    lightningStorm() {
        const allEnemies = enemies.filter(enemy => {
            if (enemy.inTunnel) return false;
            const distSq = distanceSquared(enemy.position.x, enemy.position.y, this.x, this.y);
            return dist < this.stats.range * 1.5;
        });
        
        allEnemies.forEach(enemy => {
            beams.push({
                type: 'lightning',
                from: { x: this.x, y: this.y },
                to: { x: enemy.position.x, y: enemy.position.y },
                color: this.stats.color,
                life: 20
            });
            
            const damage = this.stats.damage * (1 + this.synergyBonus) * 0.5;
            if (enemy.takeDamage(damage, enemy.position.x, enemy.position.y)) {
                const index = enemies.indexOf(enemy);
                if (index !== -1) enemies.splice(index, 1);
                this.kills++;
                totalKills++;
            }
        });
        
        addScreenShake(15);
    }
    
    plasmaNova() {
        // Create massive explosion
        const x = this.x;
        const y = this.y;
        const radius = 150;
        
        enemies.forEach(enemy => {
            if (enemy.inTunnel) return;
            const distSq = distanceSquared(enemy.position.x, enemy.position.y, x, y);
            if (dist < radius) {
                const damage = this.stats.damage * (1 + this.synergyBonus) * 4 * (1 - dist / radius);
                if (enemy.takeDamage(damage, enemy.position.x, enemy.position.y)) {
                    const index = enemies.indexOf(enemy);
                if (index !== -1) enemies.splice(index, 1);
                    this.kills++;
                    totalKills++;
                }
            }
        });
        
        // Visual explosion
        for (let i = 0; i < 50; i++) {
            const angle = (i / 50) * Math.PI * 2;
            const speed = 10 + Math.random() * 20;
            particlePool.get(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, this.stats.color, 1, 10);
        }
        
        addScreenShake(20);
    }
    
    railgunBlast() {
        // Fire a super powerful piercing shot
        const target = this.findTarget();
        if (target) {
            projectilePool.get(this.x, this.y, target, this.stats.damage * (1 + this.synergyBonus) * 5, this.stats.projectileSpeed * 2, '#ffffff', {pierce: true, towerRef: this});
            
            addScreenShake(8);
        }
    }
    
    draw() {
        const x = this.x - camera.x;
        const y = this.y - camera.y;
        const scale = getScaleFactor();
        
        // Idle animation
        this.idleAnimation += 0.02;
        
        // Upgrade animation effect
        if (this.upgradeAnimation > 0) {
            const upgradeScale = 1 + (this.upgradeAnimation / 60) * 0.3;
            ctxSaveCount++; ctx.save();
            ctx.globalAlpha = this.upgradeAnimation / 60;
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.arc(x, y, 40 * scale * upgradeScale, 0, Math.PI * 2);
            ctx.stroke();
            ctxSaveCount--; ctx.restore();
        }
        
        // Stun effect
        if (this.stunned > 0) {
            ctxSaveCount++; ctx.save();
            ctx.globalAlpha = 0.5;
            // Draw electric sparks around stunned tower
            const sparkCount = 5;
            for (let i = 0; i < sparkCount; i++) {
                const angle = (Math.PI * 2 * i) / sparkCount + Date.now() * 0.002;
                const sparkX = x + Math.cos(angle) * 30 * scale;
                const sparkY = y + Math.sin(angle) * 30 * scale;
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(sparkX, sparkY);
                ctx.stroke();
            }
            ctxSaveCount--; ctx.restore();
        }
        
        // Tower base with gradient and glow
        ctxSaveCount++; ctx.save();
        
        // Base glow effect (reduced when stunned)
        const glowIntensity = this.stunned > 0 ? '20' : '40';
        const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 50 * scale);
        glowGradient.addColorStop(0, this.stats.color + glowIntensity);
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(x - 50 * scale, y - 50 * scale, 100 * scale, 100 * scale);
        
        // Base platform
        const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, 35 * scale);
        baseGradient.addColorStop(0, 'rgba(80,80,120,0.9)');
        baseGradient.addColorStop(0.7, 'rgba(50,50,80,0.9)');
        baseGradient.addColorStop(1, 'rgba(30,30,60,0.9)');
        ctx.fillStyle = baseGradient;
        ctx.beginPath();
        ctx.arc(x, y, 35 * scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Base ring
        ctx.strokeStyle = this.stats.color;
        ctx.lineWidth = 3 * scale;
        ctx.stroke();
        
        // Inner ring
        ctx.beginPath();
        ctx.arc(x, y, 28 * scale, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1 * scale;
        ctx.stroke();
        
        ctxSaveCount--; ctx.restore();
        
        // Tower body
        ctxSaveCount++; ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        
        // Draw based on tower type
        if (this.type === 'laser') {
            this.drawLaserTower(scale);
        } else if (this.type === 'missile') {
            this.drawMissileTower(scale);
        } else if (this.type === 'tesla') {
            this.drawTeslaTower(scale);
        } else if (this.type === 'pulse') {
            this.drawPulseTower(scale);
        } else if (this.type === 'plasma') {
            this.drawPlasmaTower(scale);
        } else if (this.type === 'railgun') {
            this.drawRailgunTower(scale);
        } else if (this.type === 'quantum') {
            this.drawQuantumTower(scale);
        } else if (this.type === 'void') {
            this.drawVoidTower(scale);
        } else if (this.type === 'crystal') {
            this.drawCrystalTower(scale);
        } else if (this.type === 'omega') {
            this.drawOmegaTower(scale);
        }
        
        ctxSaveCount--; ctx.restore();
        
        // Level indicator
        if (this.level > 1) {
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${12 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText(`Lv${this.level}`, x, y - 40 * scale);
        }
        
        // Specialization indicator
        if (this.specialization) {
            const specIcon = this.specialization === 'power' ? 'üí•' :
                           this.specialization === 'speed' ? '‚ö°' :
                           this.specialization === 'effect' ? '‚ú®' :
                           this.specialization === 'special' ? '‚ú®' : '';
            ctx.fillText(specIcon, x + 25 * scale, y - 25 * scale);
        }
        
        // Range indicator when selected or hovered
        if (selectedTower === this || hoveredTower === this) {
            ctx.strokeStyle = this.stats.color + '44';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(x, y, this.stats.range * getScaleFactor(), 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Show range number
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${14 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText(`Range: ${Math.round(this.stats.range)}`, x, y + 55 * scale);
        } else if (this.showFaintRange) {
            // Faint range indicator when mouse is near
            ctx.strokeStyle = this.stats.color + '22';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 10]);
            ctx.beginPath();
            ctx.arc(x, y, this.stats.range * getScaleFactor(), 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Selection indicator
        if (selectedTower === this) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 40 * scale, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Draw beam if active
        if (this.stats.beam && this.beamTarget && enemies.includes(this.beamTarget) && !this.beamTarget.inTunnel) {
            const gradient = gradientCache.getLinearGradient(ctx, x, y,
                this.beamTarget.position.x - camera.x,
                this.beamTarget.position.y - camera.y, [
            gradient.addColorStop(0, this.stats.color);
            gradient.addColorStop(0.5, '#ffffff');
            gradient.addColorStop(1, this.stats.color);
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4 * scale;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(this.beamTarget.position.x - camera.x, this.beamTarget.position.y - camera.y);
            ctx.stroke();
        }
        
        // Draw synergy indicators (skip in performance mode)
        if (!performanceMode && this.synergyBonus > 0) {
            // Synergy aura effect
            const synergyPulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
            ctxSaveCount++; ctx.save();
            
            // Outer synergy ring
            const synergyGrad = ctx.createRadialGradient(x, y, 35 * scale, x, y, 45 * scale);
            synergyGrad.addColorStop(0, `rgba(255, 215, 0, ${0.2 * synergyPulse})`);
            synergyGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = synergyGrad;
            ctx.beginPath();
            ctx.arc(x, y, 45 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Synergy particles
            const particleCount = Math.floor(this.synergyBonus * 10);
            for (let i = 0; i < particleCount; i++) {
                const angle = (Date.now() * 0.001 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
                const radius = 40 * scale + Math.sin(Date.now() * 0.002 + i) * 5 * scale;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                
                ctx.fillStyle = `rgba(255, 215, 0, ${0.6 * synergyPulse})`;
                ctx.beginPath();
                ctx.arc(px, py, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Synergy bonus text
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${10 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText(`+${Math.floor(this.synergyBonus * 100)}%`, x, y + 50 * scale);
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Draw ability indicators
        if (this.level >= 5) {
            const abilityX = x + 30 * scale;
            const abilityY = y - 30 * scale;
            
            // Ability button background
            const abilityGrad = ctx.createRadialGradient(abilityX, abilityY, 0, abilityX, abilityY, 15 * scale);
            if (this.abilityCooldown > 0) {
                // On cooldown
                const cooldownPercent = this.abilityCooldown / 300;
                abilityGrad.addColorStop(0, `rgba(100, 100, 100, 0.8)`);
                abilityGrad.addColorStop(1, `rgba(50, 50, 50, 0.8)`);
                
                // Draw cooldown arc
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 3 * scale;
                ctx.beginPath();
                ctx.arc(abilityX, abilityY, 12 * scale, -Math.PI/2, -Math.PI/2 + (1 - cooldownPercent) * Math.PI * 2);
                ctx.stroke();
            } else {
                // Ready to use
                const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
                abilityGrad.addColorStop(0, `rgba(255, 215, 0, ${pulse})`);
                abilityGrad.addColorStop(1, `rgba(255, 140, 0, ${pulse})`);
            }
            
            ctx.fillStyle = abilityGrad;
            ctx.beginPath();
            ctx.arc(abilityX, abilityY, 12 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Ability icon
            ctx.fillStyle = this.abilityCooldown > 0 ? '#666' : '#fff';
            ctx.font = `bold ${14 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('!', abilityX, abilityY);
            
            // Active ability effect
            if (this.abilityActive) {
                const activeGlow = ctx.createRadialGradient(x, y, 0, x, y, 60 * scale);
                activeGlow.addColorStop(0, `rgba(255, 215, 0, 0.3)`);
                activeGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = activeGlow;
                ctx.beginPath();
                ctx.arc(x, y, 60 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    drawPulseTower(scale) {
        // Ultra Premium Pulse Cannon with advanced visual effects
        const pulse = Math.sin(this.idleAnimation * 3) * 0.2 + 0.8;
        const glow = Math.sin(this.idleAnimation * 4) * 0.3 + 0.7;
        
        ctxSaveCount++; ctx.save();
        
        // Enhanced outer casing with metallic effect
        const shellGrad = ctx.createLinearGradient(-20 * scale, -20 * scale, 20 * scale, 20 * scale);
        shellGrad.addColorStop(0, '#66ffaa');
        shellGrad.addColorStop(0.2, '#44ff99');
        shellGrad.addColorStop(0.5, '#00ff88');
        shellGrad.addColorStop(0.8, '#00cc66');
        shellGrad.addColorStop(1, '#008844');
        
        // Main body with beveled edges
        ctx.fillStyle = shellGrad;
        ctx.beginPath();
        ctx.moveTo(-18 * scale, -10 * scale);
        ctx.lineTo(-15 * scale, -15 * scale);
        ctx.lineTo(15 * scale, -15 * scale);
        ctx.lineTo(18 * scale, -10 * scale);
        ctx.lineTo(18 * scale, 10 * scale);
        ctx.lineTo(15 * scale, 15 * scale);
        ctx.lineTo(-15 * scale, 15 * scale);
        ctx.lineTo(-18 * scale, 10 * scale);
        ctx.closePath();
        ctx.fill();
        
        // Metallic highlight strips
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 1 * scale;
        ctx.beginPath();
        ctx.moveTo(-15 * scale, -12 * scale);
        ctx.lineTo(15 * scale, -12 * scale);
        ctx.stroke();
        
        // Advanced barrel design with multiple segments
        for (let i = 0; i < 3; i++) {
            const barrelX = 15 * scale + i * 10 * scale;
            const barrelGrad = ctx.createLinearGradient(barrelX, -10 * scale, barrelX + 10 * scale, 10 * scale);
            barrelGrad.addColorStop(0, '#00dd77');
            barrelGrad.addColorStop(0.5, '#00aa55');
            barrelGrad.addColorStop(1, '#006633');
            ctx.fillStyle = barrelGrad;
            ctx.fillRect(barrelX, -8 * scale + i * scale, 10 * scale - i * 2 * scale, 16 * scale - i * 2 * scale);
        }
        
        // Pulsating energy core with multiple layers
        for (let i = 3; i >= 0; i--) {
            ctx.beginPath();
            ctx.arc(0, 0, (8 + i * 2) * scale * (pulse + i * 0.05), 0, Math.PI * 2);
            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, (8 + i * 2) * scale);
            coreGrad.addColorStop(0, `rgba(255, 255, 255, ${1 - i * 0.2})`);
            coreGrad.addColorStop(0.3, `rgba(150, 255, 200, ${0.8 - i * 0.15})`);
            coreGrad.addColorStop(0.6, `rgba(0, 255, 136, ${0.6 - i * 0.1})`);
            coreGrad.addColorStop(1, `rgba(0, 204, 102, ${0.3 - i * 0.05})`);
            ctx.fillStyle = coreGrad;
            ctx.fill();
        }
        
        // Energy particles floating around core
        for (let i = 0; i < 6; i++) {
            const angle = (this.idleAnimation * 2 + i * Math.PI / 3) % (Math.PI * 2);
            const particleX = Math.cos(angle) * 15 * scale;
            const particleY = Math.sin(angle) * 15 * scale;
            
            ctx.beginPath();
            ctx.arc(particleX, particleY, 2 * scale * glow, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 136, ${glow})`;
            ctx.fill();
        }
        
        // Charging rings with electric effect
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 2 * scale;
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 10 * scale;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.arc(35 * scale, 0, 8 * scale - i * 1.5 * scale, 0, Math.PI * 2);
            ctx.globalAlpha = 0.8 - i * 0.15;
            ctx.stroke();
            
            // Electric sparks
            if (Math.random() < 0.1) {
                ctx.beginPath();
                ctx.moveTo(35 * scale + 8 * scale, 0);
                ctx.lineTo(35 * scale + 12 * scale, (Math.random() - 0.5) * 10 * scale);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1 * scale;
                ctx.stroke();
                ctx.strokeStyle = '#00ff88';
            }
        }
        
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        ctxSaveCount--; ctx.restore();
    }
    
    drawLaserTower(scale) {
        // Ultra Premium Crystal Laser Tower with prismatic effects
        const charge = Math.sin(this.idleAnimation * 2) * 0.3 + 0.7;
        const prism = Math.sin(this.idleAnimation * 3) * 0.2 + 0.8;
        
        ctxSaveCount++; ctx.save();
        
        // Multi-faceted crystal structure
        const facets = 8;
        for (let f = 0; f < facets; f++) {
            ctxSaveCount++; ctx.save();
            ctx.rotate((Math.PI * 2 / facets) * f);
            
            // Each facet with unique gradient
            ctx.beginPath();
            ctx.moveTo(0, -22 * scale);
            ctx.lineTo(-8 * scale, -8 * scale);
            ctx.lineTo(-8 * scale, 8 * scale);
            ctx.lineTo(0, 22 * scale);
            ctx.closePath();
            
            const facetGrad = ctx.createLinearGradient(-8 * scale, -22 * scale, 0, 22 * scale);
            const hue = (f * 45 + this.idleAnimation * 30) % 360;
            facetGrad.addColorStop(0, `hsla(${hue + 180}, 100%, 70%, 0.8)`);
            facetGrad.addColorStop(0.3, `hsla(${hue + 190}, 100%, 60%, 0.7)`);
            facetGrad.addColorStop(0.7, `hsla(${hue + 200}, 100%, 50%, 0.6)`);
            facetGrad.addColorStop(1, `hsla(${hue + 210}, 100%, 40%, 0.5)`);
            ctx.fillStyle = facetGrad;
            ctx.fill();
            
            // Facet edge highlights
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + f * 0.05})`;
            ctx.lineWidth = 0.5 * scale;
            ctx.stroke();
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Central energy core
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15 * scale);
        coreGrad.addColorStop(0, `rgba(255, 255, 255, ${charge})`);
        coreGrad.addColorStop(0.2, `rgba(100, 255, 255, ${charge * 0.8})`);
        coreGrad.addColorStop(0.5, `rgba(0, 200, 255, ${charge * 0.6})`);
        coreGrad.addColorStop(1, 'rgba(0, 100, 200, 0)');
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale * prism, 0, Math.PI * 2);
        ctx.fill();
        
        // Prismatic lens array
        for (let i = 0; i < 3; i++) {
            const lensX = 20 * scale + i * 8 * scale;
            const lensSize = 10 * scale - i * 2 * scale;
            
            // Lens housing
            ctx.strokeStyle = '#0099cc';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.arc(lensX, 0, lensSize, 0, Math.PI * 2);
            ctx.stroke();
            
            // Lens crystal
            const lensGrad = ctx.createRadialGradient(lensX, 0, 0, lensX, 0, lensSize);
            lensGrad.addColorStop(0, `rgba(255, 255, 255, ${charge + i * 0.1})`);
            lensGrad.addColorStop(0.3, `rgba(0, 255, 255, ${charge})`);
            lensGrad.addColorStop(0.7, `rgba(0, 150, 255, ${charge * 0.7})`);
            lensGrad.addColorStop(1, `rgba(0, 100, 200, ${charge * 0.4})`);
            ctx.fillStyle = lensGrad;
            ctx.fill();
            
            // Lens flare effect
            if (charge > 0.8) {
                for (let f = 0; f < 4; f++) {
                    ctxSaveCount++; ctx.save();
                    ctx.translate(lensX, 0);
                    ctx.rotate(Math.PI / 4 * f);
                    const flareGrad = ctx.createLinearGradient(0, 0, lensSize * 2, 0);
                    flareGrad.addColorStop(0, `rgba(255, 255, 255, ${0.3 - f * 0.05})`);
                    flareGrad.addColorStop(0.5, `rgba(0, 200, 255, ${0.2 - f * 0.03})`);
                    flareGrad.addColorStop(1, 'rgba(0, 150, 255, 0)');
                    ctx.fillStyle = flareGrad;
                    ctx.fillRect(0, -0.5 * scale, lensSize * 2, 1 * scale);
                    ctxSaveCount--; ctx.restore();
                }
            }
        }
        
        // Energy circulation particles
        for (let i = 0; i < 8; i++) {
            const angle = (this.idleAnimation * 2 + i * Math.PI / 4) % (Math.PI * 2);
            const radius = 10 * scale + Math.sin(angle * 2) * 5 * scale;
            const particleX = Math.cos(angle) * radius;
            const particleY = Math.sin(angle) * radius;
            
            // Particle trail
            for (let t = 0; t < 3; t++) {
                const trailAngle = angle - t * 0.1;
                const trailX = Math.cos(trailAngle) * radius;
                const trailY = Math.sin(trailAngle) * radius;
                ctx.beginPath();
                ctx.arc(trailX, trailY, (3 - t) * scale, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 255, ${(0.5 - t * 0.15) * charge})`;
                ctx.fill();
            }
            
            // Main particle
            ctx.beginPath();
            ctx.arc(particleX, particleY, 3 * scale, 0, Math.PI * 2);
            const particleGrad = ctx.createRadialGradient(particleX, particleY, 0, particleX, particleY, 3 * scale);
            particleGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            particleGrad.addColorStop(0.5, 'rgba(0, 255, 255, 0.8)');
            particleGrad.addColorStop(1, 'rgba(0, 200, 255, 0)');
            ctx.fillStyle = particleGrad;
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawMissileTower(scale) {
        // Ultra Premium Missile Launcher with advanced targeting system
        ctxSaveCount++; ctx.save();
        ctx.rotate(Math.sin(this.idleAnimation * 0.8) * 0.05);
        
        // Armored launch platform with metallic finish
        const platGrad = ctx.createLinearGradient(-25 * scale, -18 * scale, 25 * scale, 18 * scale);
        platGrad.addColorStop(0, '#ff9955');
        platGrad.addColorStop(0.2, '#ff8844');
        platGrad.addColorStop(0.4, '#dd7733');
        platGrad.addColorStop(0.6, '#cc6633');
        platGrad.addColorStop(0.8, '#aa5522');
        platGrad.addColorStop(1, '#994422');
        
        // Platform base with beveled edges
        ctx.fillStyle = platGrad;
        ctx.beginPath();
        ctx.moveTo(-22 * scale, -12 * scale);
        ctx.lineTo(-20 * scale, -15 * scale);
        ctx.lineTo(20 * scale, -15 * scale);
        ctx.lineTo(22 * scale, -12 * scale);
        ctx.lineTo(22 * scale, 12 * scale);
        ctx.lineTo(20 * scale, 15 * scale);
        ctx.lineTo(-20 * scale, 15 * scale);
        ctx.lineTo(-22 * scale, 12 * scale);
        ctx.closePath();
        ctx.fill();
        
        // Platform detail lines
        ctx.strokeStyle = 'rgba(255, 200, 150, 0.5)';
        ctx.lineWidth = 1 * scale;
        ctx.beginPath();
        ctx.moveTo(-20 * scale, -13 * scale);
        ctx.lineTo(20 * scale, -13 * scale);
        ctx.moveTo(-20 * scale, 13 * scale);
        ctx.lineTo(20 * scale, 13 * scale);
        ctx.stroke();
        
        // Advanced missile tubes with loading mechanism
        for (let i = -1; i <= 1; i++) {
            // Tube housing
            const tubeGrad = ctx.createLinearGradient(20 * scale, i * 10 * scale - 5 * scale, 45 * scale, i * 10 * scale + 5 * scale);
            tubeGrad.addColorStop(0, '#888888');
            tubeGrad.addColorStop(0.3, '#666666');
            tubeGrad.addColorStop(0.7, '#555555');
            tubeGrad.addColorStop(1, '#444444');
            ctx.fillStyle = tubeGrad;
            
            // Hexagonal tube shape
            ctx.beginPath();
            ctx.moveTo(20 * scale, i * 10 * scale - 5 * scale);
            ctx.lineTo(22 * scale, i * 10 * scale - 4 * scale);
            ctx.lineTo(43 * scale, i * 10 * scale - 4 * scale);
            ctx.lineTo(45 * scale, i * 10 * scale);
            ctx.lineTo(43 * scale, i * 10 * scale + 4 * scale);
            ctx.lineTo(22 * scale, i * 10 * scale + 4 * scale);
            ctx.lineTo(20 * scale, i * 10 * scale + 5 * scale);
            ctx.closePath();
            ctx.fill();
            
            // Missile warhead with glowing tip
            const warheadGrad = ctx.createRadialGradient(45 * scale, i * 10 * scale, 0, 45 * scale, i * 10 * scale, 6 * scale);
            warheadGrad.addColorStop(0, '#ffcc00');
            warheadGrad.addColorStop(0.3, '#ff8800');
            warheadGrad.addColorStop(0.6, '#ff4400');
            warheadGrad.addColorStop(1, '#cc0000');
            ctx.fillStyle = warheadGrad;
            ctx.beginPath();
            ctx.arc(45 * scale, i * 10 * scale, 5 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Warhead glow
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 10 * scale;
            ctx.beginPath();
            ctx.arc(45 * scale, i * 10 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fillStyle = '#ff8800';
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // Advanced targeting system
        const targetGrad = ctx.createRadialGradient(-10 * scale, -8 * scale, 0, -10 * scale, -8 * scale, 15 * scale);
        targetGrad.addColorStop(0, '#444466');
        targetGrad.addColorStop(0.5, '#333355');
        targetGrad.addColorStop(1, '#222244');
        ctx.fillStyle = targetGrad;
        ctx.fillRect(-15 * scale, -10 * scale, 30 * scale, 20 * scale);
        
        // Holographic display
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1 * scale;
        ctx.globalAlpha = 0.6;
        
        // Radar sweep
        const radarAngle = this.idleAnimation * 2 % (Math.PI * 2);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, 12 * scale, radarAngle, radarAngle + Math.PI / 4);
        ctx.closePath();
        ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
        ctx.fill();
        
        // Target reticles
        ctx.strokeStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(0, 0, 8 * scale, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-10 * scale, 0);
        ctx.lineTo(-6 * scale, 0);
        ctx.moveTo(6 * scale, 0);
        ctx.lineTo(10 * scale, 0);
        ctx.moveTo(0, -10 * scale);
        ctx.lineTo(0, -6 * scale);
        ctx.moveTo(0, 6 * scale);
        ctx.lineTo(0, 10 * scale);
        ctx.stroke();
        
        // Status indicators
        for (let i = 0; i < 3; i++) {
            const active = (this.idleAnimation * 3 + i) % 3 < 1;
            ctx.fillStyle = active ? '#00ff00' : '#004400';
            ctx.beginPath();
            ctx.arc(-5 * scale + i * 5 * scale, -5 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
        ctxSaveCount--; ctx.restore();
    }
    
    drawTeslaTower(scale) {
        // Ultra Premium Tesla Coil with dynamic lightning effects
        const spark = Math.sin(this.idleAnimation * 10);
        const pulse = Math.sin(this.idleAnimation * 5) * 0.3 + 0.7;
        
        ctxSaveCount++; ctx.save();
        
        // Copper wound coils with metallic sheen
        for (let i = 0; i < 8; i++) {
            const coilY = -15 * scale + i * 4 * scale;
            const coilRadius = 18 * scale - i * 1.5 * scale;
            
            // Coil gradient for metallic copper look
            const coilGrad = ctx.createLinearGradient(-coilRadius, coilY - 2 * scale, coilRadius, coilY + 2 * scale);
            coilGrad.addColorStop(0, '#ffcc66');
            coilGrad.addColorStop(0.3, '#ff9933');
            coilGrad.addColorStop(0.5, '#cc6600');
            coilGrad.addColorStop(0.7, '#ff9933');
            coilGrad.addColorStop(1, '#cc6600');
            
            ctx.strokeStyle = coilGrad;
            ctx.lineWidth = 4 * scale;
            ctx.beginPath();
            ctx.ellipse(0, coilY, coilRadius, 3 * scale, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Coil highlights
            ctx.strokeStyle = 'rgba(255, 255, 200, 0.4)';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.ellipse(0, coilY - 1 * scale, coilRadius - 1 * scale, 2 * scale, 0, Math.PI, Math.PI * 2);
            ctx.stroke();
        }
        
        // Central conductor with insulator rings
        const condGrad = ctx.createLinearGradient(-6 * scale, -25 * scale, 6 * scale, 25 * scale);
        condGrad.addColorStop(0, '#666688');
        condGrad.addColorStop(0.3, '#888899');
        condGrad.addColorStop(0.5, '#aaaacc');
        condGrad.addColorStop(0.7, '#888899');
        condGrad.addColorStop(1, '#666688');
        ctx.fillStyle = condGrad;
        ctx.fillRect(-6 * scale, -25 * scale, 12 * scale, 50 * scale);
        
        // Insulator rings
        for (let i = 0; i < 3; i++) {
            const ringY = -15 * scale + i * 15 * scale;
            ctx.fillStyle = '#333366';
            ctx.fillRect(-8 * scale, ringY - 2 * scale, 16 * scale, 4 * scale);
        }
        
        // Top capacitor sphere with energy field
        const sphereGrad = ctx.createRadialGradient(0, -25 * scale, 0, 0, -25 * scale, 15 * scale);
        sphereGrad.addColorStop(0, `rgba(255, 255, 255, ${pulse})`);
        sphereGrad.addColorStop(0.2, `rgba(255, 255, 200, ${pulse * 0.9})`);
        sphereGrad.addColorStop(0.4, `rgba(255, 255, 100, ${pulse * 0.8})`);
        sphereGrad.addColorStop(0.6, `rgba(255, 200, 0, ${pulse * 0.7})`);
        sphereGrad.addColorStop(1, `rgba(200, 150, 0, ${pulse * 0.6})`);
        ctx.fillStyle = sphereGrad;
        ctx.beginPath();
        ctx.arc(0, -25 * scale, 15 * scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Energy field around sphere
        ctx.strokeStyle = `rgba(100, 200, 255, ${pulse * 0.5})`;
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.arc(0, -25 * scale, 18 * scale, 0, Math.PI * 2);
        ctx.stroke();
        
        // Multiple lightning bolt layers
        const boltCount = 3 + Math.floor(Math.random() * 3);
        for (let b = 0; b < boltCount; b++) {
            if (Math.random() < 0.4 + pulse * 0.3) {
                ctxSaveCount++; ctx.save();
                
                // Main bolt
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = (3 - b * 0.5) * scale;
                ctx.shadowColor = '#6666ff';
                ctx.shadowBlur = 20 * scale;
                ctx.globalAlpha = 0.9 - b * 0.2;
                
                ctx.beginPath();
                ctx.moveTo(0, -25 * scale);
                
                let x = 0;
                let y = -25 * scale;
                const segments = 8 + Math.floor(Math.random() * 4);
                
                for (let i = 1; i <= segments; i++) {
                    const targetX = (Math.random() - 0.5) * 60 * scale;
                    const targetY = -25 * scale + (i / segments) * 50 * scale;
                    
                    // Create jagged path
                    const midX = (x + targetX) / 2 + (Math.random() - 0.5) * 20 * scale;
                    const midY = (y + targetY) / 2;
                    
                    ctx.quadraticCurveTo(midX, midY, targetX, targetY);
                    x = targetX;
                    y = targetY;
                }
                
                ctx.stroke();
                
                // Glow layer
                ctx.strokeStyle = '#8888ff';
                ctx.lineWidth = (6 - b) * scale;
                ctx.globalAlpha = 0.3 - b * 0.08;
                ctx.stroke();
                
                ctxSaveCount--; ctx.restore();
            }
        }
        
        // Electrical particles
        for (let i = 0; i < 6; i++) {
            const angle = (this.idleAnimation * 3 + i * Math.PI / 3) % (Math.PI * 2);
            const radius = 25 * scale + Math.sin(angle * 2) * 10 * scale;
            const px = Math.cos(angle) * radius;
            const py = -25 * scale + Math.sin(angle) * radius * 0.5;
            
            ctx.beginPath();
            ctx.arc(px, py, 2 * scale * pulse, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(200, 200, 255, ${pulse})`;
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawPlasmaTower(scale) {
        // Ultra Premium Plasma Reactor with swirling energy vortex
        const glow = Math.sin(this.idleAnimation * 3) * 0.3 + 0.7;
        const vortex = this.idleAnimation * 2;
        
        ctxSaveCount++; ctx.save();
        
        // Multi-layered containment field
        for (let ring = 3; ring >= 0; ring--) {
            const ringSize = 20 * scale + ring * 3 * scale;
            const ringAlpha = 0.8 - ring * 0.2;
            
            // Outer containment ring
            ctx.strokeStyle = `rgba(255, 0, 255, ${ringAlpha * glow})`;
            ctx.lineWidth = (4 - ring) * scale;
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 10 * scale;
            ctx.beginPath();
            ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Energy field segments
            ctxSaveCount++; ctx.save();
            ctx.rotate(vortex * (1 + ring * 0.2));
            for (let seg = 0; seg < 8; seg++) {
                const segAngle = (Math.PI * 2 / 8) * seg;
                ctxSaveCount++; ctx.save();
                ctx.rotate(segAngle);
                
                const fieldGrad = ctx.createLinearGradient(0, -ringSize, 0, -ringSize + 5 * scale);
                fieldGrad.addColorStop(0, `rgba(255, 100, 255, ${0.3 * ringAlpha})`);
                fieldGrad.addColorStop(0.5, `rgba(200, 0, 255, ${0.2 * ringAlpha})`);
                fieldGrad.addColorStop(1, 'rgba(150, 0, 200, 0)');
                
                ctx.fillStyle = fieldGrad;
                ctx.beginPath();
                ctx.moveTo(0, -ringSize);
                ctx.arc(0, 0, ringSize, -Math.PI / 16, Math.PI / 16);
                ctx.closePath();
                ctx.fill();
                
                ctxSaveCount--; ctx.restore();
            }
            ctxSaveCount--; ctx.restore();
        }
        
        // Swirling plasma core with multiple layers
        for (let layer = 2; layer >= 0; layer--) {
            ctxSaveCount++; ctx.save();
            ctx.rotate(vortex * (1 - layer * 0.3));
            
            const layerSize = 15 * scale - layer * 3 * scale;
            const plasmaGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, layerSize);
            plasmaGrad.addColorStop(0, `rgba(255, 255, 255, ${glow + layer * 0.1})`);
            plasmaGrad.addColorStop(0.2, `rgba(255, 150, 255, ${glow})`);
            plasmaGrad.addColorStop(0.4, `rgba(255, 100, 255, ${glow * 0.8})`);
            plasmaGrad.addColorStop(0.6, `rgba(200, 0, 200, ${glow * 0.6})`);
            plasmaGrad.addColorStop(0.8, `rgba(150, 0, 150, ${glow * 0.4})`);
            plasmaGrad.addColorStop(1, 'rgba(100, 0, 100, 0)');
            
            ctx.fillStyle = plasmaGrad;
            ctx.beginPath();
            ctx.arc(0, 0, layerSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Dynamic plasma tendrils
        ctx.strokeStyle = '#ff99ff';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 15 * scale;
        for (let i = 0; i < 8; i++) {
            const angle = vortex + (i * Math.PI / 4);
            const tendrilGlow = Math.sin(this.idleAnimation * 5 + i) * 0.5 + 0.5;
            
            ctx.lineWidth = (3 - tendrilGlow) * scale;
            ctx.globalAlpha = tendrilGlow;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            
            // Create spiraling path
            const points = 10;
            for (let p = 1; p <= points; p++) {
                const dist = (p / points) * 30 * scale;
                const spiral = angle + (p / points) * Math.PI;
                const px = Math.cos(spiral) * dist;
                const py = Math.sin(spiral) * dist;
                
                if (p === 1) {
                    ctx.lineTo(px, py);
                } else {
                    const prevDist = ((p - 1) / points) * 30 * scale;
                    const prevSpiral = angle + ((p - 1) / points) * Math.PI;
                    const cpx = Math.cos(prevSpiral + 0.5) * prevDist;
                    const cpy = Math.sin(prevSpiral + 0.5) * prevDist;
                    ctx.quadraticCurveTo(cpx, cpy, px, py);
                }
            }
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        
        // Advanced plasma cannon barrel
        const barrelGrad = ctx.createLinearGradient(20 * scale, -8 * scale, 45 * scale, 8 * scale);
        barrelGrad.addColorStop(0, '#cc00cc');
        barrelGrad.addColorStop(0.3, '#990099');
        barrelGrad.addColorStop(0.7, '#660066');
        barrelGrad.addColorStop(1, '#440044');
        
        // Hexagonal barrel shape
        ctx.fillStyle = barrelGrad;
        ctx.beginPath();
        ctx.moveTo(20 * scale, -8 * scale);
        ctx.lineTo(22 * scale, -6 * scale);
        ctx.lineTo(43 * scale, -6 * scale);
        ctx.lineTo(45 * scale, 0);
        ctx.lineTo(43 * scale, 6 * scale);
        ctx.lineTo(22 * scale, 6 * scale);
        ctx.lineTo(20 * scale, 8 * scale);
        ctx.closePath();
        ctx.fill();
        
        // Barrel energy lines
        ctx.strokeStyle = `rgba(255, 150, 255, ${glow})`;
        ctx.lineWidth = 1 * scale;
        ctx.beginPath();
        ctx.moveTo(22 * scale, -4 * scale);
        ctx.lineTo(42 * scale, -4 * scale);
        ctx.moveTo(22 * scale, 4 * scale);
        ctx.lineTo(42 * scale, 4 * scale);
        ctx.stroke();
        
        // Muzzle glow
        if (this.lastFired && Date.now() - this.lastFired < 150) {
            const muzzleGrad = ctx.createRadialGradient(45 * scale, 0, 0, 45 * scale, 0, 25 * scale);
            muzzleGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            muzzleGrad.addColorStop(0.2, 'rgba(255, 150, 255, 0.7)');
            muzzleGrad.addColorStop(0.5, 'rgba(255, 0, 255, 0.4)');
            muzzleGrad.addColorStop(1, 'rgba(200, 0, 200, 0)');
            ctx.fillStyle = muzzleGrad;
            ctx.beginPath();
            ctx.arc(45 * scale, 0, 25 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawRailgunTower(scale) {
        // Ultra Premium Electromagnetic Railgun with magnetic field visualization
        const charge = Math.min(1, (Date.now() - this.lastShot) / 2000);
        const magnetic = Math.sin(this.idleAnimation * 8) * 0.5 + 0.5;
        
        ctxSaveCount++; ctx.save();
        
        // Advanced power core with rotating components
        ctxSaveCount++; ctx.save();
        ctx.translate(-15 * scale, 0);
        
        // Outer core casing
        const casingGrad = ctx.createRadialGradient(0, 0, 8 * scale, 0, 0, 12 * scale);
        casingGrad.addColorStop(0, '#4488cc');
        casingGrad.addColorStop(0.5, '#2266aa');
        casingGrad.addColorStop(1, '#004488');
        ctx.fillStyle = casingGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Rotating energy rings
        ctx.rotate(this.idleAnimation * 2);
        for (let r = 0; r < 3; r++) {
            ctxSaveCount++; ctx.save();
            ctx.rotate(r * Math.PI * 2 / 3);
            ctx.strokeStyle = `rgba(0, 200, 255, ${0.8 - r * 0.2})`;
            ctx.lineWidth = (2 - r * 0.5) * scale;
            ctx.beginPath();
            ctx.arc(0, 0, (10 - r * 2) * scale, 0, Math.PI * 1.5);
            ctx.stroke();
            ctxSaveCount--; ctx.restore();
        }
        
        // Central power core
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8 * scale);
        coreGrad.addColorStop(0, `rgba(255, 255, 255, ${charge})`);
        coreGrad.addColorStop(0.3, `rgba(100, 200, 255, ${charge * 0.9})`);
        coreGrad.addColorStop(0.6, `rgba(0, 150, 255, ${charge * 0.7})`);
        coreGrad.addColorStop(1, `rgba(0, 100, 200, ${charge * 0.5})`);
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 6 * scale * (0.8 + charge * 0.2), 0, Math.PI * 2);
        ctx.fill();
        
        ctxSaveCount--; ctx.restore();
        
        // Enhanced rail system with magnetic field lines
        for (let rail = 0; rail < 2; rail++) {
            const railY = rail === 0 ? -9 * scale : 9 * scale;
            
            // Rail gradient for metallic look
            const railGrad = ctx.createLinearGradient(-10 * scale, railY - 6 * scale, 55 * scale, railY + 6 * scale);
            railGrad.addColorStop(0, '#0088dd');
            railGrad.addColorStop(0.2, '#0066cc');
            railGrad.addColorStop(0.5, '#004499');
            railGrad.addColorStop(0.8, '#0066cc');
            railGrad.addColorStop(1, '#004488');
            
            ctx.fillStyle = railGrad;
            ctx.fillRect(-10 * scale, railY - 6 * scale, 65 * scale, 6 * scale);
            
            // Rail edge highlights
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.moveTo(-10 * scale, railY - 5 * scale);
            ctx.lineTo(55 * scale, railY - 5 * scale);
            ctx.stroke();
        }
        
        // Advanced electromagnetic coil system
        for (let i = 0; i < 5; i++) {
            const coilX = 5 * scale + i * 10 * scale;
            const coilCharge = charge > (i / 5) ? 1 : (charge * 5 - i);
            
            // Coil housing
            ctx.strokeStyle = '#004488';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.arc(coilX, 0, 10 * scale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Electromagnetic field
            if (coilCharge > 0) {
                ctxSaveCount++; ctx.save();
                ctx.globalAlpha = coilCharge * 0.7;
                
                // Field gradient
                const fieldGrad = ctx.createRadialGradient(coilX, 0, 0, coilX, 0, 12 * scale);
                fieldGrad.addColorStop(0, 'rgba(0, 255, 255, 0.6)');
                fieldGrad.addColorStop(0.5, 'rgba(0, 200, 255, 0.3)');
                fieldGrad.addColorStop(1, 'rgba(0, 150, 255, 0)');
                ctx.fillStyle = fieldGrad;
                ctx.beginPath();
                ctx.arc(coilX, 0, 12 * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // Magnetic field lines
                ctx.strokeStyle = `rgba(0, 200, 255, ${coilCharge * 0.5})`;
                ctx.lineWidth = 1 * scale;
                ctx.setLineDash([3 * scale, 3 * scale]);
                for (let f = 0; f < 4; f++) {
                    ctx.beginPath();
                    ctx.arc(coilX, 0, (8 + f * 2) * scale, -Math.PI / 3, Math.PI / 3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(coilX, 0, (8 + f * 2) * scale, Math.PI * 2/3, Math.PI * 4/3);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
                
                ctxSaveCount--; ctx.restore();
            }
            
            // Coil core
            ctx.strokeStyle = coilCharge > 0 ? `rgba(0, 255, 255, ${coilCharge})` : '#006699';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.arc(coilX, 0, 8 * scale, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Charge indicator beam
        if (charge > 0) {
            const beamGrad = ctx.createLinearGradient(-5 * scale, 0, 50 * scale * charge, 0);
            beamGrad.addColorStop(0, `rgba(0, 255, 255, ${charge * 0.3})`);
            beamGrad.addColorStop(0.5, `rgba(0, 200, 255, ${charge * 0.6})`);
            beamGrad.addColorStop(1, `rgba(0, 150, 255, ${charge * 0.3})`);
            ctx.fillStyle = beamGrad;
            ctx.fillRect(-5 * scale, -2 * scale, 50 * scale * charge, 4 * scale);
            
            // Charge particles
            for (let p = 0; p < 5; p++) {
                const px = -5 * scale + (50 * scale * charge) * (p / 5) + magnetic * 5 * scale;
                const py = (Math.sin(this.idleAnimation * 10 + p) * 3 * scale);
                ctx.beginPath();
                ctx.arc(px, py, 2 * scale, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${charge})`;
                ctx.fill();
            }
        }
        
        // Muzzle device
        const muzzleGrad = ctx.createLinearGradient(50 * scale, -8 * scale, 60 * scale, 8 * scale);
        muzzleGrad.addColorStop(0, '#006699');
        muzzleGrad.addColorStop(0.5, '#004466');
        muzzleGrad.addColorStop(1, '#002244');
        ctx.fillStyle = muzzleGrad;
        ctx.fillRect(50 * scale, -8 * scale, 10 * scale, 16 * scale);
        
        // Muzzle flash on fire
        if (this.lastFired && Date.now() - this.lastFired < 100) {
            const flashGrad = ctx.createRadialGradient(60 * scale, 0, 0, 60 * scale, 0, 30 * scale);
            flashGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            flashGrad.addColorStop(0.2, 'rgba(100, 200, 255, 0.7)');
            flashGrad.addColorStop(0.5, 'rgba(0, 150, 255, 0.4)');
            flashGrad.addColorStop(1, 'rgba(0, 100, 200, 0)');
            ctx.fillStyle = flashGrad;
            ctx.beginPath();
            ctx.arc(60 * scale, 0, 30 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawQuantumTower(scale) {
        // Ultra Premium Quantum Disruptor with phase-shifting reality effects
        const phase = this.idleAnimation * 3;
        const quantumFlux = Math.sin(this.idleAnimation * 5) * 0.5 + 0.5;
        
        ctxSaveCount++; ctx.save();
        
        // Quantum core with multiple dimensional layers
        for (let d = 3; d >= 0; d--) {
            ctxSaveCount++; ctx.save();
            ctx.globalAlpha = 0.7 - d * 0.15;
            ctx.translate(Math.sin(phase + d) * 2 * scale, Math.cos(phase + d) * 2 * scale);
            
            // Dimensional crystal structure
            const crystalSize = 20 * scale - d * 3 * scale;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                const x = Math.cos(angle) * crystalSize;
                const y = Math.sin(angle) * crystalSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // Quantum gradient
            const dimGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, crystalSize);
            dimGrad.addColorStop(0, `rgba(0, 255, 153, ${1 - d * 0.2})`);
            dimGrad.addColorStop(0.3, `rgba(0, 255, 200, ${0.8 - d * 0.15})`);
            dimGrad.addColorStop(0.6, `rgba(0, 200, 153, ${0.6 - d * 0.1})`);
            dimGrad.addColorStop(1, `rgba(0, 150, 100, ${0.3 - d * 0.05})`);
            ctx.fillStyle = dimGrad;
            ctx.fill();
            
            ctx.strokeStyle = `rgba(100, 255, 200, ${0.5 - d * 0.1})`;
            ctx.lineWidth = (2 - d * 0.3) * scale;
            ctx.stroke();
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Phase shift emitters
        for (let e = 0; e < 4; e++) {
            const emitterAngle = (Math.PI / 2) * e + phase * 0.5;
            const emitterDist = 25 * scale;
            const ex = Math.cos(emitterAngle) * emitterDist;
            const ey = Math.sin(emitterAngle) * emitterDist;
            
            // Emitter core
            ctx.beginPath();
            ctx.arc(ex, ey, 5 * scale, 0, Math.PI * 2);
            const emitterGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, 5 * scale);
            emitterGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            emitterGrad.addColorStop(0.5, 'rgba(0, 255, 153, 0.7)');
            emitterGrad.addColorStop(1, 'rgba(0, 200, 100, 0.3)');
            ctx.fillStyle = emitterGrad;
            ctx.fill();
            
            // Phase beam
            if (quantumFlux > 0.7) {
                ctxSaveCount++; ctx.save();
                ctx.globalAlpha = quantumFlux;
                ctx.strokeStyle = '#00ff99';
                ctx.lineWidth = 2 * scale;
                ctx.shadowColor = '#00ff99';
                ctx.shadowBlur = 10 * scale;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                ctxSaveCount--; ctx.restore();
            }
        }
        
        // Quantum field distortion
        ctxSaveCount++; ctx.save();
        ctx.globalAlpha = 0.3;
        for (let f = 0; f < 3; f++) {
            const fieldSize = 35 * scale + f * 10 * scale;
            ctx.strokeStyle = `rgba(0, 255, 153, ${0.5 - f * 0.15})`;
            ctx.lineWidth = (3 - f) * scale;
            ctx.setLineDash([5 * scale, 10 * scale]);
            ctx.lineDashOffset = -phase * 10 * scale;
            ctx.beginPath();
            ctx.arc(0, 0, fieldSize, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        ctxSaveCount--; ctx.restore();
        
        // Quantum particles
        for (let p = 0; p < 12; p++) {
            const particlePhase = phase + p * Math.PI / 6;
            const radius = 20 * scale + Math.sin(particlePhase * 2) * 15 * scale;
            const px = Math.cos(particlePhase) * radius;
            const py = Math.sin(particlePhase) * radius;
            
            ctx.beginPath();
            ctx.arc(px, py, 2 * scale * quantumFlux, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 200, ${quantumFlux})`;
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawVoidTower(scale) {
        // Ultra Premium Void Cannon with gravitational singularity
        const voidPulse = Math.sin(this.idleAnimation * 2) * 0.3 + 0.7;
        const singularity = this.idleAnimation;
        
        ctxSaveCount++; ctx.save();
        
        // Event horizon effect
        for (let h = 3; h >= 0; h--) {
            const horizonSize = 25 * scale + h * 5 * scale;
            ctxSaveCount++; ctx.save();
            ctx.globalAlpha = 0.9 - h * 0.2;
            
            // Gravitational distortion
            const distortGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, horizonSize);
            distortGrad.addColorStop(0, 'rgba(0, 0, 0, 1)');
            distortGrad.addColorStop(0.3, `rgba(50, 0, 100, ${0.9 - h * 0.1})`);
            distortGrad.addColorStop(0.6, `rgba(100, 0, 200, ${0.7 - h * 0.15})`);
            distortGrad.addColorStop(1, `rgba(150, 0, 255, ${0.3 - h * 0.05})`);
            ctx.fillStyle = distortGrad;
            ctx.beginPath();
            ctx.arc(0, 0, horizonSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Singularity core
        ctxSaveCount++; ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15 * scale);
        coreGrad.addColorStop(0, 'rgba(100, 0, 200, 1)');
        coreGrad.addColorStop(0.5, 'rgba(150, 0, 255, 0.8)');
        coreGrad.addColorStop(1, 'rgba(200, 100, 255, 0)');
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale * voidPulse, 0, Math.PI * 2);
        ctx.fill();
        ctxSaveCount--; ctx.restore();
        
        // Gravitational rings
        for (let r = 0; r < 4; r++) {
            ctxSaveCount++; ctx.save();
            ctx.rotate(singularity * (1 + r * 0.3));
            ctx.strokeStyle = `rgba(150, 0, 255, ${0.6 - r * 0.1})`;
            ctx.lineWidth = (3 - r * 0.5) * scale;
            ctx.beginPath();
            ctx.ellipse(0, 0, (20 + r * 8) * scale, (10 + r * 4) * scale, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctxSaveCount--; ctx.restore();
        }
        
        // Void cannon barrel
        const barrelGrad = ctx.createLinearGradient(20 * scale, -10 * scale, 50 * scale, 10 * scale);
        barrelGrad.addColorStop(0, '#330066');
        barrelGrad.addColorStop(0.3, '#440088');
        barrelGrad.addColorStop(0.7, '#5500aa');
        barrelGrad.addColorStop(1, '#6600cc');
        
        ctx.fillStyle = barrelGrad;
        ctx.beginPath();
        ctx.moveTo(20 * scale, -10 * scale);
        ctx.lineTo(50 * scale, -8 * scale);
        ctx.lineTo(50 * scale, 8 * scale);
        ctx.lineTo(20 * scale, 10 * scale);
        ctx.closePath();
        ctx.fill();
        
        // Matter being pulled in
        for (let m = 0; m < 8; m++) {
            const matterAngle = singularity * 3 + m * Math.PI / 4;
            const matterDist = 40 * scale - (singularity * 20 % 40) * scale;
            const mx = Math.cos(matterAngle) * matterDist;
            const my = Math.sin(matterAngle) * matterDist;
            
            ctx.beginPath();
            ctx.arc(mx, my, 3 * scale, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(200, 150, 255, ${matterDist / (40 * scale)})`;
            ctx.fill();
            
            // Trail effect
            ctx.strokeStyle = `rgba(150, 100, 255, ${(matterDist / (40 * scale)) * 0.5})`;
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.moveTo(mx, my);
            ctx.lineTo(mx * 1.2, my * 1.2);
            ctx.stroke();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawCrystalTower(scale) {
        // Ultra Premium Crystal Prism with light refraction effects
        const prismRotation = this.idleAnimation * 0.5;
        const lightIntensity = Math.sin(this.idleAnimation * 4) * 0.3 + 0.7;
        
        ctxSaveCount++; ctx.save();
        ctx.rotate(prismRotation);
        
        // Main crystal prism - octagonal structure
        const sides = 8;
        const prismSize = 25 * scale;
        
        // Crystal faces with different refractive indices
        for (let face = 0; face < sides; face++) {
            ctxSaveCount++; ctx.save();
            
            const angle1 = (Math.PI * 2 / sides) * face;
            const angle2 = (Math.PI * 2 / sides) * (face + 1);
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle1) * prismSize, Math.sin(angle1) * prismSize);
            ctx.lineTo(Math.cos(angle2) * prismSize, Math.sin(angle2) * prismSize);
            ctx.closePath();
            
            // Rainbow refraction gradient
            const hue = (face * 45 + this.idleAnimation * 60) % 360;
            const faceGrad = ctx.createLinearGradient(0, 0, Math.cos((angle1 + angle2) / 2) * prismSize, Math.sin((angle1 + angle2) / 2) * prismSize);
            faceGrad.addColorStop(0, `hsla(${hue}, 100%, 80%, 0.7)`);
            faceGrad.addColorStop(0.5, `hsla(${hue + 30}, 100%, 70%, 0.6)`);
            faceGrad.addColorStop(1, `hsla(${hue + 60}, 100%, 60%, 0.5)`);
            ctx.fillStyle = faceGrad;
            ctx.fill();
            
            // Edge highlight
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 + Math.sin(face + this.idleAnimation * 2) * 0.2})`;
            ctx.lineWidth = 1 * scale;
            ctx.stroke();
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Central light core
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 12 * scale);
        coreGrad.addColorStop(0, `rgba(255, 255, 255, ${lightIntensity})`);
        coreGrad.addColorStop(0.3, `rgba(200, 255, 255, ${lightIntensity * 0.8})`);
        coreGrad.addColorStop(0.6, `rgba(150, 200, 255, ${lightIntensity * 0.6})`);
        coreGrad.addColorStop(1, 'rgba(100, 150, 255, 0)');
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();
        
        ctxSaveCount--; ctx.restore();
        
        // Refracted light beams
        for (let beam = 0; beam < 6; beam++) {
            const beamAngle = (Math.PI * 2 / 6) * beam + prismRotation * 2;
            const beamLength = 40 * scale;
            
            ctxSaveCount++; ctx.save();
            ctx.rotate(beamAngle);
            
            // Light beam gradient
            const beamGrad = ctx.createLinearGradient(15 * scale, 0, beamLength, 0);
            const beamHue = (beam * 60 + this.idleAnimation * 90) % 360;
            beamGrad.addColorStop(0, `hsla(${beamHue}, 100%, 70%, ${lightIntensity * 0.8})`);
            beamGrad.addColorStop(0.5, `hsla(${beamHue + 30}, 100%, 60%, ${lightIntensity * 0.5})`);
            beamGrad.addColorStop(1, `hsla(${beamHue + 60}, 100%, 50%, 0)`);
            
            ctx.fillStyle = beamGrad;
            ctx.beginPath();
            ctx.moveTo(15 * scale, -2 * scale);
            ctx.lineTo(beamLength, -4 * scale);
            ctx.lineTo(beamLength, 4 * scale);
            ctx.lineTo(15 * scale, 2 * scale);
            ctx.closePath();
            ctx.fill();
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Focusing lenses
        for (let lens = 0; lens < 3; lens++) {
            const lensX = 30 * scale + lens * 10 * scale;
            ctx.strokeStyle = `rgba(100, 200, 255, ${0.8 - lens * 0.2})`;
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.arc(lensX, 0, (8 - lens * 2) * scale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Lens flare
            ctx.fillStyle = `rgba(255, 255, 255, ${lightIntensity * (0.5 - lens * 0.1)})`;
            ctx.beginPath();
            ctx.arc(lensX, 0, (6 - lens * 1.5) * scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    }
    
    drawOmegaTower(scale) {
        // Ultra Premium Omega Cannon - The ultimate weapon
        const omegaCharge = Math.sin(this.idleAnimation * 2) * 0.5 + 0.5;
        const powerLevel = Math.sin(this.idleAnimation * 3) * 0.3 + 0.7;
        
        ctxSaveCount++; ctx.save();
        
        // Massive power core with rotating rings
        for (let ring = 0; ring < 4; ring++) {
            ctxSaveCount++; ctx.save();
            ctx.rotate(this.idleAnimation * (1 + ring * 0.5) * (ring % 2 ? 1 : -1));
            
            const ringRadius = 20 * scale + ring * 5 * scale;
            ctx.strokeStyle = `rgba(255, 0, 102, ${0.9 - ring * 0.2})`;
            ctx.lineWidth = (5 - ring) * scale;
            ctx.shadowColor = '#ff0066';
            ctx.shadowBlur = 15 * scale;
            
            // Ring segments
            for (let seg = 0; seg < 6; seg++) {
                ctx.beginPath();
                const startAngle = (Math.PI * 2 / 6) * seg + 0.1;
                const endAngle = (Math.PI * 2 / 6) * (seg + 1) - 0.1;
                ctx.arc(0, 0, ringRadius, startAngle, endAngle);
                ctx.stroke();
            }
            
            ctxSaveCount--; ctx.restore();
        }
        
        // Central omega core
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 18 * scale);
        coreGrad.addColorStop(0, `rgba(255, 255, 255, ${powerLevel})`);
        coreGrad.addColorStop(0.2, `rgba(255, 100, 150, ${powerLevel * 0.9})`);
        coreGrad.addColorStop(0.4, `rgba(255, 0, 102, ${powerLevel * 0.8})`);
        coreGrad.addColorStop(0.7, `rgba(200, 0, 80, ${powerLevel * 0.6})`);
        coreGrad.addColorStop(1, 'rgba(150, 0, 60, 0)');
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 18 * scale * (0.8 + omegaCharge * 0.2), 0, Math.PI * 2);
        ctx.fill();
        
        // Massive cannon barrel with segments
        for (let segment = 0; segment < 4; segment++) {
            const segX = 20 * scale + segment * 12 * scale;
            const segSize = 15 * scale - segment * 2 * scale;
            
            const segGrad = ctx.createLinearGradient(segX, -segSize, segX + 12 * scale, segSize);
            segGrad.addColorStop(0, '#cc0055');
            segGrad.addColorStop(0.3, '#990044');
            segGrad.addColorStop(0.7, '#660033');
            segGrad.addColorStop(1, '#440022');
            
            ctx.fillStyle = segGrad;
            ctx.fillRect(segX, -segSize, 12 * scale, segSize * 2);
            
            // Segment details
            ctx.strokeStyle = `rgba(255, 0, 102, ${0.7 - segment * 0.1})`;
            ctx.lineWidth = 1 * scale;
            ctx.strokeRect(segX + 2 * scale, -segSize + 2 * scale, 8 * scale, segSize * 2 - 4 * scale);
        }
        
        // Energy conduits
        for (let conduit = 0; conduit < 3; conduit++) {
            const conduitY = (conduit - 1) * 8 * scale;
            ctx.strokeStyle = `rgba(255, 100, 150, ${omegaCharge})`;
            ctx.lineWidth = 2 * scale;
            ctx.shadowColor = '#ff0066';
            ctx.shadowBlur = 10 * scale;
            ctx.beginPath();
            ctx.moveTo(-10 * scale, conduitY);
            ctx.lineTo(60 * scale, conduitY);
            ctx.stroke();
            
            // Energy pulses
            const pulseX = ((this.idleAnimation * 50) % 70) * scale - 10 * scale;
            ctx.beginPath();
            ctx.arc(pulseX, conduitY, 3 * scale, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();
        }
        
        // Omega symbol in the center
        ctxSaveCount++; ctx.save();
        ctx.globalAlpha = powerLevel * 0.7;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3 * scale;
        ctx.beginPath();
        ctx.arc(-5 * scale, 0, 5 * scale, Math.PI, 0, true);
        ctx.arc(5 * scale, 0, 5 * scale, Math.PI, 0, true);
        ctx.stroke();
        ctxSaveCount--; ctx.restore();
        
        // Devastating charge effect
        if (omegaCharge > 0.8) {
            ctxSaveCount++; ctx.save();
            ctx.globalAlpha = omegaCharge - 0.8;
            const chargeGrad = ctx.createRadialGradient(65 * scale, 0, 0, 65 * scale, 0, 40 * scale);
            chargeGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            chargeGrad.addColorStop(0.2, 'rgba(255, 100, 150, 0.7)');
            chargeGrad.addColorStop(0.5, 'rgba(255, 0, 102, 0.4)');
            chargeGrad.addColorStop(1, 'rgba(200, 0, 80, 0)');
            ctx.fillStyle = chargeGrad;
            ctx.beginPath();
            ctx.arc(65 * scale, 0, 40 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctxSaveCount--; ctx.restore();
        }
        
        ctx.shadowBlur = 0;
        ctxSaveCount--; ctx.restore();
    }
}

// Enemy class
class Enemy {
    constructor(type) {
        this.type = type;
        this.pathIndex = 0;
        this.pathProgress = 0;
        this.position = { x: path[0].x, y: path[0].y };
        this.health = enemyTypes[type].health;
        this.maxHealth = this.health;
        this.speed = enemyTypes[type].speed;
        this.reward = enemyTypes[type].reward;
        this.color = enemyTypes[type].color;
        this.size = enemyTypes[type].size;
        this.rotation = 0;
        this.hitFlash = 0;
        this.inTunnel = false;
        
        // Special properties
        this.shield = enemyTypes[type].shield || 0;
        this.maxShield = this.shield;
        this.phasing = enemyTypes[type].phasing || false;
        this.phaseTimer = 0;
        this.teleportCooldown = 0;
        this.regenRate = enemyTypes[type].regen || 0;
        this.lastRegen = Date.now();
        this.damageReduction = enemyTypes[type].damageReduction || 0;
        this.splits = enemyTypes[type].splits || 0;
        this.explodeOnDeath = enemyTypes[type].explodeOnDeath || false;
        this.healing = enemyTypes[type].healing || false;
        this.healCooldown = 0;
        this.teleports = enemyTypes[type].teleports || false;
        this.boss = enemyTypes[type].boss || false;
        
        // Health bar display
        this.healthBarVisible = 0;
        this.lastHitTime = 0;
        
        // Boss abilities
        this.megaBoss = enemyTypes[type].megaBoss || false;
        this.finalBoss = enemyTypes[type].finalBoss || false;
        this.bossAbilityCooldown = 0;
        this.summonCooldown = 0;
        this.stunWaveCooldown = 0;
    }
    
    update() {
        // Update health bar visibility
        if (this.healthBarVisible > 0) {
            this.healthBarVisible -= gameSpeed;
        }
        
        // Boss abilities
        if (this.megaBoss && this.summonCooldown <= 0) {
            // Summon minions
            if (Math.random() < 0.005) {
                for (let i = 0; i < 3; i++) {
                    const minion = new Enemy('slime');
                    minion.pathIndex = this.pathIndex;
                    minion.pathProgress = Math.max(0, this.pathProgress - 0.1 * i);
                    minion.position.x = this.position.x + (Math.random() - 0.5) * 60;
                    minion.position.y = this.position.y + (Math.random() - 0.5) * 60;
                    enemies.push(minion);
                }
                this.summonCooldown = 300;
                
                // Visual effect
                for (let i = 0; i < 20; i++) {
                    particlePool.get(this.position.x, this.position.y, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, '#ff0066', 1, 8);
                }
            }
        }
        if (this.summonCooldown > 0) this.summonCooldown--;
        
        if (this.finalBoss && this.stunWaveCooldown <= 0) {
            // Stun wave ability
            if (Math.random() < 0.003) {
                towers.forEach(tower => {
                    const distSq = distanceSquared(tower.x, tower.y, this.position.x, this.position.y);
                    if (distSq < 200 * 200) {
                        tower.stunned = 120; // Stun for 2 seconds
                    }
                });
                this.stunWaveCooldown = 600;
                
                // Visual shockwave
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 * i) / 30;
                    particlePool.get(this.position.x, this.position.y, Math.cos(angle) * 20, Math.sin(angle) * 20, '#ff00ff', 1, 10);
                }
            }
        }
        if (this.stunWaveCooldown > 0) this.stunWaveCooldown--;
        
        // Handle special abilities
        if (this.phasing) {
            this.phaseTimer++;
            this.inTunnel = Math.sin(this.phaseTimer * 0.1) > 0;
        }
        
        if (this.regenRate > 0 && Date.now() - this.lastRegen > 1000) {
            this.health = Math.min(this.maxHealth, this.health + this.regenRate);
            this.lastRegen = Date.now();
        }
        
        if (this.healing && this.healCooldown <= 0) {
            // Heal nearby enemies
            enemies.forEach(enemy => {
                if (enemy !== this && !enemy.inTunnel) {
                    const distSq = distanceSquared(enemy.position.x, enemy.position.y, this.position.x, this.position.y);
                    if (distSq < 100 * 100) {
                        enemy.health = Math.min(enemy.maxHealth, enemy.health + 20);
                        this.healCooldown = 60;
                    }
                }
            });
        }
        if (this.healCooldown > 0) this.healCooldown--;
        
        if (this.teleports && this.teleportCooldown <= 0 && Math.random() < 0.01) {
            // Teleport forward
            this.pathIndex = Math.min(path.length - 2, this.pathIndex + 3);
            this.pathProgress = 0;
            this.teleportCooldown = 120;
            
            // Teleport effect
            for (let i = 0; i < 10; i++) {
                particlePool.get(this.position.x, this.position.y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, '#ff00ff', 1, 5);
            }
        }
        if (this.teleportCooldown > 0) this.teleportCooldown--;
        
        if (this.pathIndex < path.length - 1) {
            const current = path[this.pathIndex];
            const next = path[this.pathIndex + 1];
            const dx = next.x - current.x;
            const dy = next.y - current.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            this.pathProgress += (this.speed * gameSpeed) / distance;
            
            if (this.pathProgress >= 1) {
                this.pathIndex++;
                this.pathProgress = 0;
                if (this.pathIndex >= path.length - 1) {
                    return false;
                }
                if (!this.phasing) {
                    this.inTunnel = path[this.pathIndex].tunnel || false;
                }
            }
            
            this.position.x = current.x + dx * this.pathProgress;
            this.position.y = current.y + dy * this.pathProgress;
            this.rotation = Math.atan2(dy, dx);
            
            if (!this.phasing && (current.tunnel || next.tunnel)) {
                this.inTunnel = true;
            }
        } else {
            // Move towards base
            const dx = base.x + base.width/2 - this.position.x;
            const dy = base.y + base.height/2 - this.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 30) {
                health -= this.boss ? 50 : 10;
                updateUI();
                return true;
            }
            
            this.position.x += (dx / distance) * this.speed * gameSpeed;
            this.position.y += (dy / distance) * this.speed * gameSpeed;
            this.rotation = Math.atan2(dy, dx);
            if (!this.phasing) {
                this.inTunnel = false;
            }
        }
        
        if (this.hitFlash > 0) this.hitFlash -= gameSpeed;
        
        return false;
    }
    
    draw() {
        const x = this.position.x - camera.x;
        const y = this.position.y - camera.y;
        
        ctxSaveCount++; ctx.save();
        
        // Make enemy semi-transparent in tunnel
        if (this.inTunnel) {
            ctx.globalAlpha = 0.4;
        }
        
        // Enemy body
        const scale = getScaleFactor();
        
        // Shield effect
        if (this.shield > 0) {
            const shieldAlpha = this.shield / this.maxShield;
            ctx.strokeStyle = `rgba(0, 153, 255, ${shieldAlpha})`;
            ctx.lineWidth = 4 * scale;
            ctx.beginPath();
            ctx.arc(x, y, (this.size/2 + 5) * scale, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Boss aura
        if (this.boss) {
            const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, this.size * scale);
            auraGrad.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
            auraGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = auraGrad;
            ctx.fillRect(x - this.size * scale, y - this.size * scale, this.size * 2 * scale, this.size * 2 * scale);
        }
        
        // Enemy body with glow
        const glow = enemyTypes[this.type].glow || this.color;
        ctx.shadowColor = glow;
        ctx.shadowBlur = 10 * scale;
        
        ctx.fillStyle = this.hitFlash > 0 ? '#ffffff' : this.color;
        ctx.beginPath();
        ctx.arc(x, y, (this.size/2) * scale, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2 * scale;
        ctx.stroke();
        
        // Special indicators
        if (this.healing) {
            ctx.fillStyle = '#ffff00';
            ctx.font = `${12 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('+', x, y - (this.size/2 + 10) * scale);
        }
        
        if (this.teleports) {
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2 * scale;
            ctx.setLineDash([5 * scale, 5 * scale]);
            ctx.beginPath();
            ctx.arc(x, y, (this.size/2) * scale, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        ctxSaveCount--; ctx.restore();
        
        // Health bar (shows on hit and fades)
        if (this.healthBarVisible > 0 && this.health < this.maxHealth && !this.inTunnel) {
            const alpha = Math.min(1, this.healthBarVisible / 180);
            const barWidth = this.size * 1.5 * scale;
            const barHeight = 5 * scale;
            const barY = y - (this.size * scale) - (12 * scale);
            
            ctxSaveCount++; ctx.save();
            ctx.globalAlpha = alpha;
            
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(x - barWidth/2 - 1, barY - 1, barWidth + 2, barHeight + 2);
            
            // Health bar
            const healthPercent = this.health / this.maxHealth;
            const gradient = gradientCache.getLinearGradient(ctx, x - barWidth/2, barY, x + barWidth/2, barY, [
            if (healthPercent > 0.5) {
                gradient.addColorStop(0, '#00ff00');
                gradient.addColorStop(1, '#00cc00');
            } else if (healthPercent > 0.25) {
                gradient.addColorStop(0, '#ffaa00');
                gradient.addColorStop(1, '#ff8800');
            } else {
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(1, '#cc0000');
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(x - barWidth/2, barY, barWidth * healthPercent, barHeight);
            
            // White border
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - barWidth/2, barY, barWidth, barHeight);
            
            ctxSaveCount--; ctx.restore();
        }
    }
    
    takeDamage(damage, x, y) {
        if (this.inTunnel) return false;
        
        // Apply damage reduction
        if (this.damageReduction > 0) {
            damage *= (1 - this.damageReduction);
        }
        
        // Apply shield first
        if (this.shield > 0) {
            const shieldDamage = Math.min(this.shield, damage);
            this.shield -= shieldDamage;
            damage -= shieldDamage;
        }
        
        this.health -= damage;
        this.hitFlash = 5;
        this.healthBarVisible = 180; // Show health bar for 3 seconds
        
        // Damage numbers disabled for performance
        // showDamageNumber(x, y, Math.round(damage), '#ffff00');
        
        // Hit particles
        for (let i = 0; i < 5; i++) {
            particlePool.get(x, y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, this.color, 1, 3);
        }
        
        if (this.health <= 0) {
            money += this.reward;
            score += this.reward * level;
            updateUI();
            
            // Reward numbers disabled for performance
            // showDamageNumber(this.position.x - camera.x, this.position.y - camera.y, `+${this.reward}`, '#00ff00');
            
            // Splitter effect
            if (this.splits > 0) {
                for (let i = 0; i < this.splits; i++) {
                    const splitEnemy = new Enemy('slime');
                    splitEnemy.pathIndex = this.pathIndex;
                    splitEnemy.pathProgress = this.pathProgress;
                    splitEnemy.position.x = this.position.x + (Math.random() - 0.5) * 20;
                    splitEnemy.position.y = this.position.y + (Math.random() - 0.5) * 20;
                    enemies.push(splitEnemy);
                }
            }
            
            // Bomber explosion
            if (this.explodeOnDeath) {
                enemies.forEach(enemy => {
                    if (enemy !== this && !enemy.inTunnel) {
                        const distSq = distanceSquared(enemy.position.x, enemy.position.y, this.position.x, this.position.y);
                        if (distSq < 100 * 100) {
                            enemy.takeDamage(150, enemy.position.x, enemy.position.y);
                        }
                    }
                });
                
                // Big explosion effect
                for (let i = 0; i < 30; i++) {
                    particlePool.get(this.position.x, this.position.y, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, '#ff0066', 1, 10);
                }
                
                // Screen shake for explosion
                addScreenShake(15);
            }
            
            // Boss death shake
            if (this.boss) {
                addScreenShake(25);
            }
            
            // Death effects
            for (let i = 0; i < 10; i++) {
                particlePool.get(this.position.x, this.position.y, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, this.color, 1, 5);
            }
            
            // Random power-up chance
            if (Math.random() < 0.05) { // Reduced from 0.1
                powerups.push({
                    x: this.position.x,
                    y: this.position.y,
                    type: Math.random() < 0.5 ? 'money' : 'health',
                    value: this.type === 'brute' ? 100 : 30
                });
            }
            
            if (totalKills === 1 && !achievements.firstKill.unlocked) {
                unlockAchievement('firstKill');
            }
            
            return true;
        }
        return false;
    }
}

// Show damage/reward number (disabled for performance)
function showDamageNumber(x, y, text, color) {
    // Disabled to improve performance
    return;
    /*
    const dmgNum = document.createElement('div');
    dmgNum.className = 'damage-number';
    dmgNum.textContent = typeof text === 'number' ? `-${text}` : text;
    dmgNum.style.color = color;
    dmgNum.style.left = `${x}px`;
    dmgNum.style.top = `${y}px`;
    document.body.appendChild(dmgNum);
    setTimeout(() => dmgNum.remove(), 1000);
    */
}

// Update projectiles
function updateProjectiles() {
    projectiles = projectiles.filter(proj => {
        proj.trail.push({ x: proj.x, y: proj.y });
        if (proj.trail.length > 10) proj.trail.shift();
        
        if (proj.pierce) {
            // Piercing projectiles
            proj.x += Math.cos(proj.rotation) * proj.speed * gameSpeed;
            proj.y += Math.sin(proj.rotation) * proj.speed * gameSpeed;
            
            enemies = enemies.filter(enemy => {
                if (enemy.inTunnel) return true;
                
                const distSq = distanceSquared(enemy.position.x, enemy.position.y, proj.x, proj.y);
                
                if (distSq < 30 * 30) {
                    if (enemy.takeDamage(proj.damage, enemy.position.x, enemy.position.y)) {
                        if (proj.towerRef) {
                            proj.towerRef.kills++;
                            totalKills++;
                        }
                        return false;
                    }
                }
                return true;
            });
            
            return proj.x > -100 && proj.x < canvas.width + 100 &&
                   proj.y > -100 && proj.y < canvas.height + 100;
        } else if (enemies.includes(proj.target)) {
            if (proj.target.inTunnel) {
                for (let i = 0; i < 10; i++) {
                    particlePool.get(proj.x, proj.y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, proj.color, 1, 3);
                }
                return false;
            }
            
            const dx = proj.target.position.x - proj.x;
            const dy = proj.target.position.y - proj.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (distSq < 20 * 20) {
                // Hit target
                if (proj.target.takeDamage(proj.damage, proj.target.position.x, proj.target.position.y)) {
                    const index = enemies.indexOf(proj.target);
                if (index !== -1) enemies.splice(index, 1);
                    if (proj.towerRef) {
                        proj.towerRef.kills++;
                        totalKills++;
                    }
                }
                
                // Explosion effect
                if (proj.explosive) {
                    enemies = enemies.filter(enemy => {
                        if (enemy === proj.target || enemy.inTunnel) return true;
                        
                        const explodeDistSq = distanceSquared(
                            Math.pow(enemy.position.x - proj.x, 2) +
                            Math.pow(enemy.position.y - proj.y, 2)
                        );
                        
                        if (explodeDist < 80) {
                            if (enemy.takeDamage(proj.damage * 0.5, enemy.position.x, enemy.position.y)) {
                                if (proj.towerRef) {
                                    proj.towerRef.kills++;
                                    totalKills++;
                                }
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    for (let i = 0; i < 30; i++) {
                        particlePool.get(proj.x, proj.y, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, proj.color, 1, 8);
                    }
                } else if (proj.splash) {
                    enemies = enemies.filter(enemy => {
                        if (enemy === proj.target || enemy.inTunnel) return true;
                        
                        const splashDistSq = distanceSquared(
                            Math.pow(enemy.position.x - proj.x, 2) +
                            Math.pow(enemy.position.y - proj.y, 2)
                        );
                        
                        if (splashDist < proj.splashRadius) {
                            if (enemy.takeDamage(proj.damage * 0.3, enemy.position.x, enemy.position.y)) {
                                if (proj.towerRef) {
                                    proj.towerRef.kills++;
                                    totalKills++;
                                }
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    for (let i = 0; i < 20; i++) {
                        particlePool.get(proj.x, proj.y, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, proj.color, 1, 6);
                    }
                }
                
                return false;
            }
            
            // Move towards target
            if (proj.homing || dist < 200) {
                proj.x += (dx / dist) * proj.speed * gameSpeed;
                proj.y += (dy / dist) * proj.speed * gameSpeed;
                proj.rotation = Math.atan2(dy, dx);
            } else {
                proj.x += Math.cos(proj.rotation) * proj.speed * gameSpeed;
                proj.y += Math.sin(proj.rotation) * proj.speed * gameSpeed;
            }
            
            return true;
        }
        
        return false;
    });
}

// Update particles
function updateParticles() {
    particles = particles.filter(particle => {
        particle.x += particle.vx * gameSpeed;
        particle.y += particle.vy * gameSpeed;
        particle.vy += 0.3 * gameSpeed;
        particle.life -= 0.02 * gameSpeed;
        particle.size *= 0.97;
        return particle.life > 0;
    });
}

// Update beams
function updateBeams() {
    beams = beams.filter(beam => {
        beam.life -= gameSpeed;
        return beam.life > 0;
    });
}

// Update power-ups
function updatePowerups() {
    powerups = powerups.filter(powerup => {
        // Check if player collected it (click)
        const distSq = distanceSquared(mousePos.x - (powerup.x, mousePos.y - (powerup.y, camera.x), camera.y));
        
        if (distSq < 30 * 30) {
            if (powerup.type === 'money') {
                money += powerup.value;
            } else if (powerup.type === 'health') {
                health = Math.min(100, health + powerup.value);
            }
            updateUI();
            
            // Collection effect
            for (let i = 0; i < 10; i++) {
                particlePool.get(powerup.x, powerup.y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 5, powerup.type === 'money' ? '#ffd700' : '#ff0000', 1, 5);
            }
            
            return false;
        }
        
        return true;
    });
}

// Cached background
let cachedBackground = null;
let cachedBackgroundCanvas = null;

// Draw background
function drawBackground() {
    if (performanceMode) {
        // Simple solid background in performance mode
        ctx.fillStyle = '#0a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else {
        // Cache the background for better performance
        if (!cachedBackgroundCanvas || cachedBackgroundCanvas.width !== canvas.width) {
            cachedBackgroundCanvas = document.createElement('canvas');
            cachedBackgroundCanvas.width = canvas.width;
            cachedBackgroundCanvas.height = canvas.height;
            const cacheCtx = cachedBackgroundCanvas.getContext('2d');
            
            const gradient = cacheCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a2e');
            gradient.addColorStop(0.5, '#000511');
            gradient.addColorStop(1, '#1a0033');
            cacheCtx.fillStyle = gradient;
            cacheCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars
            cacheCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137) % canvas.width;
                const y = (i * 91) % canvas.height;
                const size = (i % 3) * 0.5 + 0.5;
                cacheCtx.beginPath();
                cacheCtx.arc(x, y, size, 0, Math.PI * 2);
                cacheCtx.fill();
            }
        }
        
        // Draw cached background
        ctx.drawImage(cachedBackgroundCanvas, 0, 0);
    }
}

// Draw grid
function drawGrid() {
    if (performanceMode) {
        // Skip grid in performance mode
        return;
    }
    
    ctx.strokeStyle = 'rgba(100, 100, 150, 0.1)';
    ctx.lineWidth = 1;
    
    const gridSize = 50;
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
    }
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
    }
    ctx.stroke();
}

// Draw path with directional indicators
function drawPath() {
    const scale = getScaleFactor();
    
    // Glowing path outline
    ctxSaveCount++; ctx.save();
    ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
    ctx.shadowBlur = 20 * scale;
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 45 * scale;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.stroke();
    ctxSaveCount--; ctx.restore();
    
    // Path border
    ctx.strokeStyle = '#2a5570';
    ctx.lineWidth = 36 * scale;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // Main path surface with brighter gradient
    const pathGradient = ctx.createLinearGradient(
        path[0].x - camera.x, path[0].y - camera.y,
        base.x - camera.x, base.y - camera.y
    );
    pathGradient.addColorStop(0, '#506080');
    pathGradient.addColorStop(0.5, '#405070');
    pathGradient.addColorStop(1, '#354560');
    ctx.strokeStyle = pathGradient;
    ctx.lineWidth = 32 * scale;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // Path center line for extra definition
    ctx.strokeStyle = 'rgba(150, 200, 255, 0.2)';
    ctx.lineWidth = 2 * scale;
    ctx.stroke();
    
    // Directional texture - subtle arrows in the center of the path
    ctxSaveCount++; ctx.save();
    const arrowSpacing = 60;
    const animOffset = (Date.now() * 0.03) % arrowSpacing;
    
    // Create clipping path for arrows
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.lineWidth = 25 * scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    ctx.clip();
    
    // Draw directional arrows along the path
    for (let i = 0; i < path.length - 1; i++) {
        const current = path[i];
        const next = path[i + 1];
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        const numArrows = Math.floor(distance / arrowSpacing);
        
        for (let j = 0; j <= numArrows; j++) {
            const progress = j / Math.max(1, numArrows);
            const arrowX = current.x + dx * progress - camera.x;
            const arrowY = current.y + dy * progress - camera.y;
            
            // Calculate opacity based on animation
            const localOffset = (j * arrowSpacing - animOffset + arrowSpacing) % arrowSpacing;
            const opacity = 0.3 + (1 - localOffset / arrowSpacing) * 0.4;
            
            ctxSaveCount++; ctx.save();
            ctx.translate(arrowX, arrowY);
            ctx.rotate(angle);
            
            // Draw glowing arrow
            ctx.strokeStyle = `rgba(150, 220, 255, ${opacity})`;
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(0, 0);
            ctx.lineTo(-10, 5);
            ctx.stroke();
            
            ctxSaveCount--; ctx.restore();
        }
    }
    
    // Draw arrows for final segment to base
    const lastPath = path[path.length - 1];
    const baseX = base.x + base.width/2;
    const baseY = base.y + base.height/2;
    const dx = baseX - lastPath.x;
    const dy = baseY - lastPath.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    
    const numArrows = Math.floor(distance / arrowSpacing);
    for (let j = 0; j <= numArrows; j++) {
        const progress = j / Math.max(1, numArrows);
        const arrowX = lastPath.x + dx * progress - camera.x;
        const arrowY = lastPath.y + dy * progress - camera.y;
        
        const localOffset = (j * arrowSpacing - animOffset + arrowSpacing) % arrowSpacing;
        const opacity = 0.1 + (1 - localOffset / arrowSpacing) * 0.15;
        
        ctxSaveCount++; ctx.save();
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        
        ctx.beginPath();
        ctx.moveTo(-8, -4);
        ctx.lineTo(0, 0);
        ctx.lineTo(-8, 4);
        ctx.stroke();
        
        ctxSaveCount--; ctx.restore();
    }
    
    ctxSaveCount--; ctx.restore();
    
    // Path surface texture - subtle dots
    ctxSaveCount++; ctx.save();
    ctx.globalAlpha = 0.08;
    
    // Create clipping path
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.lineWidth = 28 * scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    ctx.clip();
    
    // Draw dot pattern
    ctx.fillStyle = '#ffffff';
    for (let x = 0; x < canvas.width; x += 8) {
        for (let y = 0; y < canvas.height; y += 8) {
            if ((x + y) % 16 === 0) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    ctxSaveCount--; ctx.restore();
    
    // Path highlights on edges
    ctxSaveCount++; ctx.save();
    ctx.globalAlpha = 0.1;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.setLineDash([20, 20]);
    ctx.beginPath();
    ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
    }
    ctx.lineTo(base.x + base.width/2 - camera.x, base.y + base.height/2 - camera.y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctxSaveCount--; ctx.restore();
}

// Draw base with enhanced animation
function drawBase() {
    const x = base.x - camera.x;
    const y = base.y - camera.y;
    
    base.energyAnimation += 0.03 * gameSpeed;
    base.shieldPulse += 0.025 * gameSpeed;
    base.coreRotation += 0.015 * gameSpeed;
    
    // Update orbital rings
    base.orbitalRings.forEach(ring => {
        ring.rotation += ring.speed * gameSpeed;
    });
    
    // Outer energy field with pulsing effect
    const pulseSize = 120 + Math.sin(base.energyAnimation) * 15;
    const fieldGradient = ctx.createRadialGradient(
        x + base.width/2, y + base.height/2, 0,
        x + base.width/2, y + base.height/2, pulseSize
    );
    fieldGradient.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
    fieldGradient.addColorStop(0.3, 'rgba(138, 43, 226, 0.08)');
    fieldGradient.addColorStop(0.6, 'rgba(255, 20, 147, 0.05)');
    fieldGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = fieldGradient;
    ctx.fillRect(x - 100, y - 100, base.width + 200, base.height + 200);
    
    // Draw orbital rings
    ctxSaveCount++; ctx.save();
    ctx.translate(x + base.width/2, y + base.height/2);
    
    base.orbitalRings.forEach((ring, i) => {
        ctxSaveCount++; ctx.save();
        ctx.rotate(ring.rotation);
        
        // Ring gradient
        const ringGradient = ctx.createLinearGradient(-ring.radius, 0, ring.radius, 0);
        ringGradient.addColorStop(0, 'transparent');
        ringGradient.addColorStop(0.4, ring.color);
        ringGradient.addColorStop(0.6, ring.color);
        ringGradient.addColorStop(1, 'transparent');
        
        ctx.strokeStyle = ringGradient;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7 + Math.sin(base.energyAnimation + i) * 0.3;
        
        // Draw ring with perspective
        ctx.beginPath();
        ctx.ellipse(0, 0, ring.radius, ring.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Energy nodes on rings
        for (let j = 0; j < 4; j++) {
            const angle = (j / 4) * Math.PI * 2;
            const nodeX = Math.cos(angle) * ring.radius;
            const nodeY = Math.sin(angle) * ring.radius * 0.4;
            
            const nodeGradient = ctx.createRadialGradient(nodeX, nodeY, 0, nodeX, nodeY, 6);
            nodeGradient.addColorStop(0, '#ffffff');
            nodeGradient.addColorStop(0.5, ring.color);
            nodeGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = nodeGradient;
            ctx.beginPath();
            ctx.arc(nodeX, nodeY, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctxSaveCount--; ctx.restore();
    });
    
    ctxSaveCount--; ctx.restore();
    
    // Base platform with hexagonal design
    ctxSaveCount++; ctx.save();
    ctx.translate(x + base.width/2, y + base.height/2);
    
    // Hexagonal platform
    ctx.fillStyle = 'rgba(10, 10, 30, 0.9)';
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const hx = Math.cos(angle) * 50;
        const hy = Math.sin(angle) * 50;
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
    }
    ctx.closePath();
    ctx.fill();
    
    // Platform edges with gradient
    const edgeGradient = ctx.createLinearGradient(-50, -50, 50, 50);
    edgeGradient.addColorStop(0, '#8a2be2');
    edgeGradient.addColorStop(0.5, '#ff1493');
    edgeGradient.addColorStop(1, '#00ffff');
    ctx.strokeStyle = edgeGradient;
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Inner hexagon
    ctx.fillStyle = 'rgba(20, 20, 50, 0.8)';
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const hx = Math.cos(angle) * 35;
        const hy = Math.sin(angle) * 35;
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
    }
    ctx.closePath();
    ctx.fill();
    
    // Central core with multiple layers
    const coreSize = 25 + Math.sin(base.energyAnimation * 2) * 3;
    
    // Outer core glow
    const outerCoreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize + 10);
    outerCoreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    outerCoreGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
    outerCoreGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
    ctx.fillStyle = outerCoreGradient;
    ctx.beginPath();
    ctx.arc(0, 0, coreSize + 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Main core
    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);
    coreGradient.addColorStop(0, '#ffffff');
    coreGradient.addColorStop(0.3, '#00ffff');
    coreGradient.addColorStop(0.6, '#ff1493');
    coreGradient.addColorStop(1, '#8a2be2');
    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner core pulse
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.7 + Math.sin(base.energyAnimation * 3) * 0.3;
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Energy beams from core to hexagon vertices
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
        if (Math.sin(base.energyAnimation * 2 + i) > 0.5) {
            const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
            const hx = Math.cos(angle) * 50;
            const hy = Math.sin(angle) * 50;
            
            const beamGradient = ctx.createLinearGradient(0, 0, hx, hy);
            beamGradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            beamGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.3)');
            beamGradient.addColorStop(1, 'rgba(0, 255, 255, 0.1)');
            ctx.strokeStyle = beamGradient;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(hx, hy);
            ctx.stroke();
        }
    }
    
    ctxSaveCount--; ctx.restore();
    
    // Shield effect
    const shieldSize = 70 + Math.sin(base.shieldPulse) * 5;
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 10]);
    ctx.beginPath();
    ctx.arc(x + base.width/2, y + base.height/2, shieldSize, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Base name with enhanced glow
    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 18px Orbitron';
    ctx.textAlign = 'center';
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#00ffff';
    ctx.fillText(base.name, x + base.width/2, y - 20);
    
    // Subtitle
    ctx.font = '12px Orbitron';
    ctx.fillStyle = '#ff1493';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ff1493';
    ctx.fillText('QUANTUM DEFENSE MATRIX', x + base.width/2, y - 5);
    ctx.shadowBlur = 0;
    
    // Health bar
    const healthPercent = health / 100;
    const barWidth = base.width + 20;
    const barHeight = 8;
    const barY = y - 10;
    const barX = x - 10;
    
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' :
                     healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
    
    ctx.strokeStyle = '#8a2be2';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barWidth, barHeight);
    
    // Floating energy particles around base
    for (let i = 0; i < 8; i++) {
        const angle = (base.energyAnimation * 0.5 + i * Math.PI / 4) % (Math.PI * 2);
        const radius = 80 + Math.sin(base.energyAnimation + i) * 10;
        const px = x + base.width/2 + Math.cos(angle) * radius;
        const py = y + base.height/2 + Math.sin(angle) * radius;
        
        const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, 5);
        particleGradient.addColorStop(0, '#ffffff');
        particleGradient.addColorStop(0.5, '#00ffff');
        particleGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = particleGradient;
        ctx.globalAlpha = 0.6 + Math.sin(base.energyAnimation * 2 + i) * 0.4;
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// Draw projectiles
function drawProjectiles() {
    projectiles.forEach(proj => {
        // Trail
        if (proj.trail.length > 1) {
            ctx.strokeStyle = proj.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.moveTo(proj.trail[0].x - camera.x, proj.trail[0].y - camera.y);
            for (let i = 1; i < proj.trail.length; i++) {
                ctx.lineTo(proj.trail[i].x - camera.x, proj.trail[i].y - camera.y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        // Projectile
        ctx.fillStyle = proj.color;
        ctx.beginPath();
        ctx.arc(proj.x - camera.x, proj.y - camera.y, 5, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Draw particles (optimized)
function drawParticles() {
    if (performanceMode && particles.length > maxParticles / 2) {
        // Skip every other particle in performance mode
        for (let i = 0; i < particles.length; i += 2) {
            const particle = particles[i];
            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            ctx.fillRect(
                particle.x - camera.x - particle.size/2, 
                particle.y - camera.y - particle.size/2, 
                particle.size, 
                particle.size
            );
        }
    } else {
        // Batch particles by color to reduce state changes
        const particlesByColor = {};
        particles.forEach(particle => {
            if (!particlesByColor[particle.color]) {
                particlesByColor[particle.color] = [];
            }
            particlesByColor[particle.color].push(particle);
        });
        
        for (const color in particlesByColor) {
            ctx.fillStyle = color;
            particlesByColor[color].forEach(particle => {
                ctx.globalAlpha = particle.life;
                if (performanceMode) {
                    // Use rectangles instead of circles for better performance
                    ctx.fillRect(
                        particle.x - camera.x - particle.size/2, 
                        particle.y - camera.y - particle.size/2, 
                        particle.size, 
                        particle.size
                    );
                } else {
                    ctx.beginPath();
                    ctx.arc(particle.x - camera.x, particle.y - camera.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    ctx.globalAlpha = 1;
}

// Draw beams
function drawBeams() {
    beams.forEach(beam => {
        ctx.globalAlpha = beam.life / 10;
        
        if (beam.type === 'lightning') {
            ctx.strokeStyle = beam.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(beam.from.x - camera.x, beam.from.y - camera.y);
            
            // Jagged lightning
            const segments = 5;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const x = beam.from.x + (beam.to.x - beam.from.x) * t + (Math.random() - 0.5) * 20;
                const y = beam.from.y + (beam.to.y - beam.from.y) * t + (Math.random() - 0.5) * 20;
                ctx.lineTo(x - camera.x, y - camera.y);
            }
            
            ctx.lineTo(beam.to.x - camera.x, beam.to.y - camera.y);
            ctx.stroke();
        } else if (beam.type === 'laser') {
            const gradient = gradientCache.getLinearGradient(ctx, 
                beam.from.x - camera.x, beam.from.y - camera.y,
                beam.to.x - camera.x, beam.to.y - camera.y
            , [
            gradient.addColorStop(0, beam.color);
            gradient.addColorStop(0.5, '#ffffff');
            gradient.addColorStop(1, beam.color);
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(beam.from.x - camera.x, beam.from.y - camera.y);
            ctx.lineTo(beam.to.x - camera.x, beam.to.y - camera.y);
            ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
    });
}

// Draw boss health bars at top of screen
function drawBossHealthBars() {
    // Find all boss enemies
    const bosses = enemies.filter(enemy => 
        enemy.type === 'boss' || 
        enemy.type === 'megaBoss' || 
        enemy.type === 'finalBoss'
    );
    
    if (bosses.length === 0) return;
    
    // Draw each boss health bar
    bosses.forEach((boss, index) => {
        const barWidth = canvas.width * 0.6;
        const barHeight = 30;
        const barX = (canvas.width - barWidth) / 2;
        const barY = 10 + (index * 40); // Stack multiple boss bars
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
        
        // Health bar background
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health bar
        const healthPercent = boss.health / boss.maxHealth;
        const gradient = gradientCache.getLinearGradient(ctx, barX, barY, barX + barWidth * healthPercent, barY, [
        
        if (boss.type === 'finalBoss') {
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(0.5, '#ff00ff');
            gradient.addColorStop(1, '#ffaa00');
        } else if (boss.type === 'megaBoss') {
            gradient.addColorStop(0, '#ff0066');
            gradient.addColorStop(1, '#ff3399');
        } else {
            gradient.addColorStop(0, '#cc0000');
            gradient.addColorStop(1, '#ff0000');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Animated shine effect
        const shineX = barX + (Date.now() % 2000) / 2000 * barWidth;
        const shineGrad = ctx.createLinearGradient(shineX - 20, barY, shineX + 20, barY);
        shineGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
        shineGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
        shineGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = shineGrad;
        ctx.fillRect(shineX - 20, barY, 40, barHeight);
        
        // Border
        ctx.strokeStyle = boss.type === 'finalBoss' ? '#ff00ff' : '#ff0000';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Boss name and health text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let bossName = 'BOSS';
        if (boss.type === 'finalBoss') bossName = '‚ò†Ô∏è FINAL BOSS ‚ò†Ô∏è';
        else if (boss.type === 'megaBoss') bossName = 'üíÄ MEGA BOSS üíÄ';
        
        ctx.fillText(bossName, canvas.width / 2, barY + barHeight / 2);
        
        // Health numbers
        ctx.font = '12px Orbitron';
        ctx.fillText(`${Math.floor(boss.health)} / ${boss.maxHealth}`, canvas.width / 2, barY + barHeight + 12);
    });
}

// Draw power-ups
function drawPowerups() {
    powerups.forEach(powerup => {
        const x = powerup.x - camera.x;
        const y = powerup.y - camera.y;
        
        ctxSaveCount++; ctx.save();
        ctx.translate(x, y);
        
        // Glow effect
        const gradient = gradientCache.getRadialGradient(ctx, 0, 0, 0, 0, 0, 30, [
        gradient.addColorStop(0, powerup.type === 'money' ? 'rgba(255,215,0,0.3)' : 'rgba(255,0,0,0.3)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(-30, -30, 60, 60);
        
        // Power-up body
        ctx.fillStyle = powerup.type === 'money' ? '#ffd700' : '#ff0000';
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Icon
        ctx.fillStyle = '#000';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(powerup.type === 'money' ? 'üí∞' : '‚ù§Ô∏è', 0, 0);
        
        ctxSaveCount--; ctx.restore();
    });
}

// Update UI
function updateUI() {
    // Check if DOM is ready
    if (!document.getElementById('money')) {
        console.log('UI not ready yet');
        return;
    }
    
    document.getElementById('money').textContent = money;
    document.getElementById('health').textContent = health;
    document.getElementById('level').textContent = level;
    document.getElementById('score').textContent = score;
    document.getElementById('themeName').textContent = 'Grassland';
    
    if (enemiesSpawning || enemies.length > 0) {
        document.getElementById('waveStatus').style.display = 'flex';
        document.getElementById('currentWave').textContent = currentWave;
        document.getElementById('totalWaves').textContent = totalWaves;
        document.getElementById('enemyCount').textContent = enemies.length;
    } else {
        document.getElementById('waveStatus').style.display = 'none';
    }
    
    // Check achievements
    if (money >= 1000 && !achievements.money1000.unlocked) {
        unlockAchievement('money1000');
    }
    
    if (towers.length >= 10 && !achievements.towerMaster.unlocked) {
        unlockAchievement('towerMaster');
    }
    
    // Update tower info
    if (selectedTower) {
        document.getElementById('towerInfo').style.display = 'block';
        document.getElementById('towerName').innerHTML = `${selectedTower.stats.name} <span style="color: ${selectedTower.stats.color};">‚óè</span>`;
        document.getElementById('towerLevel').textContent = selectedTower.level + (selectedTower.level >= 10 ? ' (MAX)' : '');
        document.getElementById('towerDamage').textContent = Math.floor(selectedTower.stats.damage);
        document.getElementById('towerRange').textContent = Math.floor(selectedTower.stats.range);
        
        const fireRate = selectedTower.stats.fireRate;
        let fireRateText = 'Slow';
        if (fireRate < 300) fireRateText = 'Very Fast';
        else if (fireRate < 600) fireRateText = 'Fast';
        else if (fireRate < 1000) fireRateText = 'Medium';
        document.getElementById('towerFireRate').textContent = fireRateText;
        
        document.getElementById('towerKills').textContent = selectedTower.kills;
        document.getElementById('towerSpec').textContent = selectedTower.specialization ?
            (selectedTower.specialization === 'power' ? 'Power' :
             selectedTower.specialization === 'speed' ? 'Speed' :
             selectedTower.specialization === 'effect' ? 'Effect' :
             selectedTower.specialization === 'special' ? 'Effect' : 'None') : 'None';
        
        // Update target priority buttons
        document.querySelectorAll('.target-option').forEach(option => {
            if (option.dataset.priority === selectedTower.targetPriority) {
                option.classList.add('active');
            } else {
                option.classList.remove('active');
            }
        });
        
        // Update upgrade button with range increase info
        const upgradeCost = selectedTower.getUpgradeCost();
        const upgradeBtn = document.getElementById('upgradeBtn');
        if (upgradeCost > 0) {
            const currentRange = Math.floor(selectedTower.stats.range);
            const nextRange = Math.floor(selectedTower.stats.range * 1.03);
            const rangeIncrease = nextRange > currentRange ? ` (+${nextRange - currentRange} range)` : '';
            upgradeBtn.innerHTML = `‚¨ÜÔ∏è UPGRADE (üí∞${upgradeCost})${rangeIncrease}`;
            upgradeBtn.disabled = money < upgradeCost;
        } else {
            upgradeBtn.textContent = '‚ú® MAX LEVEL';
            upgradeBtn.disabled = true;
        }
        
        // Show specialization buttons at level 5
        if (selectedTower.level >= 5 && !selectedTower.specialization) {
            document.getElementById('specButtons').style.display = 'flex';
        } else {
            document.getElementById('specButtons').style.display = 'none';
        }
        
        // Update sell button
        const sellValue = Math.floor(selectedTower.stats.cost * 0.7 * selectedTower.level);
        document.getElementById('sellBtn').textContent = `üí∞ SELL FOR ${sellValue}`;
    } else {
        document.getElementById('towerInfo').style.display = 'none';
    }
    
    // Update tower availability
    const towerOptions = document.querySelectorAll('.towerOption');
    if (towerOptions.length > 0) {
        towerOptions.forEach(option => {
            const type = option.dataset.type;
            if (type && towerTypes[type]) {
                if (money < towerTypes[type].cost) {
                    option.classList.add('disabled');
                } else {
                    option.classList.remove('disabled');
                }
            }
        });
    }
    
    if (health <= 0) {
        gameOver();
    }
}

// Unlock achievement
function unlockAchievement(id) {
    achievements[id].unlocked = true;
    const popup = document.getElementById('achievementPopup');
    document.getElementById('achievementText').textContent = achievements[id].desc;
    popup.classList.add('show');
    setTimeout(() => popup.classList.remove('show'), 3000);
}

// Set tower targeting
function setTowerTargeting(priority) {
    if (selectedTower) {
        selectedTower.targetPriority = priority;
        updateUI();
    }
}

// Specialize tower
function specializeTower(type) {
    if (selectedTower) {
        selectedTower.specialize(type);
        updateUI();
    }
}

// Toggle wave preview
function toggleWavePreview() {
    wavePreviewShown = !wavePreviewShown;
    const preview = document.getElementById('wavePreview');
    
    if (wavePreviewShown) {
        preview.style.display = 'block';
        updateWavePreview();
    } else {
        preview.style.display = 'none';
    }
}

// Update wave preview
function updateWavePreview() {
    const content = document.getElementById('waveContent');
    content.innerHTML = '';
    
    const levelInfo = levelData[Math.min(level - 1, levelData.length - 1)];
    
    levelInfo.enemies.forEach(group => {
        const enemyDiv = document.createElement('div');
        enemyDiv.className = 'wave-enemy';
        
        const iconDiv = document.createElement('div');
        iconDiv.className = 'wave-enemy-icon';
        iconDiv.style.backgroundColor = enemyTypes[group.type].color;
        iconDiv.textContent = group.type[0].toUpperCase();
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'wave-enemy-info';
        infoDiv.innerHTML = `
            <div class="wave-enemy-name">${group.type.charAt(0).toUpperCase() + group.type.slice(1)}</div>
            <div class="wave-enemy-count">x${group.count} ‚Ä¢ HP: ${enemyTypes[group.type].health}</div>
        `;
        
        enemyDiv.appendChild(iconDiv);
        enemyDiv.appendChild(infoDiv);
        content.appendChild(enemyDiv);
    });
}

// Upgrade tower
function upgradeTower() {
    if (selectedTower && selectedTower.upgrade()) {
        updateUI();
    }
}

// Select tower type for placement
function selectTowerType(type) {
    if (money >= towerTypes[type].cost) {
        selectedTowerType = type;
        placingTower = true;
        document.getElementById('towerModal').style.display = 'none';
        canvas.style.cursor = 'crosshair';
    }
}

// Sell tower
function sellTower() {
    if (challengeMode) {
        showNotification('‚ùå Cannot sell towers in Challenge Mode!');
        return;
    }
    
    if (selectedTower) {
        const refund = Math.floor(selectedTower.stats.cost * 0.7 * selectedTower.level);
        money += refund;
        towers = towers.filter(t => t !== selectedTower);
        
        // Recalculate synergies for remaining towers
        towers.forEach(tower => tower.checkSynergies());
        
        // Sell effect
        for (let i = 0; i < 20; i++) {
            particlePool.get(selectedTower.x, selectedTower.y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 5, '#ffd700', 1, 5);
        }
        
        selectedTower = null;
        updateUI();
    }
}

// Pause/Resume game
function togglePause() {
    isPaused = !isPaused;
    const pauseBtn = document.getElementById('pauseBtn');
    pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    if (!isPaused) {
        requestAnimationFrame(gameLoop); // Resume game loop
    }
}

// Set game speed
function cycleGameSpeed() {
    if (gameSpeed === 1) {
        gameSpeed = 2;
    } else if (gameSpeed === 2) {
        gameSpeed = 3;
    } else if (gameSpeed === 3) {
        gameSpeed = 4;
    } else if (gameSpeed === 4) {
        gameSpeed = 5;
    } else {
        gameSpeed = 1;
    }
    document.getElementById('speedBtn').textContent = `‚ö° ${gameSpeed}x Speed`;
    
    // Change button color based on speed
    const btn = document.getElementById('speedBtn');
    if (gameSpeed === 1) {
        btn.style.background = 'linear-gradient(135deg, #8a2be2 0%, #ff1493 100%)';
    } else if (gameSpeed === 2) {
        btn.style.background = 'linear-gradient(135deg, #00ff00 0%, #00aa00 100%)';
    } else if (gameSpeed === 3) {
        btn.style.background = 'linear-gradient(135deg, #ffaa00 0%, #ff6600 100%)';
    } else if (gameSpeed === 4) {
        btn.style.background = 'linear-gradient(135deg, #ff4444 0%, #cc0000 100%)';
    } else {
        btn.style.background = 'linear-gradient(135deg, #ff00ff 0%, #ff0066 100%)';
    }
}

// Level selection for testing
function selectLevel(selectedLevel) {
    if (!selectedLevel) return;
    
    const levelNum = parseInt(selectedLevel);
    if (levelNum > 0 && levelNum <= levelData.length) {
        level = levelNum;
        money = 400 + (levelNum - 1) * 100; // Give more money for higher levels
        score = levelNum * 1000;
        
        // Change path layout based on selected level
        const newLayout = getPathLayoutForLevel(level);
        if (newLayout !== currentPathLayout) {
            changePathLayout(newLayout);
        }
        
        document.getElementById('startLevel').textContent = `‚ñ∂Ô∏è Start Level ${level}`;
        updateUI();
        showNotification(`üìç Jumped to Level ${level}`);
    }
    
    // Reset dropdown
    document.getElementById('levelSelect').value = '';
}

// Game mode selection functions
function startSinglePlayer() {
    isCoOpMode = false;
    document.getElementById('gameModeSelect').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('coopIndicator').style.display = 'none';
    document.getElementById('player2Cursor').style.display = 'none';
    initGame();
}

function startCoOp() {
    isCoOpMode = true;
    document.getElementById('gameModeSelect').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('coopIndicator').style.display = 'block';
    document.getElementById('player2Cursor').style.display = 'block';
    initGame();
    
    // Initialize player 2 controls
    setupPlayer2Controls();
}

function startChallenge() {
    challengeMode = true;
    challengeWave = 0;
    challengeLives = 3;
    health = 3; // Only 3 lives in challenge mode
    money = 600; // Start with more money but can't sell
    document.getElementById('gameModeSelect').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('coopIndicator').style.display = 'none';
    document.getElementById('player2Cursor').style.display = 'none';
    
    // Show challenge mode indicator
    showNotification('üî• CHALLENGE MODE: No selling ‚Ä¢ 3 lives ‚Ä¢ Endless waves');
    
    initGame();
    
    // Auto-start first wave after delay
    setTimeout(() => {
        if (challengeMode) {
            startChallengeWave();
        }
    }, 3000);
}

function startChallengeWave() {
    if (!challengeMode) return;
    
    challengeWave++;
    currentWave = challengeWave;
    totalWaves = '‚àû'; // Infinite waves
    enemiesSpawning = true;
    
    showNotification(`üî• Challenge Wave ${challengeWave}`);
    
    // Calculate enemies for this wave
    const baseEnemies = 5 + challengeWave * 2;
    const enemyPool = [];
    
    // Add basic enemies
    for (let i = 0; i < Math.min(baseEnemies, 10); i++) {
        enemyPool.push('slime');
    }
    
    // Add harder enemies as waves progress
    if (challengeWave >= 3) {
        for (let i = 0; i < Math.floor(challengeWave / 3); i++) {
            enemyPool.push('drone');
        }
    }
    
    if (challengeWave >= 5) {
        for (let i = 0; i < Math.floor(challengeWave / 5); i++) {
            enemyPool.push('tank');
        }
    }
    
    if (challengeWave >= 10) {
        for (let i = 0; i < Math.floor(challengeWave / 10); i++) {
            enemyPool.push('destroyer');
        }
    }
    
    // Boss every 5 waves
    if (challengeWave % 5 === 0) {
        enemyPool.push(challengeWave % 10 === 0 ? 'megaBoss' : 'eliteTank');
    }
    
    // Final boss every 20 waves
    if (challengeWave % 20 === 0) {
        enemyPool.push('finalBoss');
    }
    
    enemiesRemaining = enemyPool.length;
    
    // Spawn enemies with delay
    let spawnIndex = 0;
    const spawnInterval = setInterval(() => {
        if (spawnIndex < enemyPool.length) {
            const enemy = new Enemy(enemyPool[spawnIndex]);
            // Scale health and reward based on wave
            enemy.health *= 1 + (challengeWave * 0.1);
            enemy.maxHealth = enemy.health;
            enemy.reward = Math.floor(enemy.reward * (1 + challengeWave * 0.05));
            enemies.push(enemy);
            spawnIndex++;
        } else {
            clearInterval(spawnInterval);
            enemiesSpawning = false;
        }
    }, Math.max(1200 - Math.min(challengeWave * 20, 800), 400)); // Increased spacing, minimum 400ms between enemies
}

function viewLeaderboard() {
    showLeaderboard();
}

function showInGameLeaderboard() {
    showLeaderboard();
}

function showLeaderboard() {
    loadLeaderboard();
    document.getElementById('leaderboardModal').style.display = 'flex';
    
    const content = document.getElementById('leaderboardContent');
    content.innerHTML = '';
    
    if (leaderboard.length === 0) {
        content.innerHTML = '<p style="color: #aaa; text-align: center;">No high scores yet!</p>';
        return;
    }
    
    // Sort leaderboard by score
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Display top 10 scores
    const topScores = leaderboard.slice(0, 10);
    topScores.forEach((entry, index) => {
        const div = document.createElement('div');
        div.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.1); border-radius: 10px; font-size: 18px;';
        
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
        
        div.innerHTML = `
            <div style="display: flex; align-items: center; gap: 15px;">
                <span style="font-size: 24px;">${medal}</span>
                <span style="color: #fff;">${entry.name}</span>
            </div>
            <div style="text-align: right;">
                <div style="color: #ffd700; font-size: 20px; font-weight: bold;">${entry.score.toLocaleString()}</div>
                <div style="color: #aaa; font-size: 14px;">Level ${entry.level} ‚Ä¢ ${entry.mode}</div>
            </div>
        `;
        
        content.appendChild(div);
    });
}

function closeLeaderboard() {
    document.getElementById('leaderboardModal').style.display = 'none';
}

function loadLeaderboard() {
    const saved = localStorage.getItem('ultrapremium_leaderboard');
    if (saved) {
        leaderboard = JSON.parse(saved);
    }
}

function saveLeaderboard() {
    localStorage.setItem('ultrapremium_leaderboard', JSON.stringify(leaderboard));
}

function addToLeaderboard(name, score, level) {
    const entry = {
        name: name,
        score: score,
        level: level,
        mode: isCoOpMode ? 'Co-Op' : 'Single',
        date: new Date().toISOString()
    };
    
    leaderboard.push(entry);
    saveLeaderboard();
}

// Player 2 controls for co-op mode
function setupPlayer2Controls() {
    document.addEventListener('keydown', (e) => {
        if (!isCoOpMode) return;
        player2Keys[e.key.toLowerCase()] = true;
        
        // Space to place tower
        if (e.key === ' ' && placingTower) {
            e.preventDefault();
            const gridX = Math.floor(player2Cursor.x / gridSize) * gridSize + gridSize/2;
            const gridY = Math.floor(player2Cursor.y / gridSize) * gridSize + gridSize/2;
            
            if (canPlaceTower(gridX, gridY)) {
                placeTowerAt(gridX, gridY, selectedTowerType);
            }
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (!isCoOpMode) return;
        player2Keys[e.key.toLowerCase()] = false;
    });
}

function updatePlayer2Cursor() {
    if (!isCoOpMode) return;
    
    const speed = 8;
    if (player2Keys['w']) player2Cursor.y -= speed;
    if (player2Keys['s']) player2Cursor.y += speed;
    if (player2Keys['a']) player2Cursor.x -= speed;
    if (player2Keys['d']) player2Cursor.x += speed;
    
    // Keep cursor on screen
    player2Cursor.x = Math.max(0, Math.min(canvas.width, player2Cursor.x));
    player2Cursor.y = Math.max(0, Math.min(canvas.height, player2Cursor.y));
    
    // Update cursor position on screen
    const cursorElement = document.getElementById('player2Cursor');
    if (cursorElement) {
        cursorElement.style.left = player2Cursor.x + 'px';
        cursorElement.style.top = (player2Cursor.y + document.getElementById('ui').offsetHeight) + 'px';
    }
}

function canPlaceTower(x, y) {
    const gridX = Math.floor(x / gridSize) * gridSize + gridSize/2;
    const gridY = Math.floor(y / gridSize) * gridSize + gridSize/2;
    
    // Check if position is on path
    for (let i = 0; i < path.length - 1; i++) {
        const dist = pointToLineDistance(
            gridX, gridY,
            path[i].x, path[i].y,
            path[i+1].x, path[i+1].y
        );
        if (dist < gridSize) return false;
    }
    
    // Check if position overlaps with existing towers
    for (let tower of towers) {
        const distSq = distanceSquared(tower.x, tower.y, gridX, gridY);
        if (dist < gridSize) return false;
    }
    
    // Check enemy spawn and base
    const spawnDistSq = distanceSquared(
        Math.pow(gridX - path[0].x, 2) + 
        Math.pow(gridY - path[0].y, 2)
    );
    const baseDistSq = distanceSquared(
        Math.pow(gridX - path[path.length-1].x, 2) + 
        Math.pow(gridY - path[path.length-1].y, 2)
    );
    if (spawnDist < 100 || baseDist < 100) return false;
    
    return true;
}

function placeTowerAt(x, y, towerType) {
    if (!towerType || !towerTypes[towerType]) return;
    
    const cost = towerTypes[towerType].cost;
    if (money >= cost && canPlaceTower(x, y)) {
        money -= cost;
        const newTower = new Tower(towerType, x, y);
        towers.push(newTower);
        
        // Check synergies for all towers
        towers.forEach(tower => tower.checkSynergies());
        
        updateUI();
        
        // Placement effect
        for (let i = 0; i < 10; i++) {
            particlePool.get(x, y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, towerTypes[towerType].color, 1, 5);
        }
        
        // Placement sound effect placeholder
        // playSound('towerPlace');
    }
}

// Toggle auto-start
function toggleAutoStart() {
    autoStartEnabled = document.getElementById('autoStartCheck').checked;
}

// Start next level
function startNextLevel() {
    if (level < levelData.length) {
        level++;
        
        // Change path layout every 5 levels
        const newLayout = getPathLayoutForLevel(level);
        if (newLayout !== currentPathLayout) {
            changePathLayout(newLayout);
        }
        
        levelActive = true;
        spawnLevel();
        updateUI();
    }
}

// Determine which path layout to use based on level
function getPathLayoutForLevel(level) {
    if (level <= 5) return 'serpentine';
    else if (level <= 10) return 'figure8';
    else if (level <= 15) return 'zigzag';
    else if (level <= 20) return 'diamond';
    else if (level <= 25) return 'spiral';
    // Loop back through paths for higher levels
    else {
        const pathCycle = ['serpentine', 'figure8', 'zigzag', 'diamond', 'spiral'];
        const index = Math.floor((level - 1) / 5) % pathCycle.length;
        return pathCycle[index];
    }
}

// Change path layout while preserving towers
function changePathLayout(newLayout) {
    // Store current towers
    const savedTowers = towers.map(tower => ({
        type: tower.type,
        x: tower.x,
        y: tower.y,
        level: tower.level,
        kills: tower.kills,
        specialization: tower.specialization
    }));
    
    // Change layout
    currentPathLayout = newLayout;
    originalPath = pathLayouts[currentPathLayout];
    path = scalePath();
    
    // Update base position for new path
    updateBasePosition();
    
    // Show transition effect
    showPathTransition(newLayout);
    
    // Validate tower positions and adjust if needed
    towers = [];
    savedTowers.forEach(savedTower => {
        // Check if tower position is still valid (not on new path)
        let validPosition = true;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i + 1];
            const dist = distanceToLineSegment(savedTower.x, savedTower.y, p1, p2);
            if (distSq < 45 * 45) {
                validPosition = false;
                break;
            }
        }
        
        // Check distance from new base position
        const baseDistSq = distanceSquared(
            Math.pow(savedTower.x - (base.x + base.width/2), 2) +
            Math.pow(savedTower.y - (base.y + base.height/2), 2)
        );
        if (baseDist < 100) validPosition = false;
        
        if (validPosition) {
            // Recreate tower at same position
            const tower = new Tower(savedTower.type, savedTower.x, savedTower.y);
            tower.level = savedTower.level;
            tower.kills = savedTower.kills;
            tower.specialization = savedTower.specialization;
            
            // Recalculate stats based on level
            for (let i = 1; i < tower.level; i++) {
                const upgradeType = towerTypes[tower.type];
                if (upgradeType.upgrades.damage) {
                    tower.stats.damage = Math.min(
                        upgradeType.upgrades.damage.base + upgradeType.upgrades.damage.perLevel * i,
                        upgradeType.upgrades.damage.max || Infinity
                    );
                }
                if (upgradeType.upgrades.range) {
                    tower.stats.range = Math.min(
                        upgradeType.upgrades.range.base + upgradeType.upgrades.range.perLevel * i,
                        upgradeType.upgrades.range.max || Infinity
                    );
                }
                if (upgradeType.upgrades.fireRate) {
                    tower.stats.fireRate = Math.max(
                        upgradeType.upgrades.fireRate.base + upgradeType.upgrades.fireRate.perLevel * i,
                        upgradeType.upgrades.fireRate.min || 0
                    );
                }
            }
            
            towers.push(tower);
        } else {
            // Tower is on new path, refund it
            money += Math.floor(towerTypes[savedTower.type].cost * 0.8 * savedTower.level);
            showNotification(`Tower refunded due to path change: +üí∞ ${Math.floor(towerTypes[savedTower.type].cost * 0.8 * savedTower.level)}`);
        }
    });
}

// Show path transition animation
function showPathTransition(newLayout) {
    const notification = document.createElement('div');
    notification.id = 'pathTransition';
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.95) 0%, rgba(255, 20, 147, 0.95) 100%);
        padding: 30px 60px;
        border-radius: 30px;
        font-size: 36px;
        font-weight: 900;
        color: white;
        box-shadow: 0 20px 60px rgba(138, 43, 226, 1), inset 0 2px 20px rgba(255,255,255,0.3);
        text-align: center;
        z-index: 2000;
        border: 3px solid rgba(255,255,255,0.3);
        animation: pathPop 0.6s ease-out;
    `;
    
    const layoutNames = {
        spiral: 'Spiral Path',
        zigzag: 'Zigzag Highway',
        cross: 'Cross Roads',
        maze: 'The Maze',
        highway: 'Speed Highway'
    };
    
    notification.innerHTML = `
        <div style="font-size: 20px; margin-bottom: 10px;">PATH CHANGE!</div>
        <div>${layoutNames[newLayout]}</div>
        <div style="font-size: 16px; margin-top: 10px;">Towers preserved!</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'fadeOut 0.5s ease-out';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 500);
    }, 2000);
}

// Show notification for events
function showNotification(message) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        font-size: 16px;
        z-index: 1500;
        animation: slideInRight 0.3s ease-out;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// Add screen shake effect
function addScreenShake(intensity) {
    screenShake = Math.max(screenShake, intensity);
}

// Restart game
function restartGame() {
    // Reset game state
    money = 400;
    health = 100;
    level = 1;
    score = 0;
    enemies = [];
    towers = [];
    projectiles = [];
    particles = [];
    beams = [];
    powerups = [];
    levelActive = false;
    selectedTowerType = null;
    placingTower = false;
    selectedTower = null;
    currentWave = 0;
    totalWaves = 1;
    totalKills = 0;
    enemiesSpawning = false;
    enemiesRemaining = 0;
    waveCountdown = 0;
    
    // Hide game over screen
    document.getElementById('gameOver').style.display = 'none';
    
    // Reset UI
    document.getElementById('startLevel').textContent = '‚ñ∂Ô∏è Start Level 1';
    document.getElementById('startLevel').disabled = false;
    updateUI();
}

// Game over
function gameOver() {
    document.getElementById('gameOver').style.display = 'block';
    document.getElementById('finalScore').textContent = score;
    document.getElementById('bestWave').textContent = challengeMode ? challengeWave : level;
    document.getElementById('totalKills').textContent = totalKills;
    levelActive = false;
    enemiesSpawning = false;
    
    if (challengeMode) {
        showNotification(`üî• Challenge Mode: Reached Wave ${challengeWave}!`);
    }
    
    // Check if score qualifies for leaderboard
    loadLeaderboard();
    const qualifies = leaderboard.length < 10 || score > Math.min(...leaderboard.map(e => e.score));
    
    if (qualifies) {
        setTimeout(() => {
            const name = prompt('New High Score! Enter your name for the leaderboard:') || 'Anonymous';
            addToLeaderboard(name, score, level);
            showLeaderboard();
        }, 1000);
    }
}

// Spawn level
function spawnLevel() {
    const levelInfo = levelData[Math.min(level - 1, levelData.length - 1)];
    currentWave = 0;
    totalWaves = levelInfo.waves;
    
    const healthBeforeWave = health;
    
    spawnWave(levelInfo);
}

// Spawn wave
function spawnWave(levelInfo) {
    currentWave++;
    enemiesSpawning = true;
    
    let totalEnemies = 0;
    let spawnDelay = 0;
    
    const enemySpawns = [];
    levelInfo.enemies.forEach(enemyGroup => {
        for (let i = 0; i < enemyGroup.count; i++) {
            enemySpawns.push({
                type: enemyGroup.type,
                delay: spawnDelay
            });
            spawnDelay += 600; // Faster spawn rate for longer path
        }
        totalEnemies += enemyGroup.count;
    });
    
    enemiesRemaining = totalEnemies;
    
    enemySpawns.forEach(spawn => {
        setTimeout(() => {
            if (levelActive && health > 0) {
                const enemy = new Enemy(spawn.type);
                enemies.push(enemy);
                enemiesRemaining--;
                
                if (enemiesRemaining === 0) {
                    enemiesSpawning = false;
                    
                    if (currentWave < totalWaves) {
                        // Wait for current wave to be cleared before spawning next
                        const checkForNextWave = setInterval(() => {
                            if (enemies.length === 0 && levelActive && health > 0) {
                                clearInterval(checkForNextWave);
                                setTimeout(() => {
                                    if (levelActive && health > 0) {
                                        spawnWave(levelInfo);
                                    }
                                }, 2000);
                            }
                        }, 100);
                    }
                }
            } else {
                enemiesRemaining--;
                if (enemiesRemaining === 0) {
                    enemiesSpawning = false;
                }
            }
        }, spawn.delay);
    });
}

// Check level complete
function checkLevelComplete() {
    // Challenge mode wave complete
    if (challengeMode && !enemiesSpawning && enemies.length === 0) {
        const waveBonus = 50 * challengeWave;
        money += waveBonus;
        score += waveBonus * 2;
        updateUI();
        
        showNotification(`Wave ${challengeWave} Complete! +üí∞${waveBonus}`);
        
        // Auto-start next wave after delay
        setTimeout(() => {
            if (challengeMode && health > 0) {
                startChallengeWave();
            }
        }, 3000);
        return;
    }
    
    if (levelActive && !enemiesSpawning && enemies.length === 0 && currentWave >= totalWaves) {
        levelActive = false;
        const reward = 100 + level * 50;
        money += reward;
        score += reward;
        updateUI();
        
        if (level === 10 && !achievements.wave10.unlocked) {
            unlockAchievement('wave10');
        }
        
        // Level complete notification
        const levelInfo = document.getElementById('levelInfo');
        levelInfo.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 10px;">LEVEL ${level} COMPLETE!</div>
            <div style="font-size: 24px; color: #ffd700;">+${reward} üí∞</div>
        `;
        levelInfo.style.display = 'block';
        
        setTimeout(() => {
            levelInfo.style.display = 'none';
            level++;
            updateUI();
            
            const maxLevel = levelData.length;
            
            if (level > maxLevel) {
                // Game complete!
                document.getElementById('startLevel').textContent = 'üèÜ Game Complete!';
                document.getElementById('startLevel').disabled = true;
            } else {
                document.getElementById('startLevel').textContent = `‚ñ∂Ô∏è Start Level ${level}`;
                document.getElementById('startLevel').disabled = false;
                
                // Start countdown if auto-start is enabled
                if (autoStartEnabled) {
                    waveCountdown = 300; // 5 seconds at 60 FPS
                }
            }
        }, 3000);
    }
}

// Performance settings
let performanceMode = false;
let targetFPS = 60;
let lastFrameTime = 0;
let frameCount = 0;
let ctxSaveCount = 0;
let fps = 60;
let lastFPSUpdate = 0;
let maxParticles = 500;
let particleQuality = 1.0;

// Optimized particle creation
function addParticle(x, y, vx, vy, color, life, size) {
    // Limit total particles
    if (particles.length >= maxParticles) {
        // Remove oldest particle
        particles.shift();
    }
    
    // Skip some particles in performance mode
    if (performanceMode && Math.random() > particleQuality) {
        return;
    }
    
    particlePool.get(x, y, vx, vy, color, life, size);
}

// Toggle performance mode
function togglePerformanceMode() {
    performanceMode = !performanceMode;
    const perfBtn = document.getElementById('perfBtn');
    
    if (performanceMode) {
        targetFPS = 30; // Lower FPS for better performance
        maxParticles = 200; // Fewer particles
        particleQuality = 0.5; // Skip half the particles
        perfBtn.textContent = 'üîã Eco';
        perfBtn.style.background = 'linear-gradient(135deg, #00ff00, #00aa00)';
        showNotification('üîã Performance Mode ON - Better performance, reduced effects');
    } else {
        targetFPS = 60; // Full FPS
        maxParticles = 500; // Normal particles
        particleQuality = 1.0; // All particles
        perfBtn.textContent = 'üöÄ Perf';
        perfBtn.style.background = '';
        showNotification('üöÄ Performance Mode OFF - Full visual quality');
    }
}

// Main game loop


// ========== APP STORE FEATURES ==========

function updateCurrencyDisplay() {
    document.getElementById('goldAmount').textContent = formatNumber(money);
    document.getElementById('gemAmount').textContent = formatNumber(playerData.gems);
    document.getElementById('ticketAmount').textContent = formatNumber(playerData.tickets);
    document.getElementById('bpLevel').textContent = playerData.battlePassLevel;
}

function formatNumber(num) {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
}

function checkDailyRewards() {
    if (gameSystems && gameSystems.dailyRewards) {
        const reward = gameSystems.dailyRewards.checkDailyLogin();
        if (reward) {
            showDailyRewardPopup(reward);
            document.getElementById('dailyDot').classList.add('active');
        }
    }
}

function showDailyRewardPopup(reward) {
    // Create popup HTML
    const popup = document.createElement('div');
    popup.className = 'lootbox-popup';
    popup.style.display = 'block';
    popup.innerHTML = `
        <h2 style="color: #FFD700; text-align: center;">Daily Reward!</h2>
        <p style="color: white; text-align: center;">Login Streak: ${reward.streak} days</p>
        <div style="text-align: center; margin: 20px 0;">
            <div style="font-size: 48px;">üéÅ</div>
            <div style="color: white; margin-top: 10px;">
                <div>üí∞ ${reward.gold} Gold</div>
                <div>üíé ${reward.gems} Gems</div>
                <div>üéüÔ∏è ${reward.tickets} Tickets</div>
            </div>
        </div>
        <button onclick="claimDailyReward(this)" style="width: 100%;">Claim</button>
    `;
    document.body.appendChild(popup);
    
    // Apply rewards
    money += reward.gold;
    playerData.gems += reward.gems;
    playerData.tickets += reward.tickets;
    updateCurrencyDisplay();
}

function claimDailyReward(button) {
    button.parentElement.style.display = 'none';
    document.getElementById('dailyDot').classList.remove('active');
}

function showAchievement(title, description, reward) {
    const notification = document.createElement('div');
    notification.className = 'achievement-notification';
    notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 15px;">
            <div style="font-size: 40px;">üèÜ</div>
            <div>
                <div style="font-weight: bold; font-size: 18px;">${title}</div>
                <div style="font-size: 14px; color: #333;">${description}</div>
                <div style="margin-top: 5px; font-weight: bold;">+${reward} üíé</div>
            </div>
        </div>
    `;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 100);
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 500);
    }, 5000);
}

function openGemShop() {
    // Implementation for gem shop
    console.log('Opening gem shop...');
}

function openBattlePass() {
    // Implementation for battle pass
    console.log('Opening battle pass...');
}

function showDailyRewards() {
    // Implementation for daily rewards screen
    console.log('Showing daily rewards...');
}

function initializeSocialFeatures() {
    // Initialize Game Center / Google Play Games
    if (window.webkit && window.webkit.messageHandlers) {
        // iOS Game Center
        window.webkit.messageHandlers.gameCenter.postMessage('authenticate');
    }
}

// Add XP and level progression
function addPlayerXP(amount) {
    if (gameSystems && gameSystems.progression) {
        gameSystems.progression.addXP(amount);
        playerData.level = gameSystems.progression.playerLevel;
        playerData.xp = gameSystems.progression.playerXP;
    }
}

// Hook into existing game events
const originalEnemyDeath = Enemy.prototype.die;
Enemy.prototype.die = function() {
    originalEnemyDeath.call(this);
    
    // Add XP for kill
    addPlayerXP(this.xp || 1);
    
    // Check achievements
    if (totalKills === 1) {
        showAchievement('First Blood!', 'Defeat your first enemy', 5);
        playerData.gems += 5;
    } else if (totalKills === 100) {
        showAchievement('Centurion', 'Defeat 100 enemies', 10);
        playerData.gems += 10;
    } else if (totalKills === 1000) {
        showAchievement('Exterminator', 'Defeat 1000 enemies', 25);
        playerData.gems += 25;
    }
    
    updateCurrencyDisplay();
};

// Enhanced tower selection with rarity
const TOWER_RARITIES = {
    pulse: 'common',
    laser: 'common',
    missile: 'rare',
    tesla: 'rare',
    plasma: 'epic',
    railgun: 'epic',
    quantum: 'legendary',
    void: 'legendary',
    crystal: 'mythic',
    omega: 'mythic'
};

// Add tower card collection
let towerCollection = new Set(['pulse', 'laser']); // Start with basic towers

function unlockTower(towerType) {
    if (!towerCollection.has(towerType)) {
        towerCollection.add(towerType);
        showAchievement('New Tower Unlocked!', `${towerType} tower is now available`, 20);
        playerData.gems += 20;
        updateCurrencyDisplay();
    }
}

// Loot box system
function openLootBox(rarity = 'common') {
    if (gameSystems && gameSystems.lootBox) {
        const items = gameSystems.lootBox.openLootBox(rarity);
        showLootBoxAnimation(items);
    }
}

function showLootBoxAnimation(items) {
    // Create loot box animation
    console.log('Loot box items:', items);
}

// Auto-save with cloud sync
function saveToCloud() {
    const saveData = {
        player: playerData,
        game: {
            money: money,
            wave: currentWave,
            score: score,
            towers: towers.map(t => ({ type: t.type, x: t.x, y: t.y, level: t.level }))
        },
        collection: Array.from(towerCollection),
        achievements: gameSystems ? gameSystems.progression.achievements : {}
    };
    
    localStorage.setItem('ultraTDSave', JSON.stringify(saveData));
    
    // Sync to cloud (Game Center / Google Play)
    if (window.webkit && window.webkit.messageHandlers) {
        window.webkit.messageHandlers.cloudSave.postMessage(saveData);
    }
}

// Load from cloud
function loadFromCloud() {
    const saveData = localStorage.getItem('ultraTDSave');
    if (saveData) {
        const data = JSON.parse(saveData);
        playerData = data.player;
        money = data.game.money;
        currentWave = data.game.wave;
        score = data.game.score;
        towerCollection = new Set(data.collection);
        updateCurrencyDisplay();
    }
}

// Auto-save every 30 seconds
setInterval(saveToCloud, 30000);

// Load on start
loadFromCloud();

function gameLoop(currentTime) {
    // Frame throttling for performance
    if (fps < frameSkipThreshold && skipFrames++ % 2 === 0) {
        requestAnimationFrame(gameLoop);
        return;
    }
    
    // Check if canvas and ctx are initialized
    if (!canvas || !ctx) {
        console.error('Canvas or context not initialized in gameLoop');
        return;
    }
    
    // Frame rate limiting
    if (!currentTime) currentTime = performance.now();
    const deltaTime = currentTime - lastFrameTime;
    const targetFrameTime = 1000 / targetFPS;
    
    if (deltaTime < targetFrameTime) {
        requestAnimationFrame(gameLoop);
        return;
    }
    
    lastFrameTime = currentTime - (deltaTime % targetFrameTime);
    
    // FPS counter
    frameCount++;
    if (currentTime - lastFPSUpdate >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFPSUpdate = currentTime;
        
        // Update FPS display
        const fpsElement = document.getElementById('fps');
        if (fpsElement) {
            fpsElement.textContent = `${fps} FPS`;
            // Color code based on performance
            if (fps >= 55) {
                fpsElement.style.color = '#00ff00';
            } else if (fps >= 30) {
                fpsElement.style.color = '#ffff00';
            } else {
                fpsElement.style.color = '#ff0000';
            }
        }
    }
    
    // Handle pause
    if (isPaused) {
        // Draw pause overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 48px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
        requestAnimationFrame(gameLoop);
        return; // Don't continue game loop
    }
    
    try {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Check if game is initialized
        if (!path || path.length === 0) {
            // Try to initialize path
            if (originalPath && originalPath.length > 0) {
                path = scalePath();
                updateBasePosition();
            } else {
                // Still not ready, show loading
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Initializing game...', canvas.width/2, canvas.height/2);
            }
            
            requestAnimationFrame(gameLoop);
            return;
        }
        
        // Handle screen shake
        if (screenShake > 0) {
            shakeX = (Math.random() - 0.5) * screenShake;
            shakeY = (Math.random() - 0.5) * screenShake;
            ctxSaveCount++; ctx.save();
            ctx.translate(shakeX, shakeY);
            screenShake *= 0.9; // Decay shake
            if (screenShake < 0.1) screenShake = 0;
        }
        
        // Draw background
        drawBackground();
        drawGrid();
        drawPath();
        drawBase();
        

        // Update spatial grid for enemies
        enemySpatialGrid.clear();
        enemies.forEach(enemy => {
            if (!enemy.inTunnel) {
                enemySpatialGrid.add(enemy, enemy.position.x, enemy.position.y);
            }
        });
        
        // Update and draw towers (combined loop)
        for (let i = 0; i < towers.length; i++) { const tower = towers[i];
            tower.update();
            tower.draw();
        };
        
        // Update and draw enemies
        enemies = enemies.filter(enemy => {
            const reachedBase = enemy.update();
            if (!reachedBase) {
                enemy.draw();
                return true;
            }
            return false;
        });
        
        // Update and draw projectiles
        updateProjectiles();
        drawProjectiles();
        
        // Update and draw other elements
        updateParticles();
        drawParticles();
        updateBeams();
        drawBeams();
        updatePowerups();
        drawPowerups();
        
        // Draw boss health bars
        drawBossHealthBars();
        
        // Update player 2 cursor in co-op mode
        updatePlayer2Cursor();
        
        // Tower placement preview
        if (placingTower && selectedTowerType) {
            const worldX = mousePos.x + camera.x;
            const worldY = mousePos.y + camera.y;
            
            // Check if position is valid
            let validPosition = true;
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                const dist = distanceToLineSegment(worldX, worldY, p1, p2);
                if (distSq < 45 * 45) { // Adjusted for narrower path
                    validPosition = false;
                    break;
                }
            }
            
            // Check distance from base
            const baseDistSq = distanceSquared(
                Math.pow(worldX - (base.x + base.width/2), 2) +
                Math.pow(worldY - (base.y + base.height/2), 2)
            );
            if (baseDist < 100) validPosition = false;
            
            // Check distance from other towers
            for (let tower of towers) {
                const towerDistSq = distanceSquared(
                    Math.pow(worldX - tower.x, 2) +
                    Math.pow(worldY - tower.y, 2)
                );
                if (towerDist < 60) {
                    validPosition = false;
                    break;
                }
            }
            
            // Draw range preview
            ctxSaveCount++; ctx.save();
            ctx.strokeStyle = validPosition ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(mousePos.x, mousePos.y, towerTypes[selectedTowerType].range * getScaleFactor(), 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctxSaveCount--; ctx.restore();
            
            // Draw tower preview
            ctx.globalAlpha = validPosition ? 0.7 : 0.3;
            const ghost = new Tower(selectedTowerType, worldX, worldY);
            ghost.draw();
            ctx.globalAlpha = 1;
            
            // Show cost
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            
            if (!validPosition) {
                ctx.fillStyle = '#ff0000';
                ctx.fillText('INVALID POSITION', mousePos.x, mousePos.y - 60);
            } else {
                ctx.fillStyle = money >= towerTypes[selectedTowerType].cost ? '#00ff00' : '#ff0000';
                ctx.fillText(`üí∞ ${towerTypes[selectedTowerType].cost}`, mousePos.x, mousePos.y - 60);
            }
        }
        
        // Check level complete
        checkLevelComplete();
        
        // Draw countdown if auto-starting
        if (waveCountdown > 0 && !levelActive) {
            ctxSaveCount++; ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
            
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 36px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`Next wave in: ${Math.ceil(waveCountdown / 60)}`, canvas.width/2, canvas.height/2);
            ctxSaveCount--; ctx.restore();
            
            waveCountdown -= gameSpeed;
            if (waveCountdown <= 0) {
                document.getElementById('startLevel').click();
            }
        }
        
        // Update UI
        updateUI();
        
        // Restore context if shake was applied
        if (screenShake > 0) {
            ctxSaveCount--; ctx.restore();
        }
        
    } catch (error) {
        console.error('Game loop error:', error);
        console.error('Error stack:', error.stack);
        
        // Try to draw something simple to show canvas is working
        ctx.fillStyle = 'yellow';
        ctx.font = '20px Arial';
        ctx.fillText('Error in game loop! Check console.', 50, 50);
    }
    
    requestAnimationFrame(gameLoop);
}

// Helper function for distance to line segment
function distanceToLineSegment(px, py, p1, p2) {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / (dx * dx + dy * dy)));
    const nearestX = p1.x + t * dx;
    const nearestY = p1.y + t * dy;
    return Math.sqrt(Math.pow(px - nearestX, 2) + Math.pow(py - nearestY, 2));
}

// Event listeners
// Function to handle pointer position updates
function updatePointerPosition(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    mousePos.x = clientX - rect.left;
    mousePos.y = clientY - rect.top;
}

// Setup event listeners
function setupEventListeners() {
    if (!canvas) {
        console.error('Canvas not initialized for event listeners');
        return;
    }
    
    // Mouse events
    canvas.addEventListener('mousemove', (e) => {
    updatePointerPosition(e.clientX, e.clientY);
    
    const worldX = mousePos.x + camera.x;
    const worldY = mousePos.y + camera.y;
    
    hoveredTower = null;
    if (!placingTower) {
        for (let tower of towers) {
            const distSq = distanceSquared(worldX, worldY, tower.x, tower.y);
            if (distSq < 40 * 40) {
                hoveredTower = tower;
                canvas.style.cursor = 'pointer';
                break;
            }
        }
        
        if (!hoveredTower) {
            // Check for power-ups
            let hoveringPowerup = false;
            for (let powerup of powerups) {
                const distSq = distanceSquared(worldX, worldY, powerup.x, powerup.y);
                if (distSq < 30 * 30) {
                    canvas.style.cursor = 'pointer';
                    hoveringPowerup = true;
                    break;
                }
            }
            
            if (!hoveringPowerup) {
                canvas.style.cursor = 'crosshair';
            }
        }
    }
    
    // Update faint range indicators for nearby towers
    for (let tower of towers) {
        const screenX = tower.x - camera.x;
        const screenY = tower.y - camera.y;
        const mouseDistSq = distanceSquared(
            Math.pow(screenX - mousePos.x, 2) +
            Math.pow(screenY - mousePos.y, 2)
        );
        tower.showFaintRange = mouseDist < 100 && tower !== selectedTower && tower !== hoveredTower;
    }
});

// Touch events for iOS
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        const touch = e.touches[0];
        updatePointerPosition(touch.clientX, touch.clientY);
        handleCanvasClick();
    }
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
        const touch = e.touches[0];
        updatePointerPosition(touch.clientX, touch.clientY);
    }
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
});

// Function to handle canvas clicks/taps
function handleCanvasClick() {
    const worldX = mousePos.x + camera.x;
    const worldY = mousePos.y + camera.y;
    
    // Quick sell mode with shift
    if (shiftPressed) {
        for (let tower of towers) {
            const distSq = distanceSquared(tower.x, tower.y, worldX, worldY);
            if (distSq < 40 * 40) {
                selectedTower = tower;
                sellTower();
                return;
            }
        }
    }
    
    // Check for power-up collection
    for (let i = powerups.length - 1; i >= 0; i--) {
        const powerup = powerups[i];
        const distSq = distanceSquared(worldX, worldY, powerup.x, powerup.y);
        if (distSq < 30 * 30) {
            if (powerup.type === 'money') {
                money += powerup.value;
            } else if (powerup.type === 'health') {
                health = Math.min(100, health + powerup.value);
            }
            updateUI();
            
            // Collection effect
            for (let j = 0; j < 10; j++) {
                particlePool.get(powerup.x, powerup.y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 5, powerup.type === 'money' ? '#ffd700' : '#ff0000', 1, 5);
            }
            
            powerups.splice(i, 1);
            return;
        }
    }
    
    if (placingTower && selectedTowerType) {
        // Check if position is valid
        let validPosition = true;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i + 1];
            const dist = distanceToLineSegment(worldX, worldY, p1, p2);
            if (distSq < 45 * 45) { // Adjusted for narrower path
                validPosition = false;
                break;
            }
        }
        
        // Check distance from base
        const baseDistSq = distanceSquared(
            Math.pow(worldX - (base.x + base.width/2), 2) +
            Math.pow(worldY - (base.y + base.height/2), 2)
        );
        if (baseDist < 100) validPosition = false;
        
        // Check distance from other towers
        for (let tower of towers) {
            const towerDistSq = distanceSquared(
                Math.pow(worldX - tower.x, 2) +
                Math.pow(worldY - tower.y, 2)
            );
            if (towerDist < 60) {
                validPosition = false;
                break;
            }
        }
        
        const cost = towerTypes[selectedTowerType].cost;
        if (validPosition && money >= cost) {
            money -= cost;
            const newTower = new Tower(selectedTowerType, worldX, worldY);
            towers.push(newTower);
            
            // Check synergies for all towers
            towers.forEach(tower => tower.checkSynergies());
            
            updateUI();
            
            // Placement effect
            for (let i = 0; i < 10; i++) {
                particlePool.get(worldX, worldY, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, towerTypes[selectedTowerType].color, 1, 5);
            }
            
            placingTower = false;
            selectedTowerType = null;
            canvas.style.cursor = 'crosshair';
        }
    } else if (sellMode) {
        // Sell mode - click tower to sell
        let clickedTower = null;
        for (let tower of towers) {
            const distSq = distanceSquared(worldX, worldY, tower.x, tower.y);
            if (distSq < 40 * 40) {
                clickedTower = tower;
                break;
            }
        }
        
        if (clickedTower) {
            const sellPrice = Math.floor(clickedTower.stats.cost * 0.7);
            money += sellPrice;
            towers = towers.filter(t => t !== clickedTower);
            if (selectedTower === clickedTower) {
                selectedTower = null;
            }
            showNotification(`Tower sold for üí∞${sellPrice}`);
            updateUI();
        }
        sellMode = false;
        canvas.style.cursor = 'default';
    } else if (!placingTower) {
        // Check if clicking on a tower
        let clickedTower = null;
        for (let tower of towers) {
            const distSq = distanceSquared(worldX, worldY, tower.x, tower.y);
            if (distSq < 40 * 40) {
                clickedTower = tower;
                break;
            }
        }
        
        if (clickedTower) {
            // Check if clicking on ability button
            const scale = getScaleFactor();
            const abilityX = clickedTower.x + 30 * scale;
            const abilityY = clickedTower.y - 30 * scale;
            const abilityDistSq = distanceSquared(
                Math.pow(worldX - abilityX, 2) +
                Math.pow(worldY - abilityY, 2)
            );
            
            if (abilityDist < 15 * scale && clickedTower.level >= 5) {
                // Clicked on ability button
                clickedTower.activateAbility();
            } else {
                // Normal tower selection
                selectedTower = clickedTower;
            }
        } else {
            selectedTower = null;
        }
        updateUI();
    }
}

// Mouse click event
canvas.addEventListener('click', (e) => {
    handleCanvasClick();
});

// UI Event listeners
document.getElementById('startLevel').addEventListener('click', function() {
    if (!levelActive) {
        levelActive = true;
        this.disabled = true;
        spawnLevel();
    }
});

document.getElementById('addTowerBtn').addEventListener('click', function() {
    document.getElementById('towerModal').style.display = 'flex';
    selectedTower = null;
    placingTower = false;
    selectedTowerType = null;
    updateUI();
});

document.getElementById('closeTowerModal').addEventListener('click', function() {
    document.getElementById('towerModal').style.display = 'none';
    placingTower = false;
    selectedTowerType = null;
    canvas.style.cursor = 'crosshair';
});

// Speed button click is handled by cycleGameSpeed() in the onclick attribute

document.querySelectorAll('.towerOption').forEach(option => {
    option.addEventListener('click', function() {
        const type = this.dataset.type;
        if (money >= towerTypes[type].cost && !this.classList.contains('disabled')) {
            selectedTowerType = type;
            placingTower = true;
            selectedTower = null;
            document.getElementById('towerModal').style.display = 'none';
            
            document.querySelectorAll('.towerOption').forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
        }
    });
});

// Cancel placement on right click or escape
canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    placingTower = false;
    selectedTowerType = null;
    canvas.style.cursor = 'crosshair';
});

// Shift for sell mode
let shiftPressed = false;

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        placingTower = false;
        selectedTowerType = null;
        selectedTower = null;
        sellMode = false;
        canvas.style.cursor = 'default';
        document.getElementById('towerModal').style.display = 'none';
        updateUI();
    } else if (e.key === 'u' || e.key === 'U') {
        if (selectedTower) {
            upgradeTower();
        }
    } else if (e.key === 's' || e.key === 'S') {
        if (challengeMode) {
            showNotification('‚ùå Cannot sell towers in Challenge Mode!');
        } else if (!placingTower && !selectedTower) {
            // Enter sell mode
            sellMode = true;
            canvas.style.cursor = 'not-allowed';
            showNotification('Sell Mode: Click a tower to sell (ESC to cancel)');
        } else if (selectedTower) {
            sellTower();
        }
    } else if (e.key === 'p' || e.key === 'P') {
        togglePause();
    } else if (e.key === 'a' || e.key === 'A') {
        // Activate tower ability
        if (selectedTower && selectedTower.level >= 5) {
            selectedTower.activateAbility();
        }
    } else if (e.key >= '1' && e.key <= '9') {
        // Tower hotkeys (extended to 9)
        const towerTypeMap = ['pulse', 'laser', 'missile', 'tesla', 'plasma', 'railgun', 'quantum', 'void', 'crystal'];
        const typeIndex = parseInt(e.key) - 1;
        if (typeIndex < towerTypeMap.length) {
            const towerType = towerTypeMap[typeIndex];
            if (money >= towerTypes[towerType].cost) {
                selectedTowerType = towerType;
                placingTower = true;
                canvas.style.cursor = 'crosshair';
                document.getElementById('towerModal').style.display = 'none';
                showNotification(`Placing ${towerTypes[towerType].name} (${e.key})`);
            } else {
                showNotification(`Not enough money for ${towerTypes[towerType].name}`);
            }
        }
    } else if (e.key === 'Shift' && !shiftPressed) {
        shiftPressed = true;
        canvas.style.cursor = 'pointer';
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key === 'Shift') {
        shiftPressed = false;
        canvas.style.cursor = placingTower ? 'crosshair' : 'default';
    }
});
} // End of setupEventListeners

// Initialize everything when DOM is ready
function initGame() {
    console.log('Initializing game...');
    
    // Load leaderboard data
    loadLeaderboard();
    
    // Initialize canvas
    canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error('Canvas not found!');
        return;
    }
    
    ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('Could not get 2D context!');
        return;
    }
    
    console.log('Canvas and context initialized');
    
    // Set up event listeners
    setupEventListeners();
    
    // Set initial canvas size
    resizeCanvas();
    
    // Add resize listener
    window.addEventListener('resize', resizeCanvas);

    // Initialize scaled elements after canvas is ready
    if (originalPath) {
        path = scalePath();
        updateBasePosition();
    }

    // Make functions globally accessible for onclick handlers
    window.upgradeTower = upgradeTower;
    window.sellTower = sellTower;
    window.selectTowerType = selectTowerType;
    window.specializeTower = specializeTower;
    window.startNextLevel = startNextLevel;
    window.toggleWavePreview = toggleWavePreview;
    window.togglePause = togglePause;
    window.cycleGameSpeed = cycleGameSpeed;
    window.toggleAutoStart = toggleAutoStart;
    window.restartGame = restartGame;
    window.closeLeaderboard = closeLeaderboard;
    window.showInGameLeaderboard = showInGameLeaderboard;
    window.selectLevel = selectLevel;
    
    // Also make canvas and ctx globally accessible
    window.canvas = canvas;
    window.ctx = ctx;

    // Initialize UI
    updateUI();
    
    // Populate level selector for testing
    const levelSelect = document.getElementById('levelSelect');
    if (levelSelect && levelSelect.options.length <= 1) {
        // Add boss levels with special markers
        const bossLevels = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
        for (let i = 1; i <= 50; i++) {
            const option = document.createElement('option');
            option.value = i;
            if (bossLevels.includes(i)) {
                option.textContent = `Level ${i} ‚öîÔ∏è BOSS`;
                option.style.color = '#ff0000';
            } else {
                option.textContent = `Level ${i}`;
            }
            levelSelect.appendChild(option);
        }
    }
    
    // Start game loop
    console.log('Starting game loop...');
    requestAnimationFrame(gameLoop);
}

// Call initGame when page loads
window.addEventListener('load', function() {
    console.log('Window loaded, calling initGame...');
    initGame();
});

// Also try DOMContentLoaded as backup
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded');
    if (!canvas) {
        console.log('Canvas not initialized yet, waiting for window load...');
    }
});
</script>
