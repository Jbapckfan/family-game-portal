<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <title>Tower Defense Ultimate</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        /* ============================================================
           PHASE 1 - COMPLETE CSS
           Tower Defense Ultimate - Production Styles
           ============================================================ */

        /* -------------------- RESET -------------------- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* -------------------- BASE -------------------- */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: #111;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* -------------------- CANVAS -------------------- */
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* -------------------- UI OVERLAY -------------------- */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
            z-index: 10;
        }

        .ui-interactive {
            pointer-events: auto;
        }

        /* -------------------- TOP BAR / HUD -------------------- */
        .hud-top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 48px;
            background: rgba(0, 0, 0, 0.85);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            pointer-events: auto;
            z-index: 20;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding-left: max(16px, env(safe-area-inset-left));
            padding-right: max(16px, env(safe-area-inset-right));
            padding-top: env(safe-area-inset-top);
        }

        .hud-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .hud-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .hud-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .hud-stat .icon {
            font-size: 16px;
        }

        .hud-stat.gold .value {
            color: #feca57;
        }

        .hud-stat.lives .value {
            color: #e94560;
        }

        .hud-stat.wave .value {
            color: #3498db;
        }

        .hud-stat.stars .value {
            color: #feca57;
        }

        .hud-speed-btn {
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .hud-speed-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .hud-speed-btn:active {
            transform: scale(0.94);
        }

        .hud-speed-btn.active {
            background: rgba(254, 202, 87, 0.25);
            border-color: #feca57;
            color: #feca57;
        }

        .hud-pause-btn {
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .hud-pause-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .hud-pause-btn:active {
            transform: scale(0.94);
        }

        /* -------------------- RIGHT SIDEBAR / TOWER PANEL -------------------- */
        .tower-panel {
            position: absolute;
            top: 48px;
            right: 0;
            width: 280px;
            height: calc(100% - 48px - 56px);
            background: rgba(0, 0, 0, 0.85);
            border-left: 1px solid rgba(255, 255, 255, 0.08);
            overflow-y: auto;
            overflow-x: hidden;
            pointer-events: auto;
            z-index: 15;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 12px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.15) transparent;
        }

        .tower-panel::-webkit-scrollbar {
            width: 4px;
        }

        .tower-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .tower-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .tower-panel-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .tower-tier-group {
            margin-bottom: 16px;
        }

        .tower-tier-label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: rgba(255, 255, 255, 0.35);
            margin-bottom: 8px;
        }

        .tower-tier-label.locked {
            color: rgba(255, 255, 255, 0.2);
        }

        /* -------------------- TOWER CARD -------------------- */
        .tower-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.06);
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s, transform 0.1s;
            min-height: 44px;
        }

        .tower-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .tower-card:active {
            transform: scale(0.97);
        }

        .tower-card.selected {
            background: rgba(254, 202, 87, 0.12);
            border-color: rgba(254, 202, 87, 0.4);
            box-shadow: 0 0 12px rgba(254, 202, 87, 0.1);
        }

        .tower-card.locked {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }

        .tower-card.locked:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(255, 255, 255, 0.06);
        }

        .tower-card.cant-afford {
            opacity: 0.5;
        }

        .tower-card-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            flex-shrink: 0;
        }

        .tower-card-info {
            flex: 1;
            min-width: 0;
        }

        .tower-card-name {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tower-card-meta {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.45);
            margin-top: 2px;
        }

        .tower-card-cost {
            font-size: 13px;
            font-weight: 700;
            color: #feca57;
            flex-shrink: 0;
        }

        .tower-card-hotkey {
            font-size: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.25);
            background: rgba(255, 255, 255, 0.06);
            padding: 2px 5px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        /* -------------------- TOWER INFO POPUP -------------------- */
        .tower-info-popup {
            position: absolute;
            width: 260px;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 14px;
            padding: 16px;
            pointer-events: auto;
            z-index: 30;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            animation: fadeIn 0.15s ease-out;
        }

        .tower-info-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .tower-info-icon {
            width: 48px;
            height: 48px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
        }

        .tower-info-name {
            font-size: 16px;
            font-weight: 700;
        }

        .tower-info-level {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.45);
            margin-top: 2px;
        }

        .tower-info-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 14px;
        }

        .tower-info-stat {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tower-info-stat .stat-value {
            color: #fff;
            font-weight: 600;
        }

        .tower-info-buttons {
            display: flex;
            gap: 8px;
        }

        .tower-info-btn {
            flex: 1;
            min-height: 44px;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.15s, transform 0.1s;
        }

        .tower-info-btn:active {
            transform: scale(0.96);
        }

        .tower-info-btn.upgrade {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: #fff;
        }

        .tower-info-btn.upgrade:hover {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .tower-info-btn.upgrade.disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.35);
            cursor: not-allowed;
        }

        .tower-info-btn.sell {
            background: linear-gradient(135deg, #e94560, #c0392b);
            color: #fff;
        }

        .tower-info-btn.sell:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
        }

        /* -------------------- BOTTOM BAR -------------------- */
        .hud-bottom-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: calc(100% - 280px);
            height: 56px;
            background: rgba(0, 0, 0, 0.85);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            pointer-events: auto;
            z-index: 20;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding-bottom: env(safe-area-inset-bottom);
        }

        .wave-preview {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            overflow: hidden;
        }

        .wave-preview-label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: rgba(255, 255, 255, 0.45);
            white-space: nowrap;
        }

        .wave-preview-enemies {
            display: flex;
            gap: 4px;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .wave-preview-enemies::-webkit-scrollbar {
            display: none;
        }

        .wave-preview-enemy {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .wave-preview-enemy.boss {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(233, 69, 96, 0.5);
            font-size: 18px;
        }

        .wave-start-btn {
            min-width: 120px;
            min-height: 44px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #fff;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 0 16px;
            transition: background 0.15s, transform 0.1s;
            flex-shrink: 0;
            margin-left: 12px;
        }

        .wave-start-btn:hover {
            background: linear-gradient(135deg, #2980b9, #2471a3);
        }

        .wave-start-btn:active {
            transform: scale(0.96);
        }

        .wave-start-btn.ready {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            animation: pulse 1.5s infinite;
        }

        .wave-start-btn .timer {
            font-size: 11px;
            font-weight: 600;
            opacity: 0.7;
        }

        /* -------------------- MAP SELECT SCREEN -------------------- */
        .map-select-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 60px 24px 24px;
            pointer-events: auto;
            z-index: 50;
            overflow-y: auto;
        }

        .map-select-title {
            font-size: 32px;
            font-weight: 800;
            color: #feca57;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .map-select-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.45);
            margin-bottom: 32px;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 16px;
            width: 100%;
            max-width: 960px;
        }

        .map-card {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
            min-height: 44px;
        }

        .map-card:hover {
            transform: translateY(-3px);
            border-color: rgba(254, 202, 87, 0.3);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .map-card:active {
            transform: translateY(0) scale(0.98);
        }

        .map-card.locked {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }

        .map-card.locked:hover {
            transform: none;
            border-color: rgba(255, 255, 255, 0.08);
            box-shadow: none;
        }

        .map-card-preview {
            width: 100%;
            height: 120px;
            background: rgba(26, 26, 46, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            position: relative;
        }

        .map-card-lock {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            color: rgba(255, 255, 255, 0.3);
        }

        .map-card-body {
            padding: 12px;
        }

        .map-card-name {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .map-card-difficulty {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.45);
            margin-bottom: 8px;
        }

        .map-card-stars {
            display: flex;
            gap: 4px;
        }

        .map-card-star {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.15);
        }

        .map-card-star.earned {
            color: #feca57;
        }

        .map-card-unlock-req {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 6px;
        }

        .map-select-back {
            margin-top: 24px;
            min-width: 120px;
            min-height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }

        .map-select-back:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* -------------------- MODALS / OVERLAYS -------------------- */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
            animation: fadeIn 0.2s ease-out;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .modal-box {
            background: rgba(15, 15, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 32px;
            min-width: 300px;
            max-width: 420px;
            text-align: center;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.6);
            animation: slideUp 0.25s ease-out;
        }

        .modal-title {
            font-size: 28px;
            font-weight: 800;
            margin-bottom: 8px;
        }

        .modal-title.victory {
            color: #feca57;
        }

        .modal-title.defeat {
            color: #e94560;
        }

        .modal-stars {
            font-size: 36px;
            margin-bottom: 16px;
            letter-spacing: 4px;
        }

        .modal-star {
            color: rgba(255, 255, 255, 0.15);
        }

        .modal-star.earned {
            color: #feca57;
        }

        .modal-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 14px;
        }

        .modal-stat-label {
            color: rgba(255, 255, 255, 0.5);
        }

        .modal-stat-value {
            font-weight: 700;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 24px;
        }

        .modal-btn {
            flex: 1;
            min-height: 48px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s, filter 0.15s;
        }

        .modal-btn:active {
            transform: scale(0.96);
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #feca57, #f39c12);
            color: #1a1a2e;
        }

        .modal-btn.primary:hover {
            filter: brightness(1.1);
        }

        .modal-btn.secondary {
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .modal-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* ---- Pause Menu ---- */
        .pause-menu .modal-title {
            color: #3498db;
        }

        .pause-menu-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 20px;
        }

        .pause-menu-btn {
            min-height: 48px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #fff;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s, transform 0.1s;
        }

        .pause-menu-btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .pause-menu-btn:active {
            transform: scale(0.97);
        }

        .pause-menu-btn.resume {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            border-color: transparent;
        }

        .pause-menu-btn.resume:hover {
            filter: brightness(1.1);
        }

        /* -------------------- HEALTH BARS -------------------- */
        .health-bar {
            position: relative;
            width: 32px;
            height: 4px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            border-radius: 2px;
            background: #2ecc71;
            transition: width 0.15s ease-out;
        }

        .health-bar-fill.medium {
            background: #f39c12;
        }

        .health-bar-fill.low {
            background: #e94560;
        }

        .health-bar.boss {
            width: 48px;
            height: 6px;
            border-radius: 3px;
        }

        .health-bar-shield {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(52, 152, 219, 0.6);
            border-radius: 2px;
        }

        /* -------------------- FLOATING DAMAGE NUMBERS -------------------- */
        .damage-num {
            position: absolute;
            font-size: 14px;
            font-weight: 800;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
            animation: floatUp 0.8s ease-out forwards;
            z-index: 25;
        }

        .damage-num.crit {
            font-size: 20px;
            color: #feca57;
        }

        .damage-num.heal {
            color: #2ecc71;
        }

        .damage-num.gold {
            color: #feca57;
            font-size: 12px;
        }

        /* -------------------- WAVE ANNOUNCEMENT -------------------- */
        .wave-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 35;
            animation: waveAnnounce 2.5s ease-out forwards;
        }

        .wave-announce-text {
            font-size: 52px;
            font-weight: 800;
            color: #feca57;
            text-shadow: 0 0 20px rgba(254, 202, 87, 0.3), 0 4px 8px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .wave-announce-sub {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 8px;
        }

        /* -------------------- BOSS ENTRANCE OVERLAY -------------------- */
        .boss-entrance {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            animation: bossEntrance 3s ease-out forwards;
        }

        .boss-entrance-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(233, 69, 96, 0.2) 0%, transparent 70%);
            animation: pulse 1s infinite;
        }

        .boss-entrance-name {
            font-size: 40px;
            font-weight: 900;
            color: #e94560;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5), 0 4px 12px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 6px;
            z-index: 1;
        }

        .boss-entrance-title {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-top: 8px;
            z-index: 1;
        }

        .boss-health-bar {
            position: absolute;
            top: 52px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            max-width: 80%;
            height: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            pointer-events: none;
            z-index: 25;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #c0392b);
            border-radius: 5px;
            transition: width 0.2s ease-out;
        }

        .boss-health-label {
            position: absolute;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: 700;
            color: rgba(233, 69, 96, 0.8);
            pointer-events: none;
            z-index: 25;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* -------------------- CO-OP CURSOR STYLES -------------------- */
        .coop-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 30;
        }

        .coop-cursor-ring {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid;
            opacity: 0.8;
        }

        .coop-cursor-ring.p1 {
            border-color: #feca57;
        }

        .coop-cursor-ring.p2 {
            border-color: #3498db;
        }

        .coop-cursor-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: 700;
            white-space: nowrap;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .coop-cursor-label.p1 {
            color: #feca57;
        }

        .coop-cursor-label.p2 {
            color: #3498db;
        }

        /* -------------------- TOOLTIP -------------------- */
        .tooltip {
            position: absolute;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 50;
            max-width: 200px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.1s ease-out;
        }

        /* -------------------- ANIMATIONS -------------------- */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-30px) scale(0.8); }
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            25% { transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes bossEntrance {
            0% { opacity: 0; }
            10% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes goldEarn {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #feca57; }
            100% { transform: scale(1); }
        }

        @keyframes lifeLost {
            0% { transform: scale(1); }
            25% { transform: scale(1.2); color: #e94560; }
            100% { transform: scale(1); }
        }

        /* -------------------- REDUCED MOTION -------------------- */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .wave-start-btn.ready {
                animation: none;
            }
        }

        /* -------------------- MOBILE RESPONSIVE -------------------- */
        @media (max-width: 767px) {
            .tower-panel {
                top: auto;
                right: 0;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 120px;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                white-space: nowrap;
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                padding-bottom: max(8px, env(safe-area-inset-bottom));
            }

            .tower-panel-title,
            .tower-tier-group,
            .tower-tier-label {
                display: none;
            }

            .tower-card {
                flex-direction: column;
                width: 72px;
                min-width: 72px;
                padding: 8px 6px;
                text-align: center;
                gap: 4px;
                flex-shrink: 0;
                margin-bottom: 0;
            }

            .tower-card-icon {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }

            .tower-card-info {
                display: none;
            }

            .tower-card-cost {
                font-size: 11px;
            }

            .tower-card-hotkey {
                display: none;
            }

            .hud-bottom-bar {
                width: 100%;
                bottom: 120px;
                height: 48px;
                padding: 0 12px;
            }

            .wave-start-btn {
                min-width: 90px;
                font-size: 12px;
                padding: 0 12px;
            }

            .hud-top-bar {
                padding: 0 10px;
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
            }

            .hud-left {
                gap: 12px;
            }

            .hud-stat {
                font-size: 12px;
            }

            .tower-info-popup {
                width: calc(100% - 24px);
                max-width: 320px;
                left: 50% !important;
                top: auto !important;
                bottom: 130px;
                transform: translateX(-50%);
            }

            .modal-box {
                width: calc(100% - 32px);
                max-width: 380px;
                padding: 24px 20px;
            }

            .modal-title {
                font-size: 24px;
            }

            .wave-announce-text {
                font-size: 36px;
            }

            .map-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: 12px;
            }

            .map-card-preview {
                height: 90px;
            }

            .boss-health-bar {
                width: 200px;
            }
        }

        /* -------------------- SAFE AREA INSETS -------------------- */
        @supports (padding: max(0px)) {
            .hud-top-bar {
                padding-top: max(0px, env(safe-area-inset-top));
                height: calc(48px + env(safe-area-inset-top, 0px));
            }

            .hud-bottom-bar {
                padding-bottom: max(0px, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay (populated dynamically by UIManager in Phase 4) -->
    <div id="ui-overlay"></div>

    <script>
    'use strict';

    // ================================================================
    //  PHASE 1 - CORE ENGINE FOUNDATION
    //  Tower Defense Ultimate
    //
    //  This file contains:
    //    - Constants
    //    - Utility functions
    //    - ObjectPool class
    //    - ScreenShake class
    //    - Canvas & rendering setup
    //    - Input manager
    //    - Game loop (fixed timestep)
    //    - Placeholder GameManager
    //    - Initialization
    //
    //  Later phases will append:
    //    Phase 2 - Maps, pathfinding, enemies
    //    Phase 3 - Towers, projectiles, particles
    //    Phase 4 - UI manager, HUD, menus
    //    Phase 5 - Audio, progression, co-op
    // ================================================================


    // ==================== CONSTANTS ====================

    const GRID_SIZE = 40;                  // pixels per grid cell
    const CANVAS_BG = '#1a1a2e';           // game canvas background
    const FPS_TARGET = 60;                 // target frames per second
    const FIXED_DT = 1000 / FPS_TARGET;   // fixed timestep in ms (~16.67ms)
    const MAX_FRAME_SKIP = 5;             // max update steps per frame
    const STARTING_GOLD = 300;            // initial gold
    const STARTING_LIVES = 20;            // initial lives
    const WAVE_PREP_TIME = 15000;         // 15s between waves
    const EARLY_START_BONUS = 50;         // gold bonus for skipping wave prep
    const MAX_WAVES = 30;                 // waves per map

    // Tower tier unlock thresholds (total stars needed)
    const TIER_UNLOCK = { 1: 0, 2: 5, 3: 15, 4: 30 };

    // Map unlock thresholds (total stars needed; -1 = special unlock)
    const MAP_UNLOCK = [0, 3, 6, 10, 15, 21, 28, -1];

    // Object pool sizes
    const POOL_PROJECTILES = 200;
    const POOL_PARTICLES = 500;
    const POOL_DAMAGE_NUMS = 50;

    // Game states
    const STATE = {
        MENU:       'menu',
        MAP_SELECT: 'mapSelect',
        PLAYING:    'playing',
        PAUSED:     'paused',
        GAME_OVER:  'gameOver',
        VICTORY:    'victory'
    };


    // ==================== UTILITIES ====================

    /**
     * Clamp a value between min and max (inclusive).
     */
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    /**
     * Linear interpolation from a to b by factor t.
     */
    const lerp = (a, b, t) => a + (b - a) * t;

    /**
     * Euclidean distance between two points.
     */
    const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

    /**
     * Angle in radians from point (x1,y1) to (x2,y2).
     */
    const angle = (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1);

    /**
     * Random float in [min, max).
     */
    const randFloat = (min, max) => Math.random() * (max - min) + min;

    /**
     * Random integer in [min, max] (inclusive).
     */
    const randInt = (min, max) => Math.floor(randFloat(min, max + 1));

    /**
     * Random item from an array.
     */
    const randItem = (arr) => arr[randInt(0, arr.length - 1)];

    /**
     * Convert a hex colour string (#rrggbb) to {r, g, b}.
     */
    const hexToRgb = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    };

    /**
     * Build an rgba() string from a hex colour and alpha.
     */
    const rgba = (hex, a) => {
        const c = hexToRgb(hex);
        return `rgba(${c.r},${c.g},${c.b},${a})`;
    };

    /**
     * Easing functions: t is expected in [0, 1].
     */
    const ease = {
        linear:    t => t,
        inQuad:    t => t * t,
        outQuad:   t => t * (2 - t),
        inOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,

        outBack: t => {
            const s = 1.70158;
            return --t * t * ((s + 1) * t + s) + 1;
        },

        outElastic: t => {
            if (t === 0) return 0;
            if (t === 1) return 1;
            return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1;
        },

        outBounce: t => {
            if (t < 1 / 2.75)   return 7.5625 * t * t;
            if (t < 2 / 2.75)   return 7.5625 * (t -= 1.5   / 2.75) * t + 0.75;
            if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25  / 2.75) * t + 0.9375;
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
    };


    // ==================== OBJECT POOL ====================

    /**
     * Generic object pool for frequently created/destroyed objects
     * (projectiles, particles, damage numbers, etc.).
     *
     * Usage:
     *   const pool = new ObjectPool(() => ({x:0,y:0,active:false}), obj => { obj.active=false; }, 100);
     *   const obj = pool.get();   // take from pool (or create new)
     *   pool.release(obj);        // return to pool
     *   pool.forEach(fn);         // iterate active objects (reverse order, safe to release inside)
     */
    class ObjectPool {
        /**
         * @param {Function} createFn  - Factory that returns a new blank object.
         * @param {Function} resetFn   - Called when an object is released (clean up state).
         * @param {number}   initialSize - How many objects to pre-allocate.
         */
        constructor(createFn, resetFn, initialSize) {
            this.createFn = createFn;
            this.resetFn  = resetFn;
            this.pool     = [];
            this.active   = [];

            for (let i = 0; i < initialSize; i++) {
                this.pool.push(this.createFn());
            }
        }

        /**
         * Acquire an object from the pool (or create one if empty).
         */
        get() {
            let obj = this.pool.pop();
            if (!obj) obj = this.createFn();
            this.active.push(obj);
            return obj;
        }

        /**
         * Release an object back into the pool.
         */
        release(obj) {
            const idx = this.active.indexOf(obj);
            if (idx !== -1) {
                this.active.splice(idx, 1);
                this.resetFn(obj);
                this.pool.push(obj);
            }
        }

        /**
         * Release every active object back into the pool.
         */
        releaseAll() {
            while (this.active.length > 0) {
                const obj = this.active.pop();
                this.resetFn(obj);
                this.pool.push(obj);
            }
        }

        /**
         * Iterate active objects in reverse (safe to release inside callback).
         */
        forEach(fn) {
            for (let i = this.active.length - 1; i >= 0; i--) {
                fn(this.active[i], i);
            }
        }

        /** Number of currently active objects. */
        get count() {
            return this.active.length;
        }
    }


    // ==================== SCREEN SHAKE ====================

    /**
     * Camera-shake effect.  Call trigger() to start a shake,
     * then update() each frame.  Read .x / .y to get the current offset.
     */
    class ScreenShake {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.duration  = 0;
            this.intensity = 0;
            this.elapsed   = 0;
        }

        /**
         * Begin (or intensify) a shake.
         * @param {number} intensity - Max pixel offset.
         * @param {number} duration  - Duration in ms.
         */
        trigger(intensity, duration) {
            this.intensity = Math.max(this.intensity, intensity);
            this.duration  = Math.max(this.duration, duration);
            this.elapsed   = 0;
        }

        /**
         * Advance the shake timer and compute new offsets.
         * @param {number} dt - Delta time in ms.
         */
        update(dt) {
            if (this.duration <= 0) return;

            this.elapsed += dt;

            if (this.elapsed >= this.duration) {
                this.x = 0;
                this.y = 0;
                this.duration  = 0;
                this.intensity = 0;
                return;
            }

            const progress = this.elapsed / this.duration;
            const decay    = 1 - progress;
            this.x = (Math.random() * 2 - 1) * this.intensity * decay;
            this.y = (Math.random() * 2 - 1) * this.intensity * decay;
        }
    }


    // ==================== CANVAS SETUP ====================

    const canvas    = document.getElementById('gameCanvas');
    const ctx       = canvas.getContext('2d');
    const uiOverlay = document.getElementById('ui-overlay');

    /** Logical (CSS) dimensions of the canvas. */
    let canvasWidth  = 0;
    let canvasHeight = 0;

    /** Game area dimensions, excluding UI panels. */
    let gameAreaWidth  = 0;
    let gameAreaHeight = 0;

    /** Device pixel ratio for sharp rendering on HiDPI screens. */
    let dpr = 1;

    /** Grid dimensions (how many cells fit in the game area). */
    let gridCols = 0;
    let gridRows = 0;

    /** UI layout dimensions. */
    let sidebarWidth   = 280;
    let topBarHeight   = 48;
    let bottomBarHeight = 56;

    /** Is the viewport narrow enough to trigger mobile layout? */
    let isMobile = false;

    /** User prefers reduced motion? */
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    /**
     * Resize the canvas to fill the window and recalculate layout.
     */
    function resizeCanvas() {
        dpr = window.devicePixelRatio || 1;

        canvasWidth  = window.innerWidth;
        canvasHeight = window.innerHeight;
        isMobile     = canvasWidth < 768;

        // Set the backing store to match physical pixels
        canvas.width  = canvasWidth  * dpr;
        canvas.height = canvasHeight * dpr;
        canvas.style.width  = canvasWidth  + 'px';
        canvas.style.height = canvasHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Adjust layout for mobile
        if (isMobile) {
            sidebarWidth    = 0;
            bottomBarHeight = 120; // taller for horizontal tower strip
        } else {
            sidebarWidth    = 280;
            bottomBarHeight = 56;
        }

        // Compute the playable game area (excluding UI chrome)
        gameAreaWidth  = canvasWidth - sidebarWidth;
        gameAreaHeight = canvasHeight - topBarHeight - bottomBarHeight;
        gridCols = Math.floor(gameAreaWidth  / GRID_SIZE);
        gridRows = Math.floor(gameAreaHeight / GRID_SIZE);

        // If the map renderer has a static cache, rebuild it
        if (game && game.mapRenderer) {
            game.mapRenderer.rebuildCache();
        }
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();


    // ==================== INPUT MANAGER ====================

    /**
     * Centralised input state for mouse, touch, and keyboard.
     *
     *  - Player 1 uses mouse / touch.
     *  - Player 2 (co-op) uses keyboard (WASD / arrows + action keys).
     */
    const input = {
        // ---------- Player 1 (mouse / touch) ----------
        mouse: {
            x: 0,
            y: 0,
            down: false,
            clicked: false,
            rightClicked: false
        },

        // ---------- Player 2 (keyboard) ----------
        keys: {},
        keysJustPressed: {},
        p2Cursor: { x: 400, y: 300, speed: 5 },

        /**
         * Attach all event listeners.  Call once at startup.
         */
        init() {
            // --- Mouse ---
            canvas.addEventListener('mousemove', e => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });

            canvas.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    this.mouse.down    = true;
                    this.mouse.clicked = true;
                }
                if (e.button === 2) {
                    this.mouse.rightClicked = true;
                }
            });

            canvas.addEventListener('mouseup', e => {
                if (e.button === 0) this.mouse.down = false;
            });

            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // --- Touch ---
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.touches[0];
                this.mouse.x = t.clientX;
                this.mouse.y = t.clientY;
                this.mouse.down    = true;
                this.mouse.clicked = true;
            }, { passive: false });

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const t = e.touches[0];
                this.mouse.x = t.clientX;
                this.mouse.y = t.clientY;
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                this.mouse.down = false;
            });

            // --- Keyboard (Player 2) ---
            window.addEventListener('keydown', e => {
                this.keys[e.code] = true;
                this.keysJustPressed[e.code] = true;
            });

            window.addEventListener('keyup', e => {
                this.keys[e.code] = false;
            });
        },

        /**
         * Reset per-frame flags.  Call at the end of each frame.
         */
        endFrame() {
            this.mouse.clicked      = false;
            this.mouse.rightClicked = false;
            this.keysJustPressed    = {};
        },

        /**
         * Move Player 2's cursor based on currently held keys.
         * @param {number} dt - Delta time in ms.
         */
        updateP2Cursor(dt) {
            const spd = this.p2Cursor.speed * (dt / 16.67);
            if (this.keys['KeyW'] || this.keys['ArrowUp'])    this.p2Cursor.y -= spd;
            if (this.keys['KeyS'] || this.keys['ArrowDown'])  this.p2Cursor.y += spd;
            if (this.keys['KeyA'] || this.keys['ArrowLeft'])  this.p2Cursor.x -= spd;
            if (this.keys['KeyD'] || this.keys['ArrowRight']) this.p2Cursor.x += spd;
            this.p2Cursor.x = clamp(this.p2Cursor.x, 0, gameAreaWidth);
            this.p2Cursor.y = clamp(this.p2Cursor.y, topBarHeight, topBarHeight + gameAreaHeight);
        },

        /**
         * Check if Player 2 just pressed an action key.
         * @param {string} action - One of: place, cycleNext, cyclePrev, upgrade, sell, startWave, pause
         * @returns {boolean}
         */
        isP2Action(action) {
            switch (action) {
                case 'place':     return this.keysJustPressed['Space'];
                case 'cycleNext': return this.keysJustPressed['KeyE'];
                case 'cyclePrev': return this.keysJustPressed['KeyQ'];
                case 'upgrade':   return this.keysJustPressed['KeyU'];
                case 'sell':      return this.keysJustPressed['KeyX'];
                case 'startWave': return this.keysJustPressed['KeyR'];
                case 'pause':     return this.keysJustPressed['Escape'] || this.keysJustPressed['KeyP'];
                default:          return false;
            }
        },

        /**
         * Convert screen (CSS) coordinates to grid column/row.
         * @param {number} sx - Screen X.
         * @param {number} sy - Screen Y.
         * @returns {{col: number, row: number}}
         */
        screenToGrid(sx, sy) {
            const gx = Math.floor(sx / GRID_SIZE);
            const gy = Math.floor((sy - topBarHeight) / GRID_SIZE);
            return { col: gx, row: gy };
        },

        /**
         * Convert grid column/row to the centre of that cell in screen coords.
         * @param {number} col
         * @param {number} row
         * @returns {{x: number, y: number}}
         */
        gridToScreen(col, row) {
            return {
                x: col * GRID_SIZE + GRID_SIZE / 2,
                y: topBarHeight + row * GRID_SIZE + GRID_SIZE / 2
            };
        }
    };


    // ==================== GAME LOOP ====================

    /**
     * Fixed-timestep game loop with variable rendering.
     *
     * Physics / logic run at a fixed rate (FIXED_DT ~ 16.67ms) regardless
     * of display refresh rate.  Rendering receives an interpolation alpha
     * so sub-managers can smooth motion between fixed steps.
     */

    let lastTime    = 0;
    let accumulator = 0;
    let frameId     = null;

    function gameLoop(timestamp) {
        frameId = requestAnimationFrame(gameLoop);

        // First frame: just record the time and return
        if (!lastTime) {
            lastTime = timestamp;
            return;
        }

        let delta = timestamp - lastTime;
        lastTime  = timestamp;

        // Cap delta to prevent spiral of death after long pauses / tab-away
        if (delta > FIXED_DT * MAX_FRAME_SKIP) {
            delta = FIXED_DT * MAX_FRAME_SKIP;
        }

        accumulator += delta;

        // Fixed-rate updates
        let steps = 0;
        while (accumulator >= FIXED_DT && steps < MAX_FRAME_SKIP) {
            if (game) game.update(FIXED_DT);
            accumulator -= FIXED_DT;
            steps++;
        }

        // Render with interpolation alpha
        const alpha = accumulator / FIXED_DT;
        if (game) game.render(ctx, alpha);

        // Clear per-frame input flags
        input.endFrame();
    }


    // ================================================================
    // ==                                                            ==
    // ==              P H A S E   2    G A M E   E N T I T I E S  ==
    // ==                                                            ==
    // ==  Tower definitions, Tower class, Enemy definitions,        ==
    // ==  Enemy class, ProjectileManager, ParticleSystem,           ==
    // ==  FireZone, and TowerManager.                               ==
    // ==                                                            ==
    // ================================================================


    // ==================== TOWER DEFINITIONS ====================

    /**
     * Static data for every tower type in the game.
     * Each entry defines base stats, visual info, special ability,
     * and three upgrade tiers (level 0 = base, upgrades 0-2).
     *
     * Tiers determine unlock requirements (see TIER_UNLOCK).
     *   Tier 1  starter towers (arrow, cannon, frost)
     *   Tier 2  mid-game (lightning, mortar, poison)
     *   Tier 3  advanced (laser, tesla, sniper)
     *   Tier 4  endgame (plasma, void, command)
     */
    const TOWER_DEFS = {
        arrow: {
            name: 'Arrow Tower',
            tier: 1,
            cost: 100,
            damage: 15,
            fireRate: 500,
            range: 120,
            projectileSpeed: 8,
            splash: 0,
            color: '#8B4513',
            icon: '\u{1F3F9}',
            description: 'Fast single-target. +20% vs flying.',
            special: 'antiAir',
            upgrades: [
                { cost: 75,  dmgMult: 1.5, rangeMult: 1.1, rateMult: 0.9 },
                { cost: 150, dmgMult: 2.0, rangeMult: 1.2, rateMult: 0.8 },
                { cost: 300, dmgMult: 3.0, rangeMult: 1.3, rateMult: 0.7 }
            ]
        },
        cannon: {
            name: 'Cannon Tower',
            tier: 1,
            cost: 150,
            damage: 40,
            fireRate: 1200,
            range: 90,
            projectileSpeed: 5,
            splash: 50,
            color: '#555',
            icon: '\u{1F4A3}',
            description: 'Slow but splash damage.',
            special: 'splash',
            upgrades: [
                { cost: 100, dmgMult: 1.5, rangeMult: 1.1,  rateMult: 0.9  },
                { cost: 200, dmgMult: 2.0, rangeMult: 1.15, rateMult: 0.85 },
                { cost: 400, dmgMult: 3.0, rangeMult: 1.2,  rateMult: 0.8  }
            ]
        },
        frost: {
            name: 'Frost Tower',
            tier: 1,
            cost: 125,
            damage: 8,
            fireRate: 800,
            range: 110,
            projectileSpeed: 6,
            splash: 0,
            color: '#87CEEB',
            icon: '\u{2744}\u{FE0F}',
            description: '30% slow, stacking.',
            special: 'slow',
            slowAmount: 0.3,
            slowDuration: 2000,
            upgrades: [
                { cost: 80,  dmgMult: 1.5, rangeMult: 1.1, rateMult: 0.9  },
                { cost: 160, dmgMult: 2.0, rangeMult: 1.2, rateMult: 0.85 },
                { cost: 320, dmgMult: 3.0, rangeMult: 1.3, rateMult: 0.8  }
            ]
        },
        lightning: {
            name: 'Lightning Tower',
            tier: 2,
            cost: 200,
            damage: 25,
            fireRate: 600,
            range: 140,
            projectileSpeed: 20,
            splash: 0,
            color: '#FFD700',
            icon: '\u{26A1}',
            description: 'Chains to 3 targets.',
            special: 'chain',
            chainCount: 3,
            chainFalloff: 0.6,
            upgrades: [
                { cost: 130, dmgMult: 1.5, rangeMult: 1.1, rateMult: 0.9  },
                { cost: 260, dmgMult: 2.0, rangeMult: 1.2, rateMult: 0.85 },
                { cost: 520, dmgMult: 3.0, rangeMult: 1.3, rateMult: 0.8  }
            ]
        },
        mortar: {
            name: 'Mortar Tower',
            tier: 2,
            cost: 250,
            damage: 60,
            fireRate: 2000,
            range: 180,
            projectileSpeed: 3,
            splash: 60,
            color: '#8B0000',
            icon: '\u{1F525}',
            description: 'Area denial fire zone.',
            special: 'firezone',
            firezoneDuration: 3000,
            firezoneDPS: 10,
            upgrades: [
                { cost: 160, dmgMult: 1.5, rangeMult: 1.1,  rateMult: 0.9  },
                { cost: 320, dmgMult: 2.0, rangeMult: 1.15, rateMult: 0.85 },
                { cost: 640, dmgMult: 3.0, rangeMult: 1.2,  rateMult: 0.8  }
            ]
        },
        poison: {
            name: 'Poison Tower',
            tier: 2,
            cost: 175,
            damage: 5,
            fireRate: 1000,
            range: 110,
            projectileSpeed: 5,
            splash: 0,
            color: '#00FF00',
            icon: '\u{2620}\u{FE0F}',
            description: 'DoT 20/3s, 15% slow.',
            special: 'poison',
            poisonDamage: 20,
            poisonDuration: 3000,
            slowAmount: 0.15,
            upgrades: [
                { cost: 110, dmgMult: 1.5, rangeMult: 1.1, rateMult: 0.9  },
                { cost: 220, dmgMult: 2.0, rangeMult: 1.2, rateMult: 0.85 },
                { cost: 440, dmgMult: 3.0, rangeMult: 1.3, rateMult: 0.8  }
            ]
        },
        laser: {
            name: 'Laser Tower',
            tier: 3,
            cost: 350,
            damage: 8,
            fireRate: 50,
            range: 150,
            projectileSpeed: 0,
            splash: 0,
            color: '#FF4500',
            icon: '\u{1F4A0}',
            description: 'Beam locks on, 2x ramp.',
            special: 'beam',
            beamRampTime: 3000,
            beamMaxMult: 2.0,
            upgrades: [
                { cost: 220, dmgMult: 1.5, rangeMult: 1.15, rateMult: 1 },
                { cost: 440, dmgMult: 2.0, rangeMult: 1.2,  rateMult: 1 },
                { cost: 880, dmgMult: 3.0, rangeMult: 1.3,  rateMult: 1 }
            ]
        },
        tesla: {
            name: 'Tesla Tower',
            tier: 3,
            cost: 300,
            damage: 45,
            fireRate: 3000,
            range: 100,
            projectileSpeed: 0,
            splash: 0,
            color: '#9400D3',
            icon: '\u{1F300}',
            description: 'Pulse hits all in range.',
            special: 'pulse',
            pulseInterval: 3,
            upgrades: [
                { cost: 190, dmgMult: 1.5, rangeMult: 1.15, rateMult: 0.9  },
                { cost: 380, dmgMult: 2.0, rangeMult: 1.2,  rateMult: 0.85 },
                { cost: 760, dmgMult: 3.0, rangeMult: 1.3,  rateMult: 0.8  }
            ]
        },
        sniper: {
            name: 'Sniper Tower',
            tier: 3,
            cost: 400,
            damage: 200,
            fireRate: 3000,
            range: 500,
            projectileSpeed: 30,
            splash: 0,
            color: '#2F4F4F',
            icon: '\u{1F3AF}',
            description: 'Infinite range, crit every 4th.',
            special: 'sniper',
            critEvery: 4,
            critMult: 2.0,
            upgrades: [
                { cost: 250,  dmgMult: 1.5, rangeMult: 1, rateMult: 0.9  },
                { cost: 500,  dmgMult: 2.0, rangeMult: 1, rateMult: 0.85 },
                { cost: 1000, dmgMult: 3.0, rangeMult: 1, rateMult: 0.8  }
            ]
        },
        plasma: {
            name: 'Plasma Cannon',
            tier: 4,
            cost: 500,
            damage: 100,
            fireRate: 1500,
            range: 160,
            projectileSpeed: 12,
            splash: 0,
            color: '#FF1493',
            icon: '\u{1F52B}',
            description: 'Piercing beam, all in line.',
            special: 'pierce',
            upgrades: [
                { cost: 320,  dmgMult: 1.5, rangeMult: 1.1,  rateMult: 0.9  },
                { cost: 640,  dmgMult: 2.0, rangeMult: 1.15, rateMult: 0.85 },
                { cost: 1280, dmgMult: 3.0, rangeMult: 1.2,  rateMult: 0.8  }
            ]
        },
        void: {
            name: 'Void Tower',
            tier: 4,
            cost: 600,
            damage: 30,
            fireRate: 100,
            range: 110,
            projectileSpeed: 0,
            splash: 0,
            color: '#4B0082',
            icon: '\u{1F573}\u{FE0F}',
            description: 'Black hole pulls enemies.',
            special: 'pull',
            pullStrength: 0.3,
            upgrades: [
                { cost: 380,  dmgMult: 1.5, rangeMult: 1.15, rateMult: 1 },
                { cost: 760,  dmgMult: 2.0, rangeMult: 1.2,  rateMult: 1 },
                { cost: 1520, dmgMult: 3.0, rangeMult: 1.3,  rateMult: 1 }
            ]
        },
        command: {
            name: 'Command Tower',
            tier: 4,
            cost: 450,
            damage: 0,
            fireRate: 0,
            range: 140,
            projectileSpeed: 0,
            splash: 0,
            color: '#FFD700',
            icon: '\u{1F451}',
            description: '+25% dmg, +15% speed nearby.',
            special: 'buff',
            buffDamage: 0.25,
            buffSpeed: 0.15,
            upgrades: [
                { cost: 280,  dmgMult: 1, rangeMult: 1.2, rateMult: 1 },
                { cost: 560,  dmgMult: 1, rangeMult: 1.3, rateMult: 1 },
                { cost: 1120, dmgMult: 1, rangeMult: 1.5, rateMult: 1 }
            ]
        }
    };


    // ==================== TOWER CLASS ====================

    /**
     * Represents a single tower placed on the grid.
     *
     * Handles targeting, firing, upgrading, selling, and rendering.
     * Special tower behaviours (beam, pulse, pull, buff) are handled
     * by dedicated update methods dispatched from update().
     */
    class Tower {
        /**
         * @param {string} type - Key into TOWER_DEFS.
         * @param {number} col  - Grid column.
         * @param {number} row  - Grid row.
         */
        constructor(type, col, row) {
            const def = TOWER_DEFS[type];
            this.type = type;
            this.def  = def;
            this.col  = col;
            this.row  = row;
            this.x = col * GRID_SIZE + GRID_SIZE / 2;
            this.y = topBarHeight + row * GRID_SIZE + GRID_SIZE / 2;

            // Upgrade level: 0 = base, 1-3 = upgraded
            this.level = 0;

            // Combat stats (mutated by upgrades)
            this.damage   = def.damage;
            this.fireRate = def.fireRate;
            this.range    = def.range;

            // Cooldown & targeting
            this.lastFired  = 0;
            this.target     = null;
            this.angle      = 0;
            this.shotsFired = 0;

            // Lifetime stats
            this.totalDamageDealt = 0;
            this.kills = 0;

            // Beam-specific (laser tower)
            this.beamTarget = null;
            this.beamTime   = 0;

            // Visual feedback
            this.placedAt = Date.now();
            this.recoil   = 0;

            // Command tower buff tracking (set by TowerManager each frame)
            this.buffDamage = 0;
            this.buffSpeed  = 0;

            // Nullifier disable tracking
            this.disabledUntil = 0;
        }

        // --------------------------------------------------
        //  Economy
        // --------------------------------------------------

        /**
         * Sell value = 70% of total investment (base cost + upgrade costs).
         * @returns {number}
         */
        getSellValue() {
            let total = this.def.cost;
            for (let i = 0; i < this.level; i++) {
                total += this.def.upgrades[i].cost;
            }
            return Math.floor(total * 0.7);
        }

        /**
         * Cost of the next upgrade, or -1 if fully upgraded.
         * @returns {number}
         */
        getUpgradeCost() {
            if (this.level >= 3) return -1;
            return this.def.upgrades[this.level].cost;
        }

        /**
         * Apply the next upgrade level.
         * @returns {boolean} True if the upgrade was applied.
         */
        upgrade() {
            if (this.level >= 3) return false;
            const upg = this.def.upgrades[this.level];
            this.level++;
            this.damage   = Math.round(this.def.damage   * upg.dmgMult);
            this.range    = Math.round(this.def.range     * upg.rangeMult);
            this.fireRate = Math.round(this.def.fireRate  * upg.rateMult);
            return true;
        }

        // --------------------------------------------------
        //  Effective stats (with buff modifiers)
        // --------------------------------------------------

        /** Damage including command tower buffs. */
        getEffectiveDamage() {
            return Math.round(this.damage * (1 + this.buffDamage));
        }

        /** Fire rate including command tower buffs. */
        getEffectiveFireRate() {
            return Math.round(this.fireRate * (1 - this.buffSpeed));
        }

        /** Range (currently no external modifiers). */
        getEffectiveRange() {
            return this.range;
        }

        /**
         * Can this tower fire right now?
         * @param {number} now - Current timestamp (ms).
         * @returns {boolean}
         */
        canFire(now) {
            return now - this.lastFired >= this.getEffectiveFireRate();
        }

        // --------------------------------------------------
        //  Targeting
        // --------------------------------------------------

        /**
         * Find the best target within range.
         * Prioritises the enemy furthest along the path.
         * Cloaked enemies are invisible to all towers except snipers.
         *
         * @param {Enemy[]} enemies - Active enemy list.
         * @returns {Enemy|null}
         */
        findTarget(enemies) {
            let best = null;
            let bestProgress = -1;
            const r = this.getEffectiveRange();

            for (const enemy of enemies) {
                if (!enemy.active || enemy.hp <= 0) continue;
                // Cloaked enemies are only seen by sniper towers
                if (enemy.cloaked && this.def.special !== 'sniper') continue;
                const d = dist(this.x, this.y, enemy.x, enemy.y);
                if (d <= r) {
                    if (enemy.pathProgress > bestProgress) {
                        bestProgress = enemy.pathProgress;
                        best = enemy;
                    }
                }
            }
            return best;
        }

        // --------------------------------------------------
        //  Update (per tick)
        // --------------------------------------------------

        /**
         * Main update  dispatches to the correct sub-update
         * depending on tower special ability.
         *
         * @param {number} dt       - Delta time (ms).
         * @param {number} now      - Current timestamp (ms).
         * @param {Enemy[]} enemies - Active enemy list.
         * @param {GameManager} game
         */
        update(dt, now, enemies, game) {
            // Animate recoil decay
            this.recoil = Math.max(0, this.recoil - dt * 0.01);

            // Nullifier disable check
            if (this.disabledUntil && now < this.disabledUntil) return;

            // Command tower doesn't fire  buffs applied by TowerManager
            if (this.def.special === 'buff') return;

            // Beam tower: continuous lock-on DPS
            if (this.def.special === 'beam') {
                this.updateBeam(dt, now, enemies, game);
                return;
            }

            // Void tower: pull enemies inward + DPS
            if (this.def.special === 'pull') {
                this.updatePull(dt, enemies, game);
                return;
            }

            // Tesla tower: periodic AoE pulse
            if (this.def.special === 'pulse') {
                this.updatePulse(dt, now, enemies, game);
                return;
            }

            // Standard projectile-based towers
            const target = this.findTarget(enemies);
            if (target) {
                this.angle  = angle(this.x, this.y, target.x, target.y);
                this.target = target;
            }

            if (target && this.canFire(now)) {
                this.fire(target, now, game);
            }
        }

        // --------------------------------------------------
        //  Firing
        // --------------------------------------------------

        /**
         * Fire a projectile at the given target.
         *
         * @param {Enemy} target
         * @param {number} now
         * @param {GameManager} game
         */
        fire(target, now, game) {
            this.lastFired = now;
            this.shotsFired++;
            this.recoil = 1;

            if (game.audioEngine) game.audioEngine.playTowerFire(this.type);

            // Spawn projectile via the ProjectileManager
            if (game.projectileManager) {
                const dmg = this.getEffectiveDamage();

                // Sniper critical hit every Nth shot
                let finalDmg = dmg;
                let isCrit = false;
                if (this.def.special === 'sniper' && this.shotsFired % this.def.critEvery === 0) {
                    finalDmg = Math.round(dmg * this.def.critMult);
                    isCrit = true;
                }

                game.projectileManager.spawn({
                    x: this.x,
                    y: this.y,
                    target: target,
                    damage: finalDmg,
                    speed: this.def.projectileSpeed,
                    splash: this.def.splash || 0,
                    type: this.type,
                    special: this.def.special,
                    isCrit: isCrit,
                    tower: this,
                    // Chain lightning data
                    chainCount: this.def.chainCount || 0,
                    chainFalloff: this.def.chainFalloff || 0,
                    // Slow data
                    slowAmount: this.def.slowAmount || 0,
                    slowDuration: this.def.slowDuration || 0,
                    // Poison data
                    poisonDamage: this.def.poisonDamage || 0,
                    poisonDuration: this.def.poisonDuration || 0,
                    // Fire zone data
                    firezoneDuration: this.def.firezoneDuration || 0,
                    firezoneDPS: this.def.firezoneDPS || 0,
                    // Pierce
                    pierce: this.def.special === 'pierce',
                    // Anti-air bonus
                    antiAir: this.def.special === 'antiAir'
                });
            }
        }

        // --------------------------------------------------
        //  Beam tower (laser)
        // --------------------------------------------------

        /**
         * Continuous beam that ramps damage the longer it stays on the
         * same target.  Switches if the current target dies or leaves range.
         */
        updateBeam(dt, now, enemies, game) {
            // Validate current beam target
            if (this.beamTarget && this.beamTarget.active && this.beamTarget.hp > 0) {
                const d = dist(this.x, this.y, this.beamTarget.x, this.beamTarget.y);
                if (d > this.getEffectiveRange()) {
                    this.beamTarget = null;
                    this.beamTime   = 0;
                }
            } else {
                this.beamTarget = null;
                this.beamTime   = 0;
            }

            // Acquire new target if needed
            if (!this.beamTarget) {
                this.beamTarget = this.findTarget(enemies);
                this.beamTime   = 0;
            }

            // Deal ramping DPS
            if (this.beamTarget) {
                this.angle = angle(this.x, this.y, this.beamTarget.x, this.beamTarget.y);
                this.beamTime += dt;
                const rampProgress = Math.min(1, this.beamTime / this.def.beamRampTime);
                const rampMult = 1 + (this.def.beamMaxMult - 1) * rampProgress;
                const dmg = this.getEffectiveDamage() * rampMult * (dt / 1000);
                this.beamTarget.takeDamage(dmg, this, game);
            }
        }

        // --------------------------------------------------
        //  Pull tower (void)
        // --------------------------------------------------

        /**
         * Pulls all enemies within range toward the tower centre
         * and deals continuous DPS.
         */
        updatePull(dt, enemies, game) {
            const r = this.getEffectiveRange();
            for (const enemy of enemies) {
                if (!enemy.active || enemy.hp <= 0) continue;
                const d = dist(this.x, this.y, enemy.x, enemy.y);
                if (d <= r && d > 5) {
                    const a = angle(enemy.x, enemy.y, this.x, this.y);
                    const strength = this.def.pullStrength * (1 - d / r) * (dt / 16.67);
                    enemy.x += Math.cos(a) * strength;
                    enemy.y += Math.sin(a) * strength;
                    // Continuous DPS while pulled
                    const dmg = this.getEffectiveDamage() * (dt / 1000);
                    enemy.takeDamage(dmg, this, game);
                }
            }
        }

        // --------------------------------------------------
        //  Pulse tower (tesla)
        // --------------------------------------------------

        /**
         * Periodically damages all enemies in range simultaneously.
         */
        updatePulse(dt, now, enemies, game) {
            if (!this.canFire(now)) return;
            this.lastFired = now;
            this.shotsFired++;
            this.recoil = 1;

            const r   = this.getEffectiveRange();
            const dmg = this.getEffectiveDamage();
            let hit = false;

            for (const enemy of enemies) {
                if (!enemy.active || enemy.hp <= 0) continue;
                const d = dist(this.x, this.y, enemy.x, enemy.y);
                if (d <= r) {
                    enemy.takeDamage(dmg, this, game);
                    hit = true;
                }
            }

            if (hit && game.audioEngine) game.audioEngine.playTowerFire('tesla');
            if (hit && game.particleSystem) {
                game.particleSystem.emitRing(this.x, this.y, r, this.def.color, 20);
            }
        }

        // --------------------------------------------------
        //  Rendering
        // --------------------------------------------------

        /**
         * Draw the tower on the canvas.
         * @param {CanvasRenderingContext2D} ctx
         */
        render(ctx) {
            const s  = GRID_SIZE;
            const hs = s / 2;
            const recoilOffset = this.recoil * 3;

            ctx.save();
            ctx.translate(this.x, this.y);

            // Base shape  varies by tier
            const baseSize = hs * 0.85;
            ctx.fillStyle  = this.def.color;
            ctx.globalAlpha = (this.disabledUntil && Date.now() < this.disabledUntil) ? 0.4 : 1;

            if (this.def.tier === 1) {
                // Circle base
                ctx.beginPath();
                ctx.arc(0, 0, baseSize, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.def.tier === 2) {
                // Rounded square
                const rr = 4;
                ctx.beginPath();
                ctx.moveTo(-baseSize + rr, -baseSize);
                ctx.arcTo(baseSize,  -baseSize, baseSize,  baseSize, rr);
                ctx.arcTo(baseSize,   baseSize, -baseSize, baseSize, rr);
                ctx.arcTo(-baseSize,  baseSize, -baseSize, -baseSize, rr);
                ctx.arcTo(-baseSize, -baseSize,  baseSize, -baseSize, rr);
                ctx.fill();
            } else if (this.def.tier === 3) {
                // Hexagon
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI / 3) * i - Math.PI / 6;
                    ctx.lineTo(Math.cos(a) * baseSize, Math.sin(a) * baseSize);
                }
                ctx.closePath();
                ctx.fill();
            } else {
                // 8-pointed star (tier 4)
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const a  = (Math.PI / 4) * i;
                    const r2 = i % 2 === 0 ? baseSize : baseSize * 0.6;
                    ctx.lineTo(Math.cos(a) * r2, Math.sin(a) * r2);
                }
                ctx.closePath();
                ctx.fill();
            }

            // Level pips (yellow dots indicating upgrade level)
            ctx.fillStyle = '#feca57';
            for (let i = 0; i < this.level; i++) {
                ctx.beginPath();
                ctx.arc(-8 + i * 8, baseSize + 4, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Turret barrel (rotates toward target)
            if (this.def.special !== 'buff' && this.def.special !== 'pull') {
                ctx.rotate(this.angle);
                ctx.fillStyle = '#ddd';
                const barrelLength = baseSize * 0.8 - recoilOffset;
                ctx.fillRect(0, -3, barrelLength, 6);
                // Barrel tip accent
                ctx.fillStyle = this.def.color;
                ctx.beginPath();
                ctx.arc(barrelLength, 0, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Buff tower pulsing aura
            if (this.def.special === 'buff') {
                ctx.globalAlpha = 0.1 + 0.05 * Math.sin(Date.now() / 500);
                ctx.beginPath();
                ctx.arc(0, 0, this.getEffectiveRange(), 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Void tower spinning arcs
            if (this.def.special === 'pull') {
                const t = Date.now() / 1000;
                ctx.globalAlpha = 0.3;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * (0.5 + i * 0.2),
                            t * 2 + i, t * 2 + i + Math.PI * 1.5);
                    ctx.strokeStyle = '#9400D3';
                    ctx.lineWidth   = 2;
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // Beam rendering (laser tower)
            if (this.def.special === 'beam' && this.beamTarget) {
                ctx.restore();
                ctx.save();
                const rampPct = Math.min(1, this.beamTime / this.def.beamRampTime);
                ctx.strokeStyle = this.def.color;
                ctx.lineWidth   = 2 + rampPct * 4;
                ctx.globalAlpha = 0.6 + rampPct * 0.4;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.beamTarget.x, this.beamTarget.y);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }
    }


    // ==================== ENEMY DEFINITIONS ====================

    /**
     * Static data for every enemy type in the game.
     *
     * Categories:
     *   Ground (10)   grunt, runner, tank, shield, healer, splitter,
     *                    berserker, cloaker, regenerator, engineer
     *   Flying (4)    drone, bomber, swarm, carrier
     *   Elite  (6)    juggernaut, phasewalker, nullifier, mirror,
     *                    necromancer, voidwraith
     */
    const ENEMY_DEFS = {
        // ---- Ground ----
        grunt: {
            name: 'Grunt',
            hp: 50,
            speed: 1.0,
            armor: 0,
            gold: 10,
            flying: false,
            special: null
        },
        runner: {
            name: 'Runner',
            hp: 30,
            speed: 2.0,
            armor: 0,
            gold: 8,
            flying: false,
            special: null
        },
        tank: {
            name: 'Tank',
            hp: 200,
            speed: 0.5,
            armor: 5,
            gold: 25,
            flying: false,
            special: null
        },
        shield: {
            name: 'Shield Bearer',
            hp: 80,
            speed: 0.8,
            armor: 0,
            gold: 15,
            flying: false,
            special: 'shield'
        },
        healer: {
            name: 'Healer',
            hp: 60,
            speed: 0.9,
            armor: 0,
            gold: 20,
            flying: false,
            special: 'heal',
            healRate: 5,
            healRange: 80
        },
        splitter: {
            name: 'Splitter',
            hp: 100,
            speed: 0.8,
            armor: 0,
            gold: 15,
            flying: false,
            special: 'split',
            splitCount: 2
        },
        berserker: {
            name: 'Berserker',
            hp: 120,
            speed: 0.7,
            armor: 0,
            gold: 18,
            flying: false,
            special: 'berserk',
            berserkSpeed: 1.5
        },
        cloaker: {
            name: 'Cloaker',
            hp: 45,
            speed: 1.2,
            armor: 0,
            gold: 20,
            flying: false,
            special: 'cloak',
            cloakRange: 100
        },
        regenerator: {
            name: 'Regenerator',
            hp: 150,
            speed: 0.6,
            armor: 0,
            gold: 22,
            flying: false,
            special: 'regen',
            regenRate: 3
        },
        engineer: {
            name: 'Engineer',
            hp: 70,
            speed: 0.8,
            armor: 0,
            gold: 20,
            flying: false,
            special: 'barricade'
        },
        // ---- Flying ----
        drone: {
            name: 'Drone',
            hp: 40,
            speed: 1.5,
            armor: 0,
            gold: 12,
            flying: true,
            special: null
        },
        bomber: {
            name: 'Bomber',
            hp: 80,
            speed: 1.0,
            armor: 0,
            gold: 25,
            flying: true,
            special: 'bomb',
            bombDamage: 10,
            bombInterval: 5000
        },
        swarm: {
            name: 'Swarm',
            hp: 15,
            speed: 2.0,
            armor: 0,
            gold: 5,
            flying: true,
            special: null
        },
        carrier: {
            name: 'Carrier',
            hp: 200,
            speed: 0.6,
            armor: 0,
            gold: 30,
            flying: true,
            special: 'carrier',
            carryCount: 4
        },
        // ---- Elite ----
        juggernaut: {
            name: 'Juggernaut',
            hp: 500,
            speed: 0.3,
            armor: 10,
            gold: 50,
            flying: false,
            special: 'slowImmune'
        },
        phasewalker: {
            name: 'Phase Walker',
            hp: 100,
            speed: 1.0,
            armor: 0,
            gold: 35,
            flying: false,
            special: 'teleport',
            teleportDist: 100,
            teleportInterval: 5000
        },
        nullifier: {
            name: 'Nullifier',
            hp: 150,
            speed: 0.8,
            armor: 0,
            gold: 40,
            flying: false,
            special: 'nullify',
            nullifyDuration: 3000
        },
        mirror: {
            name: 'Mirror Knight',
            hp: 120,
            speed: 0.9,
            armor: 0,
            gold: 35,
            flying: false,
            special: 'reflect',
            reflectPct: 0.2
        },
        necromancer: {
            name: 'Necromancer',
            hp: 80,
            speed: 0.7,
            armor: 0,
            gold: 45,
            flying: false,
            special: 'resurrect',
            resInterval: 10000,
            resCount: 2
        },
        voidwraith: {
            name: 'Void Wraith',
            hp: 200,
            speed: 1.0,
            armor: 0,
            gold: 40,
            flying: false,
            special: 'voidresist'
        }
    };


    // ==================== ENEMY CLASS ====================

    /**
     * Represents a single enemy unit moving along a path.
     *
     * Handles movement, status effects (slow, poison, berserk),
     * special abilities, taking damage, death behaviour, and rendering.
     */
    class Enemy {
        /**
         * @param {string}   type       - Key into ENEMY_DEFS.
         * @param {Array}    pathPoints - Array of {x, y} waypoints.
         * @param {number}   waveScale  - Multiplier for HP & gold (scales with wave).
         */
        constructor(type, pathPoints, waveScale) {
            const def = ENEMY_DEFS[type];
            this.type = type;
            this.def  = def;

            // Path data
            this.pathPoints  = pathPoints;
            this.pathIndex   = 0;
            this.pathProgress = 0; // total distance travelled (for targeting priority)

            // Position (start at first waypoint)
            this.x = pathPoints[0].x;
            this.y = pathPoints[0].y;
            this.prevX = this.x;
            this.prevY = this.y;

            // Health (scaled by wave)
            this.maxHp = Math.round(def.hp * waveScale);
            this.hp    = this.maxHp;

            // Movement
            this.speed     = def.speed;
            this.baseSpeed = def.speed;

            // Armour reduces incoming damage by a flat amount
            this.armor = def.armor;

            // Gold reward (scaled by wave)
            this.gold = Math.round(def.gold * waveScale);

            // State flags
            this.active  = true;
            this.flying  = def.flying;
            this.cloaked = def.special === 'cloak'; // cloakers start cloaked

            // Status effects
            this.slowEffects   = [];  // { amount: 0-1, until: timestamp }
            this.poisonEffects = [];  // { dps, until: timestamp }

            // Shield bearer: directional block angle (faces direction of most hits)
            this.shieldAngle    = 0;
            this.shieldHitCount = 0;

            // Berserker: tracks if below 50% HP for speed boost
            this.isBerserk = false;

            // Regenerator: regen pauses for 2s after being hit
            this.lastHitTime = 0;

            // Phase Walker: teleport cooldown
            this.lastTeleport = 0;

            // Bomber: bomb drop cooldown
            this.lastBombDrop = 0;

            // Necromancer: resurrect cooldown
            this.lastResurrect = 0;

            // Nullifier: tracks towers already disabled this lifetime
            this.nullifiedTowers = new Set();

            // Engineer: barricade spawn tracking
            this.lastBarricade  = 0;
            this.barricadesLeft = 2; // max barricades per engineer

            // Animation
            this.spawnTime = Date.now();
            this.deathTime = 0;
            this.flashUntil = 0; // white flash on hit
        }

        // --------------------------------------------------
        //  Taking damage
        // --------------------------------------------------

        /**
         * Apply damage to this enemy, accounting for armour,
         * directional shield blocking, mirror reflect, and void resistance.
         *
         * @param {number}      amount - Raw damage.
         * @param {Tower|null}  tower  - The tower that dealt the damage (null for DoT/zones).
         * @param {GameManager} game
         */
        takeDamage(amount, tower, game) {
            if (!this.active || this.hp <= 0) return;

            let dmg = amount;

            // Flat armour reduction
            if (this.armor > 0) {
                dmg = Math.max(1, dmg - this.armor);
            }

            // Shield bearer: 60% block if projectile comes from within the shield arc
            if (this.def.special === 'shield' && tower) {
                const incAngle = angle(tower.x, tower.y, this.x, this.y);
                const diff = Math.abs(incAngle - this.shieldAngle);
                const normDiff = diff > Math.PI ? (2 * Math.PI - diff) : diff;
                if (normDiff < Math.PI / 3) { // 60-degree shield arc
                    dmg = Math.round(dmg * 0.4); // block 60%
                }
                // Adapt shield direction toward incoming fire
                this.shieldHitCount++;
                const weight = 1 / this.shieldHitCount;
                this.shieldAngle = lerp(this.shieldAngle, incAngle, weight);
            }

            // Void Wraith: 50% damage reduction from single-target attacks
            if (this.def.special === 'voidresist' && tower) {
                const towerDef = tower.def || {};
                if (!towerDef.splash && towerDef.special !== 'pulse') {
                    dmg = Math.round(dmg * 0.5);
                }
            }

            // Mirror Knight: reflect a portion back at the tower
            if (this.def.special === 'reflect' && tower) {
                const reflected = Math.round(amount * this.def.reflectPct);
                // We don't damage the tower (towers have no HP), but we show
                // a visual damage number on the tower and track it as a miss
                if (game && reflected > 0) {
                    game.addDamageNum(tower.x, tower.y - 10, `-${reflected}`, '#ff6b6b');
                }
            }

            // Apply final damage
            this.hp -= dmg;
            this.lastHitTime = Date.now();
            this.flashUntil  = Date.now() + 80;

            // Cloaker: reveal on hit
            if (this.def.special === 'cloak') {
                this.cloaked = false;
                // Re-cloak after 2 seconds
                this._recloakAt = Date.now() + 2000;
            }

            // Track on tower
            if (tower) {
                tower.totalDamageDealt += dmg;
            }

            // Anti-air bonus: arrow towers deal 20% more to flying
            // (handled at projectile hit  this is a fallback for beam/pulse)
            // already factored into the damage before this call

            // Floating damage number
            if (game && dmg > 0) {
                const color = (tower && tower.def.special === 'sniper' && tower.shotsFired % (tower.def.critEvery || 999) === 0)
                    ? '#ff0' : '#fff';
                game.addDamageNum(this.x, this.y - 15, Math.round(dmg).toString(), color);
            }

            // Death check
            if (this.hp <= 0) {
                this.hp = 0;
                if (tower) tower.kills++;
                this.die(game);
            }
        }

        // --------------------------------------------------
        //  Death
        // --------------------------------------------------

        /**
         * Handle enemy death: award gold, spawn split children,
         * carrier drops, particles, sound.
         *
         * @param {GameManager} game
         */
        die(game) {
            this.active    = false;
            this.deathTime = Date.now();

            // Award gold
            if (game) {
                game.addGold(this.gold);
                game.addDamageNum(this.x, this.y - 25, `+${this.gold}g`, '#feca57');
            }

            // Splitter: spawn smaller children at current position
            if (this.def.special === 'split' && game && game.enemyManager) {
                const count = this.def.splitCount || 2;
                for (let i = 0; i < count; i++) {
                    // Build a sub-path starting from the current waypoint onward
                    const subPath = [{ x: this.x + randFloat(-10, 10), y: this.y + randFloat(-10, 10) }];
                    for (let j = this.pathIndex; j < this.pathPoints.length; j++) {
                        subPath.push(this.pathPoints[j]);
                    }
                    const child = new Enemy('grunt', subPath, 0.5);
                    child.maxHp = Math.round(this.maxHp * 0.3);
                    child.hp    = child.maxHp;
                    child.speed = this.baseSpeed * 1.2;
                    child.baseSpeed = child.speed;
                    child.gold  = Math.round(this.gold * 0.3);
                    game.enemyManager.addEnemy(child);
                }
            }

            // Carrier: drop ground units on death
            if (this.def.special === 'carrier' && game && game.enemyManager) {
                const count = this.def.carryCount || 4;
                for (let i = 0; i < count; i++) {
                    // Ground units start from closest path waypoint to current position
                    let closestIdx = 0;
                    let closestDist = Infinity;
                    for (let j = 0; j < this.pathPoints.length; j++) {
                        const d = dist(this.x, this.y, this.pathPoints[j].x, this.pathPoints[j].y);
                        if (d < closestDist) {
                            closestDist = d;
                            closestIdx  = j;
                        }
                    }
                    const subPath = [{ x: this.x + randFloat(-15, 15), y: this.y + randFloat(-15, 15) }];
                    for (let j = closestIdx; j < this.pathPoints.length; j++) {
                        subPath.push(this.pathPoints[j]);
                    }
                    const child = new Enemy('grunt', subPath, 0.7);
                    child.maxHp = Math.round(this.maxHp * 0.15);
                    child.hp    = child.maxHp;
                    child.gold  = Math.round(this.gold * 0.2);
                    child.flying = false;
                    game.enemyManager.addEnemy(child);
                }
            }

            // Death particles
            if (game && game.particleSystem) {
                const col = this.def.flying ? '#88ccff' : '#ff6b6b';
                game.particleSystem.emit(this.x, this.y, 12, col, 3, 2, 600, 3);
            }

            // Death sound
            if (game && game.audioEngine) {
                game.audioEngine.playEnemyDeath(this.type);
            }
        }

        // --------------------------------------------------
        //  Update (per tick)
        // --------------------------------------------------

        /**
         * Advance the enemy along its path, process status effects
         * and special abilities.
         *
         * @param {number}      dt   - Delta time (ms).
         * @param {number}      now  - Current timestamp (ms).
         * @param {GameManager} game
         */
        update(dt, now, game) {
            if (!this.active) return;

            // Store previous position for interpolation
            this.prevX = this.x;
            this.prevY = this.y;

            // ---- Status effects ----

            // Process & clean expired slows
            let totalSlow = 0;
            for (let i = this.slowEffects.length - 1; i >= 0; i--) {
                if (now > this.slowEffects[i].until) {
                    this.slowEffects.splice(i, 1);
                } else {
                    totalSlow += this.slowEffects[i].amount;
                }
            }
            // Slow-immune enemies ignore slows
            if (this.def.special === 'slowImmune') totalSlow = 0;
            totalSlow = clamp(totalSlow, 0, 0.8); // cap at 80% slow

            // Process poison DoT
            for (let i = this.poisonEffects.length - 1; i >= 0; i--) {
                const p = this.poisonEffects[i];
                if (now > p.until) {
                    this.poisonEffects.splice(i, 1);
                } else {
                    const tickDmg = p.dps * (dt / 1000);
                    this.hp -= tickDmg;
                    // Poison damage numbers (intermittent to avoid spam)
                    if (game && Math.random() < 0.1) {
                        game.addDamageNum(this.x + randFloat(-8, 8), this.y - 10, Math.round(tickDmg).toString(), '#00ff00');
                    }
                    if (this.hp <= 0) {
                        this.hp = 0;
                        this.die(game);
                        return;
                    }
                }
            }

            // ---- Berserker speed boost below 50% HP ----
            if (this.def.special === 'berserk' && !this.isBerserk && this.hp < this.maxHp * 0.5) {
                this.isBerserk = true;
                this.baseSpeed *= this.def.berserkSpeed;
            }

            // ---- Regenerator: heal if not recently hit ----
            if (this.def.special === 'regen' && now - this.lastHitTime > 2000) {
                this.hp = Math.min(this.maxHp, this.hp + this.def.regenRate * (dt / 1000));
            }

            // ---- Cloaker: re-cloak after reveal timer ----
            if (this.def.special === 'cloak' && this._recloakAt && now > this._recloakAt) {
                this.cloaked = true;
                this._recloakAt = 0;
            }

            // ---- Healer: heal nearby allies ----
            if (this.def.special === 'heal' && game && game.enemyManager) {
                const allies = game.enemyManager.getActiveEnemies();
                const hr = this.def.healRange || 80;
                for (const ally of allies) {
                    if (ally === this || !ally.active || ally.hp <= 0) continue;
                    if (ally.hp >= ally.maxHp) continue;
                    const d = dist(this.x, this.y, ally.x, ally.y);
                    if (d <= hr) {
                        const heal = this.def.healRate * (dt / 1000);
                        ally.hp = Math.min(ally.maxHp, ally.hp + heal);
                    }
                }
            }

            // ---- Phase Walker: periodic teleport forward ----
            if (this.def.special === 'teleport') {
                if (now - this.lastTeleport > (this.def.teleportInterval || 5000)) {
                    this.lastTeleport = now;
                    // Jump forward along the path
                    const jumpDist = this.def.teleportDist || 100;
                    let remaining = jumpDist;
                    while (remaining > 0 && this.pathIndex < this.pathPoints.length - 1) {
                        const next = this.pathPoints[this.pathIndex + 1];
                        const d = dist(this.x, this.y, next.x, next.y);
                        if (d <= remaining) {
                            this.x = next.x;
                            this.y = next.y;
                            this.pathIndex++;
                            this.pathProgress += d;
                            remaining -= d;
                        } else {
                            const a = angle(this.x, this.y, next.x, next.y);
                            this.x += Math.cos(a) * remaining;
                            this.y += Math.sin(a) * remaining;
                            this.pathProgress += remaining;
                            remaining = 0;
                        }
                    }
                    // Teleport particle effect
                    if (game && game.particleSystem) {
                        game.particleSystem.emit(this.x, this.y, 8, '#00ffff', 2, 1.5, 400, 2);
                    }
                }
            }

            // ---- Bomber: periodic bomb drops ----
            if (this.def.special === 'bomb') {
                if (now - this.lastBombDrop > (this.def.bombInterval || 5000)) {
                    this.lastBombDrop = now;
                    // Drop a small fire zone below
                    if (game && game.towerManager) {
                        game.towerManager.fireZones.push(
                            new FireZone(this.x, this.y, 30, this.def.bombDamage || 10, 2000)
                        );
                    }
                    if (game && game.particleSystem) {
                        game.particleSystem.emit(this.x, this.y, 6, '#ff4500', 1.5, 1, 300, 2);
                    }
                }
            }

            // ---- Nullifier: disable nearby towers on first pass ----
            if (this.def.special === 'nullify' && game && game.towerManager) {
                const towers = game.towerManager.towers;
                for (const t of towers) {
                    if (this.nullifiedTowers.has(t)) continue;
                    const d = dist(this.x, this.y, t.x, t.y);
                    if (d < 60) {
                        t.disabledUntil = now + (this.def.nullifyDuration || 3000);
                        this.nullifiedTowers.add(t);
                        if (game.particleSystem) {
                            game.particleSystem.emit(t.x, t.y, 8, '#9400D3', 2, 1, 500, 2);
                        }
                    }
                }
            }

            // ---- Necromancer: resurrect nearby dead enemies ----
            if (this.def.special === 'resurrect' && game && game.enemyManager) {
                if (now - this.lastResurrect > (this.def.resInterval || 10000)) {
                    const deadList = game.enemyManager.getRecentlyDead();
                    let resCount = 0;
                    const maxRes = this.def.resCount || 2;
                    for (const dead of deadList) {
                        if (resCount >= maxRes) break;
                        if (dead.type === 'necromancer') continue; // can't res necromancers
                        // Resurrect with 50% HP at necromancer's position
                        const subPath = [{ x: this.x, y: this.y }];
                        for (let j = this.pathIndex; j < this.pathPoints.length; j++) {
                            subPath.push(this.pathPoints[j]);
                        }
                        const revived = new Enemy(dead.type, subPath, 0.5);
                        revived.maxHp = Math.round(dead.maxHp * 0.5);
                        revived.hp    = revived.maxHp;
                        revived.gold  = Math.round(dead.gold * 0.5);
                        game.enemyManager.addEnemy(revived);
                        resCount++;
                    }
                    this.lastResurrect = now;
                    if (resCount > 0 && game.particleSystem) {
                        game.particleSystem.emit(this.x, this.y, 10, '#8B00FF', 3, 2, 600, 3);
                    }
                }
            }

            // ---- Engineer: spawn barricade ----
            if (this.def.special === 'barricade' && this.barricadesLeft > 0) {
                if (now - this.lastBarricade > 8000) {
                    this.lastBarricade = now;
                    this.barricadesLeft--;
                    // A barricade is just a high-HP, zero-speed "enemy" that blocks the path
                    // This encourages towers to waste shots on it
                    if (game && game.enemyManager) {
                        const barricadePath = [{ x: this.x, y: this.y }, { x: this.x, y: this.y }];
                        const barricade = new Enemy('grunt', barricadePath, 1);
                        barricade.maxHp = 80;
                        barricade.hp    = 80;
                        barricade.speed = 0;
                        barricade.baseSpeed = 0;
                        barricade.gold  = 5;
                        barricade.isBarricade = true;
                        game.enemyManager.addEnemy(barricade);
                    }
                }
            }

            // ---- Movement along path ----
            let moveSpeed = this.baseSpeed * (1 - totalSlow);
            // Poison slow (additive with frost)
            for (const p of this.poisonEffects) {
                if (p.slowAmount) {
                    moveSpeed *= (1 - p.slowAmount);
                }
            }
            moveSpeed = Math.max(0.05, moveSpeed); // minimum speed

            const moveDist = moveSpeed * GRID_SIZE * (dt / 1000);

            if (this.pathIndex < this.pathPoints.length - 1) {
                const next = this.pathPoints[this.pathIndex + 1];
                const d    = dist(this.x, this.y, next.x, next.y);

                if (d <= moveDist) {
                    // Reached the next waypoint
                    this.x = next.x;
                    this.y = next.y;
                    this.pathIndex++;
                    this.pathProgress += d;

                    // If that was the last waypoint, enemy reached the end
                    if (this.pathIndex >= this.pathPoints.length - 1) {
                        this.active = false;
                        if (game) game.loseLife(1);
                        return;
                    }
                } else {
                    // Move toward next waypoint
                    const a = angle(this.x, this.y, next.x, next.y);
                    this.x += Math.cos(a) * moveDist;
                    this.y += Math.sin(a) * moveDist;
                    this.pathProgress += moveDist;
                }
            } else {
                // Already at the last waypoint  enemy leaked
                this.active = false;
                if (game) game.loseLife(1);
            }
        }

        // --------------------------------------------------
        //  Rendering
        // --------------------------------------------------

        /**
         * Draw the enemy on the canvas.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} alpha - Interpolation alpha for smooth rendering.
         */
        render(ctx, alpha) {
            if (!this.active) return;

            // Interpolated position
            const ix = lerp(this.prevX, this.x, alpha);
            const iy = lerp(this.prevY, this.y, alpha);

            const now = Date.now();
            const size = this.flying ? 8 : (this.def.special === 'slowImmune' || this.def.special === 'voidresist' ? 12 : 9);

            ctx.save();
            ctx.translate(ix, iy);

            // Cloaked enemies are translucent
            if (this.cloaked) {
                ctx.globalAlpha = 0.15;
            }

            // Barricade special rendering
            if (this.isBarricade) {
                ctx.fillStyle = '#8B6914';
                ctx.fillRect(-8, -6, 16, 12);
                ctx.strokeStyle = '#5C4A0E';
                ctx.lineWidth = 1;
                ctx.strokeRect(-8, -6, 16, 12);
                ctx.globalAlpha = 1;
                // HP bar
                this._renderHPBar(ctx, size);
                ctx.restore();
                return;
            }

            // Tint when poisoned
            const isPoisoned = this.poisonEffects.length > 0;
            // Tint when slowed
            const isSlowed = this.slowEffects.length > 0;
            // Flash on hit
            const isFlashing = now < this.flashUntil;

            // Body colour
            let bodyColor;
            if (isFlashing) {
                bodyColor = '#fff';
            } else if (isPoisoned) {
                bodyColor = '#66ff66';
            } else if (isSlowed) {
                bodyColor = '#aaddff';
            } else if (this.flying) {
                bodyColor = '#55aaff';
            } else if (this.isBerserk) {
                bodyColor = '#ff4444';
            } else {
                bodyColor = '#e74c3c';
            }

            ctx.fillStyle = bodyColor;

            if (this.flying) {
                // Diamond shape for flying enemies
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(size, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size, 0);
                ctx.closePath();
                ctx.fill();
                // Wing lines
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-size - 3, -2);
                ctx.lineTo(-size + 2, 0);
                ctx.lineTo(-size - 3, 2);
                ctx.moveTo(size + 3, -2);
                ctx.lineTo(size - 2, 0);
                ctx.lineTo(size + 3, 2);
                ctx.stroke();
            } else {
                // Circle for ground enemies
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                // Outline for elites
                if (this.def.gold >= 35) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Shield bearer: directional shield arc
            if (this.def.special === 'shield') {
                ctx.save();
                ctx.rotate(this.shieldAngle);
                ctx.strokeStyle = '#55ccff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, size + 4, -Math.PI / 3, Math.PI / 3);
                ctx.stroke();
                ctx.restore();
            }

            // Healer aura indicator
            if (this.def.special === 'heal') {
                ctx.globalAlpha = 0.15;
                ctx.beginPath();
                ctx.arc(0, 0, this.def.healRange || 80, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                ctx.globalAlpha = this.cloaked ? 0.15 : 1;
            }

            // Necromancer: skull indicator
            if (this.def.special === 'resurrect') {
                ctx.fillStyle = '#8B00FF';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('\u2620', 0, -size - 6);
            }

            ctx.globalAlpha = 1;

            // HP bar
            this._renderHPBar(ctx, size);

            ctx.restore();
        }

        /**
         * Draw a small health bar above the enemy.
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} size - Enemy radius.
         */
        _renderHPBar(ctx, size) {
            if (this.hp >= this.maxHp) return; // don't show full HP

            const barW = size * 2.5;
            const barH = 3;
            const barX = -barW / 2;
            const barY = -size - 8;
            const pct  = clamp(this.hp / this.maxHp, 0, 1);

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX, barY, barW, barH);

            // Fill  green > yellow > red
            let color;
            if (pct > 0.6) color = '#2ecc71';
            else if (pct > 0.3) color = '#f1c40f';
            else color = '#e74c3c';

            ctx.fillStyle = color;
            ctx.fillRect(barX, barY, barW * pct, barH);
        }
    }


    // ==================== PROJECTILE MANAGER ====================

    /**
     * Manages a pool of projectiles fired by towers.
     *
     * Projectiles are homing (track living targets) or ballistic
     * (fly toward last-known position if target dies).
     * Handles splash, chain lightning, pierce, slow, poison, and
     * fire zone spawning on impact.
     */
    class ProjectileManager {
        /**
         * @param {number} poolSize - Number of projectiles to pre-allocate.
         */
        constructor(poolSize) {
            this.pool = new ObjectPool(
                () => this._createProjectile(),
                (p) => this._resetProjectile(p),
                poolSize || POOL_PROJECTILES
            );
            /** Reference to fire zones (managed by TowerManager). */
            this.fireZonesRef = null;
            /** Reference to enemy list for splash / chain. */
            this.enemiesRef = null;
            /** Reference to game for damage numbers, particles, etc. */
            this.gameRef = null;
        }

        /** Factory: blank projectile object. */
        _createProjectile() {
            return {
                x: 0, y: 0,
                targetX: 0, targetY: 0,
                target: null,
                damage: 0,
                speed: 1,
                splash: 0,
                type: '',
                special: '',
                active: false,
                dx: 0, dy: 0,
                trail: [],      // recent positions for trail rendering
                isCrit: false,
                pierce: false,
                piercedEnemies: [],
                chainCount: 0,
                chainFalloff: 0,
                slowAmount: 0,
                slowDuration: 0,
                poisonDamage: 0,
                poisonDuration: 0,
                firezoneDuration: 0,
                firezoneDPS: 0,
                antiAir: false,
                tower: null
            };
        }

        /** Reset: return projectile to blank state. */
        _resetProjectile(p) {
            p.active = false;
            p.target = null;
            p.tower  = null;
            p.trail.length = 0;
            p.piercedEnemies.length = 0;
            p.isCrit = false;
            p.pierce = false;
            p.chainCount = 0;
        }

        /**
         * Spawn a new projectile from a config object.
         * @param {Object} config - Projectile parameters from Tower.fire().
         */
        spawn(config) {
            const p = this.pool.get();
            p.x = config.x;
            p.y = config.y;
            p.target = config.target;
            p.targetX = config.target ? config.target.x : config.x;
            p.targetY = config.target ? config.target.y : config.y;
            p.damage = config.damage || 0;
            p.speed  = config.speed  || 5;
            p.splash = config.splash || 0;
            p.type    = config.type    || '';
            p.special = config.special || '';
            p.active  = true;
            p.isCrit  = config.isCrit || false;
            p.pierce  = config.pierce || false;
            p.piercedEnemies = [];
            p.tower   = config.tower  || null;
            p.chainCount   = config.chainCount   || 0;
            p.chainFalloff = config.chainFalloff || 0;
            p.slowAmount   = config.slowAmount   || 0;
            p.slowDuration = config.slowDuration || 0;
            p.poisonDamage   = config.poisonDamage   || 0;
            p.poisonDuration = config.poisonDuration || 0;
            p.firezoneDuration = config.firezoneDuration || 0;
            p.firezoneDPS      = config.firezoneDPS      || 0;
            p.antiAir = config.antiAir || false;
            p.trail   = [];

            // Compute initial direction
            const a = angle(p.x, p.y, p.targetX, p.targetY);
            p.dx = Math.cos(a) * p.speed;
            p.dy = Math.sin(a) * p.speed;

            return p;
        }

        /**
         * Update all active projectiles.
         * @param {number} dt - Delta time (ms).
         */
        update(dt) {
            const now = Date.now();
            const enemies = this.enemiesRef || [];
            const game = this.gameRef;
            const dtScale = dt / 16.67; // normalise to ~60fps step

            this.pool.forEach((p) => {
                if (!p.active) return;

                // Store trail point
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > 6) p.trail.shift();

                // Update target position (homing)
                if (p.target && p.target.active && p.target.hp > 0) {
                    p.targetX = p.target.x;
                    p.targetY = p.target.y;
                }

                // Steer toward target
                const a = angle(p.x, p.y, p.targetX, p.targetY);
                p.dx = Math.cos(a) * p.speed;
                p.dy = Math.sin(a) * p.speed;

                // Move
                p.x += p.dx * dtScale;
                p.y += p.dy * dtScale;

                // Collision check: within 8px of target position
                const d = dist(p.x, p.y, p.targetX, p.targetY);
                if (d < 8) {
                    this._onHit(p, enemies, game, now);
                }

                // Off-screen cleanup
                if (p.x < -50 || p.x > canvasWidth + 50 ||
                    p.y < -50 || p.y > canvasHeight + 50) {
                    this.pool.release(p);
                }
            });
        }

        /**
         * Handle projectile impact.
         *
         * @param {Object}  p       - The projectile.
         * @param {Enemy[]} enemies - Active enemy list.
         * @param {GameManager} game
         * @param {number}  now     - Current timestamp.
         */
        _onHit(p, enemies, game, now) {
            // Direct hit on target
            if (p.target && p.target.active && p.target.hp > 0) {
                let dmg = p.damage;

                // Anti-air bonus: +20% vs flying
                if (p.antiAir && p.target.flying) {
                    dmg = Math.round(dmg * 1.2);
                }

                p.target.takeDamage(dmg, p.tower, game);

                // Apply slow effect
                if (p.slowAmount > 0 && p.slowDuration > 0) {
                    p.target.slowEffects.push({
                        amount: p.slowAmount,
                        until: now + p.slowDuration
                    });
                }

                // Apply poison effect
                if (p.poisonDamage > 0 && p.poisonDuration > 0) {
                    p.target.poisonEffects.push({
                        dps: p.poisonDamage / (p.poisonDuration / 1000),
                        until: now + p.poisonDuration,
                        slowAmount: p.slowAmount || 0
                    });
                }
            }

            // Splash damage
            if (p.splash > 0) {
                for (const enemy of enemies) {
                    if (!enemy.active || enemy.hp <= 0) continue;
                    if (enemy === p.target) continue; // already hit
                    const d = dist(p.x, p.y, enemy.x, enemy.y);
                    if (d <= p.splash) {
                        const falloff = 1 - (d / p.splash) * 0.5; // 50% damage falloff at edge
                        const splashDmg = Math.round(p.damage * falloff);
                        enemy.takeDamage(splashDmg, p.tower, game);
                    }
                }
                // Splash particle burst
                if (game && game.particleSystem) {
                    game.particleSystem.emit(p.x, p.y, 8, '#ff8800', 2, 1.5, 400, 2);
                }
            }

            // Chain lightning: jump to additional targets
            if (p.chainCount > 0) {
                this._chainLightning(p, enemies, game, now);
            }

            // Fire zone: spawn a persistent damage area
            if (p.firezoneDuration > 0 && p.firezoneDPS > 0) {
                if (this.fireZonesRef) {
                    this.fireZonesRef.push(
                        new FireZone(p.x, p.y, p.splash || 40, p.firezoneDPS, p.firezoneDuration)
                    );
                }
            }

            // Pierce: continue through and hit more targets
            if (p.pierce) {
                if (p.target) p.piercedEnemies.push(p.target);
                // Find next target in the line of travel
                let nextTarget = null;
                let nextDist = Infinity;
                for (const enemy of enemies) {
                    if (!enemy.active || enemy.hp <= 0) continue;
                    if (p.piercedEnemies.includes(enemy)) continue;
                    const d = dist(p.x, p.y, enemy.x, enemy.y);
                    if (d < nextDist && d < 200) { // look ahead 200px
                        // Check if enemy is roughly in the direction of travel
                        const aToEnemy = angle(p.x, p.y, enemy.x, enemy.y);
                        const aTravel  = Math.atan2(p.dy, p.dx);
                        const angleDiff = Math.abs(aToEnemy - aTravel);
                        const normDiff  = angleDiff > Math.PI ? (2 * Math.PI - angleDiff) : angleDiff;
                        if (normDiff < Math.PI / 4) { // within 45 degree cone
                            nextDist   = d;
                            nextTarget = enemy;
                        }
                    }
                }
                if (nextTarget) {
                    p.target  = nextTarget;
                    p.targetX = nextTarget.x;
                    p.targetY = nextTarget.y;
                    p.damage  = Math.round(p.damage * 0.8); // 20% damage falloff per pierce
                    return; // don't release  keep flying
                }
            }

            // Hit particle
            if (game && game.particleSystem) {
                const col = p.isCrit ? '#ff0' : (TOWER_DEFS[p.type] ? TOWER_DEFS[p.type].color : '#fff');
                game.particleSystem.emit(p.x, p.y, p.isCrit ? 6 : 3, col, 1.5, 1, 250, 2);
            }

            // Release projectile
            this.pool.release(p);
        }

        /**
         * Chain lightning: spawn instant hits to nearby enemies.
         *
         * @param {Object}  p       - Source projectile.
         * @param {Enemy[]} enemies - Active enemy list.
         * @param {GameManager} game
         * @param {number}  now
         */
        _chainLightning(p, enemies, game, now) {
            const hit = [p.target]; // enemies already hit
            let lastX = p.x;
            let lastY = p.y;
            let dmg   = p.damage;

            for (let c = 0; c < p.chainCount; c++) {
                dmg = Math.round(dmg * p.chainFalloff);
                if (dmg < 1) break;

                let nearest = null;
                let nearDist = Infinity;

                for (const enemy of enemies) {
                    if (!enemy.active || enemy.hp <= 0) continue;
                    if (hit.includes(enemy)) continue;
                    const d = dist(lastX, lastY, enemy.x, enemy.y);
                    if (d < nearDist && d < 150) { // chain range = 150px
                        nearDist = d;
                        nearest  = enemy;
                    }
                }

                if (!nearest) break;

                nearest.takeDamage(dmg, p.tower, game);

                // Apply slow to chain targets too
                if (p.slowAmount > 0 && p.slowDuration > 0) {
                    nearest.slowEffects.push({
                        amount: p.slowAmount * 0.5, // half slow on chains
                        until: now + p.slowDuration
                    });
                }

                // Lightning visual: line between chain points
                if (game && game.particleSystem) {
                    // Emit particles along the chain line
                    const steps = 4;
                    for (let s = 0; s < steps; s++) {
                        const t  = s / steps;
                        const px = lerp(lastX, nearest.x, t) + randFloat(-5, 5);
                        const py = lerp(lastY, nearest.y, t) + randFloat(-5, 5);
                        game.particleSystem.emitTrail(px, py, '#FFD700');
                    }
                }

                hit.push(nearest);
                lastX = nearest.x;
                lastY = nearest.y;
            }
        }

        /**
         * Render all active projectiles.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} alpha - Interpolation alpha.
         */
        render(ctx, alpha) {
            this.pool.forEach((p) => {
                if (!p.active) return;

                // Trail
                if (p.trail.length > 1) {
                    const trailColor = TOWER_DEFS[p.type] ? TOWER_DEFS[p.type].color : '#fff';
                    ctx.strokeStyle = trailColor;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    for (let i = 1; i < p.trail.length; i++) {
                        ctx.lineTo(p.trail[i].x, p.trail[i].y);
                    }
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Projectile body
                const color = TOWER_DEFS[p.type] ? TOWER_DEFS[p.type].color : '#fff';
                const radius = p.isCrit ? 5 : 3;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Crit glow
                if (p.isCrit) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius + 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
        }
    }


    // ==================== PARTICLE SYSTEM ====================

    /**
     * Manages visual-only particles for effects like explosions,
     * tower firing, enemy death, trails, and ring pulses.
     *
     * Uses an ObjectPool for efficiency.
     */
    class ParticleSystem {
        /**
         * @param {number} poolSize - Number of particles to pre-allocate.
         */
        constructor(poolSize) {
            this.pool = new ObjectPool(
                () => this._createParticle(),
                (p) => this._resetParticle(p),
                poolSize || POOL_PARTICLES
            );
        }

        /** Factory: blank particle. */
        _createParticle() {
            return {
                x: 0, y: 0,
                vx: 0, vy: 0,
                life: 0,
                maxLife: 0,
                color: '#fff',
                size: 2,
                alpha: 1,
                type: 'default' // 'default', 'ring', 'trail'
            };
        }

        /** Reset particle to blank state. */
        _resetParticle(p) {
            p.life = 0;
            p.alpha = 0;
        }

        /**
         * Emit a burst of particles from a point.
         *
         * @param {number} x      - Centre X.
         * @param {number} y      - Centre Y.
         * @param {number} count  - Number of particles.
         * @param {string} color  - CSS colour.
         * @param {number} spread - Random spread multiplier.
         * @param {number} speed  - Base speed.
         * @param {number} life   - Lifetime (ms).
         * @param {number} size   - Particle radius.
         */
        emit(x, y, count, color, spread, speed, life, size) {
            for (let i = 0; i < count; i++) {
                const p = this.pool.get();
                p.x = x + randFloat(-spread, spread);
                p.y = y + randFloat(-spread, spread);
                const a = randFloat(0, Math.PI * 2);
                const s = randFloat(speed * 0.5, speed * 1.5);
                p.vx = Math.cos(a) * s;
                p.vy = Math.sin(a) * s;
                p.color   = color;
                p.size    = size || 2;
                p.life    = 0;
                p.maxLife = life || 500;
                p.alpha   = 1;
                p.type    = 'default';
            }
        }

        /**
         * Emit a ring of particles expanding outward from a centre point.
         *
         * @param {number} x      - Centre X.
         * @param {number} y      - Centre Y.
         * @param {number} radius - Ring radius.
         * @param {string} color  - CSS colour.
         * @param {number} count  - Number of particles.
         */
        emitRing(x, y, radius, color, count) {
            for (let i = 0; i < count; i++) {
                const p = this.pool.get();
                const a = (Math.PI * 2 / count) * i;
                p.x = x + Math.cos(a) * radius;
                p.y = y + Math.sin(a) * radius;
                p.vx = Math.cos(a) * 1.5;
                p.vy = Math.sin(a) * 1.5;
                p.color   = color;
                p.size    = 2;
                p.life    = 0;
                p.maxLife = 400;
                p.alpha   = 0.8;
                p.type    = 'ring';
            }
        }

        /**
         * Emit a single trail particle (used for chain lightning, etc.).
         *
         * @param {number} x     - X position.
         * @param {number} y     - Y position.
         * @param {string} color - CSS colour.
         */
        emitTrail(x, y, color) {
            const p = this.pool.get();
            p.x = x;
            p.y = y;
            p.vx = randFloat(-0.3, 0.3);
            p.vy = randFloat(-0.5, -0.1);
            p.color   = color;
            p.size    = randFloat(1, 2.5);
            p.life    = 0;
            p.maxLife = 300;
            p.alpha   = 0.9;
            p.type    = 'trail';
        }

        /**
         * Update all active particles.
         * @param {number} dt - Delta time (ms).
         */
        update(dt) {
            this.pool.forEach((p) => {
                p.life += dt;
                if (p.life >= p.maxLife) {
                    this.pool.release(p);
                    return;
                }
                // Move
                p.x += p.vx * (dt / 16.67);
                p.y += p.vy * (dt / 16.67);
                // Fade
                const progress = p.life / p.maxLife;
                p.alpha = 1 - progress;
                // Shrink
                if (p.type === 'default') {
                    p.size = Math.max(0.5, p.size * (1 - progress * 0.02));
                }
            });
        }

        /**
         * Render all active particles.
         * @param {CanvasRenderingContext2D} ctx
         */
        render(ctx) {
            this.pool.forEach((p) => {
                if (p.alpha <= 0) return;
                ctx.globalAlpha = clamp(p.alpha, 0, 1);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.max(0.5, p.size), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
    }


    // ==================== FIRE ZONE ====================

    /**
     * Persistent area-of-effect damage zone left by mortar towers
     * or bomber enemies.  Damages all enemies standing inside each frame.
     */
    class FireZone {
        /**
         * @param {number} x        - Centre X.
         * @param {number} y        - Centre Y.
         * @param {number} radius   - Effect radius (px).
         * @param {number} dps      - Damage per second.
         * @param {number} duration - How long the zone lasts (ms).
         */
        constructor(x, y, radius, dps, duration) {
            this.x = x;
            this.y = y;
            this.radius   = radius;
            this.dps      = dps;
            this.duration = duration;
            this.elapsed  = 0;
            this.active   = true;
        }

        /**
         * Advance the zone timer and damage enemies inside.
         *
         * @param {number}  dt      - Delta time (ms).
         * @param {Enemy[]} enemies - Active enemy list.
         * @param {GameManager} game
         */
        update(dt, enemies, game) {
            this.elapsed += dt;
            if (this.elapsed >= this.duration) {
                this.active = false;
                return;
            }
            for (const enemy of enemies) {
                if (!enemy.active || enemy.hp <= 0) continue;
                const d = dist(this.x, this.y, enemy.x, enemy.y);
                if (d <= this.radius) {
                    enemy.takeDamage(this.dps * (dt / 1000), null, game);
                }
            }
        }

        /**
         * Render the fire zone as a fading translucent circle.
         * @param {CanvasRenderingContext2D} ctx
         */
        render(ctx) {
            const progress = this.elapsed / this.duration;
            ctx.globalAlpha = 0.3 * (1 - progress);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#FF4500';
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }


    // ==================== TOWER MANAGER ====================

    /**
     * Manages all placed towers, the placement grid, fire zones,
     * tower selection, and command-tower buff distribution.
     */
    class TowerManager {
        constructor() {
            /** All currently placed towers. */
            this.towers = [];

            /** Currently selected tower (for upgrade/sell UI). */
            this.selectedTower = null;

            /** Currently selected tower type for placement (TOWER_DEFS key). */
            this.selectedType = null;

            /**
             * 2D grid tracking tower occupancy.
             * Initialised by initGrid() when a game starts.
             * null = not built yet, Tower ref = occupied.
             */
            this.grid = [];

            /** Active fire zones (from mortar / bombers). */
            this.fireZones = [];
        }

        /**
         * Initialise the tower grid for the current map dimensions.
         * Call this when a new game starts.
         *
         * @param {number} cols - Grid columns.
         * @param {number} rows - Grid rows.
         */
        initGrid(cols, rows) {
            this.grid = [];
            for (let c = 0; c < cols; c++) {
                this.grid[c] = [];
                for (let r = 0; r < rows; r++) {
                    this.grid[c][r] = null;
                }
            }
            this.towers     = [];
            this.fireZones  = [];
            this.selectedTower = null;
            this.selectedType  = null;
        }

        /**
         * Check whether a grid cell is valid and unoccupied.
         *
         * @param {number} col
         * @param {number} row
         * @param {GameManager} game - For checking path cells.
         * @returns {boolean}
         */
        canPlace(col, row, game) {
            // Out of bounds
            if (col < 0 || row < 0 || col >= gridCols || row >= gridRows) return false;
            // Already occupied
            if (this.grid[col] && this.grid[col][row]) return false;
            // On a path cell (checked via mapRenderer if available)
            if (game && game.mapRenderer && game.mapRenderer.isPathCell) {
                if (game.mapRenderer.isPathCell(col, row)) return false;
            }
            return true;
        }

        /**
         * Place a tower on the grid.
         *
         * @param {string}      type - Key into TOWER_DEFS.
         * @param {number}      col  - Grid column.
         * @param {number}      row  - Grid row.
         * @param {GameManager} game
         * @returns {Tower|null} The placed tower, or null on failure.
         */
        placeTower(type, col, row, game) {
            const def = TOWER_DEFS[type];
            if (!def) return null;

            // Validate placement
            if (!this.canPlace(col, row, game)) return null;

            // Check affordability
            if (!game || game.gold < def.cost) return null;

            // Deduct gold
            game.spendGold(def.cost);

            // Create tower
            const tower = new Tower(type, col, row);
            this.towers.push(tower);
            if (this.grid[col]) this.grid[col][row] = tower;

            // Place particle effect
            if (game.particleSystem) {
                game.particleSystem.emit(tower.x, tower.y, 10, def.color, 5, 1.5, 400, 2);
            }

            // Sound
            if (game.audioEngine) game.audioEngine.playPlaceTower();

            return tower;
        }

        /**
         * Sell a tower, refunding 70% of total investment.
         *
         * @param {Tower}       tower
         * @param {GameManager} game
         */
        sellTower(tower, game) {
            const refund = tower.getSellValue();
            if (game) game.addGold(refund);

            // Remove from grid
            if (this.grid[tower.col]) {
                this.grid[tower.col][tower.row] = null;
            }

            // Remove from towers array
            const idx = this.towers.indexOf(tower);
            if (idx !== -1) this.towers.splice(idx, 1);

            // Clear selection
            if (this.selectedTower === tower) this.selectedTower = null;

            // Sell particle
            if (game && game.particleSystem) {
                game.particleSystem.emit(tower.x, tower.y, 8, '#feca57', 3, 1, 300, 2);
            }
            // Sell sound
            if (game && game.audioEngine) game.audioEngine.playSellTower();

            // Floating gold number
            if (game) game.addDamageNum(tower.x, tower.y - 20, `+${refund}g`, '#feca57');
        }

        /**
         * Upgrade a tower to its next level.
         *
         * @param {Tower}       tower
         * @param {GameManager} game
         * @returns {boolean} True if the upgrade succeeded.
         */
        upgradeTower(tower, game) {
            const cost = tower.getUpgradeCost();
            if (cost < 0) return false; // max level
            if (!game || game.gold < cost) return false;

            game.spendGold(cost);
            tower.upgrade();

            // Upgrade particle effect
            if (game.particleSystem) {
                game.particleSystem.emit(tower.x, tower.y, 12, '#feca57', 4, 2, 500, 3);
            }
            // Upgrade sound
            if (game.audioEngine) game.audioEngine.playUpgradeTower();

            return true;
        }

        /**
         * Update all towers each tick.
         *
         * Applies command tower buffs, then updates each tower.
         *
         * @param {number}      dt      - Delta time (ms).
         * @param {Enemy[]}     enemies - Active enemy list.
         * @param {GameManager} game
         */
        update(dt, enemies, game) {
            const now = Date.now();

            // ---- Reset all buff values ----
            for (const t of this.towers) {
                t.buffDamage = 0;
                t.buffSpeed  = 0;
            }

            // ---- Apply command tower buffs ----
            for (const cmd of this.towers) {
                if (cmd.def.special !== 'buff') continue;
                if (cmd.disabledUntil && now < cmd.disabledUntil) continue;
                const r = cmd.getEffectiveRange();
                for (const t of this.towers) {
                    if (t === cmd) continue;
                    const d = dist(cmd.x, cmd.y, t.x, t.y);
                    if (d <= r) {
                        t.buffDamage += cmd.def.buffDamage || 0;
                        t.buffSpeed  += cmd.def.buffSpeed  || 0;
                    }
                }
            }

            // ---- Update towers ----
            for (const t of this.towers) {
                t.update(dt, now, enemies, game);
            }

            // ---- Update fire zones ----
            for (let i = this.fireZones.length - 1; i >= 0; i--) {
                this.fireZones[i].update(dt, enemies, game);
                if (!this.fireZones[i].active) {
                    this.fireZones.splice(i, 1);
                }
            }
        }

        /**
         * Render all towers, fire zones, and UI overlays
         * (range circles, placement ghosts).
         *
         * @param {CanvasRenderingContext2D} ctx
         */
        render(ctx) {
            // Fire zones (render below towers)
            for (const fz of this.fireZones) {
                fz.render(ctx);
            }

            // Towers
            for (const t of this.towers) {
                t.render(ctx);
            }

            // Selected tower range ring
            if (this.selectedTower) {
                const t = this.selectedTower;
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                ctx.lineWidth   = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(t.x, t.y, t.getEffectiveRange(), 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }

            // Placement ghost (when a tower type is selected for building)
            if (this.selectedType && this._ghostCol != null && this._ghostRow != null) {
                const def = TOWER_DEFS[this.selectedType];
                if (def) {
                    const gx = this._ghostCol * GRID_SIZE + GRID_SIZE / 2;
                    const gy = topBarHeight + this._ghostRow * GRID_SIZE + GRID_SIZE / 2;

                    // Range circle
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = def.color;
                    ctx.beginPath();
                    ctx.arc(gx, gy, def.range, 0, Math.PI * 2);
                    ctx.fill();

                    // Tower preview
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = def.color;
                    ctx.beginPath();
                    ctx.arc(gx, gy, GRID_SIZE / 2 * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        /**
         * Set the ghost placement position (for rendering preview).
         *
         * @param {number|null} col
         * @param {number|null} row
         */
        setGhostPosition(col, row) {
            this._ghostCol = col;
            this._ghostRow = row;
        }

        /**
         * Clear all state (for game restart).
         */
        reset() {
            this.towers     = [];
            this.fireZones  = [];
            this.selectedTower = null;
            this.selectedType  = null;
            this.grid = [];
        }
    }


    // ================================================================
    // ==           END OF PHASE 2  GAME ENTITIES                   ==
    // ================================================================


    // ================================================================
    // ==                                                            ==
    // ==                   PHASE 3  MAPS, WAVES, BOSSES           ==
    // ==                                                            ==
    // ================================================================


    // ==================== MAP DEFINITIONS ====================

    /**
     * MAP_DEFS  array of 8 map definitions.
     *
     * Each map specifies:
     *   - name / theme / difficulty / colours
     *   - description and bossType key
     *   - paths  array of path objects with waypoints in grid coordinates
     *   - hazards  environmental zones with gameplay effects
     *   - ambientParticles  theme-specific background particle config
     */
    const MAP_DEFS = [
        // ---- Map 0: Emerald Forest (difficulty 1) ----
        {
            name: 'Emerald Forest',
            theme: 'forest',
            difficulty: 1,
            bgColor: '#1a2e1a',
            pathColor: '#8B7355',
            gridColor: 'rgba(255,255,255,0.03)',
            description: 'A winding path through the ancient woods',
            bossType: 'forestGuardian',
            paths: [
                { waypoints: [
                    {x:0, y:5}, {x:3, y:5}, {x:3, y:2}, {x:7, y:2}, {x:7, y:8},
                    {x:11, y:8}, {x:11, y:4}, {x:15, y:4}, {x:15, y:7}, {x:19, y:7},
                    {x:19, y:3}, {x:23, y:3}, {x:23, y:9}, {x:27, y:9}
                ]}
            ],
            hazards: [
                { type: 'fog', zones: [{col:5, row:3, radius:3}, {col:16, row:6, radius:2}], effect: {rangeReduction: 0.3} }
            ],
            ambientParticles: { color: '#4a7c4a', count: 15, speed: 0.3 }
        },
        // ---- Map 1: Scorching Sands (difficulty 2)  2 entry points merging ----
        {
            name: 'Scorching Sands',
            theme: 'desert',
            difficulty: 2,
            bgColor: '#2e2a1a',
            pathColor: '#C4A36E',
            gridColor: 'rgba(255,255,255,0.03)',
            description: 'Desert canyon with treacherous quicksand',
            bossType: 'sandWyrm',
            paths: [
                { waypoints: [{x:0, y:2}, {x:5, y:2}, {x:5, y:5}, {x:10, y:5}, {x:10, y:8}, {x:15, y:8}, {x:15, y:5}, {x:20, y:5}, {x:20, y:8}, {x:27, y:8}] },
                { waypoints: [{x:0, y:10}, {x:4, y:10}, {x:4, y:7}, {x:8, y:7}, {x:8, y:5}, {x:10, y:5}, {x:10, y:8}, {x:15, y:8}, {x:15, y:5}, {x:20, y:5}, {x:20, y:8}, {x:27, y:8}] }
            ],
            hazards: [
                { type: 'quicksand', zones: [{col:10, row:6, radius:2}, {col:18, row:7, radius:2}], effect: {speedReduction: 0.3, projectileSlowdown: 0.2} }
            ],
            ambientParticles: { color: '#c4a36e', count: 20, speed: 0.5 }
        },
        // ---- Map 2: Frozen Peaks (difficulty 2) ----
        {
            name: 'Frozen Peaks',
            theme: 'ice',
            difficulty: 2,
            bgColor: '#1a2030',
            pathColor: '#9BB8CD',
            gridColor: 'rgba(200,220,255,0.04)',
            description: 'Winding mountain trail through the blizzard',
            bossType: 'frostTitan',
            paths: [
                { waypoints: [{x:0, y:1}, {x:4, y:1}, {x:4, y:4}, {x:8, y:4}, {x:8, y:1}, {x:13, y:1}, {x:13, y:6}, {x:9, y:6}, {x:9, y:9}, {x:14, y:9}, {x:14, y:4}, {x:19, y:4}, {x:19, y:9}, {x:24, y:9}, {x:24, y:5}, {x:27, y:5}] }
            ],
            hazards: [
                { type: 'ice', zones: [{col:6, row:3, radius:2}, {col:15, row:5, radius:2}, {col:22, row:7, radius:2}], effect: {fireRateReduction: 0.2} }
            ],
            ambientParticles: { color: '#cce5ff', count: 30, speed: 0.8 }
        },
        // ---- Map 3: Volcanic Forge (difficulty 3) ----
        {
            name: 'Volcanic Forge',
            theme: 'volcanic',
            difficulty: 3,
            bgColor: '#2e1a1a',
            pathColor: '#8B6B4F',
            gridColor: 'rgba(255,100,50,0.04)',
            description: 'Active volcano with lava bridges',
            bossType: 'magmaColossus',
            paths: [
                { waypoints: [{x:0, y:5}, {x:4, y:5}, {x:4, y:2}, {x:9, y:2}, {x:9, y:5}, {x:14, y:5}, {x:14, y:9}, {x:18, y:9}, {x:18, y:3}, {x:22, y:3}, {x:22, y:7}, {x:27, y:7}] }
            ],
            hazards: [
                { type: 'lava', zones: [{col:9, row:4, radius:1}, {col:14, row:7, radius:1}], effect: {enemyDPS: 2, towerDamage: 0.1} },
                { type: 'eruption', zones: [{col:12, row:5, radius:3}], effect: {towerDamageChance: 0.01, towerDamageAmount: 10} }
            ],
            ambientParticles: { color: '#ff6a33', count: 25, speed: 1.0 }
        },
        // ---- Map 4: Void Expanse (difficulty 3) ----
        {
            name: 'Void Expanse',
            theme: 'void',
            difficulty: 3,
            bgColor: '#15091e',
            pathColor: '#6a4c93',
            gridColor: 'rgba(150,100,200,0.04)',
            description: 'Floating islands in the abyss',
            bossType: 'voidSovereign',
            paths: [
                { waypoints: [{x:0, y:5}, {x:5, y:5}, {x:5, y:2}, {x:10, y:2}, {x:10, y:8}, {x:15, y:8}, {x:15, y:3}, {x:20, y:3}, {x:20, y:7}, {x:27, y:7}] }
            ],
            hazards: [
                { type: 'voidZone', zones: [{col:7, row:5, radius:2}, {col:17, row:5, radius:2}], effect: {disablePlacement: true} }
            ],
            ambientParticles: { color: '#9b59b6', count: 18, speed: 0.4 }
        },
        // ---- Map 5: Crystal Caverns (difficulty 4)  3 entry points merging ----
        {
            name: 'Crystal Caverns',
            theme: 'crystal',
            difficulty: 4,
            bgColor: '#1a1a2e',
            pathColor: '#7B68AE',
            gridColor: 'rgba(180,160,255,0.04)',
            description: 'Underground caves with prismatic crystals',
            bossType: 'crystalEmpress',
            paths: [
                { waypoints: [{x:0, y:2}, {x:5, y:2}, {x:5, y:5}, {x:12, y:5}, {x:12, y:8}, {x:20, y:8}, {x:20, y:5}, {x:27, y:5}] },
                { waypoints: [{x:0, y:6}, {x:4, y:6}, {x:4, y:5}, {x:12, y:5}, {x:12, y:8}, {x:20, y:8}, {x:20, y:5}, {x:27, y:5}] },
                { waypoints: [{x:0, y:10}, {x:6, y:10}, {x:6, y:8}, {x:12, y:8}, {x:12, y:8}, {x:20, y:8}, {x:20, y:5}, {x:27, y:5}] }
            ],
            hazards: [
                { type: 'crystal', zones: [{col:8, row:4, radius:2}, {col:16, row:7, radius:2}], effect: {towerRangeBoost: 0.25, enemySpeedBoost: 0.1} }
            ],
            ambientParticles: { color: '#b388ff', count: 20, speed: 0.6 }
        },
        // ---- Map 6: Cyber Grid (difficulty 4) ----
        {
            name: 'Cyber Grid',
            theme: 'cyber',
            difficulty: 4,
            bgColor: '#0a0a1a',
            pathColor: '#00e5ff',
            gridColor: 'rgba(0,229,255,0.06)',
            description: 'Neon circuit board with shifting paths',
            bossType: 'cyberOverlord',
            paths: [
                { waypoints: [{x:0, y:3}, {x:5, y:3}, {x:5, y:7}, {x:10, y:7}, {x:10, y:3}, {x:15, y:3}, {x:15, y:9}, {x:20, y:9}, {x:20, y:5}, {x:27, y:5}] }
            ],
            hazards: [
                { type: 'emp', zones: [{col:8, row:5, radius:3}, {col:18, row:6, radius:3}], effect: {disableDuration: 2000, empInterval: 15000} }
            ],
            ambientParticles: { color: '#00e5ff', count: 25, speed: 1.2 }
        },
        // ---- Map 7: The Convergence (difficulty 5)  final map ----
        {
            name: 'The Convergence',
            theme: 'convergence',
            difficulty: 5,
            bgColor: '#1a0a20',
            pathColor: '#ff6b9d',
            gridColor: 'rgba(255,107,157,0.04)',
            description: 'All biomes merged in unstable reality',
            bossType: 'convergence',
            paths: [
                { waypoints: [{x:0, y:3}, {x:4, y:3}, {x:4, y:7}, {x:8, y:7}, {x:8, y:2}, {x:13, y:2}, {x:13, y:9}, {x:17, y:9}, {x:17, y:4}, {x:21, y:4}, {x:21, y:8}, {x:27, y:8}] },
                { waypoints: [{x:0, y:9}, {x:3, y:9}, {x:3, y:6}, {x:7, y:6}, {x:7, y:9}, {x:13, y:9}, {x:13, y:9}, {x:17, y:9}, {x:17, y:4}, {x:21, y:4}, {x:21, y:8}, {x:27, y:8}] }
            ],
            hazards: [
                { type: 'fog', zones: [{col:5, row:5, radius:2}], effect: {rangeReduction: 0.3} },
                { type: 'lava', zones: [{col:10, row:5, radius:1}], effect: {enemyDPS: 2} },
                { type: 'ice', zones: [{col:19, row:5, radius:2}], effect: {fireRateReduction: 0.2} },
                { type: 'emp', zones: [{col:24, row:7, radius:2}], effect: {disableDuration: 2000, empInterval: 20000} }
            ],
            ambientParticles: { color: '#ff6b9d', count: 30, speed: 0.7 }
        }
    ];


    // ==================== MAP RENDERER ====================

    /**
     * Renders map terrain, paths, grid overlay, and hazard zones.
     *
     * Builds a static off-screen canvas cache so the background only
     * needs to be redrawn when the map changes or the viewport resizes.
     * Also marks which grid cells are path cells (for tower placement
     * validation) and converts grid-coordinate waypoints to pixel
     * coordinates for enemy pathing.
     */
    class MapRenderer {
        /**
         * @param {Object} mapDef - An entry from MAP_DEFS.
         */
        constructor(mapDef) {
            this.mapDef = mapDef;
            this.staticCanvas = null;
            this.staticCtx = null;
            this.pathCells = new Set(); // stored as "col,row" strings
            this.buildPathCells();
            this.rebuildCache();
        }

        // --------------------------------------------------
        //  Path cell computation
        // --------------------------------------------------

        /**
         * Walk every pair of consecutive waypoints in every path
         * and mark the grid cells they cross (assumes axis-aligned
         * horizontal or vertical segments between waypoints).
         */
        buildPathCells() {
            this.pathCells.clear();
            for (const path of this.mapDef.paths) {
                const wp = path.waypoints;
                for (let i = 0; i < wp.length - 1; i++) {
                    const x0 = wp[i].x, y0 = wp[i].y;
                    const x1 = wp[i + 1].x, y1 = wp[i + 1].y;
                    const dx = Math.abs(x1 - x0);
                    const dy = Math.abs(y1 - y0);

                    if (dx === 0) {
                        // Vertical segment
                        const minY = Math.min(y0, y1);
                        const maxY = Math.max(y0, y1);
                        for (let y = minY; y <= maxY; y++) {
                            this.pathCells.add(`${x0},${y}`);
                        }
                    } else if (dy === 0) {
                        // Horizontal segment
                        const minX = Math.min(x0, x1);
                        const maxX = Math.max(x0, x1);
                        for (let x = minX; x <= maxX; x++) {
                            this.pathCells.add(`${x},${y0}`);
                        }
                    } else {
                        // Diagonal fallback  rasterise with Bresenham
                        let cx = x0, cy = y0;
                        const sx = x0 < x1 ? 1 : -1;
                        const sy = y0 < y1 ? 1 : -1;
                        let err = dx - dy;
                        while (true) {
                            this.pathCells.add(`${cx},${cy}`);
                            if (cx === x1 && cy === y1) break;
                            const e2 = 2 * err;
                            if (e2 > -dy) { err -= dy; cx += sx; }
                            if (e2 < dx) { err += dx; cy += sy; }
                        }
                    }
                }
            }
        }

        /**
         * @param {number} col - Grid column.
         * @param {number} row - Grid row.
         * @returns {boolean} True if this cell is on a path.
         */
        isPathCell(col, row) {
            return this.pathCells.has(`${col},${row}`);
        }

        /**
         * @param {number} col - Grid column.
         * @param {number} row - Grid row.
         * @returns {boolean} True if a tower can be placed on this cell.
         */
        isPlaceable(col, row) {
            if (col < 0 || col >= gridCols || row < 0 || row >= gridRows) return false;
            if (this.isPathCell(col, row)) return false;

            // Hazard zones that forbid placement
            for (const h of this.mapDef.hazards) {
                if (h.effect.disablePlacement) {
                    for (const z of h.zones) {
                        if (dist(col, row, z.col, z.row) <= z.radius) return false;
                    }
                }
            }
            return true;
        }

        // --------------------------------------------------
        //  Static canvas cache
        // --------------------------------------------------

        /**
         * Rebuild the off-screen background cache.
         * Call after map load or viewport resize.
         */
        rebuildCache() {
            this.staticCanvas = document.createElement('canvas');
            this.staticCanvas.width = canvasWidth * dpr;
            this.staticCanvas.height = canvasHeight * dpr;
            this.staticCtx = this.staticCanvas.getContext('2d');
            this.staticCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            this.drawStatic(this.staticCtx);
        }

        /**
         * Draw every static layer onto the given context:
         *   1. Background fill
         *   2. Grid lines
         *   3. Path cell fills
         *   4. Smooth path lines
         *   5. Hazard zone overlays
         */
        drawStatic(ctx) {
            // 1  Background
            ctx.fillStyle = this.mapDef.bgColor;
            ctx.fillRect(0, topBarHeight, gameAreaWidth, gameAreaHeight);

            // 2  Grid lines
            ctx.strokeStyle = this.mapDef.gridColor;
            ctx.lineWidth = 0.5;
            for (let c = 0; c <= gridCols; c++) {
                ctx.beginPath();
                ctx.moveTo(c * GRID_SIZE, topBarHeight);
                ctx.lineTo(c * GRID_SIZE, topBarHeight + gridRows * GRID_SIZE);
                ctx.stroke();
            }
            for (let r = 0; r <= gridRows; r++) {
                ctx.beginPath();
                ctx.moveTo(0, topBarHeight + r * GRID_SIZE);
                ctx.lineTo(gridCols * GRID_SIZE, topBarHeight + r * GRID_SIZE);
                ctx.stroke();
            }

            // 3  Path cell fills
            ctx.fillStyle = this.mapDef.pathColor;
            for (const key of this.pathCells) {
                const [c, r] = key.split(',').map(Number);
                ctx.fillRect(
                    c * GRID_SIZE + 1,
                    topBarHeight + r * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2
                );
            }

            // 4  Smooth path centre lines
            for (const path of this.mapDef.paths) {
                ctx.strokeStyle = this.mapDef.pathColor;
                ctx.lineWidth = GRID_SIZE * 0.6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                const wp = path.waypoints;
                ctx.moveTo(
                    wp[0].x * GRID_SIZE + GRID_SIZE / 2,
                    topBarHeight + wp[0].y * GRID_SIZE + GRID_SIZE / 2
                );
                for (let i = 1; i < wp.length; i++) {
                    ctx.lineTo(
                        wp[i].x * GRID_SIZE + GRID_SIZE / 2,
                        topBarHeight + wp[i].y * GRID_SIZE + GRID_SIZE / 2
                    );
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // 5  Hazard zone overlays
            for (const h of this.mapDef.hazards) {
                for (const z of h.zones) {
                    const cx = z.col * GRID_SIZE + GRID_SIZE / 2;
                    const cy = topBarHeight + z.row * GRID_SIZE + GRID_SIZE / 2;
                    const radius = z.radius * GRID_SIZE;

                    ctx.globalAlpha = 0.15;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);

                    switch (h.type) {
                        case 'fog':       ctx.fillStyle = '#888888'; break;
                        case 'quicksand': ctx.fillStyle = '#c4a36e'; break;
                        case 'ice':       ctx.fillStyle = '#87CEEB'; break;
                        case 'lava':      ctx.fillStyle = '#ff4500'; break;
                        case 'eruption':  ctx.fillStyle = '#ff6600'; break;
                        case 'voidZone':  ctx.fillStyle = '#6a0dad'; break;
                        case 'crystal':   ctx.fillStyle = '#b388ff'; break;
                        case 'emp':       ctx.fillStyle = '#00e5ff'; break;
                        default:          ctx.fillStyle = '#ffffff';
                    }
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
        }

        // --------------------------------------------------
        //  Rendering
        // --------------------------------------------------

        /**
         * Blit the cached static canvas onto the main canvas context.
         * @param {CanvasRenderingContext2D} ctx
         */
        render(ctx) {
            ctx.drawImage(this.staticCanvas, 0, 0, canvasWidth, canvasHeight);
        }

        // --------------------------------------------------
        //  Pixel-path conversion for enemy pathing
        // --------------------------------------------------

        /**
         * Convert every path's grid-coordinate waypoints to pixel
         * coordinates (centre of the grid cell).
         *
         * @returns {Array<{waypoints: Array<{x: number, y: number}>}>}
         */
        getPixelPaths() {
            return this.mapDef.paths.map(p => ({
                waypoints: p.waypoints.map(wp => ({
                    x: wp.x * GRID_SIZE + GRID_SIZE / 2,
                    y: topBarHeight + wp.y * GRID_SIZE + GRID_SIZE / 2
                }))
            }));
        }
    }


    // ==================== BOSS DEFINITIONS ====================

    /**
     * BOSS_DEFS  keyed lookup for boss stats and abilities.
     *
     * Each boss has:
     *   - hp / speed / armor / gold  base stats (hp is scaled by wave)
     *   - color  primary rendering colour
     *   - abilities  array of ability keys used in sequence
     *   - phases  array of { hpPercent, abilityInterval } describing
     *     phase transitions (checked from highest phase index downward)
     */
    const BOSS_DEFS = {
        forestGuardian: {
            name: 'Forest Guardian',
            hp: 3000, speed: 0.4, armor: 3, gold: 200,
            color: '#2d5a1e',
            abilities: ['vineWall', 'rootTrap', 'healPulse'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 8000 },
                { hpPercent: 0.5, abilityInterval: 5000 }
            ]
        },
        sandWyrm: {
            name: 'Sand Wyrm',
            hp: 4000, speed: 0.35, armor: 5, gold: 250,
            color: '#c4a36e',
            abilities: ['burrow', 'erupt', 'dustCloud'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 10000 },
                { hpPercent: 0.5, abilityInterval: 6000 }
            ]
        },
        frostTitan: {
            name: 'Frost Titan',
            hp: 5000, speed: 0.3, armor: 8, gold: 300,
            color: '#87CEEB',
            abilities: ['iceArmor', 'frozenGround', 'iceShards'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 9000 },
                { hpPercent: 0.4, abilityInterval: 5000 }
            ]
        },
        magmaColossus: {
            name: 'Magma Colossus',
            hp: 6000, speed: 0.25, armor: 10, gold: 350,
            color: '#ff4500',
            abilities: ['lavaTrail', 'eruption', 'moltenShield'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 8000 },
                { hpPercent: 0.5, abilityInterval: 4000 }
            ]
        },
        voidSovereign: {
            name: 'Void Sovereign',
            hp: 4500, speed: 0.45, armor: 5, gold: 300,
            color: '#6a0dad',
            abilities: ['teleportBlink', 'disableTower', 'voidPortal'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 7000 },
                { hpPercent: 0.4, abilityInterval: 4000 }
            ]
        },
        crystalEmpress: {
            name: 'Crystal Empress',
            hp: 5500, speed: 0.35, armor: 6, gold: 350,
            color: '#b388ff',
            abilities: ['crystalShield', 'shatterAttack', 'empowerEnemies'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 8000 },
                { hpPercent: 0.45, abilityInterval: 4500 }
            ]
        },
        cyberOverlord: {
            name: 'Cyber Overlord',
            hp: 7000, speed: 0.3, armor: 8, gold: 400,
            color: '#00e5ff',
            abilities: ['hackTower', 'empPulse', 'spawnDrones'],
            phases: [
                { hpPercent: 1.0, abilityInterval: 10000 },
                { hpPercent: 0.5, abilityInterval: 5000 },
                { hpPercent: 0.2, abilityInterval: 3000 }
            ]
        },
        convergence: {
            name: 'The Convergence',
            hp: 10000, speed: 0.3, armor: 12, gold: 500,
            color: '#ff6b9d',
            abilities: [
                'vineWall', 'burrow', 'iceArmor', 'lavaTrail',
                'teleportBlink', 'crystalShield', 'empPulse', 'spawnDrones'
            ],
            phases: [
                { hpPercent: 1.0, abilityInterval: 8000 },
                { hpPercent: 0.6, abilityInterval: 5000 },
                { hpPercent: 0.3, abilityInterval: 3000 }
            ]
        }
    };


    // ==================== BOSS CLASS ====================

    /**
     * Boss entity  a large, multi-phase enemy with special abilities.
     *
     * Bosses appear on the final wave of each map.  They share the
     * Enemy path-following contract (x, y, prevX, prevY, pathIndex,
     * pathProgress, active, isBoss, flying, cloaked) but have their
     * own damage, phase-transition, and ability systems.
     */
    class Boss {
        /**
         * @param {Object}  bossDef    - Entry from BOSS_DEFS.
         * @param {Array}   pathPoints - Pixel-coordinate waypoints.
         * @param {number}  waveScale  - HP / gold multiplier.
         */
        constructor(bossDef, pathPoints, waveScale) {
            this.def  = bossDef;
            this.name = bossDef.name;

            // Stats (scaled)
            this.hp      = bossDef.hp * waveScale;
            this.maxHp   = this.hp;
            this.speed   = bossDef.speed;
            this.baseSpeed = bossDef.speed;
            this.armor   = bossDef.armor;
            this.gold    = bossDef.gold;
            this.color   = bossDef.color;

            // State flags shared with Enemy interface
            this.active  = true;
            this.isBoss  = true;
            this.flying  = false;
            this.cloaked = false;

            // Path following
            this.pathPoints  = pathPoints;
            this.pathIndex   = 0;
            this.pathProgress = 0;
            this.x     = pathPoints[0].x;
            this.y     = pathPoints[0].y;
            this.prevX = this.x;
            this.prevY = this.y;

            // Status effects (same format as Enemy)
            this.slowEffects   = [];
            this.poisonEffects = [];

            // Ability state
            this.abilities      = bossDef.abilities;
            this.currentPhase   = 0;
            this.lastAbilityTime = 0;
            this.abilityIndex   = 0;
            this.burrowed       = false;
            this.shielded       = false;
            this.shieldHits     = 0;
            this.enraged        = false;

            // Visual / animation
            this.size           = 20;
            this.pulsePhase     = 0;
            this.entranceComplete = false;
            this.entranceTimer  = 0;

            // Tower targeting compatibility
            this.flashUntil     = 0;
            this.type           = 'boss';
            this.spawnTime      = Date.now();
            this.deathTime      = 0;
        }

        // --------------------------------------------------
        //  Damage handling
        // --------------------------------------------------

        /**
         * Apply damage to the boss, accounting for burrow immunity,
         * shield mitigation, and flat armour reduction.
         *
         * @param {number}      amount - Raw damage.
         * @param {Tower|null}  tower  - Source tower (null for DoT).
         * @param {GameManager} game
         */
        takeDamage(amount, tower, game) {
            if (!this.active || this.hp <= 0) return;
            if (this.burrowed) return; // immune while burrowed

            let dmg = amount;

            // Shield mitigation
            if (this.shielded) {
                this.shieldHits--;
                dmg *= 0.5;
                if (this.shieldHits <= 0) this.shielded = false;
            }

            // Flat armour reduction
            dmg = Math.max(1, dmg - this.armor);
            this.hp -= dmg;

            // Flash on hit
            this.flashUntil = Date.now() + 80;

            // Tower stat tracking
            if (tower) {
                tower.totalDamageDealt = (tower.totalDamageDealt || 0) + dmg;
            }

            // Damage number
            if (game) {
                game.addDamageNum(
                    this.x + randFloat(-15, 15),
                    this.y - 25,
                    Math.round(dmg).toString(),
                    '#ff6b6b'
                );
            }

            // Check for phase transition
            this.checkPhase(game);

            if (this.hp <= 0) {
                this.die(game);
            }
        }

        // --------------------------------------------------
        //  Phase transitions
        // --------------------------------------------------

        /**
         * Check whether the boss has crossed a phase HP threshold.
         * Also triggers enrage at 10% HP.
         */
        checkPhase(game) {
            const hpPct = this.hp / this.maxHp;

            for (let i = this.def.phases.length - 1; i >= 0; i--) {
                if (hpPct <= this.def.phases[i].hpPercent && i > this.currentPhase) {
                    this.currentPhase = i;
                    // Phase transition effects
                    if (game && game.shake) game.shake.trigger(12, 500);
                    if (game) {
                        game.addAnnouncement(
                            `${this.name} - Phase ${i + 1}!`,
                            1500, 36, '#ff4444'
                        );
                    }
                    if (game && game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 30, this.color,
                            8, 4, 800, 5
                        );
                    }
                    break;
                }
            }

            // Enrage at 10%
            if (hpPct <= 0.1 && !this.enraged) {
                this.enraged = true;
                this.baseSpeed *= 1.5;
                if (game) {
                    game.addAnnouncement(
                        `${this.name} ENRAGED!`,
                        2000, 42, '#ff0000'
                    );
                }
            }
        }

        // --------------------------------------------------
        //  Death
        // --------------------------------------------------

        /**
         * Handle boss death: award gold, announce victory,
         * trigger screen shake and particle burst.
         */
        die(game) {
            this.active = false;
            this.deathTime = Date.now();

            if (game) {
                game.addGold(this.gold);
                game.addDamageNum(this.x, this.y - 30, `+${this.gold}g`, '#feca57');

                if (game.shake) game.shake.trigger(15, 800);
                game.addAnnouncement(
                    `${this.name} DEFEATED!`,
                    3000, 48, '#feca57'
                );

                if (game.particleSystem) {
                    game.particleSystem.emit(
                        this.x, this.y, 60, this.color,
                        12, 6, 1200, 6
                    );
                    game.particleSystem.emit(
                        this.x, this.y, 30, '#feca57',
                        10, 5, 1000, 4
                    );
                }
            }
        }

        // --------------------------------------------------
        //  Ability execution
        // --------------------------------------------------

        /**
         * Fire the next ability in the boss's rotation.
         * @param {GameManager} game
         */
        useAbility(game) {
            if (!game || this.abilities.length === 0) return;

            const ability = this.abilities[this.abilityIndex % this.abilities.length];
            this.abilityIndex++;

            switch (ability) {

                /* ---- Forest Guardian abilities ---- */

                case 'vineWall':
                    // Visual barricade burst near the boss
                    if (game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 15, '#2d5a1e',
                            6, 2, 2000, 4
                        );
                    }
                    break;

                case 'rootTrap':
                    // Disable the nearest tower for 5 seconds
                    if (game.towerManager) {
                        let nearest = null;
                        let nd = Infinity;
                        for (const t of game.towerManager.towers) {
                            const d = dist(this.x, this.y, t.x, t.y);
                            if (d < nd) { nd = d; nearest = t; }
                        }
                        if (nearest) {
                            nearest.disabledUntil = Date.now() + 5000;
                            if (game.particleSystem) {
                                game.particleSystem.emit(
                                    nearest.x, nearest.y, 10, '#2d5a1e',
                                    4, 1, 1500, 3
                                );
                            }
                        }
                    }
                    break;

                case 'healPulse':
                    this.hp = Math.min(this.maxHp, this.hp + this.maxHp * 0.05);
                    if (game.particleSystem) {
                        game.particleSystem.emitRing(this.x, this.y, 60, '#2ecc71', 15);
                    }
                    break;

                /* ---- Sand Wyrm abilities ---- */

                case 'burrow': {
                    this.burrowed = true;
                    const self = this;
                    setTimeout(() => {
                        self.burrowed = false;
                        // Jump forward along path
                        self.pathIndex = Math.min(
                            self.pathPoints.length - 1,
                            self.pathIndex + 2
                        );
                        if (self.pathIndex < self.pathPoints.length) {
                            self.x = self.pathPoints[self.pathIndex].x;
                            self.y = self.pathPoints[self.pathIndex].y;
                        }
                        if (game.particleSystem) {
                            game.particleSystem.emit(
                                self.x, self.y, 20, '#c4a36e',
                                8, 3, 600, 5
                            );
                        }
                        if (game.shake) game.shake.trigger(10, 400);
                    }, 2000);
                    break;
                }

                case 'erupt':
                    if (game.shake) game.shake.trigger(8, 300);
                    if (game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 25, '#ff4500',
                            10, 5, 800, 6
                        );
                    }
                    break;

                case 'dustCloud':
                    // Reduce tower effectiveness in area
                    if (game.towerManager) {
                        for (const t of game.towerManager.towers) {
                            if (dist(this.x, this.y, t.x, t.y) < 150) {
                                t.disabledUntil = Date.now() + 3000;
                            }
                        }
                    }
                    break;

                /* ---- Frost Titan abilities ---- */

                case 'iceArmor':
                    this.shielded = true;
                    this.shieldHits = 10;
                    if (game.particleSystem) {
                        game.particleSystem.emitRing(this.x, this.y, 30, '#87CEEB', 12);
                    }
                    break;

                case 'frozenGround':
                    if (game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 20, '#87CEEB',
                            6, 2, 1000, 3
                        );
                    }
                    break;

                case 'iceShards':
                    if (game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 15, '#cce5ff',
                            8, 4, 600, 4
                        );
                    }
                    break;

                /* ---- Magma Colossus abilities ---- */

                case 'lavaTrail':
                    // Drop a fire zone at the current position
                    if (game.towerManager) {
                        game.towerManager.fireZones.push(
                            new FireZone(this.x, this.y, 40, 8, 5000)
                        );
                    }
                    break;

                case 'eruption':
                    if (game.shake) game.shake.trigger(12, 500);
                    if (game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 40, '#ff4500',
                            12, 6, 1000, 7
                        );
                    }
                    break;

                case 'moltenShield':
                    this.shielded = true;
                    this.shieldHits = 15;
                    break;

                /* ---- Void Sovereign abilities ---- */

                case 'teleportBlink':
                    // Blink forward along the path
                    this.pathIndex = Math.min(
                        this.pathPoints.length - 1,
                        this.pathIndex + 3
                    );
                    if (this.pathIndex < this.pathPoints.length) {
                        if (game.particleSystem) {
                            game.particleSystem.emit(
                                this.x, this.y, 10, '#6a0dad',
                                6, 3, 400, 3
                            );
                        }
                        this.x = this.pathPoints[this.pathIndex].x;
                        this.y = this.pathPoints[this.pathIndex].y;
                        if (game.particleSystem) {
                            game.particleSystem.emit(
                                this.x, this.y, 10, '#6a0dad',
                                6, 3, 400, 3
                            );
                        }
                    }
                    break;

                case 'disableTower':
                    if (game.towerManager && game.towerManager.towers.length > 0) {
                        const idx = randInt(0, game.towerManager.towers.length - 1);
                        const tower = game.towerManager.towers[idx];
                        if (tower) tower.disabledUntil = Date.now() + 4000;
                    }
                    break;

                case 'voidPortal':
                    if (game.particleSystem) {
                        game.particleSystem.emitRing(this.x, this.y, 80, '#6a0dad', 20);
                    }
                    break;

                /* ---- Crystal Empress abilities ---- */

                case 'crystalShield':
                    this.shielded = true;
                    this.shieldHits = 12;
                    if (game.particleSystem) {
                        game.particleSystem.emitRing(
                            this.x, this.y, 35, '#b388ff', 15
                        );
                    }
                    break;

                case 'shatterAttack':
                    if (game.shake) game.shake.trigger(10, 400);
                    if (game.particleSystem) {
                        game.particleSystem.emit(
                            this.x, this.y, 30, '#b388ff',
                            10, 5, 800, 5
                        );
                    }
                    break;

                case 'empowerEnemies':
                    if (game.particleSystem) {
                        game.particleSystem.emitRing(
                            this.x, this.y, 100, '#b388ff', 20
                        );
                    }
                    break;

                /* ---- Cyber Overlord abilities ---- */

                case 'hackTower':
                    if (game.towerManager && game.towerManager.towers.length > 0) {
                        const ti = randInt(0, game.towerManager.towers.length - 1);
                        const tw = game.towerManager.towers[ti];
                        if (tw) {
                            tw.disabledUntil = Date.now() + 5000;
                            if (game.particleSystem) {
                                game.particleSystem.emit(
                                    tw.x, tw.y, 8, '#00e5ff',
                                    4, 2, 800, 3
                                );
                            }
                        }
                    }
                    break;

                case 'empPulse':
                    if (game.towerManager) {
                        for (const t of game.towerManager.towers) {
                            if (dist(this.x, this.y, t.x, t.y) < 200) {
                                t.disabledUntil = Date.now() + 3000;
                            }
                        }
                    }
                    if (game.shake) game.shake.trigger(8, 300);
                    if (game.particleSystem) {
                        game.particleSystem.emitRing(
                            this.x, this.y, 200, '#00e5ff', 25
                        );
                    }
                    break;

                case 'spawnDrones':
                    // Spawn 3 drone enemies via the EnemyManager
                    if (game.enemyManager) {
                        for (let i = 0; i < 3; i++) {
                            game.enemyManager.spawnEnemy('drone', game.wave);
                        }
                    }
                    break;
            }
        }

        // --------------------------------------------------
        //  Update (per-frame)
        // --------------------------------------------------

        /**
         * Update the boss each fixed timestep.
         *
         * @param {number}      dt  - Delta time in ms.
         * @param {number}      now - Current timestamp (Date.now()).
         * @param {GameManager} game
         */
        update(dt, now, game) {
            if (!this.active) return;

            // Entrance animation (2 second grow-in)
            if (!this.entranceComplete) {
                this.entranceTimer += dt;
                if (this.entranceTimer >= 2000) this.entranceComplete = true;
                return; // hold position during entrance
            }

            // Burrowed = underground, skip movement
            if (this.burrowed) return;

            // ------ Ability cooldown ------
            const phase = this.def.phases[this.currentPhase] || this.def.phases[0];
            if (now - this.lastAbilityTime >= phase.abilityInterval) {
                this.lastAbilityTime = now;
                this.useAbility(game);
            }

            // ------ Process slow effects ------
            let speedMult = 1;
            for (let i = this.slowEffects.length - 1; i >= 0; i--) {
                if (now > this.slowEffects[i].until) {
                    this.slowEffects.splice(i, 1);
                } else {
                    speedMult = Math.min(speedMult, 1 - this.slowEffects[i].amount);
                }
            }

            // ------ Process poison effects ------
            for (let i = this.poisonEffects.length - 1; i >= 0; i--) {
                if (now > this.poisonEffects[i].until) {
                    this.poisonEffects.splice(i, 1);
                } else {
                    this.hp -= this.poisonEffects[i].dps * (dt / 1000);
                    if (this.hp <= 0) { this.die(game); return; }
                }
            }

            // ------ Movement along path ------
            this.prevX = this.x;
            this.prevY = this.y;
            const effectiveSpeed = this.baseSpeed
                * speedMult
                * (this.enraged ? 1.5 : 1)
                * (dt / 16.67);

            if (this.pathIndex < this.pathPoints.length - 1) {
                const target = this.pathPoints[this.pathIndex + 1];
                const d = dist(this.x, this.y, target.x, target.y);

                if (d < effectiveSpeed * 2) {
                    this.pathIndex++;
                    this.pathProgress = this.pathIndex / (this.pathPoints.length - 1);
                    if (this.pathIndex >= this.pathPoints.length - 1) {
                        // Reached the end of the path
                        if (game) game.loseLife(3); // bosses cost 3 lives
                        this.active = false;
                        return;
                    }
                } else {
                    const a = angle(this.x, this.y, target.x, target.y);
                    this.x += Math.cos(a) * effectiveSpeed;
                    this.y += Math.sin(a) * effectiveSpeed;
                }
            }

            this.pulsePhase += dt * 0.003;
        }

        // --------------------------------------------------
        //  Rendering
        // --------------------------------------------------

        /**
         * Draw the boss on the main canvas.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number}                  alpha - Interpolation factor for smooth rendering.
         */
        render(ctx, alpha) {
            if (!this.active) return;

            const ix = lerp(this.prevX, this.x, alpha);
            const iy = lerp(this.prevY, this.y, alpha);
            const pulsed = this.size + Math.sin(this.pulsePhase) * 3;

            ctx.save();
            ctx.translate(ix, iy);

            // Burrowed transparency
            if (this.burrowed) {
                ctx.globalAlpha = 0.3;
            }

            // Entrance grow-in animation
            if (!this.entranceComplete) {
                const p = this.entranceTimer / 2000;
                ctx.globalAlpha = p;
                ctx.scale(1 + (1 - p) * 0.5, 1 + (1 - p) * 0.5);
            }

            // Hit flash
            if (Date.now() < this.flashUntil) {
                ctx.fillStyle = '#ffffff';
            } else {
                ctx.fillStyle = this.color;
            }

            // Main body  large circle
            ctx.beginPath();
            ctx.arc(0, 0, pulsed, 0, Math.PI * 2);
            ctx.fill();

            // Inner crown detail
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = (this.burrowed ? 0.3 : 1) * 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, pulsed * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = this.burrowed ? 0.3 : 1;

            // Outer crown spikes
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const a = (Math.PI * 2 / 6) * i + this.pulsePhase;
                ctx.beginPath();
                ctx.moveTo(
                    Math.cos(a) * pulsed * 0.7,
                    Math.sin(a) * pulsed * 0.7
                );
                ctx.lineTo(
                    Math.cos(a) * (pulsed + 6),
                    Math.sin(a) * (pulsed + 6)
                );
                ctx.stroke();
            }

            // Shield visual
            if (this.shielded) {
                ctx.strokeStyle = '#87CEEB';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(0, 0, pulsed + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Enrage glow
            if (this.enraged) {
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, pulsed + 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.restore();

            // ------ Health bar (wider, above boss) ------
            const barW = 60;
            const barH = 6;
            const barX = ix - barW / 2;
            const barY = iy - pulsed - 14;
            const hpPct = Math.max(0, this.hp / this.maxHp);

            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);

            const hpColor = hpPct > 0.5 ? '#2ecc71'
                          : hpPct > 0.25 ? '#f39c12'
                          : '#e74c3c';
            ctx.fillStyle = hpColor;
            ctx.fillRect(barX, barY, barW * hpPct, barH);

            // Phase pips
            for (let i = 0; i < this.def.phases.length; i++) {
                const px = barX + barW * this.def.phases[i].hpPercent;
                ctx.fillStyle = i <= this.currentPhase ? '#ff4444' : '#888';
                ctx.fillRect(px - 1, barY - 2, 2, barH + 4);
            }

            // ------ Boss name label ------
            ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(this.name, ix, barY - 4);
            ctx.textBaseline = 'alphabetic';
        }
    }


    // ==================== AMBIENT PARTICLE LAYER ====================

    /**
     * AmbientParticleLayer  lightweight background particle system
     * that renders theme-specific floating particles for visual atmosphere.
     * These are purely cosmetic and do not interact with gameplay.
     */
    class AmbientParticleLayer {
        /**
         * @param {Object} config - { color, count, speed } from mapDef.ambientParticles.
         */
        constructor(config) {
            this.config = config;
            this.particles = [];
            this.init();
        }

        /** Create the initial set of ambient particles. */
        init() {
            this.particles = [];
            for (let i = 0; i < this.config.count; i++) {
                this.particles.push({
                    x: randFloat(0, gameAreaWidth),
                    y: randFloat(topBarHeight, topBarHeight + gridRows * GRID_SIZE),
                    vx: randFloat(-this.config.speed, this.config.speed),
                    vy: randFloat(-this.config.speed, this.config.speed),
                    size: randFloat(1, 3),
                    alpha: randFloat(0.1, 0.4),
                    phase: randFloat(0, Math.PI * 2)
                });
            }
        }

        /**
         * Update all ambient particles.
         * @param {number} dt - Delta time in ms.
         */
        update(dt) {
            const dtSec = dt / 1000;
            const minY = topBarHeight;
            const maxY = topBarHeight + gridRows * GRID_SIZE;
            for (const p of this.particles) {
                p.x += p.vx * dtSec * 60;
                p.y += p.vy * dtSec * 60;
                p.phase += dtSec * 2;
                p.alpha = 0.1 + Math.sin(p.phase) * 0.15;

                // Wrap around
                if (p.x < 0) p.x = gameAreaWidth;
                if (p.x > gameAreaWidth) p.x = 0;
                if (p.y < minY) p.y = maxY;
                if (p.y > maxY) p.y = minY;
            }
        }

        /**
         * Render ambient particles.
         * @param {CanvasRenderingContext2D} ctx
         */
        render(ctx) {
            ctx.save();
            for (const p of this.particles) {
                ctx.globalAlpha = Math.max(0, Math.min(1, p.alpha));
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
    }


    // ==================== HAZARD MANAGER ====================

    /**
     * HazardManager  applies map hazard effects to towers
     * and enemies each frame.
     *
     * Hazard types:
     *   fog        reduce tower range
     *   quicksand  slow enemies + projectiles
     *   ice        reduce tower fire rate
     *   lava       damage enemies (DPS) + damage towers
     *   eruption   chance to damage towers
     *   voidZone   disable placement (handled by MapRenderer.isPlaceable)
     *   crystal    boost tower range + enemy speed
     *   emp        periodically disable towers
     */
    class HazardManager {
        /**
         * @param {Object} mapDef - Map definition with hazards array.
         */
        constructor(mapDef) {
            this.mapDef = mapDef;
            this.hazards = mapDef.hazards || [];
            this.empTimers = {};

            // Pre-calculate EMP timers per hazard index
            for (let i = 0; i < this.hazards.length; i++) {
                const h = this.hazards[i];
                if (h.type === 'emp' && h.effect.empInterval) {
                    this.empTimers[i] = { lastFire: 0, interval: h.effect.empInterval };
                }
            }
        }

        /**
         * Is a tower inside a hazard zone of the given type?
         * @param {number} tx - Tower pixel X.
         * @param {number} ty - Tower pixel Y.
         * @param {string} type - Hazard type.
         * @returns {Object|null} The hazard effect, or null.
         */
        getTowerHazard(tx, ty, type) {
            for (const h of this.hazards) {
                if (h.type !== type) continue;
                for (const z of h.zones) {
                    const zx = z.col * GRID_SIZE + GRID_SIZE / 2;
                    const zy = topBarHeight + z.row * GRID_SIZE + GRID_SIZE / 2;
                    const zr = z.radius * GRID_SIZE;
                    if (dist(tx, ty, zx, zy) <= zr) {
                        return h.effect;
                    }
                }
            }
            return null;
        }

        /**
         * Is an enemy inside a hazard zone of the given type?
         * @param {number} ex - Enemy pixel X.
         * @param {number} ey - Enemy pixel Y.
         * @param {string} type - Hazard type.
         * @returns {Object|null} The hazard effect, or null.
         */
        getEnemyHazard(ex, ey, type) {
            return this.getTowerHazard(ex, ey, type); // same zone check
        }

        /**
         * Apply all hazard effects per frame.
         *
         * @param {number}      dt      - Delta time in ms.
         * @param {number}      now     - Current timestamp.
         * @param {Array}       towers  - Active towers.
         * @param {Array}       enemies - Active enemies.
         * @param {GameManager} game    - Game reference for effects.
         */
        update(dt, now, towers, enemies, game) {
            for (let i = 0; i < this.hazards.length; i++) {
                const h = this.hazards[i];

                switch (h.type) {
                    case 'fog':
                        // Fog reduces tower range  applied at targeting time
                        // by checking getTowerHazard('fog') in tower update
                        break;

                    case 'quicksand':
                        // Slow enemies in quicksand zones
                        for (const e of enemies) {
                            if (!e.active) continue;
                            const eff = this.getEnemyHazard(e.x, e.y, 'quicksand');
                            if (eff) {
                                // Apply a gentle slow (non-stacking with tower slows)
                                const hasQS = e.slowEffects.some(s => s.source === 'quicksand');
                                if (!hasQS) {
                                    e.slowEffects.push({
                                        amount: eff.speedReduction || 0.3,
                                        until: now + 500,
                                        source: 'quicksand'
                                    });
                                }
                            }
                        }
                        break;

                    case 'ice':
                        // Ice reduces tower fire rate  applied at targeting time
                        break;

                    case 'lava':
                        // Damage enemies standing in lava
                        for (const e of enemies) {
                            if (!e.active) continue;
                            const eff = this.getEnemyHazard(e.x, e.y, 'lava');
                            if (eff && eff.enemyDPS) {
                                e.hp -= eff.enemyDPS * (dt / 1000);
                                if (e.hp <= 0 && e.active) {
                                    e.active = false;
                                    if (game) {
                                        game.addGold(e.gold || 5);
                                        game.addDamageNum(
                                            e.x, e.y - 15,
                                            `+${e.gold || 5}g`, '#feca57'
                                        );
                                    }
                                }
                            }
                        }
                        break;

                    case 'eruption':
                        // Random chance to damage towers in eruption zone
                        if (h.effect.towerDamageChance) {
                            for (const t of towers) {
                                const eff = this.getTowerHazard(t.x, t.y, 'eruption');
                                if (eff && Math.random() < eff.towerDamageChance) {
                                    t.disabledUntil = Math.max(
                                        t.disabledUntil || 0,
                                        now + 2000
                                    );
                                    if (game && game.particleSystem) {
                                        game.particleSystem.emit(
                                            t.x, t.y, 8, '#ff4500',
                                            4, 2, 500, 3
                                        );
                                    }
                                }
                            }
                        }
                        break;

                    case 'crystal':
                        // Crystal boosts tower range and enemy speed
                        // Range boost is applied during targeting; speed
                        // boost is applied as a brief speed increase
                        for (const e of enemies) {
                            if (!e.active) continue;
                            const eff = this.getEnemyHazard(e.x, e.y, 'crystal');
                            if (eff && eff.enemySpeedBoost) {
                                e.speed = e.baseSpeed * (1 + eff.enemySpeedBoost);
                            }
                        }
                        break;

                    case 'emp':
                        // Periodically disable towers in EMP zone
                        if (this.empTimers[i]) {
                            const timer = this.empTimers[i];
                            if (now - timer.lastFire >= timer.interval) {
                                timer.lastFire = now;
                                const dur = h.effect.disableDuration || 2000;
                                for (const t of towers) {
                                    const eff = this.getTowerHazard(t.x, t.y, 'emp');
                                    if (eff) {
                                        t.disabledUntil = Math.max(
                                            t.disabledUntil || 0,
                                            now + dur
                                        );
                                    }
                                }
                                // Visual pulse
                                for (const z of h.zones) {
                                    const zx = z.col * GRID_SIZE + GRID_SIZE / 2;
                                    const zy = topBarHeight + z.row * GRID_SIZE + GRID_SIZE / 2;
                                    if (game && game.particleSystem) {
                                        game.particleSystem.emitRing(
                                            zx, zy,
                                            z.radius * GRID_SIZE,
                                            '#00e5ff', 12
                                        );
                                    }
                                }
                            }
                        }
                        break;

                    // voidZone is handled at placement time by MapRenderer
                }
            }
        }

        /**
         * Get the fog range reduction multiplier for a tower.
         * Returns 1.0 if no fog, or (1 - reduction) if in fog.
         *
         * @param {number} tx - Tower pixel X.
         * @param {number} ty - Tower pixel Y.
         * @returns {number} Range multiplier (0..1).
         */
        getFogRangeMultiplier(tx, ty) {
            const eff = this.getTowerHazard(tx, ty, 'fog');
            if (eff && eff.rangeReduction) return 1 - eff.rangeReduction;
            return 1;
        }

        /**
         * Get the ice fire-rate reduction multiplier for a tower.
         * Returns 1.0 if no ice, or (1 - reduction) if in ice.
         *
         * @param {number} tx - Tower pixel X.
         * @param {number} ty - Tower pixel Y.
         * @returns {number} Fire rate multiplier (0..1).
         */
        getIceFireRateMultiplier(tx, ty) {
            const eff = this.getTowerHazard(tx, ty, 'ice');
            if (eff && eff.fireRateReduction) return 1 - eff.fireRateReduction;
            return 1;
        }

        /**
         * Get the crystal tower range boost multiplier.
         * Returns 1.0 if no crystal zone, or (1 + boost) if in crystal.
         *
         * @param {number} tx - Tower pixel X.
         * @param {number} ty - Tower pixel Y.
         * @returns {number} Range multiplier (>=1).
         */
        getCrystalRangeMultiplier(tx, ty) {
            const eff = this.getTowerHazard(tx, ty, 'crystal');
            if (eff && eff.towerRangeBoost) return 1 + eff.towerRangeBoost;
            return 1;
        }
    }


    // ==================== ENEMY MANAGER ====================

    /**
     * EnemyManager  owns the enemy pool, handles spawning,
     * boss spawning, and per-frame updates for all active enemies.
     */
    class EnemyManager {
        /**
         * @param {MapRenderer} mapRenderer - Current map renderer for pixel paths.
         */
        constructor(mapRenderer) {
            this.enemies = [];
            this.boss = null;
            this.mapRenderer = mapRenderer;
            this.pixelPaths = mapRenderer.getPixelPaths();
            this.deadEnemies = []; // tracks recent deaths for necromancer resurrect
        }

        // --------------------------------------------------
        //  Spawning
        // --------------------------------------------------

        /**
         * Spawn a normal enemy.
         *
         * @param {string} type      - Key into ENEMY_DEFS.
         * @param {number} wave      - Current wave number (for scaling).
         * @param {number} pathIndex - Which path to use (-1 = random).
         * @returns {Enemy|null}
         */
        spawnEnemy(type, wave, pathIndex) {
            const def = ENEMY_DEFS[type];
            if (!def) return null;

            const pi = (pathIndex != null && pathIndex >= 0)
                     ? pathIndex
                     : randInt(0, this.pixelPaths.length - 1);
            const path = this.pixelPaths[pi];
            if (!path) return null;

            const waveScale = 1 + (wave - 1) * 0.08; // +8% HP / gold per wave
            const enemy = new Enemy(type, path.waypoints, waveScale);
            this.enemies.push(enemy);
            return enemy;
        }

        /**
         * Spawn a boss.
         *
         * @param {string} bossType - Key into BOSS_DEFS.
         * @param {number} wave     - Current wave number.
         * @returns {Boss|null}
         */
        spawnBoss(bossType, wave) {
            const def = BOSS_DEFS[bossType];
            if (!def) return null;

            const path = this.pixelPaths[0]; // bosses always use path 0
            const waveScale = 1;
            this.boss = new Boss(def, path.waypoints, waveScale);
            this.enemies.push(this.boss);
            return this.boss;
        }

        // --------------------------------------------------
        //  Queries
        // --------------------------------------------------

        /**
         * @returns {Array<Enemy|Boss>} All enemies with active=true and hp>0.
         */
        getActiveEnemies() {
            return this.enemies.filter(e => e.active && e.hp > 0);
        }

        // --------------------------------------------------
        //  Frame update
        // --------------------------------------------------

        /**
         * @param {number}      dt   - Delta time in ms.
         * @param {GameManager} game
         */
        update(dt, game) {
            const now = Date.now();
            for (let i = this.enemies.length - 1; i >= 0; i--) {
                const e = this.enemies[i];
                if (!e.active) {
                    if (e.hp <= 0) {
                        this.deadEnemies.push({
                            type: e.type || 'grunt',
                            pathIndex: 0,
                            time: now
                        });
                    }
                    this.enemies.splice(i, 1);
                    continue;
                }
                e.update(dt, now, game);
            }
            // Cap dead enemies list to prevent unbounded growth
            if (this.deadEnemies.length > 50) {
                this.deadEnemies.splice(0, this.deadEnemies.length - 50);
            }
        }

        // --------------------------------------------------
        //  Rendering
        // --------------------------------------------------

        /**
         * @param {CanvasRenderingContext2D} ctx
         * @param {number}                  alpha - Interpolation factor.
         */
        render(ctx, alpha) {
            for (const e of this.enemies) {
                e.render(ctx, alpha);
            }
        }

        // --------------------------------------------------
        //  Reset
        // --------------------------------------------------

        /** Clear all enemies and the boss reference. */
        reset() {
            this.enemies = [];
            this.boss = null;
            this.deadEnemies = [];
        }
    }


    // ==================== WAVE MANAGER ====================

    /**
     * WaveManager  procedurally generates waves, manages spawn
     * queues, prep timers, and boss-wave logic.
     *
     * Each wave's enemy composition is built from a budget that
     * scales with the wave number.  The final wave is always a
     * boss wave that spawns the map's designated boss plus
     * support enemies.
     */
    class WaveManager {
        /**
         * @param {Object}       mapDef       - Map definition from MAP_DEFS.
         * @param {EnemyManager} enemyManager - Enemy manager for spawning.
         * @param {GameManager}  game         - Back-reference to the game.
         */
        constructor(mapDef, enemyManager, game) {
            this.mapDef = mapDef;
            this.enemyManager = enemyManager;
            this.game = game;

            this.currentWave = 0;
            this.maxWaves = MAX_WAVES;
            this.waveActive = false;
            this.prepTimer = WAVE_PREP_TIME;
            this.spawnQueue = [];
            this.spawnTimer = 0;
            this.spawnInterval = 800; // base ms between spawns
            this.wavesCompleted = false;
        }

        // --------------------------------------------------
        //  Wave generation
        // --------------------------------------------------

        /**
         * Build the spawn queue for a given wave number.
         *
         * The final wave (maxWaves) is a boss wave.  All others
         * are procedurally generated from a budget system.
         *
         * @param {number} waveNum
         * @returns {Array<{type: string, delay: number}>}
         */
        generateWave(waveNum) {
            const queue = [];

            // ------ Boss wave ------
            if (waveNum === this.maxWaves) {
                queue.push({ type: '__boss__', delay: 0 });
                // Support enemies alongside the boss
                const supportCount = 5 + Math.floor(waveNum / 5);
                for (let i = 0; i < supportCount; i++) {
                    queue.push({
                        type: randItem(['grunt', 'runner', 'tank']),
                        delay: 1000 + i * 600
                    });
                }
                return queue;
            }

            // ------ Normal wave  budget system ------
            let budget = 50 + waveNum * 30;
            const available = [];

            // Tier 1 (waves 1+)
            available.push('grunt', 'runner');
            if (waveNum >= 3) available.push('tank');
            if (waveNum >= 5) available.push('shield', 'healer');
            if (waveNum >= 7) available.push('splitter', 'berserker');
            if (waveNum >= 9) available.push('cloaker', 'regenerator', 'engineer');

            // Flying (waves 8+)
            if (waveNum >= 8)  available.push('drone');
            if (waveNum >= 12) available.push('bomber', 'swarm');
            if (waveNum >= 16) available.push('carrier');

            // Elite (waves 15+)
            if (waveNum >= 15) available.push('juggernaut');
            if (waveNum >= 17) available.push('phasewalker');
            if (waveNum >= 19) available.push('nullifier');
            if (waveNum >= 21) available.push('mirror');
            if (waveNum >= 23) available.push('necromancer');
            if (waveNum >= 25) available.push('voidwraith');

            // Enemy costs (roughly proportional to difficulty)
            const costs = {
                grunt: 10, runner: 8, tank: 25, shield: 15, healer: 20,
                splitter: 15, berserker: 18, cloaker: 18, regenerator: 20,
                engineer: 18, drone: 12, bomber: 20, swarm: 5, carrier: 30,
                juggernaut: 50, phasewalker: 35, nullifier: 40, mirror: 30,
                necromancer: 45, voidwraith: 40
            };

            let delay = 0;
            let safeguard = 0; // prevent infinite loop
            while (budget > 0 && safeguard < 200) {
                safeguard++;
                const type = randItem(available);
                const cost = costs[type] || 10;
                if (cost > budget && budget < 10) break;
                if (cost > budget) continue;

                // Swarms come in groups
                if (type === 'swarm') {
                    const count = Math.min(8, Math.floor(budget / cost));
                    for (let j = 0; j < count; j++) {
                        queue.push({ type, delay: delay + j * 200 });
                        budget -= cost;
                    }
                    delay += count * 200 + 400;
                } else {
                    queue.push({ type, delay });
                    budget -= cost;
                    delay += Math.max(200, this.spawnInterval - Math.min(400, waveNum * 15));
                }
            }

            return queue;
        }

        // --------------------------------------------------
        //  Wave start
        // --------------------------------------------------

        /** Begin the next wave (called by player or auto-timer). */
        startWave() {
            if (this.waveActive || this.wavesCompleted) return;

            this.currentWave++;
            this.game.wave = this.currentWave;
            this.waveActive = true;
            this.spawnQueue = this.generateWave(this.currentWave);
            this.spawnTimer = 0;

            // Bonus gold for early start
            if (this.prepTimer > 0) {
                const bonus = Math.floor(
                    EARLY_START_BONUS * (this.prepTimer / WAVE_PREP_TIME)
                );
                if (bonus > 0) {
                    this.game.addGold(bonus);
                    this.game.addDamageNum(
                        canvasWidth / 2, canvasHeight / 2,
                        `Early start! +${bonus}g`, '#feca57'
                    );
                }
            }
            this.prepTimer = 0;

            // Announcement
            if (this.currentWave === this.maxWaves) {
                this.game.addAnnouncement('FINAL WAVE - BOSS!', 2500, 48, '#e94560');
            } else {
                this.game.addAnnouncement(
                    `Wave ${this.currentWave}`,
                    1500, 42, '#feca57'
                );
            }
        }

        // --------------------------------------------------
        //  Frame update
        // --------------------------------------------------

        /**
         * @param {number} dt - Delta time in ms.
         */
        update(dt) {
            if (this.wavesCompleted) return;

            // During prep phase, count down
            if (!this.waveActive) {
                this.prepTimer -= dt;
                if (this.prepTimer <= 0) {
                    this.startWave();
                }
                return;
            }

            // Spawn enemies from queue
            this.spawnTimer += dt;
            while (
                this.spawnQueue.length > 0 &&
                this.spawnTimer >= this.spawnQueue[0].delay
            ) {
                const spawn = this.spawnQueue.shift();
                if (spawn.type === '__boss__') {
                    this.enemyManager.spawnBoss(
                        this.mapDef.bossType,
                        this.currentWave
                    );
                    this.game.addAnnouncement(
                        BOSS_DEFS[this.mapDef.bossType].name,
                        3000, 52, '#e94560'
                    );
                } else {
                    this.enemyManager.spawnEnemy(spawn.type, this.currentWave);
                }
            }

            // Check if wave is complete
            if (
                this.spawnQueue.length === 0 &&
                this.enemyManager.getActiveEnemies().length === 0
            ) {
                this.waveActive = false;

                if (this.currentWave >= this.maxWaves) {
                    this.wavesCompleted = true;
                    this.game.endGame(true);
                } else {
                    // Start prep timer for next wave
                    this.prepTimer = WAVE_PREP_TIME;
                    // Wave complete bonus
                    const bonus = 20 + this.currentWave * 5;
                    this.game.addGold(bonus);
                    this.game.addAnnouncement(
                        `Wave ${this.currentWave} Complete! +${bonus}g`,
                        2000, 32, '#2ecc71'
                    );
                }
            }
        }

        // --------------------------------------------------
        //  Wave preview / info
        // --------------------------------------------------

        /**
         * Get a summary of enemy types and counts for the next wave.
         * Useful for a wave preview UI panel.
         *
         * @returns {Array<{type: string, count: number}>}
         */
        getNextWavePreview() {
            if (this.currentWave >= this.maxWaves) return [];
            const nextWave = this.currentWave + 1;
            const queue = this.generateWave(nextWave);

            const counts = {};
            for (const s of queue) {
                if (s.type === '__boss__') {
                    counts['BOSS'] = 1;
                    continue;
                }
                counts[s.type] = (counts[s.type] || 0) + 1;
            }
            return Object.entries(counts).map(([type, count]) => ({ type, count }));
        }

        /**
         * @returns {number} Remaining prep time in ms (0 if wave is active).
         */
        getPrepTimeRemaining() {
            return Math.max(0, this.prepTimer);
        }

        // --------------------------------------------------
        //  Reset
        // --------------------------------------------------

        /** Reset all wave state for a new game. */
        reset() {
            this.currentWave = 0;
            this.waveActive = false;
            this.prepTimer = WAVE_PREP_TIME;
            this.spawnQueue = [];
            this.wavesCompleted = false;
        }
    }


    // ==================== WAVE PREVIEW RENDERER ====================

    /**
     * WavePreviewRenderer  draws a compact wave preview panel
     * showing upcoming enemy types and counts.
     */
    class WavePreviewRenderer {
        /**
         * @param {WaveManager} waveManager
         */
        constructor(waveManager) {
            this.waveManager = waveManager;
            this.cachedPreview = [];
            this.lastWave = -1;
        }

        /**
         * Render the wave preview panel.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number}                  x   - Top-left X.
         * @param {number}                  y   - Top-left Y.
         * @param {number}                  w   - Panel width.
         */
        render(ctx, x, y, w) {
            // Update cache if wave changed
            if (this.waveManager.currentWave !== this.lastWave) {
                this.lastWave = this.waveManager.currentWave;
                this.cachedPreview = this.waveManager.getNextWavePreview();
            }

            if (this.cachedPreview.length === 0) return;

            const lineH = 16;
            const padY = 6;
            const totalH = padY * 2 + lineH * (this.cachedPreview.length + 1);

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x, y, w, totalH);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.strokeRect(x, y, w, totalH);

            // Title
            ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#feca57';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText('Next Wave:', x + 8, y + padY);

            // Enemy list
            ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#cccccc';
            for (let i = 0; i < this.cachedPreview.length; i++) {
                const entry = this.cachedPreview[i];
                const label = entry.type === 'BOSS'
                    ? 'BOSS'
                    : `${entry.type} x${entry.count}`;
                const color = entry.type === 'BOSS' ? '#e94560' : '#cccccc';
                ctx.fillStyle = color;
                ctx.fillText(label, x + 12, y + padY + lineH * (i + 1));
            }

            ctx.textBaseline = 'alphabetic';
        }
    }


    // ==================== MAP SELECTION HELPERS ====================

    /**
     * MapSelectionData  helper to generate map selection card data
     * including difficulty stars, lock status, and best score.
     */
    class MapSelectionData {
        constructor() {
            this.totalStars = 0;
            this.mapStars = new Array(MAP_DEFS.length).fill(0);
            this.mapUnlocked = new Array(MAP_DEFS.length).fill(false);
            this.mapBestWave = new Array(MAP_DEFS.length).fill(0);
            this.refresh();
        }

        /** Recalculate unlock states from saved star counts. */
        refresh() {
            this.totalStars = this.mapStars.reduce((a, b) => a + b, 0);
            for (let i = 0; i < MAP_DEFS.length; i++) {
                if (MAP_UNLOCK[i] === -1) {
                    // Special unlock: requires all other maps beaten
                    this.mapUnlocked[i] = this.mapStars.every(
                        (s, j) => j === i || s > 0
                    );
                } else {
                    this.mapUnlocked[i] = this.totalStars >= MAP_UNLOCK[i];
                }
            }
        }

        /**
         * Record a game result.
         * @param {number}  mapIndex - Map index.
         * @param {number}  wave     - Wave reached.
         * @param {boolean} won      - Whether the player won.
         */
        recordResult(mapIndex, wave, won) {
            if (wave > this.mapBestWave[mapIndex]) {
                this.mapBestWave[mapIndex] = wave;
            }
            // Stars: 1 for completing, 2 for no lives lost, 3 for completing under time
            // (Simplified: 1 star for reaching wave 10+, 2 for wave 20+, 3 for winning)
            let stars = 0;
            if (wave >= 10) stars = 1;
            if (wave >= 20) stars = 2;
            if (won) stars = 3;
            if (stars > this.mapStars[mapIndex]) {
                this.mapStars[mapIndex] = stars;
            }
            this.refresh();
        }

        /**
         * Get card data for the map selection screen.
         * @returns {Array<Object>} Card data per map.
         */
        getCards() {
            return MAP_DEFS.map((m, i) => ({
                index: i,
                name: m.name,
                theme: m.theme,
                difficulty: m.difficulty,
                description: m.description,
                bgColor: m.bgColor,
                pathColor: m.pathColor,
                unlocked: this.mapUnlocked[i],
                stars: this.mapStars[i],
                bestWave: this.mapBestWave[i]
            }));
        }
    }


    // ==================== MAP SELECTION RENDERER ====================

    /**
     * MapSelectionRenderer  draws the map selection screen with
     * interactive cards showing map previews, difficulty, and stars.
     */
    class MapSelectionRenderer {
        /**
         * @param {MapSelectionData} data
         */
        constructor(data) {
            this.data = data;
            this.hoveredIndex = -1;
            this.scrollY = 0;
            this.targetScrollY = 0;
        }

        /**
         * Render the full map selection screen.
         *
         * @param {CanvasRenderingContext2D} ctx
         * @param {number}                  cw  - Canvas width.
         * @param {number}                  ch  - Canvas height.
         */
        render(ctx, cw, ch) {
            // Background overlay
            ctx.fillStyle = '#0d0d1a';
            ctx.fillRect(0, 0, cw, ch);

            // Title
            ctx.font = 'bold 36px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#feca57';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('SELECT MAP', cw / 2, 50);

            // Total stars
            ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#aaa';
            ctx.fillText(
                `Total Stars: ${this.data.totalStars}`,
                cw / 2, 80
            );

            // Smooth scroll
            this.scrollY += (this.targetScrollY - this.scrollY) * 0.15;

            // Cards layout
            const cards = this.data.getCards();
            const cols = cw > 900 ? 4 : cw > 600 ? 3 : 2;
            const cardW = Math.min(220, (cw - 40 - (cols - 1) * 16) / cols);
            const cardH = 160;
            const gap = 16;
            const startX = (cw - (cols * cardW + (cols - 1) * gap)) / 2;
            const startY = 110;

            ctx.save();
            ctx.translate(0, this.scrollY);

            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = startX + col * (cardW + gap);
                const cy = startY + row * (cardH + gap);

                const hovered = i === this.hoveredIndex;

                // Card background
                if (card.unlocked) {
                    ctx.fillStyle = hovered ? card.bgColor : 'rgba(30,30,50,0.9)';
                } else {
                    ctx.fillStyle = 'rgba(20,20,30,0.9)';
                }
                ctx.fillRect(cx, cy, cardW, cardH);

                // Border
                ctx.strokeStyle = card.unlocked
                    ? (hovered ? card.pathColor : 'rgba(255,255,255,0.15)')
                    : 'rgba(255,255,255,0.05)';
                ctx.lineWidth = hovered ? 2 : 1;
                ctx.strokeRect(cx, cy, cardW, cardH);

                // Map name
                ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = card.unlocked ? '#fff' : '#555';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(card.name, cx + 10, cy + 10);

                // Difficulty stars
                ctx.font = '12px -apple-system, sans-serif';
                let diffText = '';
                for (let d = 0; d < 5; d++) {
                    diffText += d < card.difficulty ? '\u2605' : '\u2606';
                }
                ctx.fillStyle = card.unlocked ? '#feca57' : '#444';
                ctx.fillText(diffText, cx + 10, cy + 30);

                // Description
                ctx.font = '11px -apple-system, sans-serif';
                ctx.fillStyle = card.unlocked ? '#aaa' : '#444';
                ctx.fillText(card.description, cx + 10, cy + 50, cardW - 20);

                // Lock icon or progress
                if (!card.unlocked) {
                    ctx.font = '28px sans-serif';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'center';
                    ctx.fillText('\uD83D\uDD12', cx + cardW / 2, cy + cardH - 40);
                    ctx.textAlign = 'left';
                } else {
                    // Earned stars
                    ctx.font = '18px sans-serif';
                    ctx.textAlign = 'left';
                    let starText = '';
                    for (let s = 0; s < 3; s++) {
                        starText += s < card.stars ? '\u2605' : '\u2606';
                    }
                    ctx.fillStyle = '#feca57';
                    ctx.fillText(starText, cx + 10, cy + cardH - 30);

                    // Best wave
                    if (card.bestWave > 0) {
                        ctx.font = '10px -apple-system, sans-serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText(
                            `Best: Wave ${card.bestWave}`,
                            cx + 10, cy + cardH - 12
                        );
                    }
                }

                // Theme colour bar at bottom
                ctx.fillStyle = card.unlocked ? card.pathColor : '#333';
                ctx.fillRect(cx, cy + cardH - 4, cardW, 4);
            }

            ctx.restore();
            ctx.textBaseline = 'alphabetic';
            ctx.textAlign = 'left';
        }

        /**
         * Hit-test the map cards.
         *
         * @param {number} mx - Mouse X.
         * @param {number} my - Mouse Y.
         * @param {number} cw - Canvas width.
         * @returns {number} Map index clicked, or -1.
         */
        getClickedMap(mx, my, cw) {
            const cards = this.data.getCards();
            const cols = cw > 900 ? 4 : cw > 600 ? 3 : 2;
            const cardW = Math.min(220, (cw - 40 - (cols - 1) * 16) / cols);
            const cardH = 160;
            const gap = 16;
            const startX = (cw - (cols * cardW + (cols - 1) * gap)) / 2;
            const startY = 110;

            const adjY = my - this.scrollY;

            for (let i = 0; i < cards.length; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = startX + col * (cardW + gap);
                const cy = startY + row * (cardH + gap);

                if (
                    mx >= cx && mx <= cx + cardW &&
                    adjY >= cy && adjY <= cy + cardH
                ) {
                    return cards[i].unlocked ? i : -1;
                }
            }
            return -1;
        }

        /**
         * Update hover state.
         *
         * @param {number} mx - Mouse X.
         * @param {number} my - Mouse Y.
         * @param {number} cw - Canvas width.
         */
        updateHover(mx, my, cw) {
            const cards = this.data.getCards();
            const cols = cw > 900 ? 4 : cw > 600 ? 3 : 2;
            const cardW = Math.min(220, (cw - 40 - (cols - 1) * 16) / cols);
            const cardH = 160;
            const gap = 16;
            const startX = (cw - (cols * cardW + (cols - 1) * gap)) / 2;
            const startY = 110;

            const adjY = my - this.scrollY;
            this.hoveredIndex = -1;

            for (let i = 0; i < cards.length; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = startX + col * (cardW + gap);
                const cy = startY + row * (cardH + gap);

                if (
                    mx >= cx && mx <= cx + cardW &&
                    adjY >= cy && adjY <= cy + cardH &&
                    cards[i].unlocked
                ) {
                    this.hoveredIndex = i;
                    break;
                }
            }
        }
    }


    // ================================================================
    // ==            END OF PHASE 3  MAPS, WAVES, BOSSES           ==
    // ================================================================


    // ================================================================
    // ==                                                            ==
    // ==          PHASE 4-6  AUDIO, PROGRESSION, INTEGRATION      ==
    // ==                                                            ==
    // ================================================================


    // ==================== AUDIO ENGINE ====================

    /**
     * Procedural Web Audio API engine for all game sounds.
     * Generates tones and noise bursts for tower fire, enemy death,
     * wave events, and UI feedback.
     */
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.enabled = true;
            this.volume = 0.3;
            this.initialized = false;
        }

        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                this.masterGain.connect(this.ctx.destination);
                this.initialized = true;
            } catch(e) {
                this.initialized = false;
            }
        }

        resume() {
            if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
        }

        setVolume(v) {
            this.volume = v;
            if (this.masterGain) this.masterGain.gain.value = v;
        }

        // Play a short tone
        _tone(freq, duration, type = 'square', volume = 0.3) {
            if (!this.initialized || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(volume * this.volume, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }

        // Play noise burst
        _noise(duration, volume = 0.2) {
            if (!this.initialized || !this.enabled) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const source = this.ctx.createBufferSource();
            source.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(volume * this.volume, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            source.connect(gain);
            gain.connect(this.masterGain);
            source.start();
        }

        playTowerFire(type) {
            switch(type) {
                case 'arrow': this._tone(800, 0.1, 'sawtooth', 0.15); break;
                case 'cannon': this._noise(0.2, 0.3); this._tone(100, 0.15, 'square', 0.2); break;
                case 'frost': this._tone(1200, 0.15, 'sine', 0.15); break;
                case 'lightning': this._tone(2000, 0.08, 'sawtooth', 0.2); this._tone(1500, 0.08, 'sawtooth', 0.15); break;
                case 'mortar': this._noise(0.3, 0.25); this._tone(80, 0.2, 'square', 0.2); break;
                case 'poison': this._tone(400, 0.2, 'sine', 0.1); break;
                case 'laser': this._tone(600, 0.05, 'sine', 0.1); break;
                case 'tesla': this._tone(1800, 0.1, 'sawtooth', 0.25); break;
                case 'sniper': this._noise(0.15, 0.35); this._tone(200, 0.1, 'square', 0.25); break;
                case 'plasma': this._tone(500, 0.2, 'sawtooth', 0.2); break;
                default: this._tone(600, 0.1, 'square', 0.15);
            }
        }

        playEnemyHit() { this._tone(300, 0.05, 'square', 0.1); }
        playEnemyDeath() { this._tone(200, 0.15, 'square', 0.15); this._tone(150, 0.1, 'sine', 0.1); }
        playWaveStart() { this._tone(440, 0.15, 'square', 0.2); this._tone(660, 0.15, 'square', 0.2); setTimeout(() => this._tone(880, 0.2, 'square', 0.25), 100); }
        playWaveComplete() { this._tone(523, 0.1, 'sine', 0.2); setTimeout(() => this._tone(659, 0.1, 'sine', 0.2), 100); setTimeout(() => this._tone(784, 0.2, 'sine', 0.25), 200); }
        playBossEntrance() { this._tone(100, 0.5, 'sawtooth', 0.3); this._noise(0.4, 0.2); }
        playVictory() { [523,659,784,1047].forEach((f,i) => setTimeout(() => this._tone(f, 0.3, 'sine', 0.25), i*150)); }
        playDefeat() { [400,350,300,200].forEach((f,i) => setTimeout(() => this._tone(f, 0.3, 'square', 0.2), i*200)); }
        playPlaceTower() { this._tone(500, 0.1, 'sine', 0.2); this._tone(700, 0.08, 'sine', 0.15); }
        playSellTower() { this._tone(800, 0.08, 'sine', 0.15); this._tone(600, 0.08, 'sine', 0.15); }
        playUpgradeTower() { this._tone(600, 0.1, 'sine', 0.2); this._tone(900, 0.1, 'sine', 0.2); this._tone(1200, 0.15, 'sine', 0.2); }
        playUIClick() { this._tone(1000, 0.05, 'sine', 0.1); }
        playGoldEarn() { this._tone(1200, 0.08, 'sine', 0.12); }
        playLifeLost() { this._tone(200, 0.3, 'sawtooth', 0.25); }
    }


    // ==================== PROGRESSION MANAGER ====================

    /**
     * Handles saving/loading player progress (stars, map results)
     * to localStorage and tracking tower/map unlock state.
     */
    class ProgressionManager {
        constructor() {
            this.saveKey = 'td_ultimate_v1';
            this.data = this.load();
        }

        load() {
            try {
                const raw = localStorage.getItem(this.saveKey);
                if (raw) return JSON.parse(raw);
            } catch(e) {}
            return { maps: {}, totalStars: 0, settings: { volume: 0.3, reducedMotion: false, coopMode: false } };
        }

        save() {
            try {
                localStorage.setItem(this.saveKey, JSON.stringify(this.data));
            } catch(e) {}
        }

        recordMapResult(mapIndex, stars, wave, score) {
            const key = `map_${mapIndex}`;
            if (!this.data.maps[key]) {
                this.data.maps[key] = { bestStars: 0, bestWave: 0, bestScore: 0 };
            }
            const m = this.data.maps[key];
            m.bestStars = Math.max(m.bestStars, stars);
            m.bestWave = Math.max(m.bestWave, wave);
            m.bestScore = Math.max(m.bestScore, score);
            this.recalcTotalStars();
            this.save();
        }

        recalcTotalStars() {
            let total = 0;
            for (const key in this.data.maps) {
                total += this.data.maps[key].bestStars || 0;
            }
            this.data.totalStars = total;
        }

        getTotalStars() { return this.data.totalStars; }

        getMapData(mapIndex) {
            return this.data.maps[`map_${mapIndex}`] || { bestStars: 0, bestWave: 0, bestScore: 0 };
        }

        isMapUnlocked(mapIndex) {
            if (mapIndex === 0) return true;
            if (mapIndex === 7) {
                // Final map: all others must have 1+ star
                for (let i = 0; i < 7; i++) {
                    if (this.getMapData(i).bestStars < 1) return false;
                }
                return true;
            }
            return this.data.totalStars >= MAP_UNLOCK[mapIndex];
        }

        isTowerUnlocked(tier) {
            return this.data.totalStars >= TIER_UNLOCK[tier];
        }

        getSettings() { return this.data.settings; }
        setSettings(settings) { this.data.settings = { ...this.data.settings, ...settings }; this.save(); }
    }


    // ================================================================
    // ==          END OF PHASE 4-6  AUDIO, PROGRESSION             ==
    // ================================================================


    // ==================== GAME MANAGER ====================

    /**
     * Top-level game controller.
     *
     * Orchestrates all sub-managers, handles input routing,
     * state machine, and the complete render pipeline.
     */
    class GameManager {
        constructor() {
            // ---- State ----
            this.state = STATE.MENU;

            // ---- Economy / progress ----
            this.gold      = STARTING_GOLD;
            this.lives     = STARTING_LIVES;
            this.wave      = 0;
            this.maxWaves  = MAX_WAVES;
            this.score     = 0;
            this.stars     = 0;
            this.livesLost = 0;
            this.gameSpeed = 1;
            this.elapsedTime = 0;
            this.currentMap  = 0;
            this.coopEnabled = false;

            // ---- Sub-managers ----
            this.mapRenderer       = null;
            this.towerManager      = null;
            this.enemyManager      = null;
            this.projectileManager = null;
            this.waveManager       = null;
            this.particleSystem    = null;
            this.audioEngine       = null;
            this.progressionManager = null;
            this.hazardManager     = null;
            this.ambientParticles  = null;
            this.wavePreview       = null;

            // ---- Map selection ----
            this.mapSelData     = null;
            this.mapSelRenderer = null;

            // ---- Tower interaction ----
            this.hoveredGridCell   = null;
            this.selectedTower     = null;
            this.selectedTowerType = null;
            this._towerTypeKeys    = Object.keys(TOWER_DEFS);

            // ---- Effects ----
            this.shake = new ScreenShake();
            this.announcements = [];
            this.damageNums    = [];

            // ---- Menu animation state ----
            this._menuParticles = this._createMenuParticles();

            // ---- Persistent managers ----
            this.audioEngine = new AudioEngine();
            this.progressionManager = new ProgressionManager();

            // ---- Init map selection ----
            this._syncMapSelData();
        }

        _createMenuParticles() {
            const particles = [];
            for (let i = 0; i < 60; i++) {
                particles.push({
                    x: Math.random() * (window.innerWidth || 1280),
                    y: Math.random() * (window.innerHeight || 720),
                    r: randFloat(1, 3),
                    dx: randFloat(-0.3, 0.3),
                    dy: randFloat(-0.15, -0.5),
                    alpha: randFloat(0.15, 0.4)
                });
            }
            return particles;
        }

        _syncMapSelData() {
            this.mapSelData = new MapSelectionData();
            for (let i = 0; i < MAP_DEFS.length; i++) {
                const pd = this.progressionManager.getMapData(i);
                this.mapSelData.mapStars[i] = pd.bestStars;
                this.mapSelData.mapBestWave[i] = pd.bestWave;
            }
            this.mapSelData.refresh();
            this.mapSelRenderer = new MapSelectionRenderer(this.mapSelData);
        }

        addAnnouncement(text, duration = 2000, size = 48, color = '#feca57') {
            this.announcements.push({ text, duration, elapsed: 0, size, color });
        }

        addDamageNum(x, y, text, color = '#fff') {
            this.damageNums.push({ x, y, text, color, elapsed: 0, duration: 800, vy: -2 });
        }

        startGame(mapIndex) {
            this.currentMap  = mapIndex;
            this.gold        = STARTING_GOLD;
            this.lives       = STARTING_LIVES;
            this.wave        = 0;
            this.score       = 0;
            this.stars       = 0;
            this.livesLost   = 0;
            this.elapsedTime = 0;
            this.gameSpeed   = 1;
            this.announcements = [];
            this.damageNums    = [];
            this.selectedTower     = null;
            this.selectedTowerType = null;
            this.hoveredGridCell   = null;
            this.state = STATE.PLAYING;

            const mapDef = MAP_DEFS[mapIndex];
            this.mapRenderer = new MapRenderer(mapDef);
            this.particleSystem = new ParticleSystem();
            this.projectileManager = new ProjectileManager();
            this.towerManager = new TowerManager();
            this.towerManager.initGrid(gridCols, gridRows);
            this.enemyManager = new EnemyManager(this.mapRenderer);
            this.waveManager = new WaveManager(mapDef, this.enemyManager, this);
            this.hazardManager = new HazardManager(mapDef);
            this.ambientParticles = new AmbientParticleLayer(mapDef.ambientParticles);
            this.wavePreview = new WavePreviewRenderer(this.waveManager);

            this.projectileManager.enemiesRef = this.enemyManager.enemies;
            this.projectileManager.gameRef = this;
            this.projectileManager.fireZonesRef = this.towerManager.fireZones;

            if (!this.audioEngine.initialized) this.audioEngine.init();
            this.audioEngine.resume();
            this.addAnnouncement(mapDef.name, 2000, 42, '#feca57');
        }

        pauseGame() { if (this.state === STATE.PLAYING) this.state = STATE.PAUSED; }
        resumeGame() { if (this.state === STATE.PAUSED) this.state = STATE.PLAYING; }

        endGame(won) {
            this.state = won ? STATE.VICTORY : STATE.GAME_OVER;
            if (won) {
                if (this.livesLost === 0) this.stars = 3;
                else if (this.livesLost <= 5) this.stars = 2;
                else this.stars = 1;
                if (this.audioEngine) this.audioEngine.playVictory();
            } else {
                this.stars = 0;
                if (this.wave >= 20) this.stars = 2;
                else if (this.wave >= 10) this.stars = 1;
                if (this.audioEngine) this.audioEngine.playDefeat();
            }
            if (this.progressionManager) {
                this.progressionManager.recordMapResult(this.currentMap, this.stars, this.wave, this.score);
            }
        }

        loseLife(count = 1) {
            this.lives -= count;
            this.livesLost += count;
            this.shake.trigger(8, 300);
            if (this.audioEngine) this.audioEngine.playLifeLost();
            if (this.lives <= 0) { this.lives = 0; this.endGame(false); }
        }

        addGold(amount) { this.gold += amount; this.score += amount; }

        spendGold(amount) {
            if (this.gold >= amount) { this.gold -= amount; return true; }
            return false;
        }

        _getAvailableTowerTypes() {
            const totalStars = this.progressionManager ? this.progressionManager.getTotalStars() : 0;
            return this._towerTypeKeys.filter(key => totalStars >= TIER_UNLOCK[TOWER_DEFS[key].tier]);
        }

        _cycleTowerType(direction) {
            const available = this._getAvailableTowerTypes();
            if (available.length === 0) return;
            if (!this.selectedTowerType) { this.selectedTowerType = available[0]; this.selectedTower = null; return; }
            const idx = available.indexOf(this.selectedTowerType);
            const next = (idx + direction + available.length) % available.length;
            this.selectedTowerType = available[next];
            this.selectedTower = null;
        }

        // --------------------------------------------------
        //  Update
        // --------------------------------------------------
        update(dt) {
            const scaledDt = dt * this.gameSpeed;
            this.shake.update(dt);

            for (let i = this.announcements.length - 1; i >= 0; i--) {
                this.announcements[i].elapsed += dt;
                if (this.announcements[i].elapsed >= this.announcements[i].duration) this.announcements.splice(i, 1);
            }
            for (let i = this.damageNums.length - 1; i >= 0; i--) {
                const d = this.damageNums[i];
                d.elapsed += dt; d.y += d.vy;
                if (d.elapsed >= d.duration) this.damageNums.splice(i, 1);
            }

            if (this.state === STATE.MENU || this.state === STATE.MAP_SELECT) {
                for (const p of this._menuParticles) {
                    p.x += p.dx; p.y += p.dy;
                    if (p.y < -10) { p.y = canvasHeight + 10; p.x = Math.random() * canvasWidth; }
                    if (p.x < -10) p.x = canvasWidth + 10;
                    if (p.x > canvasWidth + 10) p.x = -10;
                }
            }

            if (this.state === STATE.MAP_SELECT && this.mapSelRenderer) {
                this.mapSelRenderer.updateHover(input.mouse.x, input.mouse.y, canvasWidth);
            }

            if (this.state === STATE.PLAYING) {
                this.elapsedTime += scaledDt;
                input.updateP2Cursor(dt);

                const grid = input.screenToGrid(input.mouse.x, input.mouse.y);
                if (grid.col >= 0 && grid.col < gridCols && grid.row >= 0 && grid.row < gridRows) {
                    this.hoveredGridCell = grid;
                } else {
                    this.hoveredGridCell = null;
                }

                if (this.towerManager && this.selectedTowerType && this.hoveredGridCell) {
                    this.towerManager.setGhostPosition(this.hoveredGridCell.col, this.hoveredGridCell.row);
                    this.towerManager.selectedType = this.selectedTowerType;
                } else if (this.towerManager) {
                    this.towerManager.setGhostPosition(null, null);
                    if (!this.selectedTowerType) this.towerManager.selectedType = null;
                }

                if (this.hazardManager) {
                    const towers = this.towerManager ? this.towerManager.towers : [];
                    const enemies = this.enemyManager ? this.enemyManager.getActiveEnemies() : [];
                    this.hazardManager.update(scaledDt, Date.now(), towers, enemies, this);
                }

                if (this.waveManager) this.waveManager.update(scaledDt);
                if (this.enemyManager) {
                    this.enemyManager.update(scaledDt, this);
                    if (this.projectileManager) this.projectileManager.enemiesRef = this.enemyManager.enemies;
                }
                if (this.towerManager && this.enemyManager) {
                    this.towerManager.update(scaledDt, this.enemyManager.getActiveEnemies(), this);
                }
                if (this.projectileManager) this.projectileManager.update(scaledDt);
                if (this.particleSystem) this.particleSystem.update(scaledDt);
                if (this.ambientParticles) this.ambientParticles.update(dt);

                if (input.mouse.clicked) this._handlePlayingClick(input.mouse.x, input.mouse.y);
                if (input.mouse.rightClicked) { this.selectedTower = null; this.selectedTowerType = null; }
                if (this.coopEnabled) this._handleP2Actions();
            }
        }

        // --------------------------------------------------
        //  Click handling during PLAYING state
        // --------------------------------------------------
        _handlePlayingClick(mx, my) {
            if (mx < 40 && my < topBarHeight) { this.state = STATE.MAP_SELECT; this._syncMapSelData(); return; }

            const speedBtnX = canvasWidth - (isMobile ? 60 : sidebarWidth + 60);
            if (mx >= speedBtnX && mx <= speedBtnX + 50 && my <= topBarHeight) {
                this.gameSpeed = this.gameSpeed === 1 ? 2 : 1; return;
            }
            const pauseBtnX = canvasWidth - (isMobile ? 10 : sidebarWidth + 10);
            if (mx >= pauseBtnX - 40 && mx <= pauseBtnX && my <= topBarHeight) { this.pauseGame(); return; }

            const bbTop = canvasHeight - bottomBarHeight;
            const bbRight = isMobile ? canvasWidth : canvasWidth - sidebarWidth;

            if (my >= bbTop && mx < bbRight) {
                const btnX = bbRight - 130;
                if (mx >= btnX && this.waveManager && !this.waveManager.waveActive) {
                    this.waveManager.startWave();
                    if (this.audioEngine) this.audioEngine.playWaveStart();
                    return;
                }
            }

            if (!isMobile && mx >= canvasWidth - sidebarWidth && my >= topBarHeight) {
                this._handleSidebarClick(mx, my); return;
            }
            if (isMobile && my >= bbTop) { this._handleMobileTowerStripClick(mx, my); return; }

            if (my >= topBarHeight && my < bbTop && mx < (isMobile ? canvasWidth : canvasWidth - sidebarWidth)) {
                const grid = input.screenToGrid(mx, my);
                if (grid.col >= 0 && grid.col < gridCols && grid.row >= 0 && grid.row < gridRows) {
                    const existing = this.towerManager && this.towerManager.grid[grid.col] ?
                        this.towerManager.grid[grid.col][grid.row] : null;
                    if (existing) {
                        this.selectedTower = existing;
                        this.selectedTowerType = null;
                        this.towerManager.selectedTower = existing;
                        if (this.audioEngine) this.audioEngine.playUIClick();
                    } else if (this.selectedTowerType) {
                        if (this.towerManager && this.towerManager.canPlace(grid.col, grid.row, this)) {
                            this.towerManager.placeTower(this.selectedTowerType, grid.col, grid.row, this);
                        }
                    } else {
                        this.selectedTower = null;
                        if (this.towerManager) this.towerManager.selectedTower = null;
                    }
                }
            }
        }

        _handleSidebarClick(mx, my) {
            const sx = canvasWidth - sidebarWidth;
            const localY = my - topBarHeight;

            if (this.selectedTower) {
                if (localY >= 118 && localY <= 152) {
                    const cost = this.selectedTower.getUpgradeCost();
                    if (cost > 0 && this.gold >= cost && this.towerManager) this.towerManager.upgradeTower(this.selectedTower, this);
                    return;
                }
                if (localY >= 156 && localY <= 190) {
                    if (this.towerManager) { this.towerManager.sellTower(this.selectedTower, this); this.selectedTower = null; }
                    return;
                }
                if (localY >= 200) { this.selectedTower = null; if (this.towerManager) this.towerManager.selectedTower = null; }
            }

            const available = this._getAvailableTowerTypes();
            const startY = this.selectedTower ? 210 : 10;
            const cardH = 48, gap = 4;
            for (let i = 0; i < this._towerTypeKeys.length; i++) {
                const key = this._towerTypeKeys[i];
                const cy = startY + i * (cardH + gap);
                if (localY >= cy && localY <= cy + cardH) {
                    if (available.includes(key)) {
                        if (this.selectedTowerType === key) this.selectedTowerType = null;
                        else { this.selectedTowerType = key; this.selectedTower = null; if (this.towerManager) this.towerManager.selectedTower = null; }
                        if (this.audioEngine) this.audioEngine.playUIClick();
                    }
                    return;
                }
            }
        }

        _handleMobileTowerStripClick(mx, my) {
            const bbTop = canvasHeight - bottomBarHeight;
            const localY = my - bbTop;

            if (this.selectedTower && localY < 40) {
                if (mx < canvasWidth / 2) {
                    const cost = this.selectedTower.getUpgradeCost();
                    if (cost > 0 && this.gold >= cost && this.towerManager) this.towerManager.upgradeTower(this.selectedTower, this);
                } else {
                    if (this.towerManager) { this.towerManager.sellTower(this.selectedTower, this); this.selectedTower = null; }
                }
                return;
            }

            const available = this._getAvailableTowerTypes();
            const cardW = 64, padX = 8;
            const towerStripY = this.selectedTower ? 44 : 4;
            if (localY >= towerStripY && localY <= towerStripY + 56) {
                for (let i = 0; i < this._towerTypeKeys.length; i++) {
                    const key = this._towerTypeKeys[i];
                    const cx = padX + i * (cardW + 4);
                    if (mx >= cx && mx <= cx + cardW) {
                        if (available.includes(key)) {
                            if (this.selectedTowerType === key) this.selectedTowerType = null;
                            else { this.selectedTowerType = key; this.selectedTower = null; if (this.towerManager) this.towerManager.selectedTower = null; }
                            if (this.audioEngine) this.audioEngine.playUIClick();
                        }
                        return;
                    }
                }
            }

            if (mx >= canvasWidth - 130 && localY >= bottomBarHeight - 44) {
                if (this.waveManager && !this.waveManager.waveActive) {
                    this.waveManager.startWave();
                    if (this.audioEngine) this.audioEngine.playWaveStart();
                }
            }
        }

        _handleP2Actions() {
            if (input.isP2Action('cycleNext')) this._cycleTowerType(1);
            if (input.isP2Action('cyclePrev')) this._cycleTowerType(-1);
            if (input.isP2Action('place') && this.selectedTowerType) {
                const grid = input.screenToGrid(input.p2Cursor.x, input.p2Cursor.y);
                if (this.towerManager && this.towerManager.canPlace(grid.col, grid.row, this)) {
                    this.towerManager.placeTower(this.selectedTowerType, grid.col, grid.row, this);
                }
            }
            if (input.isP2Action('upgrade') && this.selectedTower && this.towerManager) this.towerManager.upgradeTower(this.selectedTower, this);
            if (input.isP2Action('sell') && this.selectedTower && this.towerManager) { this.towerManager.sellTower(this.selectedTower, this); this.selectedTower = null; }
            if (input.isP2Action('startWave') && this.waveManager && !this.waveManager.waveActive) {
                this.waveManager.startWave();
                if (this.audioEngine) this.audioEngine.playWaveStart();
            }
        }

        // --------------------------------------------------
        //  Render
        // --------------------------------------------------
        render(ctx, alpha) {
            ctx.save();
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.fillStyle = CANVAS_BG;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            if (this.shake.x || this.shake.y) ctx.translate(this.shake.x, this.shake.y);

            switch (this.state) {
                case STATE.MENU: this.renderMenu(ctx); break;
                case STATE.MAP_SELECT: this.renderMapSelect(ctx); break;
                case STATE.PLAYING:
                case STATE.PAUSED:
                    this.renderGame(ctx, alpha);
                    if (this.state === STATE.PAUSED) this.renderPauseOverlay(ctx);
                    break;
                case STATE.GAME_OVER:
                case STATE.VICTORY:
                    this.renderGame(ctx, alpha);
                    this.renderEndScreen(ctx);
                    break;
            }
            ctx.restore();
        }

        // ---- Menu ----
        renderMenu(ctx) {
            const cx = canvasWidth / 2, cy = canvasHeight / 2;

            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, canvasWidth * 0.6);
            grad.addColorStop(0, 'rgba(15, 52, 96, 0.5)');
            grad.addColorStop(1, 'rgba(26, 26, 46, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (!reducedMotion) {
                for (const p of this._menuParticles) {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = '#feca57';
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; ctx.lineWidth = 1;
            for (let x = 0; x < canvasWidth; x += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvasHeight); ctx.stroke(); }
            for (let y = 0; y < canvasHeight; y += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y); ctx.stroke(); }

            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

            ctx.save();
            ctx.font = 'bold 56px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#feca57'; ctx.shadowColor = '#e94560'; ctx.shadowBlur = 20;
            ctx.fillText('TOWER DEFENSE', cx, cy - 60);
            ctx.font = 'bold 36px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#e94560';
            ctx.fillText('ULTIMATE', cx, cy - 10);
            ctx.shadowBlur = 0; ctx.restore();

            ctx.font = '18px -apple-system, BlinkMacSystemFont, sans-serif'; ctx.fillStyle = '#b8b8b8';
            ctx.fillText('8 Maps  \u2022  12 Towers  \u2022  30 Waves  \u2022  Epic Bosses', cx, cy + 40);
            ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif'; ctx.fillStyle = '#666';
            ctx.fillText('Local co-op: Player 2 uses keyboard (WASD + Space)', cx, cy + 68);

            const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 500);
            ctx.globalAlpha = pulse;
            ctx.font = '24px -apple-system, BlinkMacSystemFont, sans-serif'; ctx.fillStyle = '#feca57';
            ctx.fillText('Click anywhere to start', cx, cy + 120);
            ctx.globalAlpha = 1;

            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif'; ctx.fillStyle = '#444';
            ctx.fillText('v1.0  |  Alford Family Game Portal', cx, canvasHeight - 24);

            ctx.font = '13px -apple-system, sans-serif'; ctx.fillStyle = '#555'; ctx.textAlign = 'left';
            ctx.fillText('\u2302 Home', 12, canvasHeight - 24);
        }

        // ---- Map Select ----
        renderMapSelect(ctx) {
            if (!reducedMotion) {
                for (const p of this._menuParticles) {
                    ctx.globalAlpha = p.alpha * 0.5; ctx.fillStyle = '#feca57';
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            if (this.mapSelRenderer) this.mapSelRenderer.render(ctx, canvasWidth, canvasHeight);
            ctx.font = '14px -apple-system, sans-serif'; ctx.fillStyle = '#aaa';
            ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            ctx.fillText('\u2190 Back', 16, 30);
        }

        // ---- In-Game ----
        renderGame(ctx, alpha) {
            if (this.mapRenderer) this.mapRenderer.render(ctx);
            if (this.ambientParticles && !reducedMotion) this.ambientParticles.render(ctx);
            if (this.towerManager) this.towerManager.render(ctx);
            if (this.enemyManager) this.enemyManager.render(ctx, alpha);
            if (this.projectileManager) this.projectileManager.render(ctx, alpha);
            if (this.particleSystem) this.particleSystem.render(ctx);

            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            for (const d of this.damageNums) {
                const progress = d.elapsed / d.duration;
                ctx.globalAlpha = 1 - progress;
                ctx.font = `bold ${14 + (1 - progress) * 4}px -apple-system, sans-serif`;
                ctx.fillStyle = d.color;
                ctx.fillText(d.text, d.x, d.y);
            }
            ctx.globalAlpha = 1;

            for (const a of this.announcements) {
                const progress = a.elapsed / a.duration;
                let annoAlpha = 1;
                if (progress < 0.1) annoAlpha = progress / 0.1;
                else if (progress > 0.7) annoAlpha = (1 - progress) / 0.3;
                ctx.globalAlpha = annoAlpha;
                ctx.font = `bold ${a.size}px -apple-system, sans-serif`;
                ctx.fillStyle = a.color; ctx.textAlign = 'center';
                const aY = topBarHeight + gameAreaHeight * 0.35;
                ctx.fillText(a.text, (isMobile ? canvasWidth : gameAreaWidth) / 2, aY);
            }
            ctx.globalAlpha = 1;

            if (this.coopEnabled) {
                ctx.beginPath(); ctx.arc(input.p2Cursor.x, input.p2Cursor.y, 12, 0, Math.PI * 2);
                ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3; ctx.stroke();
                ctx.font = '10px sans-serif'; ctx.fillStyle = '#3498db'; ctx.textAlign = 'center';
                ctx.fillText('P2', input.p2Cursor.x, input.p2Cursor.y - 18);
            }

            if (this.hoveredGridCell && this.selectedTowerType && this.state === STATE.PLAYING) {
                const hc = this.hoveredGridCell;
                const hx = hc.col * GRID_SIZE, hy = topBarHeight + hc.row * GRID_SIZE;
                const canPlace = this.towerManager && this.towerManager.canPlace(hc.col, hc.row, this);
                ctx.fillStyle = canPlace ? 'rgba(46,204,113,0.15)' : 'rgba(233,69,96,0.15)';
                ctx.fillRect(hx, hy, GRID_SIZE, GRID_SIZE);
            }

            if (this.enemyManager && this.enemyManager.boss) {
                const boss = this.enemyManager.boss;
                if (boss.active && boss.hp > 0) this._renderBossHealthBar(ctx, boss);
            }

            this._renderHUD(ctx);
        }

        _renderBossHealthBar(ctx, boss) {
            const barW = Math.min(400, gameAreaWidth * 0.5), barH = 12;
            const bx = (isMobile ? canvasWidth : gameAreaWidth) / 2 - barW / 2;
            const by = topBarHeight + 8;
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(bx - 4, by - 4, barW + 8, barH + 24);
            ctx.font = 'bold 11px -apple-system, sans-serif'; ctx.fillStyle = '#e94560';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.fillText(boss.bossName || 'BOSS', bx + barW / 2, by - 2);
            const hbY = by + 14;
            ctx.fillStyle = '#333'; ctx.fillRect(bx, hbY, barW, barH);
            const ratio = Math.max(0, boss.hp / boss.maxHp);
            ctx.fillStyle = ratio > 0.5 ? '#e94560' : ratio > 0.25 ? '#ff6b6b' : '#ff0000';
            ctx.fillRect(bx, hbY, barW * ratio, barH);
            ctx.font = '9px -apple-system, sans-serif'; ctx.fillStyle = '#fff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.ceil(boss.hp)} / ${Math.ceil(boss.maxHp)}`, bx + barW / 2, hbY + barH / 2);
        }

        // --------------------------------------------------
        //  Full HUD
        // --------------------------------------------------
        _renderHUD(ctx) {
            ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0, 0, canvasWidth, topBarHeight);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, topBarHeight); ctx.lineTo(canvasWidth, topBarHeight); ctx.stroke();

            ctx.textBaseline = 'middle'; ctx.textAlign = 'left';
            const y = topBarHeight / 2;
            let x = 44;

            ctx.font = '18px sans-serif'; ctx.fillStyle = '#888'; ctx.fillText('\u2302', 12, y);

            ctx.font = '12px -apple-system, sans-serif'; ctx.fillStyle = '#888'; ctx.fillText('WAVE', x, y);
            x += 42;
            ctx.font = 'bold 15px -apple-system, sans-serif'; ctx.fillStyle = '#3498db';
            ctx.fillText(`${this.wave}/${this.maxWaves}`, x, y); x += 64;

            ctx.font = '15px sans-serif'; ctx.fillStyle = this.lives <= 5 ? '#e94560' : '#e74c3c'; ctx.fillText('\u2764', x, y);
            x += 22;
            ctx.font = 'bold 15px -apple-system, sans-serif'; ctx.fillStyle = this.lives <= 5 ? '#e94560' : '#fff';
            ctx.fillText(String(this.lives), x, y); x += 36;

            ctx.font = '14px sans-serif'; ctx.fillStyle = '#feca57'; ctx.fillText('\u{1F4B0}', x, y);
            x += 22;
            ctx.font = 'bold 15px -apple-system, sans-serif'; ctx.fillStyle = '#feca57';
            ctx.fillText(String(this.gold), x, y); x += 64;

            ctx.font = '14px sans-serif'; ctx.fillStyle = '#feca57';
            const starCount = this.progressionManager ? this.progressionManager.getTotalStars() : 0;
            ctx.fillText(`\u2605 ${starCount}`, x, y);

            const rightEdge = canvasWidth - (isMobile ? 16 : sidebarWidth + 16);
            ctx.textAlign = 'right';
            ctx.font = '14px -apple-system, sans-serif'; ctx.fillStyle = '#aaa'; ctx.fillText('\u23F8', rightEdge, y);
            ctx.font = 'bold 13px -apple-system, sans-serif'; ctx.fillStyle = this.gameSpeed > 1 ? '#feca57' : '#666';
            ctx.fillText(`${this.gameSpeed}x`, rightEdge - 30, y);
            ctx.textAlign = 'left';

            if (!isMobile) this._renderSidebar(ctx);
            this._renderBottomBar(ctx);
        }

        // --------------------------------------------------
        //  Sidebar (tower panel)
        // --------------------------------------------------
        _renderSidebar(ctx) {
            const sx = canvasWidth - sidebarWidth;
            ctx.fillStyle = 'rgba(0,0,0,0.88)';
            ctx.fillRect(sx, topBarHeight, sidebarWidth, canvasHeight - topBarHeight);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(sx, topBarHeight); ctx.lineTo(sx, canvasHeight); ctx.stroke();

            const available = this._getAvailableTowerTypes();
            let startY = 0;
            if (this.selectedTower) startY = this._renderSelectedTowerInfo(ctx, sx, topBarHeight);

            const cardStartY = topBarHeight + startY + 8;
            ctx.font = 'bold 11px -apple-system, sans-serif'; ctx.fillStyle = '#888';
            ctx.textAlign = 'left'; ctx.textBaseline = 'top';
            ctx.fillText('TOWERS', sx + 10, cardStartY);

            const cardH = 48, gap = 3;
            let cy = cardStartY + 18;
            const tiers = [1, 2, 3, 4];
            const tierNames = { 1: 'Tier 1', 2: 'Tier 2', 3: 'Tier 3', 4: 'Tier 4' };

            for (const tier of tiers) {
                const tierKeys = this._towerTypeKeys.filter(k => TOWER_DEFS[k].tier === tier);
                if (tierKeys.length === 0) continue;
                const tierUnlocked = this.progressionManager ? this.progressionManager.isTowerUnlocked(tier) : tier === 1;

                ctx.font = '9px -apple-system, sans-serif'; ctx.fillStyle = tierUnlocked ? '#666' : '#444';
                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                ctx.fillText(tierUnlocked ? tierNames[tier] : `${tierNames[tier]} (\u2605${TIER_UNLOCK[tier]})`, sx + 10, cy);
                cy += 14;

                for (const key of tierKeys) {
                    const def = TOWER_DEFS[key];
                    const isAvail = available.includes(key);
                    const isSelected = this.selectedTowerType === key;
                    const canAfford = this.gold >= def.cost;

                    ctx.fillStyle = isSelected ? 'rgba(254,202,87,0.15)' : (isAvail && canAfford ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.3)');
                    ctx.fillRect(sx + 6, cy, sidebarWidth - 12, cardH);
                    if (isSelected) { ctx.strokeStyle = '#feca57'; ctx.lineWidth = 2; ctx.strokeRect(sx + 6, cy, sidebarWidth - 12, cardH); }

                    ctx.font = '20px sans-serif'; ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
                    ctx.fillStyle = isAvail ? def.color : '#444';
                    ctx.fillText(def.icon, sx + 28, cy + cardH / 2);

                    ctx.textAlign = 'left'; ctx.font = 'bold 12px -apple-system, sans-serif';
                    ctx.fillStyle = isAvail ? '#ddd' : '#555'; ctx.textBaseline = 'top';
                    ctx.fillText(def.name, sx + 48, cy + 6);
                    ctx.font = '10px -apple-system, sans-serif';
                    ctx.fillStyle = isAvail ? (canAfford ? '#feca57' : '#e94560') : '#555';
                    ctx.fillText(`${def.cost}g`, sx + 48, cy + 22);
                    ctx.fillStyle = isAvail ? '#777' : '#444';
                    ctx.fillText(def.description.substring(0, 28), sx + 48, cy + 34);

                    if (!isAvail) {
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sx + 6, cy, sidebarWidth - 12, cardH);
                        ctx.font = '14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#666'; ctx.fillText('\uD83D\uDD12', sx + sidebarWidth / 2, cy + cardH / 2);
                    }
                    cy += cardH + gap;
                }
                cy += 4;
            }
        }

        _renderSelectedTowerInfo(ctx, sx, offsetY) {
            const t = this.selectedTower;
            if (!t) return 0;
            const def = t.def, panelH = 200;

            ctx.fillStyle = 'rgba(30,30,50,0.95)'; ctx.fillRect(sx + 2, offsetY + 2, sidebarWidth - 4, panelH);
            ctx.strokeStyle = def.color; ctx.lineWidth = 2; ctx.strokeRect(sx + 2, offsetY + 2, sidebarWidth - 4, panelH);

            const px = sx + 12;
            let py = offsetY + 14;

            ctx.font = '22px sans-serif'; ctx.fillStyle = def.color; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
            ctx.fillText(def.icon, px, py);
            ctx.font = 'bold 14px -apple-system, sans-serif'; ctx.fillStyle = '#fff';
            ctx.fillText(`${def.name} Lv.${t.level}`, px + 32, py + 2);
            py += 30;

            ctx.font = '11px -apple-system, sans-serif'; ctx.fillStyle = '#aaa';
            ctx.fillText(`DMG: ${t.damage}  |  Rate: ${t.fireRate}ms  |  Range: ${t.range}`, px, py);
            py += 16;
            ctx.fillText(`Kills: ${t.kills}  |  Total DMG: ${t.totalDamageDealt}`, px, py);
            py += 20;

            const upgCost = t.getUpgradeCost();
            const btnW = sidebarWidth - 24, btnH = 28;
            if (upgCost > 0) {
                const canUpg = this.gold >= upgCost;
                ctx.fillStyle = canUpg ? 'rgba(46,204,113,0.3)' : 'rgba(100,100,100,0.3)';
                ctx.fillRect(px, py, btnW, btnH);
                ctx.strokeStyle = canUpg ? '#2ecc71' : '#555'; ctx.lineWidth = 1; ctx.strokeRect(px, py, btnW, btnH);
                ctx.font = 'bold 12px -apple-system, sans-serif'; ctx.fillStyle = canUpg ? '#2ecc71' : '#666';
                ctx.textBaseline = 'middle'; ctx.fillText(`Upgrade (${upgCost}g)`, px + 8, py + btnH / 2);
            } else {
                ctx.fillStyle = 'rgba(100,100,100,0.2)'; ctx.fillRect(px, py, btnW, btnH);
                ctx.font = '12px -apple-system, sans-serif'; ctx.fillStyle = '#555';
                ctx.textBaseline = 'middle'; ctx.fillText('MAX LEVEL', px + 8, py + btnH / 2);
            }
            py += btnH + 6;

            const sellVal = t.getSellValue();
            ctx.fillStyle = 'rgba(233,69,96,0.3)'; ctx.fillRect(px, py, btnW, btnH);
            ctx.strokeStyle = '#e94560'; ctx.lineWidth = 1; ctx.strokeRect(px, py, btnW, btnH);
            ctx.font = 'bold 12px -apple-system, sans-serif'; ctx.fillStyle = '#e94560';
            ctx.textBaseline = 'middle'; ctx.fillText(`Sell (+${sellVal}g)`, px + 8, py + btnH / 2);

            return panelH + 4;
        }

        // --------------------------------------------------
        //  Bottom bar
        // --------------------------------------------------
        _renderBottomBar(ctx) {
            const bbTop = canvasHeight - bottomBarHeight;
            const bbWidth = isMobile ? canvasWidth : canvasWidth - sidebarWidth;

            ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0, bbTop, bbWidth, bottomBarHeight);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, bbTop); ctx.lineTo(bbWidth, bbTop); ctx.stroke();

            if (isMobile) { this._renderMobileTowerStrip(ctx, bbTop); return; }

            if (this.wavePreview) this.wavePreview.render(ctx, 10, bbTop + 4, bbWidth * 0.55);

            const wm = this.waveManager;
            if (wm) {
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (!wm.waveActive && !wm.wavesCompleted) {
                    const remain = Math.ceil(wm.getPrepTimeRemaining() / 1000);
                    ctx.font = '11px -apple-system, sans-serif'; ctx.fillStyle = '#888';
                    ctx.fillText(`Next wave in ${remain}s`, bbWidth * 0.7, bbTop + bottomBarHeight / 2 - 8);
                } else if (wm.waveActive) {
                    const activeCount = this.enemyManager ? this.enemyManager.getActiveEnemies().length : 0;
                    ctx.font = '11px -apple-system, sans-serif'; ctx.fillStyle = '#e94560';
                    ctx.fillText(`Enemies: ${activeCount}`, bbWidth * 0.7, bbTop + bottomBarHeight / 2 - 8);
                }
                if (!wm.waveActive && !wm.wavesCompleted) {
                    const btnX = bbWidth - 130, btnY = bbTop + 8, btnW = 120, btnH = bottomBarHeight - 16;
                    ctx.fillStyle = 'rgba(46,204,113,0.3)'; ctx.fillRect(btnX, btnY, btnW, btnH);
                    ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 2; ctx.strokeRect(btnX, btnY, btnW, btnH);
                    ctx.font = 'bold 14px -apple-system, sans-serif'; ctx.fillStyle = '#2ecc71';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('Start Wave', btnX + btnW / 2, btnY + btnH / 2);
                }
            }
        }

        _renderMobileTowerStrip(ctx, bbTop) {
            const available = this._getAvailableTowerTypes();
            let stripY = bbTop + 4;

            if (this.selectedTower) {
                const t = this.selectedTower;
                ctx.font = '11px -apple-system, sans-serif'; ctx.textBaseline = 'middle'; ctx.textAlign = 'left';
                ctx.fillStyle = t.def.color;
                ctx.fillText(`${t.def.icon} ${t.def.name} Lv.${t.level}`, 8, stripY + 14);
                const upgCost = t.getUpgradeCost();
                if (upgCost > 0) { ctx.fillStyle = this.gold >= upgCost ? '#2ecc71' : '#666'; ctx.fillText(`[Upg ${upgCost}g]`, canvasWidth * 0.35, stripY + 14); }
                ctx.fillStyle = '#e94560'; ctx.fillText(`[Sell +${t.getSellValue()}g]`, canvasWidth * 0.65, stripY + 14);
                stripY += 32;
            }

            const cardW = 58, cardH = 48, padX = 6;
            for (let i = 0; i < this._towerTypeKeys.length; i++) {
                const key = this._towerTypeKeys[i];
                const def = TOWER_DEFS[key];
                const isAvail = available.includes(key);
                const isSelected = this.selectedTowerType === key;
                const cx = padX + i * (cardW + 4);

                ctx.fillStyle = isSelected ? 'rgba(254,202,87,0.2)' : (isAvail ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.3)');
                ctx.fillRect(cx, stripY, cardW, cardH);
                if (isSelected) { ctx.strokeStyle = '#feca57'; ctx.lineWidth = 2; ctx.strokeRect(cx, stripY, cardW, cardH); }

                ctx.font = '18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = isAvail ? def.color : '#444'; ctx.fillText(def.icon, cx + cardW / 2, stripY + 16);
                ctx.font = '9px -apple-system, sans-serif';
                ctx.fillStyle = isAvail ? (this.gold >= def.cost ? '#feca57' : '#e94560') : '#444';
                ctx.fillText(`${def.cost}`, cx + cardW / 2, stripY + 36);
            }

            if (this.waveManager && !this.waveManager.waveActive && !this.waveManager.wavesCompleted) {
                const btnX = canvasWidth - 110, btnY = bbTop + bottomBarHeight - 38, btnW = 100, btnH = 30;
                ctx.fillStyle = 'rgba(46,204,113,0.3)'; ctx.fillRect(btnX, btnY, btnW, btnH);
                ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 2; ctx.strokeRect(btnX, btnY, btnW, btnH);
                ctx.font = 'bold 12px -apple-system, sans-serif'; ctx.fillStyle = '#2ecc71';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('Start Wave', btnX + btnW / 2, btnY + btnH / 2);
            }
        }

        // ---- Pause Overlay ----
        renderPauseOverlay(ctx) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const cx = canvasWidth / 2, cy = canvasHeight / 2;

            ctx.font = 'bold 48px -apple-system, sans-serif'; ctx.fillStyle = '#feca57';
            ctx.fillText('PAUSED', cx, cy - 40);

            const btnW = 180, btnH = 44;
            ctx.fillStyle = 'rgba(46,204,113,0.3)'; ctx.fillRect(cx - btnW / 2, cy + 10, btnW, btnH);
            ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 2; ctx.strokeRect(cx - btnW / 2, cy + 10, btnW, btnH);
            ctx.font = 'bold 18px -apple-system, sans-serif'; ctx.fillStyle = '#2ecc71';
            ctx.fillText('Click to Resume', cx, cy + 32);

            ctx.fillStyle = 'rgba(233,69,96,0.2)'; ctx.fillRect(cx - btnW / 2, cy + 68, btnW, btnH);
            ctx.strokeStyle = '#e94560'; ctx.lineWidth = 1; ctx.strokeRect(cx - btnW / 2, cy + 68, btnW, btnH);
            ctx.font = '14px -apple-system, sans-serif'; ctx.fillStyle = '#e94560';
            ctx.fillText('Quit to Map Select', cx, cy + 90);

            ctx.font = '12px -apple-system, sans-serif'; ctx.fillStyle = '#666';
            ctx.fillText('Press Escape or P to resume', cx, cy + 130);
        }

        // ---- End Screen ----
        renderEndScreen(ctx) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const cx = canvasWidth / 2, cy = canvasHeight / 2;

            if (this.state === STATE.VICTORY) {
                const grad = ctx.createRadialGradient(cx, cy - 30, 0, cx, cy - 30, 200);
                grad.addColorStop(0, 'rgba(254,202,87,0.15)'); grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.font = 'bold 52px -apple-system, sans-serif'; ctx.fillStyle = '#feca57';
                ctx.shadowColor = '#feca57'; ctx.shadowBlur = 20;
                ctx.fillText('VICTORY!', cx, cy - 60); ctx.shadowBlur = 0;
                ctx.font = '40px sans-serif'; ctx.fillStyle = '#feca57';
                ctx.fillText('\u2605'.repeat(this.stars) + '\u2606'.repeat(3 - this.stars), cx, cy);
                ctx.font = '16px -apple-system, sans-serif'; ctx.fillStyle = '#b8b8b8';
                ctx.fillText(`Score: ${this.score}`, cx, cy + 45);
                ctx.fillText(`Time: ${Math.floor(this.elapsedTime / 60000)}m ${Math.floor((this.elapsedTime % 60000) / 1000)}s`, cx, cy + 70);
            } else {
                const grad = ctx.createRadialGradient(cx, cy - 30, 0, cx, cy - 30, 200);
                grad.addColorStop(0, 'rgba(233,69,96,0.15)'); grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.font = 'bold 52px -apple-system, sans-serif'; ctx.fillStyle = '#e94560';
                ctx.shadowColor = '#e94560'; ctx.shadowBlur = 20;
                ctx.fillText('DEFEATED', cx, cy - 60); ctx.shadowBlur = 0;
                ctx.font = '20px -apple-system, sans-serif'; ctx.fillStyle = '#b8b8b8';
                ctx.fillText(`Reached wave ${this.wave} of ${this.maxWaves}`, cx, cy);
                ctx.font = '16px -apple-system, sans-serif'; ctx.fillStyle = '#888';
                ctx.fillText(`Score: ${this.score}`, cx, cy + 35);
            }

            const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 500);
            ctx.globalAlpha = pulse; ctx.font = '20px -apple-system, sans-serif'; ctx.fillStyle = '#fff';
            ctx.fillText('Click to continue', cx, cy + 110); ctx.globalAlpha = 1;
        }
    }


    // ==================== INITIALIZATION ====================

    var game = null;

    function init() {
        input.init();
        game = new GameManager();

        canvas.addEventListener('click', (e) => {
            if (!game) return;
            const mx = e.clientX, my = e.clientY;

            if (game.audioEngine && !game.audioEngine.initialized) game.audioEngine.init();
            if (game.audioEngine) game.audioEngine.resume();

            if (game.state === STATE.MENU) {
                if (mx < 80 && my > canvasHeight - 40) { window.location.href = '../../index.html'; return; }
                game.state = STATE.MAP_SELECT;
                game._syncMapSelData();
                if (game.audioEngine) game.audioEngine.playUIClick();
                return;
            }

            if (game.state === STATE.MAP_SELECT) {
                if (mx < 80 && my < 50) { game.state = STATE.MENU; if (game.audioEngine) game.audioEngine.playUIClick(); return; }
                if (game.mapSelRenderer) {
                    const mapIdx = game.mapSelRenderer.getClickedMap(mx, my, canvasWidth);
                    if (mapIdx >= 0) { game.startGame(mapIdx); if (game.audioEngine) game.audioEngine.playUIClick(); }
                }
                return;
            }

            if (game.state === STATE.PAUSED) {
                const cx = canvasWidth / 2, cy = canvasHeight / 2, btnW = 180;
                if (mx >= cx - btnW / 2 && mx <= cx + btnW / 2 && my >= cy + 10 && my <= cy + 54) { game.resumeGame(); return; }
                if (mx >= cx - btnW / 2 && mx <= cx + btnW / 2 && my >= cy + 68 && my <= cy + 112) { game.state = STATE.MAP_SELECT; game._syncMapSelData(); return; }
                game.resumeGame();
                return;
            }

            if (game.state === STATE.GAME_OVER || game.state === STATE.VICTORY) {
                game.state = STATE.MAP_SELECT;
                game._syncMapSelData();
                return;
            }
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        window.addEventListener('keydown', (e) => {
            if (!game) return;
            if (e.code === 'Escape' || e.code === 'KeyP') {
                if (game.state === STATE.PLAYING) game.pauseGame();
                else if (game.state === STATE.PAUSED) game.resumeGame();
            }
            if (game.state === STATE.PLAYING) {
                const num = parseInt(e.key);
                if (num >= 1 && num <= 9) {
                    const available = game._getAvailableTowerTypes();
                    if (num <= available.length) {
                        game.selectedTowerType = available[num - 1];
                        game.selectedTower = null;
                        if (game.towerManager) game.towerManager.selectedTower = null;
                    }
                }
                if (e.code === 'Escape') { game.selectedTowerType = null; game.selectedTower = null; }
            }
        });

        canvas.addEventListener('wheel', (e) => {
            if (!game) return;
            if (game.state === STATE.MAP_SELECT && game.mapSelRenderer) {
                game.mapSelRenderer.targetScrollY -= e.deltaY * 0.5;
                game.mapSelRenderer.targetScrollY = Math.min(0, game.mapSelRenderer.targetScrollY);
            }
        });

        requestAnimationFrame(gameLoop);
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    </script>
</body>
</html>