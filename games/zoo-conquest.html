<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zoo Conquest - A Risk-Style Adventure!</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700&display=swap');

    body {
      font-family: 'Nunito', sans-serif;
      background: linear-gradient(135deg, #2d5016 0%, #4a7c23 50%, #2d5016 100%);
      min-height: 100vh;
    }

    .game-title {
      font-family: 'Fredoka One', cursive;
    }

    .territory {
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .territory:hover {
      filter: brightness(1.2);
      transform: scale(1.02);
    }

    .territory.selected {
      filter: brightness(1.3);
      stroke-width: 4;
      stroke: gold;
    }

    .dice {
      animation: roll 0.5s ease-out;
    }

    @keyframes roll {
      0% { transform: rotate(0deg) scale(0.5); }
      50% { transform: rotate(180deg) scale(1.2); }
      100% { transform: rotate(360deg) scale(1); }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .bounce {
      animation: bounce 0.5s ease infinite;
    }

    @keyframes cardFlip {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(0deg); }
    }

    .card-flip {
      animation: cardFlip 0.6s ease;
    }

    .glow {
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    }

    .animal-piece {
      display: inline-block;
      filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
    }

    @keyframes wiggle {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }

    .animal-piece:hover {
      animation: wiggle 0.3s ease infinite;
    }

    @keyframes placeAnimal {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }

    .placing {
      animation: placeAnimal 0.3s ease forwards;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    // Animal Army Types with Colors
    const ANIMAL_ARMIES = {
      turtles: { name: 'Turtles', color: '#22c55e', emoji: 'üê¢', bgColor: 'bg-green-500' },
      pandas: { name: 'Pandas', color: '#1f2937', emoji: 'üêº', bgColor: 'bg-gray-800' },
      penguins: { name: 'Penguins', color: '#3b82f6', emoji: 'üêß', bgColor: 'bg-blue-500' },
      stingrays: { name: 'Stingrays', color: '#92400e', emoji: 'ü¶à', bgColor: 'bg-amber-700' },
      redPandas: { name: 'Red Pandas', color: '#dc2626', emoji: 'ü¶ä', bgColor: 'bg-red-600' },
      flamingos: { name: 'Flamingos', color: '#ec4899', emoji: 'ü¶©', bgColor: 'bg-pink-500' },
    };

    // Kansas City Zoo Territories (based on actual zoo layout)
    // IMPORTANT: All territories within the same region MUST be connected to each other
    const TERRITORIES = {
      // Africa Region - all 3 connected to each other
      africa_savanna: { name: 'Africa Savanna', region: 'Africa', x: 120, y: 80, connections: ['africa_plains', 'africa_kopje', 'polar_passage'] },
      africa_plains: { name: 'African Plains', region: 'Africa', x: 200, y: 120, connections: ['africa_savanna', 'africa_kopje', 'discovery_barn'] },
      africa_kopje: { name: 'Kopje', region: 'Africa', x: 280, y: 80, connections: ['africa_savanna', 'africa_plains', 'tropics_entrance'] },

      // Tropics Region - all 3 connected to each other
      tropics_entrance: { name: 'Tropics Entrance', region: 'Tropics', x: 380, y: 100, connections: ['africa_kopje', 'tropics_aviary', 'tropics_rainforest', 'australia'] },
      tropics_aviary: { name: 'Tropical Aviary', region: 'Tropics', x: 450, y: 150, connections: ['tropics_entrance', 'tropics_rainforest'] },
      tropics_rainforest: { name: 'Rainforest', region: 'Tropics', x: 520, y: 100, connections: ['tropics_entrance', 'tropics_aviary', 'penguin_plaza'] },

      // Polar Region - both connected to each other
      polar_passage: { name: 'Polar Passage', region: 'Polar', x: 80, y: 180, connections: ['africa_savanna', 'penguin_plaza', 'stingray_bay', 'sea_lion_sound'] },
      penguin_plaza: { name: 'Penguin Plaza', region: 'Polar', x: 580, y: 180, connections: ['polar_passage', 'tropics_rainforest', 'australia'] },

      // Aquatic Region - both connected to each other
      stingray_bay: { name: 'Stingray Bay', region: 'Aquatic', x: 150, y: 280, connections: ['polar_passage', 'sea_lion_sound', 'discovery_barn'] },
      sea_lion_sound: { name: 'Sea Lion Sound', region: 'Aquatic', x: 60, y: 350, connections: ['polar_passage', 'stingray_bay', 'kids_zoo'] },

      // Australia Region - single territory
      australia: { name: 'Australia', region: 'Australia', x: 500, y: 250, connections: ['tropics_entrance', 'penguin_plaza', 'asia_trail'] },

      // Asia Region - both connected to each other
      asia_trail: { name: 'Asia Trail', region: 'Asia', x: 420, y: 320, connections: ['australia', 'tiger_trail', 'discovery_barn', 'helzberg_penguin'] },
      tiger_trail: { name: 'Tiger Trail', region: 'Asia', x: 350, y: 380, connections: ['asia_trail', 'kids_zoo', 'carousel_plaza'] },

      // Family Region - all 4 connected to each other (central hub)
      discovery_barn: { name: 'Discovery Barn', region: 'Family', x: 250, y: 220, connections: ['africa_plains', 'stingray_bay', 'asia_trail', 'helzberg_penguin', 'kids_zoo', 'carousel_plaza'] },
      kids_zoo: { name: "Kids' Zoo", region: 'Family', x: 180, y: 380, connections: ['sea_lion_sound', 'tiger_trail', 'carousel_plaza', 'discovery_barn', 'helzberg_penguin'] },
      carousel_plaza: { name: 'Carousel Plaza', region: 'Family', x: 280, y: 450, connections: ['kids_zoo', 'helzberg_penguin', 'discovery_barn', 'tiger_trail'] },
      helzberg_penguin: { name: 'Helzberg Penguin', region: 'Family', x: 350, y: 280, connections: ['discovery_barn', 'carousel_plaza', 'kids_zoo', 'asia_trail'] },
    };

    // Regions for bonus armies - Professional color palette with distinct, vibrant colors
    const REGIONS = {
      Africa: {
        territories: ['africa_savanna', 'africa_plains', 'africa_kopje'],
        bonus: 3,
        color: '#F59E0B',
        lightColor: '#FEF3C7',
        darkColor: '#B45309',
        emoji: 'ü¶Å',
        labelPos: { x: 200, y: 45 }
      },
      Tropics: {
        territories: ['tropics_entrance', 'tropics_aviary', 'tropics_rainforest'],
        bonus: 3,
        color: '#10B981',
        lightColor: '#D1FAE5',
        darkColor: '#047857',
        emoji: 'üå¥',
        labelPos: { x: 450, y: 55 }
      },
      Polar: {
        territories: ['polar_passage', 'penguin_plaza'],
        bonus: 2,
        color: '#3B82F6',
        lightColor: '#DBEAFE',
        darkColor: '#1D4ED8',
        emoji: '‚ùÑÔ∏è',
        labelPos: { x: 330, y: 155 }
      },
      Aquatic: {
        territories: ['stingray_bay', 'sea_lion_sound'],
        bonus: 2,
        color: '#06B6D4',
        lightColor: '#CFFAFE',
        darkColor: '#0E7490',
        emoji: 'üåä',
        labelPos: { x: 80, y: 250 }
      },
      Australia: {
        territories: ['australia'],
        bonus: 1,
        color: '#F97316',
        lightColor: '#FED7AA',
        darkColor: '#C2410C',
        emoji: 'ü¶ò',
        labelPos: { x: 530, y: 220 }
      },
      Asia: {
        territories: ['asia_trail', 'tiger_trail'],
        bonus: 2,
        color: '#EF4444',
        lightColor: '#FEE2E2',
        darkColor: '#B91C1C',
        emoji: 'üêÖ',
        labelPos: { x: 420, y: 380 }
      },
      Family: {
        territories: ['discovery_barn', 'kids_zoo', 'carousel_plaza', 'helzberg_penguin'],
        bonus: 4,
        color: '#A855F7',
        lightColor: '#F3E8FF',
        darkColor: '#7E22CE',
        emoji: 'üé†',
        labelPos: { x: 240, y: 320 }
      },
    };

    // Risk-Style Cards - Three types plus wild
    // Trade in 3 of same type OR 3 different types for bonus troops
    const CARD_TYPES = {
      infantry: { name: 'Infantry', emoji: 'üêæ', color: 'bg-green-500', description: 'Paw Print' },
      cavalry: { name: 'Cavalry', emoji: 'ü¶ì', color: 'bg-blue-500', description: 'Zebra' },
      artillery: { name: 'Artillery', emoji: 'üêò', color: 'bg-red-500', description: 'Elephant' },
      wild: { name: 'Wild', emoji: 'üåü', color: 'bg-yellow-500', description: 'Star - counts as any!' },
    };

    // Card deck - 14 infantry, 14 cavalry, 14 artillery, 2 wild (like Risk)
    const CARD_DECK = [
      // Infantry cards (14)
      ...Array(14).fill(null).map((_, i) => ({ id: `inf_${i}`, type: 'infantry', ...CARD_TYPES.infantry })),
      // Cavalry cards (14)
      ...Array(14).fill(null).map((_, i) => ({ id: `cav_${i}`, type: 'cavalry', ...CARD_TYPES.cavalry })),
      // Artillery cards (14)
      ...Array(14).fill(null).map((_, i) => ({ id: `art_${i}`, type: 'artillery', ...CARD_TYPES.artillery })),
      // Wild cards (2)
      ...Array(2).fill(null).map((_, i) => ({ id: `wild_${i}`, type: 'wild', ...CARD_TYPES.wild })),
    ];

    // Card trade-in values (escalating like Risk)
    const TRADE_IN_VALUES = [4, 6, 8, 10, 12, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60];

    // Check if a set of 3 cards can be traded
    const canTradeCards = (cards) => {
      if (cards.length < 3) return false;

      // Count card types (wild counts as any)
      const types = cards.map(c => c.type);
      const nonWildTypes = types.filter(t => t !== 'wild');
      const wildCount = types.filter(t => t === 'wild').length;

      // Check all combinations of 3 cards
      for (let i = 0; i < cards.length - 2; i++) {
        for (let j = i + 1; j < cards.length - 1; j++) {
          for (let k = j + 1; k < cards.length; k++) {
            const combo = [cards[i], cards[j], cards[k]];
            if (isValidTradeSet(combo)) return true;
          }
        }
      }
      return false;
    };

    // Check if exactly 3 cards form a valid trade set
    const isValidTradeSet = (threeCards) => {
      if (threeCards.length !== 3) return false;

      const types = threeCards.map(c => c.type);
      const wildCount = types.filter(t => t === 'wild').length;
      const nonWildTypes = types.filter(t => t !== 'wild');

      // All same type (with wilds filling in)
      const uniqueNonWild = [...new Set(nonWildTypes)];
      if (uniqueNonWild.length <= 1) return true; // All same (or all wild)

      // All different types (with wilds filling in)
      if (uniqueNonWild.length + wildCount >= 3 && uniqueNonWild.length === nonWildTypes.length) {
        // Check if we have 3 different types
        const allTypes = ['infantry', 'cavalry', 'artillery'];
        const missingTypes = allTypes.filter(t => !nonWildTypes.includes(t));
        if (missingTypes.length <= wildCount) return true;
      }

      return false;
    };

    // Find a valid trade set from cards (returns indices)
    const findValidTradeSet = (cards) => {
      for (let i = 0; i < cards.length - 2; i++) {
        for (let j = i + 1; j < cards.length - 1; j++) {
          for (let k = j + 1; k < cards.length; k++) {
            const combo = [cards[i], cards[j], cards[k]];
            if (isValidTradeSet(combo)) return [i, j, k];
          }
        }
      }
      return null;
    };

    // Dice Component
    const Dice = ({ value, color, isRolling }) => {
      const dots = {
        1: [[50, 50]],
        2: [[25, 25], [75, 75]],
        3: [[25, 25], [50, 50], [75, 75]],
        4: [[25, 25], [75, 25], [25, 75], [75, 75]],
        5: [[25, 25], [75, 25], [50, 50], [25, 75], [75, 75]],
        6: [[25, 25], [75, 25], [25, 50], [75, 50], [25, 75], [75, 75]],
      };

      return (
        <div className={`w-14 h-14 rounded-lg shadow-lg flex items-center justify-center ${isRolling ? 'dice' : ''}`}
             style={{ backgroundColor: color }}>
          <svg viewBox="0 0 100 100" className="w-10 h-10">
            {dots[value]?.map((pos, i) => (
              <circle key={i} cx={pos[0]} cy={pos[1]} r="10" fill="white" />
            ))}
          </svg>
        </div>
      );
    };

    // Risk-Style Card Component
    const Card = ({ card, isSelected, onSelect, small }) => {
      const typeInfo = CARD_TYPES[card.type];
      const sizeClass = small ? 'w-16 p-2' : 'w-24 p-3';

      return (
        <div
          className={`${sizeClass} bg-white rounded-xl shadow-lg border-4 transition-all cursor-pointer hover:scale-105 ${
            isSelected ? 'border-yellow-400 ring-2 ring-yellow-300' : 'border-gray-300'
          }`}
          onClick={() => onSelect && onSelect(card)}
        >
          <div className={`text-center mb-1 ${small ? 'text-2xl' : 'text-4xl'}`}>{typeInfo.emoji}</div>
          <div className={`font-bold text-center text-gray-800 ${small ? 'text-xs' : 'text-sm'}`}>{typeInfo.name}</div>
          <div className={`text-center mt-1 px-1 py-0.5 rounded-full ${typeInfo.color} text-white ${small ? 'text-[8px]' : 'text-xs'}`}>
            {card.type === 'wild' ? '‚≠ê WILD' : typeInfo.description}
          </div>
        </div>
      );
    };

    // Card Trade Modal
    const CardTradeModal = ({ cards, onTrade, onCancel, tradeCount, nextTradeValue }) => {
      const [selectedCards, setSelectedCards] = useState([]);

      const toggleCard = (card) => {
        if (selectedCards.find(c => c.id === card.id)) {
          setSelectedCards(selectedCards.filter(c => c.id !== card.id));
        } else if (selectedCards.length < 3) {
          setSelectedCards([...selectedCards, card]);
        }
      };

      const isValidSelection = selectedCards.length === 3 && isValidTradeSet(selectedCards);

      return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="bg-gradient-to-b from-amber-100 to-amber-200 p-6 rounded-2xl max-w-2xl w-full mx-4 shadow-2xl">
            <h2 className="text-2xl font-bold text-center mb-2 game-title text-amber-800">
              üÉè Trade Cards for Animals! üÉè
            </h2>
            <p className="text-center text-amber-700 mb-4">
              Select 3 cards: all same type OR one of each type
            </p>

            {/* Trade value info */}
            <div className="bg-green-100 rounded-lg p-3 mb-4 text-center">
              <span className="text-green-800 font-bold">
                Next trade gives you: <span className="text-2xl">{nextTradeValue}</span> animals! üéâ
              </span>
              <div className="text-green-600 text-sm">(Trade #{tradeCount + 1})</div>
            </div>

            {/* Card selection */}
            <div className="bg-white/50 rounded-xl p-4 mb-4">
              <div className="text-sm font-bold text-amber-800 mb-2">Your Cards ({cards.length}):</div>
              <div className="flex flex-wrap gap-2 justify-center">
                {cards.map((card) => (
                  <Card
                    key={card.id}
                    card={card}
                    isSelected={selectedCards.find(c => c.id === card.id)}
                    onSelect={toggleCard}
                    small
                  />
                ))}
              </div>
            </div>

            {/* Selected cards preview */}
            <div className="bg-amber-50 rounded-xl p-3 mb-4">
              <div className="text-sm font-bold text-amber-800 mb-2">Selected ({selectedCards.length}/3):</div>
              <div className="flex gap-2 justify-center min-h-[80px] items-center">
                {selectedCards.length === 0 ? (
                  <span className="text-amber-400">Click cards above to select</span>
                ) : (
                  selectedCards.map((card) => (
                    <Card key={card.id} card={card} isSelected onSelect={toggleCard} small />
                  ))
                )}
              </div>
              {selectedCards.length === 3 && (
                <div className={`text-center mt-2 font-bold ${isValidSelection ? 'text-green-600' : 'text-red-600'}`}>
                  {isValidSelection ? '‚úÖ Valid set!' : '‚ùå Must be 3 same OR 3 different types'}
                </div>
              )}
            </div>

            {/* Buttons */}
            <div className="flex gap-3 justify-center">
              <button
                onClick={() => onTrade(selectedCards)}
                disabled={!isValidSelection}
                className={`px-6 py-3 font-bold rounded-xl shadow-lg transition-all ${
                  isValidSelection
                    ? 'bg-green-500 hover:bg-green-600 text-white hover:scale-105'
                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                }`}
              >
                üéÅ Trade for {nextTradeValue} Animals!
              </button>
              <button
                onClick={onCancel}
                className="px-6 py-3 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg transition-all"
              >
                ‚ùå Cancel
              </button>
            </div>

            {/* Help text */}
            <div className="mt-4 text-center text-xs text-amber-600">
              <div>üêæ Infantry | ü¶ì Cavalry | üêò Artillery | üåü Wild (counts as any)</div>
            </div>
          </div>
        </div>
      );
    };

    // Territory on Map - Enhanced with region color indicator
    const Territory = ({ id, data, owner, troops, isSelected, isValidTarget, onClick }) => {
      const army = owner ? ANIMAL_ARMIES[owner] : null;
      const baseColor = army ? army.color : '#9ca3af';
      const region = REGIONS[data.region];
      const regionColor = region?.darkColor || '#1f2937';

      return (
        <g className={`territory ${isSelected ? 'selected' : ''}`} onClick={() => onClick(id)}>
          {/* Outer ring showing region color */}
          <circle
            cx={data.x}
            cy={data.y}
            r="40"
            fill="none"
            stroke={regionColor}
            strokeWidth="6"
            opacity="0.8"
          />

          {/* Shadow */}
          <ellipse
            cx={data.x + 2}
            cy={data.y + 3}
            rx="33"
            ry="33"
            fill="#000"
            opacity="0.2"
          />

          {/* Main territory circle */}
          <circle
            cx={data.x}
            cy={data.y}
            r="33"
            fill={baseColor}
            stroke={isValidTarget ? '#fbbf24' : isSelected ? '#fff' : '#1f2937'}
            strokeWidth={isValidTarget || isSelected ? 4 : 2}
          />

          {/* Highlight gradient overlay */}
          <circle
            cx={data.x}
            cy={data.y - 8}
            r="25"
            fill="white"
            opacity="0.15"
          />

          {/* Army emoji */}
          <text x={data.x} y={data.y - 3} textAnchor="middle" fill="white" fontSize="22"
                style={{ textShadow: '1px 1px 2px rgba(0,0,0,0.5)' }}>
            {army ? army.emoji : '‚ùì'}
          </text>

          {/* Troop count badge */}
          <circle
            cx={data.x + 20}
            cy={data.y + 20}
            r="14"
            fill="#1f2937"
            stroke="white"
            strokeWidth="2"
          />
          <text x={data.x + 20} y={data.y + 25} textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">
            {troops}
          </text>

          {/* Territory name below */}
          <text x={data.x} y={data.y + 55} textAnchor="middle" fill="#fef3c7" fontSize="9" fontWeight="600"
                style={{ textShadow: '1px 1px 2px rgba(0,0,0,0.8)' }}>
            {data.name}
          </text>
        </g>
      );
    };

    // Game Board Map - Professional Design
    const GameMap = ({ gameState, selectedTerritory, validTargets, onTerritoryClick }) => {

      // Create smooth convex hull-like path around region territories
      const createRegionPath = (territories, padding = 55) => {
        const points = territories.map(t => TERRITORIES[t]);
        if (points.length === 1) {
          // Single territory - create circle
          const p = points[0];
          return `M ${p.x - padding} ${p.y}
                  A ${padding} ${padding} 0 1 1 ${p.x + padding} ${p.y}
                  A ${padding} ${padding} 0 1 1 ${p.x - padding} ${p.y}`;
        }

        // Calculate centroid
        const cx = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const cy = points.reduce((sum, p) => sum + p.y, 0) / points.length;

        // Sort points by angle from centroid for proper polygon ordering
        const sortedPoints = [...points].sort((a, b) => {
          return Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx);
        });

        // Create expanded points
        const expandedPoints = sortedPoints.map(p => {
          const angle = Math.atan2(p.y - cy, p.x - cx);
          return {
            x: p.x + Math.cos(angle) * padding,
            y: p.y + Math.sin(angle) * padding
          };
        });

        // Create smooth curved path
        if (expandedPoints.length === 2) {
          const p1 = expandedPoints[0];
          const p2 = expandedPoints[1];
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          const bulge = dist * 0.4;

          // Calculate perpendicular direction
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const perpX = -dy / dist * bulge;
          const perpY = dx / dist * bulge;

          return `M ${p1.x} ${p1.y}
                  Q ${midX + perpX} ${midY + perpY} ${p2.x} ${p2.y}
                  Q ${midX - perpX} ${midY - perpY} ${p1.x} ${p1.y}`;
        }

        // For 3+ points, create smooth bezier curves
        let path = `M ${expandedPoints[0].x} ${expandedPoints[0].y}`;
        for (let i = 0; i < expandedPoints.length; i++) {
          const curr = expandedPoints[i];
          const next = expandedPoints[(i + 1) % expandedPoints.length];
          const midX = (curr.x + next.x) / 2;
          const midY = (curr.y + next.y) / 2;
          path += ` Q ${curr.x} ${curr.y} ${midX} ${midY}`;
        }
        path += ' Z';
        return path;
      };

      return (
      <svg viewBox="0 0 650 570" className="w-full max-w-4xl mx-auto drop-shadow-2xl">
        {/* Definitions for gradients and filters */}
        <defs>
          {/* Region gradients */}
          {Object.entries(REGIONS).map(([name, region]) => (
            <linearGradient key={`grad-${name}`} id={`region-gradient-${name}`} x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor={region.lightColor} stopOpacity="0.7" />
              <stop offset="100%" stopColor={region.color} stopOpacity="0.4" />
            </linearGradient>
          ))}

          {/* Glow filter for regions */}
          <filter id="region-glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feMerge>
              <feMergeNode in="blur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>

          {/* Drop shadow for labels */}
          <filter id="label-shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="1" dy="2" stdDeviation="2" floodOpacity="0.4" />
          </filter>

          {/* Path pattern */}
          <pattern id="path-pattern" x="0" y="0" width="12" height="12" patternUnits="userSpaceOnUse">
            <circle cx="2" cy="2" r="1.5" fill="#1a3d0c" opacity="0.5" />
          </pattern>
        </defs>

        {/* Decorative border */}
        <rect x="5" y="5" width="640" height="560" fill="none" stroke="#2d5016" strokeWidth="10" rx="25" />

        {/* Main background with texture */}
        <rect x="10" y="10" width="630" height="550" fill="#4a7c23" rx="20" />
        <rect x="10" y="10" width="630" height="550" fill="url(#path-pattern)" rx="20" opacity="0.3" />

        {/* REGION BACKGROUNDS - Main visual grouping */}
        {Object.entries(REGIONS).map(([name, region]) => {
          const path = createRegionPath(region.territories, 52);

          return (
            <g key={`region-bg-${name}`}>
              {/* Outer glow/border */}
              <path
                d={path}
                fill="none"
                stroke={region.color}
                strokeWidth="8"
                opacity="0.3"
                filter="url(#region-glow)"
              />

              {/* Main region fill */}
              <path
                d={path}
                fill={`url(#region-gradient-${name})`}
                stroke={region.darkColor}
                strokeWidth="3"
                strokeDasharray="0"
              />

              {/* Inner highlight */}
              <path
                d={createRegionPath(region.territories, 45)}
                fill="none"
                stroke={region.lightColor}
                strokeWidth="2"
                opacity="0.5"
              />
            </g>
          );
        })}

        {/* REGION LABELS - Clear, prominent labels */}
        {Object.entries(REGIONS).map(([name, region]) => {
          const labelX = region.labelPos.x;
          const labelY = region.labelPos.y;
          const labelWidth = name.length * 9 + 60;

          return (
            <g key={`region-label-${name}`} filter="url(#label-shadow)">
              {/* Label background plate */}
              <rect
                x={labelX - labelWidth / 2}
                y={labelY - 14}
                width={labelWidth}
                height="28"
                rx="14"
                fill={region.darkColor}
              />
              <rect
                x={labelX - labelWidth / 2 + 2}
                y={labelY - 12}
                width={labelWidth - 4}
                height="24"
                rx="12"
                fill={region.color}
              />

              {/* Label text */}
              <text
                x={labelX}
                y={labelY + 5}
                textAnchor="middle"
                fill="white"
                fontSize="13"
                fontWeight="bold"
                fontFamily="'Fredoka One', cursive"
              >
                {region.emoji} {name} +{region.bonus}
              </text>
            </g>
          );
        })}

        {/* Zoo paths/connections - drawn on top of regions */}
        {Object.entries(TERRITORIES).map(([id, data]) =>
          data.connections.map(connId => {
            if (id > connId) return null; // Only draw each connection once
            const conn = TERRITORIES[connId];
            const sameRegion = data.region === conn.region;

            return (
              <g key={`path-${id}-${connId}`}>
                {/* Path shadow */}
                <line
                  x1={data.x}
                  y1={data.y + 2}
                  x2={conn.x}
                  y2={conn.y + 2}
                  stroke="#1a3d0c"
                  strokeWidth="7"
                  strokeLinecap="round"
                  opacity="0.4"
                />
                {/* Main path */}
                <line
                  x1={data.x}
                  y1={data.y}
                  x2={conn.x}
                  y2={conn.y}
                  stroke={sameRegion ? "#5d9c2e" : "#3d6b1c"}
                  strokeWidth="5"
                  strokeLinecap="round"
                  strokeDasharray={sameRegion ? "0" : "8,6"}
                />
              </g>
            );
          })
        )}

        {/* Territories */}
        {Object.entries(TERRITORIES).map(([id, data]) => (
          <Territory
            key={id}
            id={id}
            data={data}
            owner={gameState.territories[id]?.owner}
            troops={gameState.territories[id]?.troops || 0}
            isSelected={selectedTerritory === id}
            isValidTarget={validTargets.includes(id)}
            onClick={onTerritoryClick}
          />
        ))}

        {/* Title Banner */}
        <g>
          <rect x="175" y="520" width="300" height="35" rx="17" fill="#2d5016" />
          <rect x="178" y="523" width="294" height="29" rx="14" fill="#4a7c23" />
          <text x="325" y="543" textAnchor="middle" fill="#fef3c7" fontSize="15" fontWeight="bold" fontFamily="'Fredoka One', cursive">
            ü¶Å Kansas City Zoo Adventure üêò
          </text>
        </g>
      </svg>
    );
    };

    // Region Legend Component - Shows all regions with bonuses
    const RegionLegend = () => (
      <div className="bg-gradient-to-b from-amber-800 to-amber-900 rounded-xl p-3 shadow-lg border-2 border-amber-600">
        <div className="text-center text-amber-100 font-bold text-sm mb-2 game-title">üó∫Ô∏è Zoo Regions</div>
        <div className="grid grid-cols-2 gap-1.5">
          {Object.entries(REGIONS).map(([name, region]) => (
            <div
              key={name}
              className="flex items-center gap-1.5 px-2 py-1 rounded-lg text-xs"
              style={{ backgroundColor: region.color + '33', borderLeft: `3px solid ${region.color}` }}
            >
              <span>{region.emoji}</span>
              <span className="font-semibold text-white">{name}</span>
              <span className="ml-auto font-bold" style={{ color: region.lightColor }}>+{region.bonus}</span>
            </div>
          ))}
        </div>
        <div className="text-center text-amber-200 text-xs mt-2 italic">
          Control all territories in a region for bonus animals!
        </div>
      </div>
    );

    // Player Panel
    const PlayerPanel = ({ player, isCurrentPlayer, armies, cards, onTradeCards, canTrade, troops, turnPhase }) => {
      // Count card types for display
      const cardCounts = {
        infantry: cards.filter(c => c.type === 'infantry').length,
        cavalry: cards.filter(c => c.type === 'cavalry').length,
        artillery: cards.filter(c => c.type === 'artillery').length,
        wild: cards.filter(c => c.type === 'wild').length,
      };

      return (
        <div className={`p-4 rounded-xl ${isCurrentPlayer ? 'ring-4 ring-yellow-400 glow' : ''}`}
             style={{ backgroundColor: armies.color + '33', borderLeft: `6px solid ${armies.color}` }}>
          <div className="flex items-center gap-3 mb-3">
            <span className="text-3xl">{armies.emoji}</span>
            <div>
              <div className="font-bold text-white text-lg">{player.name}</div>
              <div className="text-sm text-gray-200">{armies.name} Army</div>
            </div>
            {isCurrentPlayer && (
              <span className="ml-auto text-yellow-300 bounce">
                {player.isAI ? 'ü§ñ AI Turn' : 'üëë Your Turn!'}
              </span>
            )}
          </div>

          <div className="grid grid-cols-3 gap-2 text-center mb-3">
            <div className="bg-white/20 rounded-lg p-2">
              <div className="text-xl font-bold text-white">{player.territories}</div>
              <div className="text-xs text-gray-200">Zones</div>
            </div>
            <div className="bg-white/20 rounded-lg p-2">
              <div className="text-xl font-bold text-white">{troops}</div>
              <div className="text-xs text-gray-200">Animals</div>
            </div>
            <div className="bg-white/20 rounded-lg p-2">
              <div className="text-xl font-bold text-white">{cards.length}</div>
              <div className="text-xs text-gray-200">Cards</div>
            </div>
          </div>

          {/* Show card summary for current player */}
          {isCurrentPlayer && cards.length > 0 && (
            <div className="mt-2">
              <div className="text-sm text-white mb-2">Your Cards:</div>
              <div className="flex gap-1 justify-center mb-2">
                {cardCounts.infantry > 0 && (
                  <div className="bg-green-500 px-2 py-1 rounded text-white text-xs font-bold">
                    üêæ √ó{cardCounts.infantry}
                  </div>
                )}
                {cardCounts.cavalry > 0 && (
                  <div className="bg-blue-500 px-2 py-1 rounded text-white text-xs font-bold">
                    ü¶ì √ó{cardCounts.cavalry}
                  </div>
                )}
                {cardCounts.artillery > 0 && (
                  <div className="bg-red-500 px-2 py-1 rounded text-white text-xs font-bold">
                    üêò √ó{cardCounts.artillery}
                  </div>
                )}
                {cardCounts.wild > 0 && (
                  <div className="bg-yellow-500 px-2 py-1 rounded text-white text-xs font-bold">
                    üåü √ó{cardCounts.wild}
                  </div>
                )}
              </div>

              {/* Trade button - only during reinforce phase */}
              {turnPhase === 'reinforce' && canTrade && (
                <button
                  onClick={onTradeCards}
                  className="w-full px-3 py-2 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 text-white font-bold rounded-lg shadow transition-all hover:scale-105"
                >
                  üÉè Trade Cards for Animals!
                </button>
              )}
              {cards.length >= 5 && turnPhase === 'reinforce' && (
                <div className="text-yellow-300 text-xs text-center mt-1 font-bold animate-pulse">
                  ‚ö†Ô∏è 5+ cards - Must trade!
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Battle Modal
    const BattleModal = ({ attacker, defender, attackingFrom, defendingTo, onRoll, onRetreat, onClaimTerritory, battleResult, attackerDice, defenderDice, isRolling, isVictory, troopsToMove, setTroopsToMove }) => {
      // Attacker must leave 1 behind - can only attack with (troops - 1)
      // This is the core Risk rule: you cannot empty a territory
      const attackingAnimals = Math.max(0, attacker.troops - 1);
      const attackDiceCount = Math.min(3, attackingAnimals);
      const defendDiceCount = Math.min(2, defender.troops);
      const canContinueBattle = !isVictory && attacker.troops > 1 && defender.troops > 0;
      const cannotAttack = !isVictory && attacker.troops <= 1;

      // For victory: min 1 troop must move, max is all but 1 (leave 1 behind)
      const minTroopsToMove = 1;
      const maxTroopsToMove = attacker.troops - 1;

      return (
      <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
        <div className="bg-gradient-to-b from-amber-100 to-amber-200 p-6 rounded-2xl max-w-lg w-full mx-4 shadow-2xl">
          <h2 className="text-2xl font-bold text-center mb-4 game-title text-amber-800">
            {isVictory ? 'üéâ VICTORY! üéâ' : '‚öîÔ∏è BATTLE TIME! ‚öîÔ∏è'}
          </h2>

          <div className="flex justify-between items-center mb-6">
            <div className="text-center">
              <div className="text-4xl mb-2">{ANIMAL_ARMIES[attacker.army].emoji}</div>
              <div className="font-bold text-amber-900">{ANIMAL_ARMIES[attacker.army].name}</div>
              <div className="text-sm text-amber-700">{TERRITORIES[attackingFrom].name}</div>
              <div className="text-lg text-amber-800 mt-2">
                <span className="font-bold">{attacker.troops}</span> total
              </div>
              {!isVictory && (
                <>
                  <div className="text-sm text-amber-600">
                    ({attackingAnimals} can attack, 1 stays behind)
                  </div>
                  <div className="text-xl font-bold text-red-600 mt-1">
                    üé≤ {attackDiceCount} {attackDiceCount === 1 ? 'die' : 'dice'}
                  </div>
                </>
              )}
            </div>

            <div className="text-4xl">{isVictory ? '‚û°Ô∏è' : '‚öîÔ∏è'}</div>

            <div className="text-center">
              <div className="text-4xl mb-2">{isVictory ? ANIMAL_ARMIES[attacker.army].emoji : ANIMAL_ARMIES[defender.army].emoji}</div>
              <div className="font-bold text-amber-900">{isVictory ? 'NEW TERRITORY!' : ANIMAL_ARMIES[defender.army].name}</div>
              <div className="text-sm text-amber-700">{TERRITORIES[defendingTo].name}</div>
              {!isVictory && (
                <>
                  <div className="text-lg text-amber-800 mt-2">
                    <span className="font-bold">{defender.troops}</span> defending
                  </div>
                  <div className="text-xl font-bold text-blue-600 mt-1">
                    üé≤ {defendDiceCount} {defendDiceCount === 1 ? 'die' : 'dice'}
                  </div>
                </>
              )}
            </div>
          </div>

          {attackerDice.length > 0 && !isVictory && (
            <div className="mb-6">
              <div className="flex justify-center gap-8">
                <div className="text-center">
                  <div className="text-sm font-bold mb-2 text-red-600">Attacker</div>
                  <div className="flex gap-2 justify-center">
                    {[...attackerDice].sort((a, b) => b - a).map((val, i) => (
                      <Dice key={i} value={val} color="#dc2626" isRolling={isRolling} />
                    ))}
                  </div>
                </div>
                <div className="text-center">
                  <div className="text-sm font-bold mb-2 text-blue-600">Defender</div>
                  <div className="flex gap-2 justify-center">
                    {[...defenderDice].sort((a, b) => b - a).map((val, i) => (
                      <Dice key={i} value={val} color="#2563eb" isRolling={isRolling} />
                    ))}
                  </div>
                </div>
              </div>
            </div>
          )}

          {battleResult && !isVictory && (
            <div className="text-center mb-4 p-3 bg-white/50 rounded-lg">
              <div className="text-lg font-bold text-amber-900">{battleResult}</div>
            </div>
          )}

          {/* Victory: Choose troops to move */}
          {isVictory && (
            <div className="mb-6 p-4 bg-green-100 rounded-xl">
              <div className="text-center mb-3">
                <div className="font-bold text-green-800 text-lg">How many animals to move?</div>
                <div className="text-sm text-green-600">(Must leave at least 1 behind to guard)</div>
              </div>

              <div className="flex items-center justify-center gap-4">
                <button
                  onClick={() => setTroopsToMove(Math.max(minTroopsToMove, troopsToMove - 1))}
                  className="w-10 h-10 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg text-xl"
                  disabled={troopsToMove <= minTroopsToMove}
                >
                  -
                </button>
                <div className="text-center">
                  <div className="text-4xl font-bold text-green-700">{troopsToMove}</div>
                  <div className="text-sm text-green-600">{ANIMAL_ARMIES[attacker.army].emoji}</div>
                </div>
                <button
                  onClick={() => setTroopsToMove(Math.min(maxTroopsToMove, troopsToMove + 1))}
                  className="w-10 h-10 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg text-xl"
                  disabled={troopsToMove >= maxTroopsToMove}
                >
                  +
                </button>
              </div>

              <div className="text-center mt-3 text-sm text-green-700">
                {attacker.troops - troopsToMove} will stay at {TERRITORIES[attackingFrom].name}
              </div>
            </div>
          )}

          {/* Buttons based on state */}
          <div className="flex gap-3 justify-center">
            {isVictory ? (
              <button
                onClick={() => onClaimTerritory(troopsToMove)}
                className="px-6 py-3 bg-green-500 hover:bg-green-600 text-white font-bold rounded-xl shadow-lg transition-all hover:scale-105"
              >
                üèÜ Claim Territory!
              </button>
            ) : canContinueBattle ? (
              <>
                <button
                  onClick={onRoll}
                  disabled={isRolling}
                  className="px-6 py-3 bg-red-500 hover:bg-red-600 text-white font-bold rounded-xl shadow-lg transition-all hover:scale-105 disabled:opacity-50"
                >
                  üé≤ Roll Dice!
                </button>
                <button
                  onClick={onRetreat}
                  className="px-6 py-3 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg transition-all"
                >
                  üè≥Ô∏è Retreat
                </button>
              </>
            ) : cannotAttack ? (
              <button
                onClick={onRetreat}
                className="px-6 py-3 bg-amber-500 hover:bg-amber-600 text-white font-bold rounded-xl shadow-lg transition-all"
              >
                üòÖ Done (No troops left to attack)
              </button>
            ) : (
              <button
                onClick={onRetreat}
                className="px-6 py-3 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg transition-all"
              >
                üè≥Ô∏è Retreat
              </button>
            )}
          </div>
        </div>
      </div>
    );
    };

    // Card Reward Modal
    const CardRewardModal = ({ card, onClose }) => {
      const typeInfo = CARD_TYPES[card.type];
      return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="bg-gradient-to-b from-yellow-100 to-yellow-200 p-8 rounded-2xl max-w-sm w-full mx-4 shadow-2xl text-center">
            <h2 className="text-2xl font-bold mb-4 game-title text-yellow-800">üéâ You Won a Card! üéâ</h2>
            <div className="mb-4">
              <div className="text-6xl mb-2">{typeInfo.emoji}</div>
              <div className="text-xl font-bold text-gray-800">{typeInfo.name}</div>
              <div className={`inline-block mt-2 px-4 py-1 rounded-full ${typeInfo.color} text-white font-bold`}>
                {card.type === 'wild' ? '‚≠ê WILD - Counts as any!' : typeInfo.description}
              </div>
            </div>
            <p className="text-sm text-gray-600 mb-4">
              Collect 3 of the same type OR one of each type to trade for bonus animals!
            </p>
            <button
              onClick={onClose}
              className="px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded-xl shadow-lg transition-all hover:scale-105"
            >
              Awesome! üéä
            </button>
          </div>
        </div>
      );
    };

    // Reinforcement Tray - Shows individual animal pieces to place
    const ReinforcementTray = ({ army, count, emoji }) => {
      // Create array of animal pieces with staggered positions
      const pieces = Array.from({ length: count }, (_, i) => i);

      return (
        <div className="bg-gradient-to-r from-amber-600 to-amber-700 rounded-xl p-4 shadow-lg border-4 border-amber-800">
          <div className="text-center mb-2">
            <span className="text-white font-bold text-lg">üéØ Click your territories to deploy!</span>
          </div>
          <div className="bg-amber-900/50 rounded-lg p-3 min-h-[80px] flex flex-wrap justify-center items-center gap-1">
            {pieces.length > 0 ? (
              pieces.map((_, i) => (
                <div
                  key={i}
                  className="animal-piece text-3xl transform hover:scale-125 transition-transform cursor-pointer animate-bounce"
                  style={{
                    animationDelay: `${i * 0.1}s`,
                    animationDuration: '1s',
                  }}
                >
                  {emoji}
                </div>
              ))
            ) : (
              <div className="text-amber-300 text-sm">All troops deployed! ‚úÖ</div>
            )}
          </div>
          <div className="text-center mt-2">
            <span className="text-amber-200 text-sm">{count} {count === 1 ? 'animal' : 'animals'} remaining</span>
          </div>
        </div>
      );
    };

    // Main Game Component
    const ZooRiskGame = () => {
      const [gamePhase, setGamePhase] = useState('setup'); // setup, place, play, battle, fortify, gameOver
      const [players, setPlayers] = useState([]);
      const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
      const [gameState, setGameState] = useState({ territories: {} });
      const [selectedTerritory, setSelectedTerritory] = useState(null);
      const [troopsToPlace, setTroopsToPlace] = useState(0);
      const [turnPhase, setTurnPhase] = useState('reinforce'); // reinforce, attack, fortify
      const [battleState, setBattleState] = useState(null);
      const [cardReward, setCardReward] = useState(null);
      const [playerCards, setPlayerCards] = useState({});
      const [conqueredThisTurn, setConqueredThisTurn] = useState(false);
      const [earnedCardThisTurn, setEarnedCardThisTurn] = useState(false); // NEW: Track if card earned this turn
      const [message, setMessage] = useState('Welcome to Zoo Conquest! ü¶Å');
      const [aiThinking, setAiThinking] = useState(false);
      const [showCardTrade, setShowCardTrade] = useState(false); // NEW: Show card trade modal
      const [tradeCount, setTradeCount] = useState(0); // NEW: Global trade count for escalating values
      const [cardDeck, setCardDeck] = useState([...CARD_DECK].sort(() => Math.random() - 0.5)); // Shuffled deck

      // Setup functions
      const startGame = (numHumans, numAI) => {
        const totalPlayers = numHumans + numAI;
        const armies = Object.keys(ANIMAL_ARMIES).slice(0, totalPlayers);
        const aiNames = ['Captain Claw', 'Baron Beak', 'Duke Fang', 'Lady Paw', 'Sir Scales'];

        const newPlayers = armies.map((army, i) => {
          const isHuman = i < numHumans;
          const aiIndex = i - numHumans;
          return {
            id: i,
            name: isHuman ? (numHumans === 1 ? 'You' : `Player ${i + 1}`) : aiNames[aiIndex],
            army,
            territories: 0,
            isAI: !isHuman,
          };
        });

        // Distribute territories randomly
        const territoryIds = Object.keys(TERRITORIES);
        const shuffled = [...territoryIds].sort(() => Math.random() - 0.5);
        const newTerritories = {};

        shuffled.forEach((id, i) => {
          const playerIdx = i % totalPlayers;
          newTerritories[id] = {
            owner: armies[playerIdx],
            troops: 1,
          };
        });

        // Count territories per player
        newPlayers.forEach(p => {
          p.territories = Object.values(newTerritories).filter(t => t.owner === p.army).length;
        });

        // Initialize player cards
        const cards = {};
        armies.forEach(army => cards[army] = []);

        setPlayers(newPlayers);
        setGameState({ territories: newTerritories });
        setPlayerCards(cards);
        setGamePhase('play');
        setTurnPhase('reinforce');
        setCurrentPlayerIndex(0);
        setConqueredThisTurn(false);
        const initialTroops = calculateReinforcements(newPlayers[0], newTerritories);
        setTroopsToPlace(initialTroops);
        const firstPlayer = newPlayers[0];
        if (firstPlayer.isAI) {
          setMessage(`ü§ñ ${firstPlayer.name}'s turn!`);
        } else {
          setMessage(`${firstPlayer.name}'s turn! Place ${initialTroops} reinforcements.`);
        }
      };

      // Calculate reinforcements
      const calculateReinforcements = (player, territories) => {
        let troops = Math.max(3, Math.floor(player.territories / 3));

        // Region bonuses
        Object.entries(REGIONS).forEach(([name, region]) => {
          const ownsAll = region.territories.every(t => territories[t]?.owner === player.army);
          if (ownsAll) troops += region.bonus;
        });

        return troops;
      };

      // Draw a card from the deck
      const drawCard = () => {
        if (cardDeck.length === 0) {
          // Reshuffle if deck is empty
          setCardDeck([...CARD_DECK].sort(() => Math.random() - 0.5));
          return CARD_DECK[Math.floor(Math.random() * CARD_DECK.length)];
        }
        const card = cardDeck[0];
        setCardDeck(prev => prev.slice(1));
        return card;
      };

      // Handle card trade
      const handleCardTrade = (selectedCards) => {
        if (!isValidTradeSet(selectedCards)) return;

        const army = currentPlayer.army;
        const bonusTroops = TRADE_IN_VALUES[Math.min(tradeCount, TRADE_IN_VALUES.length - 1)];

        // Remove traded cards from player's hand
        const cardIds = selectedCards.map(c => c.id);
        setPlayerCards(prev => ({
          ...prev,
          [army]: prev[army].filter(c => !cardIds.includes(c.id))
        }));

        // Add bonus troops
        setTroopsToPlace(prev => prev + bonusTroops);
        setTradeCount(prev => prev + 1);
        setShowCardTrade(false);
        setMessage(`üéÅ Traded cards for ${bonusTroops} extra animals! Place your reinforcements.`);
      };

      // Get next trade value
      const getNextTradeValue = () => {
        return TRADE_IN_VALUES[Math.min(tradeCount, TRADE_IN_VALUES.length - 1)];
      };

      // Check if current player can trade cards
      const canCurrentPlayerTrade = () => {
        if (!currentPlayer) return false;
        const cards = playerCards[currentPlayer.army] || [];
        return canTradeCards(cards);
      };

      // Get current player
      const currentPlayer = players[currentPlayerIndex];
      const currentArmy = currentPlayer ? ANIMAL_ARMIES[currentPlayer.army] : null;

      // Calculate total troops for a player
      const getPlayerTroops = (army) => {
        return Object.values(gameState.territories)
          .filter(t => t.owner === army)
          .reduce((sum, t) => sum + t.troops, 0);
      };

      // Get valid targets for attack
      const getValidTargets = () => {
        if (!selectedTerritory || turnPhase !== 'attack') return [];
        const territory = TERRITORIES[selectedTerritory];
        const myArmy = gameState.territories[selectedTerritory]?.owner;

        return territory.connections.filter(connId =>
          gameState.territories[connId]?.owner !== myArmy
        );
      };

      // Get valid fortify targets
      const getValidFortifyTargets = () => {
        if (!selectedTerritory || turnPhase !== 'fortify') return [];
        const territory = TERRITORIES[selectedTerritory];
        const myArmy = gameState.territories[selectedTerritory]?.owner;

        return territory.connections.filter(connId =>
          gameState.territories[connId]?.owner === myArmy
        );
      };

      // Handle territory click
      const handleTerritoryClick = (id) => {
        const territory = gameState.territories[id];

        if (turnPhase === 'reinforce' && territory?.owner === currentPlayer?.army && troopsToPlace > 0) {
          // Place troops
          setGameState(prev => ({
            ...prev,
            territories: {
              ...prev.territories,
              [id]: { ...prev.territories[id], troops: prev.territories[id].troops + 1 }
            }
          }));
          setTroopsToPlace(prev => prev - 1);

          if (troopsToPlace === 1) {
            setTurnPhase('attack');
            setMessage('Attack phase! Select a territory to attack from.');
          }
        } else if (turnPhase === 'attack') {
          if (selectedTerritory === null) {
            // Select attacking territory
            if (territory?.owner === currentPlayer?.army && territory?.troops > 1) {
              setSelectedTerritory(id);
              setMessage('Now select an enemy territory to attack!');
            }
          } else if (selectedTerritory === id) {
            // Deselect
            setSelectedTerritory(null);
            setMessage('Select a territory to attack from.');
          } else {
            // Attack target
            const validTargets = getValidTargets();
            if (validTargets.includes(id)) {
              startBattle(selectedTerritory, id);
            }
          }
        } else if (turnPhase === 'fortify') {
          if (selectedTerritory === null) {
            if (territory?.owner === currentPlayer?.army && territory?.troops > 1) {
              setSelectedTerritory(id);
              setMessage('Select an adjacent friendly territory to send troops to.');
            }
          } else if (selectedTerritory === id) {
            setSelectedTerritory(null);
            setMessage('Select a territory to fortify from, or end turn.');
          } else {
            const validTargets = getValidFortifyTargets();
            if (validTargets.includes(id)) {
              // Move troops (move half, rounded down)
              const fromTroop = gameState.territories[selectedTerritory].troops;
              const toMove = Math.floor((fromTroop - 1) / 2) + 1;

              setGameState(prev => ({
                ...prev,
                territories: {
                  ...prev.territories,
                  [selectedTerritory]: { ...prev.territories[selectedTerritory], troops: fromTroop - toMove },
                  [id]: { ...prev.territories[id], troops: prev.territories[id].troops + toMove }
                }
              }));
              setSelectedTerritory(null);
              setMessage(`Moved ${toMove} troops! You can fortify again or end turn.`);
            }
          }
        }
      };

      // Start battle
      const startBattle = (from, to) => {
        setBattleState({
          from,
          to,
          attackerTroops: gameState.territories[from].troops,
          defenderTroops: gameState.territories[to].troops,
          attackerDice: [],
          defenderDice: [],
          isRolling: false,
          result: null,
          isVictory: false,
          troopsToMove: 1,
        });
      };

      // ============ AI LOGIC ============

      // AI: Get territories owned by a player
      const getPlayerTerritories = (army) => {
        return Object.entries(gameState.territories)
          .filter(([id, t]) => t.owner === army)
          .map(([id, t]) => ({ id, ...t }));
      };

      // AI: Find best territory to reinforce (border territories with enemies nearby)
      const aiFindBestReinforceTarget = (army) => {
        const myTerritories = getPlayerTerritories(army);
        let bestTarget = null;
        let bestScore = -1;

        myTerritories.forEach(territory => {
          const connections = TERRITORIES[territory.id].connections;
          const enemyNeighbors = connections.filter(
            connId => gameState.territories[connId]?.owner !== army
          ).length;
          // Prefer territories with more enemy neighbors and fewer troops
          const score = enemyNeighbors * 10 - territory.troops;
          if (score > bestScore) {
            bestScore = score;
            bestTarget = territory.id;
          }
        });
        return bestTarget || myTerritories[0]?.id;
      };

      // AI: Find best attack opportunity
      const aiFindBestAttack = (army) => {
        const myTerritories = getPlayerTerritories(army);
        let bestAttack = null;
        let bestScore = -1;

        myTerritories.forEach(territory => {
          if (territory.troops <= 1) return; // Can't attack with 1 troop

          const connections = TERRITORIES[territory.id].connections;
          connections.forEach(targetId => {
            const target = gameState.territories[targetId];
            if (target?.owner === army) return; // Can't attack own territory

            // Score based on advantage (my troops vs their troops)
            const myAttackers = territory.troops - 1;
            const theirDefenders = target.troops;
            const advantage = myAttackers - theirDefenders;

            // Only attack if we have advantage or are desperate
            if (advantage >= 0 || (myAttackers >= 3 && theirDefenders <= 2)) {
              const score = advantage + (myAttackers * 2);
              if (score > bestScore) {
                bestScore = score;
                bestAttack = { from: territory.id, to: targetId };
              }
            }
          });
        });

        return bestAttack;
      };

      // AI: Find best fortify move
      const aiFindBestFortify = (army) => {
        const myTerritories = getPlayerTerritories(army);
        let bestMove = null;
        let bestScore = -1;

        myTerritories.forEach(from => {
          if (from.troops <= 1) return;

          const connections = TERRITORIES[from.id].connections;
          const fromEnemyNeighbors = connections.filter(
            id => gameState.territories[id]?.owner !== army
          ).length;

          // If this territory has no enemies nearby, move troops away
          if (fromEnemyNeighbors === 0) {
            connections.forEach(toId => {
              const to = gameState.territories[toId];
              if (to?.owner !== army) return;

              const toConnections = TERRITORIES[toId].connections;
              const toEnemyNeighbors = toConnections.filter(
                id => gameState.territories[id]?.owner !== army
              ).length;

              if (toEnemyNeighbors > 0) {
                const score = toEnemyNeighbors * 10 + (from.troops - 1);
                if (score > bestScore) {
                  bestScore = score;
                  bestMove = { from: from.id, to: toId, troops: from.troops - 1 };
                }
              }
            });
          }
        });

        return bestMove;
      };

      // AI: Execute a single dice roll battle (returns promise)
      const aiExecuteBattle = (from, to) => {
        return new Promise((resolve) => {
          const attackerTroops = gameState.territories[from].troops;
          const defenderTroops = gameState.territories[to].troops;

          const attackerMax = Math.min(3, attackerTroops - 1);
          const defenderMax = Math.min(2, defenderTroops);

          const attackerDice = Array.from({ length: attackerMax }, () => Math.floor(Math.random() * 6) + 1);
          const defenderDice = Array.from({ length: defenderMax }, () => Math.floor(Math.random() * 6) + 1);

          const sortedAttacker = [...attackerDice].sort((a, b) => b - a);
          const sortedDefender = [...defenderDice].sort((a, b) => b - a);

          let attackerLosses = 0;
          let defenderLosses = 0;

          const comparisons = Math.min(sortedAttacker.length, sortedDefender.length);
          for (let i = 0; i < comparisons; i++) {
            if (sortedAttacker[i] > sortedDefender[i]) {
              defenderLosses++;
            } else {
              attackerLosses++;
            }
          }

          const newAttackerTroops = attackerTroops - attackerLosses;
          const newDefenderTroops = defenderTroops - defenderLosses;
          const victory = newDefenderTroops <= 0;

          resolve({
            attackerDice,
            defenderDice,
            attackerLosses,
            defenderLosses,
            newAttackerTroops,
            newDefenderTroops,
            victory
          });
        });
      };

      // AI Turn Controller
      useEffect(() => {
        if (gamePhase !== 'play' || !currentPlayer?.isAI || battleState || cardReward || aiThinking) {
          return;
        }

        const runAITurn = async () => {
          setAiThinking(true);
          const army = currentPlayer.army;
          const aiName = currentPlayer.name;

          // Phase 1: Reinforce
          if (turnPhase === 'reinforce' && troopsToPlace > 0) {
            setMessage(`ü§ñ ${aiName} is placing reinforcements...`);

            for (let i = 0; i < troopsToPlace; i++) {
              await new Promise(r => setTimeout(r, 300));
              const target = aiFindBestReinforceTarget(army);
              if (target) {
                setGameState(prev => ({
                  ...prev,
                  territories: {
                    ...prev.territories,
                    [target]: { ...prev.territories[target], troops: prev.territories[target].troops + 1 }
                  }
                }));
              }
            }

            await new Promise(r => setTimeout(r, 500));
            setTroopsToPlace(0);
            setTurnPhase('attack');
            setMessage(`ü§ñ ${aiName} is looking for targets...`);
            setAiThinking(false);
            return;
          }

          // Phase 2: Attack
          if (turnPhase === 'attack') {
            const attack = aiFindBestAttack(army);

            if (attack) {
              setMessage(`ü§ñ ${aiName} attacks ${TERRITORIES[attack.to].name}!`);
              await new Promise(r => setTimeout(r, 800));

              // Execute battle
              const result = await aiExecuteBattle(attack.from, attack.to);

              setGameState(prev => {
                const newTerritories = { ...prev.territories };
                newTerritories[attack.from] = {
                  ...newTerritories[attack.from],
                  troops: result.newAttackerTroops
                };

                if (result.victory) {
                  // Move troops to conquered territory
                  const troopsToMove = Math.max(1, result.newAttackerTroops - 1);
                  newTerritories[attack.to] = {
                    owner: army,
                    troops: troopsToMove
                  };
                  newTerritories[attack.from].troops -= troopsToMove;
                  setConqueredThisTurn(true);
                  setMessage(`ü§ñ ${aiName} conquered ${TERRITORIES[attack.to].name}!`);
                } else {
                  newTerritories[attack.to] = {
                    ...newTerritories[attack.to],
                    troops: result.newDefenderTroops
                  };
                }

                return { ...prev, territories: newTerritories };
              });

              await new Promise(r => setTimeout(r, 1000));

              // Check for more attacks
              setAiThinking(false);
              return;
            } else {
              // No good attacks, move to fortify
              setTurnPhase('fortify');
              setMessage(`ü§ñ ${aiName} is fortifying...`);
              setAiThinking(false);
              return;
            }
          }

          // Phase 3: Fortify
          if (turnPhase === 'fortify') {
            await new Promise(r => setTimeout(r, 500));
            const fortify = aiFindBestFortify(army);

            if (fortify) {
              setGameState(prev => ({
                ...prev,
                territories: {
                  ...prev.territories,
                  [fortify.from]: { ...prev.territories[fortify.from], troops: prev.territories[fortify.from].troops - fortify.troops },
                  [fortify.to]: { ...prev.territories[fortify.to], troops: prev.territories[fortify.to].troops + fortify.troops }
                }
              }));
              setMessage(`ü§ñ ${aiName} moved troops to ${TERRITORIES[fortify.to].name}`);
              await new Promise(r => setTimeout(r, 800));
            }

            // End AI turn
            await new Promise(r => setTimeout(r, 500));

            // Award card if conquered
            if (conqueredThisTurn) {
              const randomCard = CARDS[Math.floor(Math.random() * CARDS.length)];
              setPlayerCards(prev => ({
                ...prev,
                [army]: [...(prev[army] || []), randomCard]
              }));
            }

            // Move to next player
            const nextIndex = (currentPlayerIndex + 1) % players.length;
            let idx = nextIndex;
            let attempts = 0;
            while (attempts < players.length) {
              const playerArmy = players[idx].army;
              const hasTerritories = Object.values(gameState.territories).some(t => t.owner === playerArmy);
              if (hasTerritories) break;
              idx = (idx + 1) % players.length;
              attempts++;
            }

            setCurrentPlayerIndex(idx);
            setConqueredThisTurn(false);

            const nextPlayer = players[idx];
            const newTroops = calculateReinforcements(nextPlayer, gameState.territories);
            setTroopsToPlace(newTroops);
            setTurnPhase('reinforce');

            if (nextPlayer.isAI) {
              setMessage(`ü§ñ ${nextPlayer.name}'s turn!`);
            } else {
              setMessage(`Your turn! Place ${newTroops} reinforcements.`);
            }

            setAiThinking(false);

            // Check game over
            const owners = new Set(Object.values(gameState.territories).map(t => t.owner));
            if (owners.size === 1) {
              setGamePhase('gameOver');
            }

            // Update territory counts
            setPlayers(prev => prev.map(p => ({
              ...p,
              territories: Object.values(gameState.territories).filter(t => t.owner === p.army).length
            })));

            return;
          }

          setAiThinking(false);
        };

        const timer = setTimeout(runAITurn, 600);
        return () => clearTimeout(timer);
      }, [gamePhase, currentPlayer, turnPhase, troopsToPlace, battleState, cardReward, aiThinking, gameState.territories]);

      // ============ END AI LOGIC ============

      // Roll dice (Risk rules)
      // CRITICAL: Attacker must leave 1 troop behind, so max dice = troops - 1 (capped at 3)
      const rollDice = () => {
        // Get current troops from game state as source of truth
        const currentAttackerTroops = battleState.attackerTroops;
        const currentDefenderTroops = battleState.defenderTroops;

        // Attacker: max 3 dice, but must leave 1 behind (so troops-1)
        const attackerMax = Math.min(3, Math.max(0, currentAttackerTroops - 1));
        // Defender: max 2 dice, uses all available
        const defenderMax = Math.min(2, currentDefenderTroops);

        // Prevent rolling with 0 dice
        if (attackerMax <= 0) {
          setBattleState(prev => ({
            ...prev,
            result: 'Not enough troops to attack! (Need at least 2)',
            attackerDice: [],
            defenderDice: []
          }));
          return;
        }

        const attackerDice = Array.from({ length: attackerMax }, () => Math.floor(Math.random() * 6) + 1);
        const defenderDice = Array.from({ length: defenderMax }, () => Math.floor(Math.random() * 6) + 1);

        setBattleState(prev => ({ ...prev, attackerDice, defenderDice, isRolling: true }));

        setTimeout(() => {
          // Compare dice (Risk rules: highest vs highest, then second highest)
          const sortedAttacker = [...attackerDice].sort((a, b) => b - a);
          const sortedDefender = [...defenderDice].sort((a, b) => b - a);

          let attackerLosses = 0;
          let defenderLosses = 0;

          const comparisons = Math.min(sortedAttacker.length, sortedDefender.length);
          for (let i = 0; i < comparisons; i++) {
            if (sortedAttacker[i] > sortedDefender[i]) {
              defenderLosses++;
            } else {
              attackerLosses++;
            }
          }

          const newAttackerTroops = battleState.attackerTroops - attackerLosses;
          const newDefenderTroops = battleState.defenderTroops - defenderLosses;

          let result = `Attacker lost ${attackerLosses}, Defender lost ${defenderLosses}!`;
          const isVictory = newDefenderTroops <= 0;

          if (isVictory) {
            result = 'üéâ VICTORY! Territory conquered!';
          } else if (newAttackerTroops <= 1) {
            result = 'üòî No more troops to attack with!';
          }

          // Update battle state - if victory, show claim UI instead of auto-moving
          setBattleState(prev => ({
            ...prev,
            attackerTroops: newAttackerTroops,
            defenderTroops: newDefenderTroops,
            isRolling: false,
            result,
            isVictory,
            troopsToMove: Math.max(1, newAttackerTroops - 1), // Default to moving all but 1
          }));

          // Only update game state for losses (not victory - that happens on claim)
          if (!isVictory) {
            setGameState(prev => {
              const newTerritories = { ...prev.territories };
              newTerritories[battleState.from] = {
                ...newTerritories[battleState.from],
                troops: newAttackerTroops
              };
              newTerritories[battleState.to] = {
                ...newTerritories[battleState.to],
                troops: newDefenderTroops
              };
              return { ...prev, territories: newTerritories };
            });
          }

        }, 600);
      };

      // Claim territory after victory
      const claimTerritory = (troopsToMove) => {
        const newAttackerTroops = battleState.attackerTroops;

        setGameState(prev => {
          const newTerritories = { ...prev.territories };
          // Leave remaining troops at origin
          newTerritories[battleState.from] = {
            ...newTerritories[battleState.from],
            troops: newAttackerTroops - troopsToMove
          };
          // Move selected troops to conquered territory
          newTerritories[battleState.to] = {
            owner: currentPlayer.army,
            troops: troopsToMove
          };
          return { ...prev, territories: newTerritories };
        });

        setConqueredThisTurn(true);
        setBattleState(null);
        setSelectedTerritory(null);
        setMessage(`üéâ Conquered ${TERRITORIES[battleState.to].name}! Continue attacking or move to fortify.`);

        // Check for game over
        setTimeout(() => {
          checkGameOver();
        }, 100);
      };

      // Retreat from battle
      const retreatBattle = () => {
        setBattleState(null);
        setSelectedTerritory(null);
        // Don't award card here - only at end of attack phase
        setMessage('Select another territory to attack, or move to fortify phase.');
      };

      // Check for game over
      const checkGameOver = () => {
        const owners = new Set(Object.values(gameState.territories).map(t => t.owner));
        if (owners.size === 1) {
          setGamePhase('gameOver');
        }

        // Update player territory counts
        setPlayers(prev => prev.map(p => ({
          ...p,
          territories: Object.values(gameState.territories).filter(t => t.owner === p.army).length
        })));
      };

      // End current phase
      const endPhase = () => {
        setSelectedTerritory(null);

        if (turnPhase === 'attack') {
          // Award ONE card if conquered at least one territory this turn (and haven't already earned one)
          if (conqueredThisTurn && !earnedCardThisTurn) {
            const newCard = drawCard();
            setCardReward(newCard);
            setPlayerCards(prev => ({
              ...prev,
              [currentPlayer.army]: [...(prev[currentPlayer.army] || []), newCard]
            }));
            setEarnedCardThisTurn(true);
          }
          setTurnPhase('fortify');
          setMessage('Fortify phase! Move troops between your territories.');
        } else if (turnPhase === 'fortify') {
          // Next player
          const nextIndex = (currentPlayerIndex + 1) % players.length;

          // Skip eliminated players
          let attempts = 0;
          let idx = nextIndex;
          while (attempts < players.length) {
            const playerArmy = players[idx].army;
            const hasTerritories = Object.values(gameState.territories).some(t => t.owner === playerArmy);
            if (hasTerritories) break;
            idx = (idx + 1) % players.length;
            attempts++;
          }

          setCurrentPlayerIndex(idx);
          setConqueredThisTurn(false);
          setEarnedCardThisTurn(false); // Reset for next player's turn

          const nextPlayer = players[idx];
          const newTroops = calculateReinforcements(nextPlayer, gameState.territories);
          setTroopsToPlace(newTroops);
          setTurnPhase('reinforce');

          // Check if player has 5+ cards (must trade)
          const nextPlayerCards = playerCards[nextPlayer.army] || [];
          if (nextPlayerCards.length >= 5 && canTradeCards(nextPlayerCards) && !nextPlayer.isAI) {
            setMessage(`Your turn! You have ${nextPlayerCards.length} cards - you MUST trade first!`);
            setShowCardTrade(true);
          } else if (nextPlayer.isAI) {
            setMessage(`ü§ñ ${nextPlayer.name} is taking their turn...`);
          } else {
            setMessage(`Your turn, ${nextPlayer.name}! Place ${newTroops} reinforcements.`);
          }
        }
      };

      // Setup Screen
      const [setupHumans, setSetupHumans] = useState(1);
      const [setupAIs, setSetupAIs] = useState(1);

      if (gamePhase === 'setup') {
        const aiNames = ['Captain Claw', 'Baron Beak', 'Duke Fang', 'Lady Paw', 'Sir Scales'];
        const armyList = Object.entries(ANIMAL_ARMIES);
        const totalPlayers = setupHumans + setupAIs;
        const maxPlayers = 6;
        const minTotal = 2;

        const canAddHuman = totalPlayers < maxPlayers;
        const canRemoveHuman = setupHumans > 0 && totalPlayers > minTotal;
        const canAddAI = totalPlayers < maxPlayers;
        const canRemoveAI = setupAIs > 0 && totalPlayers > minTotal;

        return (
          <div className="min-h-screen flex items-center justify-center p-4">
            <div className="bg-white/90 backdrop-blur rounded-3xl p-8 max-w-lg w-full text-center shadow-2xl">
              <h1 className="text-4xl mb-2 game-title text-amber-800">ü¶Å Zoo Conquest üêò</h1>
              <p className="text-gray-600 mb-6">A Risk-style adventure at the Kansas City Zoo!</p>

              {/* Player Selection */}
              <div className="mb-6 bg-gray-50 rounded-xl p-4">
                <div className="text-lg font-bold text-gray-800 mb-4">Choose Your Players</div>

                {/* Human Players */}
                <div className="flex items-center justify-between mb-4 bg-white rounded-lg p-3">
                  <div className="flex items-center gap-2">
                    <span className="text-2xl">üë§</span>
                    <div className="text-left">
                      <div className="font-bold text-gray-800">Human Players</div>
                      <div className="text-xs text-gray-500">Pass & play with friends</div>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => canRemoveHuman && setSetupHumans(h => h - 1)}
                      disabled={!canRemoveHuman}
                      className="w-8 h-8 rounded-lg bg-gray-200 hover:bg-gray-300 disabled:opacity-30 disabled:cursor-not-allowed font-bold"
                    >
                      -
                    </button>
                    <span className="w-8 text-center text-xl font-bold text-gray-800">{setupHumans}</span>
                    <button
                      onClick={() => canAddHuman && setSetupHumans(h => h + 1)}
                      disabled={!canAddHuman}
                      className="w-8 h-8 rounded-lg bg-gray-200 hover:bg-gray-300 disabled:opacity-30 disabled:cursor-not-allowed font-bold"
                    >
                      +
                    </button>
                  </div>
                </div>

                {/* AI Players */}
                <div className="flex items-center justify-between bg-white rounded-lg p-3">
                  <div className="flex items-center gap-2">
                    <span className="text-2xl">ü§ñ</span>
                    <div className="text-left">
                      <div className="font-bold text-gray-800">AI Opponents</div>
                      <div className="text-xs text-gray-500">Computer-controlled</div>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => canRemoveAI && setSetupAIs(a => a - 1)}
                      disabled={!canRemoveAI}
                      className="w-8 h-8 rounded-lg bg-gray-200 hover:bg-gray-300 disabled:opacity-30 disabled:cursor-not-allowed font-bold"
                    >
                      -
                    </button>
                    <span className="w-8 text-center text-xl font-bold text-gray-800">{setupAIs}</span>
                    <button
                      onClick={() => canAddAI && setSetupAIs(a => a + 1)}
                      disabled={!canAddAI}
                      className="w-8 h-8 rounded-lg bg-gray-200 hover:bg-gray-300 disabled:opacity-30 disabled:cursor-not-allowed font-bold"
                    >
                      +
                    </button>
                  </div>
                </div>

                <div className="text-sm text-gray-500 mt-3">
                  Total: {totalPlayers} players (min 2, max 6)
                </div>
              </div>

              {/* Player Preview */}
              <div className="bg-amber-50 rounded-xl p-3 mb-4">
                <div className="text-sm font-bold text-amber-800 mb-2">Players in this game:</div>
                <div className="flex flex-wrap justify-center gap-2">
                  {armyList.slice(0, totalPlayers).map(([key, army], i) => {
                    const isHuman = i < setupHumans;
                    const aiIndex = i - setupHumans;
                    return (
                      <div key={key} className={`flex items-center gap-1 px-2 py-1 rounded-lg text-xs ${isHuman ? 'bg-green-100' : 'bg-blue-100'}`}>
                        <span>{army.emoji}</span>
                        <span className="text-gray-700">
                          {isHuman ? `Player ${i + 1}` : aiNames[aiIndex]}
                        </span>
                        <span className="text-xs">{isHuman ? 'üë§' : 'ü§ñ'}</span>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Start Button */}
              <button
                onClick={() => startGame(setupHumans, setupAIs)}
                className="w-full mb-4 px-6 py-4 bg-gradient-to-b from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white text-xl font-bold rounded-xl shadow-lg transition-all hover:scale-105"
              >
                üéÆ Start Game!
              </button>

              <div className="text-left bg-gray-50 rounded-xl p-4">
                <div className="font-bold text-gray-800 mb-2">üéÆ How to Play:</div>
                <ul className="text-sm text-gray-700 space-y-1">
                  <li>üéØ Conquer all zoo zones to win!</li>
                  <li>üè† 1 animal must always stay behind to guard!</li>
                  <li>üé≤ Roll 1 die per attacking animal (max 3)</li>
                  <li>üõ°Ô∏è Defenders roll up to 2 dice</li>
                  <li>üÉè Earn fun cards by conquering territories</li>
                </ul>
              </div>

              <div className="text-left bg-blue-50 rounded-xl p-4 mt-3">
                <div className="font-bold text-blue-800 mb-2">üé≤ Dice Rules:</div>
                <ul className="text-xs text-gray-700 space-y-1">
                  <li>‚Ä¢ 2 animals = 1 attack die (1 stays home)</li>
                  <li>‚Ä¢ 3 animals = 2 attack dice</li>
                  <li>‚Ä¢ 4+ animals = 3 attack dice (max)</li>
                  <li>‚Ä¢ Highest dice compare - ties go to defender!</li>
                </ul>
              </div>
            </div>
          </div>
        );
      }

      // Game Over Screen
      if (gamePhase === 'gameOver') {
        const winner = players.find(p =>
          Object.values(gameState.territories).some(t => t.owner === p.army)
        );
        const playerWon = winner && !winner.isAI;

        return (
          <div className="min-h-screen flex items-center justify-center p-4">
            <div className="bg-white/90 backdrop-blur rounded-3xl p-8 max-w-md w-full text-center shadow-2xl">
              {playerWon ? (
                <>
                  <h1 className="text-4xl mb-4 game-title text-amber-800">üèÜ YOU WON! üèÜ</h1>
                  <div className="text-6xl mb-4">{ANIMAL_ARMIES[winner.army].emoji}</div>
                  <div className="text-2xl font-bold text-gray-800 mb-2">Congratulations!</div>
                  <div className="text-lg text-gray-600 mb-6">Your {ANIMAL_ARMIES[winner.army].name} have conquered the entire zoo!</div>
                </>
              ) : (
                <>
                  <h1 className="text-4xl mb-4 game-title text-red-800">üò¢ GAME OVER üò¢</h1>
                  <div className="text-6xl mb-4">{ANIMAL_ARMIES[winner?.army]?.emoji || 'ü§ñ'}</div>
                  <div className="text-2xl font-bold text-gray-800 mb-2">{winner?.name || 'AI'} Wins!</div>
                  <div className="text-lg text-gray-600 mb-6">The {ANIMAL_ARMIES[winner?.army]?.name || 'enemies'} have taken over the zoo!</div>
                </>
              )}
              <button
                onClick={() => setGamePhase('setup')}
                className="px-8 py-4 bg-gradient-to-b from-amber-400 to-amber-500 hover:from-amber-500 hover:to-amber-600 text-white text-xl font-bold rounded-xl shadow-lg transition-all hover:scale-105"
              >
                üîÑ Play Again!
              </button>
            </div>
          </div>
        );
      }

      // Main Game Screen
      return (
        <div className="min-h-screen p-4">
          {/* Header */}
          <div className="text-center mb-4">
            <h1 className="text-3xl game-title text-yellow-300 drop-shadow-lg">ü¶Å Zoo Conquest üêò</h1>
            <div className="bg-white/20 backdrop-blur rounded-full px-6 py-2 inline-block mt-2">
              <span className="text-white font-semibold">{message}</span>
            </div>
          </div>

          <div className="max-w-7xl mx-auto grid lg:grid-cols-4 gap-4">
            {/* Left Panel - Current Player */}
            <div className="lg:col-span-1 space-y-4">
              {currentPlayer && (
                <PlayerPanel
                  player={currentPlayer}
                  isCurrentPlayer={true}
                  armies={currentArmy}
                  cards={playerCards[currentPlayer.army] || []}
                  onTradeCards={() => setShowCardTrade(true)}
                  canTrade={canCurrentPlayerTrade()}
                  troops={getPlayerTroops(currentPlayer.army)}
                  turnPhase={turnPhase}
                />
              )}

              {/* Phase Controls */}
              <div className="bg-white/10 backdrop-blur rounded-xl p-4">
                <div className="text-white font-bold mb-3">Turn Phase</div>
                <div className="flex gap-2 flex-wrap">
                  <div className={`px-3 py-2 rounded-lg text-sm font-semibold ${turnPhase === 'reinforce' ? 'bg-green-500 text-white' : 'bg-white/20 text-gray-300'}`}>
                    1. Reinforce {troopsToPlace > 0 && `(${troopsToPlace})`}
                  </div>
                  <div className={`px-3 py-2 rounded-lg text-sm font-semibold ${turnPhase === 'attack' ? 'bg-red-500 text-white' : 'bg-white/20 text-gray-300'}`}>
                    2. Attack
                  </div>
                  <div className={`px-3 py-2 rounded-lg text-sm font-semibold ${turnPhase === 'fortify' ? 'bg-blue-500 text-white' : 'bg-white/20 text-gray-300'}`}>
                    3. Fortify
                  </div>
                </div>

                {(turnPhase === 'attack' || turnPhase === 'fortify') && (
                  <button
                    onClick={endPhase}
                    className="w-full mt-3 px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded-lg transition-all"
                  >
                    {turnPhase === 'attack' ? '‚û°Ô∏è Go to Fortify' : '‚úÖ End Turn'}
                  </button>
                )}
              </div>
            </div>

            {/* Center - Map */}
            <div className="lg:col-span-2">
              <div className="bg-white/10 backdrop-blur rounded-2xl p-4">
                <GameMap
                  gameState={gameState}
                  selectedTerritory={selectedTerritory}
                  validTargets={turnPhase === 'attack' ? getValidTargets() : getValidFortifyTargets()}
                  onTerritoryClick={handleTerritoryClick}
                />
              </div>

              {/* Reinforcement Tray - Show during reinforce phase for human players */}
              {turnPhase === 'reinforce' && troopsToPlace > 0 && currentPlayer && !currentPlayer.isAI && (
                <div className="mt-4">
                  <ReinforcementTray
                    army={currentPlayer.army}
                    count={troopsToPlace}
                    emoji={ANIMAL_ARMIES[currentPlayer.army].emoji}
                  />
                </div>
              )}

              {/* Legend */}
              <div className="mt-4 bg-white/10 backdrop-blur rounded-xl p-3">
                <div className="flex flex-wrap justify-center gap-4">
                  {players.map(p => (
                    <div key={p.id} className="flex items-center gap-2">
                      <span className="text-xl">{ANIMAL_ARMIES[p.army].emoji}</span>
                      <span className="text-white text-sm">{ANIMAL_ARMIES[p.army].name}: {p.territories} zones</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            {/* Right Panel - Other Players */}
            <div className="lg:col-span-1 space-y-3">
              <div className="text-white font-bold mb-2">Other Players</div>
              {players.filter((p, i) => i !== currentPlayerIndex).map(p => (
                <div key={p.id} className={`bg-white/10 backdrop-blur rounded-xl p-3`}>
                  <div className="flex items-center gap-2">
                    <span className="text-2xl">{ANIMAL_ARMIES[p.army].emoji}</span>
                    <div className="flex-1">
                      <div className="text-white font-semibold flex items-center gap-2">
                        {p.name}
                        <span className={`text-xs px-1 rounded ${p.isAI ? 'bg-blue-500' : 'bg-green-500'}`}>
                          {p.isAI ? 'ü§ñ' : 'üë§'}
                        </span>
                      </div>
                      <div className="text-gray-300 text-sm">{p.territories} zones ‚Ä¢ {getPlayerTroops(p.army)} troops</div>
                    </div>
                  </div>
                  {playerCards[p.army]?.length > 0 && (
                    <div className="text-yellow-300 text-sm mt-1">üÉè {playerCards[p.army].length} cards</div>
                  )}
                </div>
              ))}

              {/* Region Legend */}
              <RegionLegend />

              {/* Card Trading Info */}
              <div className="bg-amber-100 rounded-xl p-4 mt-3">
                <div className="font-bold text-amber-800 mb-2">üÉè Card Trading</div>
                <div className="text-xs space-y-1 text-gray-700">
                  <div className="flex items-center gap-1">
                    <span className="bg-green-500 text-white px-1 rounded">üêæ</span>
                    <span className="bg-blue-500 text-white px-1 rounded">ü¶ì</span>
                    <span className="bg-red-500 text-white px-1 rounded">üêò</span>
                    <span className="bg-yellow-500 text-white px-1 rounded">üåü</span>
                  </div>
                  <div className="mt-2"><span className="font-bold">Trade 3 cards:</span></div>
                  <div>‚Ä¢ 3 of same type, OR</div>
                  <div>‚Ä¢ 1 of each type</div>
                  <div className="mt-1 text-amber-600 font-semibold">üåü Wild = any type!</div>
                  <div className="mt-2 text-green-700">Next trade: +{getNextTradeValue()} animals</div>
                </div>
              </div>
            </div>
          </div>

          {/* Battle Modal */}
          {battleState && (
            <BattleModal
              attacker={{ army: currentPlayer.army, troops: battleState.attackerTroops }}
              defender={{ army: gameState.territories[battleState.to]?.owner || currentPlayer.army, troops: battleState.defenderTroops }}
              attackingFrom={battleState.from}
              defendingTo={battleState.to}
              onRoll={rollDice}
              onRetreat={retreatBattle}
              onClaimTerritory={claimTerritory}
              battleResult={battleState.result}
              attackerDice={battleState.attackerDice}
              defenderDice={battleState.defenderDice}
              isRolling={battleState.isRolling}
              isVictory={battleState.isVictory}
              troopsToMove={battleState.troopsToMove}
              setTroopsToMove={(val) => setBattleState(prev => ({ ...prev, troopsToMove: val }))}
            />
          )}

          {/* Card Reward Modal */}
          {cardReward && (
            <CardRewardModal
              card={cardReward}
              onClose={() => setCardReward(null)}
            />
          )}

          {/* Card Trade Modal */}
          {showCardTrade && currentPlayer && (
            <CardTradeModal
              cards={playerCards[currentPlayer.army] || []}
              onTrade={handleCardTrade}
              onCancel={() => setShowCardTrade(false)}
              tradeCount={tradeCount}
              nextTradeValue={getNextTradeValue()}
            />
          )}
        </div>
      );
    };

    // Render the app
    ReactDOM.createRoot(document.getElementById('root')).render(<ZooRiskGame />);
  </script>
</body>
</html>
